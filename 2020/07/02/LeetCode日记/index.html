<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="偶尔在力扣上刷刷题碰到些有价值的题目随手都记录到这里了。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode日记">
<meta property="og:url" content="http://yoursite.com/2020/07/02/LeetCode%E6%97%A5%E8%AE%B0/index.html">
<meta property="og:site_name" content="今天你Coding了吗?">
<meta property="og:description" content="偶尔在力扣上刷刷题碰到些有价值的题目随手都记录到这里了。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-02T03:22:37.000Z">
<meta property="article:modified_time" content="2020-07-22T06:40:30.334Z">
<meta property="article:author" content="Michael Johnson">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="C">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/07/02/LeetCode%E6%97%A5%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>LeetCode日记 | 今天你Coding了吗?</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">今天你Coding了吗?</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/02/LeetCode%E6%97%A5%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E7%A8%8B%E5%BA%8F%E7%8C%BF.jpg">
      <meta itemprop="name" content="Michael Johnson">
      <meta itemprop="description" content="小白的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天你Coding了吗?">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode日记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-02 11:22:37" itemprop="dateCreated datePublished" datetime="2020-07-02T11:22:37+08:00">2020-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-22 14:40:30" itemprop="dateModified" datetime="2020-07-22T14:40:30+08:00">2020-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">算法题目</span></a>
                </span>
            </span>

          
            <span id="/2020/07/02/LeetCode%E6%97%A5%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="LeetCode日记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>偶尔在力扣上刷刷题碰到些有价值的题目随手都记录到这里了。</p>
<a id="more"></a>
<p><strong><em>题目分类：</em></strong></p>
<p><strong>动态规划：</strong></p>
<ul>
<li>爬楼梯</li>
<li>恢复空格</li>
<li>地下城与勇士</li>
<li>三角形最小路径和</li>
<li>不同的二叉搜索树</li>
</ul>
<p><strong>双指针：</strong></p>
<ul>
<li>删除链表的倒数第n个结点</li>
<li>删除排序链表里的重复元素II</li>
<li>相交链表</li>
<li>环形链表</li>
<li>重排链表</li>
<li>数组交集</li>
<li>两数之和II</li>
<li>快乐数</li>
<li>戳气球</li>
</ul>
<p>贪心法：</p>
<ul>
<li>跳跃游戏</li>
</ul>
<p><strong>hash表：</strong></p>
<ul>
<li>删除排序链表里的重复元素II</li>
<li>恢复空格</li>
<li>数组交集</li>
<li>存在重复元素II</li>
<li>存在重复元素III</li>
</ul>
<p>递归：</p>
<ul>
<li>删除排序链表里的重复元素II</li>
<li>反转链表</li>
</ul>
<p>二分法</p>
<ul>
<li>排列硬币</li>
<li>旋转数组的最小值</li>
</ul>
<p>排除法</p>
<ul>
<li>计数质数</li>
</ul>
<hr>
<h4 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h4><h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><p>输入：两个二进制字符串<br>输出：加法后得到的二进制字符串</p>
<h5 id="个人解答-Python"><a href="#个人解答-Python" class="headerlink" title="个人解答(Python)"></a>个人解答(Python)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        carry = <span class="number">0</span>  <span class="comment"># 进位初始化为0</span></span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        n = max(len(a),len(b))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(i &gt; len(a)<span class="number">-1</span>):  <span class="comment"># 当b未遍历完，a遍历完</span></span><br><span class="line">                result += str((int(b[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">                carry = (int(b[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; len(b)<span class="number">-1</span>):  <span class="comment"># 当a未遍历完，b遍历完</span></span><br><span class="line">                result += str((int(a[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">                carry = (int(a[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            result += str((int(a[-i<span class="number">-1</span>])+int(b[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">            carry = (int(a[-i<span class="number">-1</span>])+int(b[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>):  <span class="comment"># 如果最后进位是1，补位</span></span><br><span class="line">            result += str(carry)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h5 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h5><p>两个数字位数较小的一个，直接用0补齐，使得两个字符串的位数相同，可以节省代码空间，减少判断次数，降低运行时间。</p>
<h5 id="法2：位运算"><a href="#法2：位运算" class="headerlink" title="法2：位运算"></a>法2：位运算</h5><p><a href="https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/" target="_blank" rel="noopener">戳我看解法</a></p>
<hr>
<h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><h5 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h5><p>人一次只能爬1个或2个楼梯<br>输入：楼梯个数<br>输出：爬楼梯共有多少种爬法</p>
<h5 id="个人解答-Python-1"><a href="#个人解答-Python-1" class="headerlink" title="个人解答(Python)"></a>个人解答(Python)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * f(n<span class="number">-1</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = (n//<span class="number">2</span>)+<span class="number">1</span>  <span class="comment"># 共有多少种不重复的已经确定的1，2个数分布</span></span><br><span class="line">        j = n  <span class="comment"># 排列组合公式的底数</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">            result += f(j)/(f(i)*f(j-i))</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h5 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结"></a>我的总结</h5><p>我的思路是先找到1，2个数的所有组合，举个例子：<br>比如n=6，那么楼梯的1，2组合只能是以下四种：</p>
<ul>
<li>111111</li>
<li>11112</li>
<li>1122</li>
<li>222</li>
</ul>
<p>那么只需要找到2的排列组合数就行：</p>
<ul>
<li>0/6 111111</li>
<li>1/5 11112</li>
<li>2/4 1122</li>
<li>3/3 222</li>
</ul>
<p>虽然找到了公式，但不得不说，我这个不论空间还是时间都垃圾的很……直接看标答吧…<br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">戳我看完整答案</a></p>
<h5 id="方法1：动态规划！"><a href="#方法1：动态规划！" class="headerlink" title="方法1：动态规划！"></a>方法1：动态规划！</h5><p>我们用 <code>f(x)</code> 表示爬到第 <code>x</code> 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：<br>$$f(x) = f(x-1) + f(x-2)$$</p>
<p>这个公式的意思是，爬到第n级台阶只能是爬到n-1级（爬到第n级用了一步）或是爬到n-2级（爬到n级用了两步）的方案的集合。看到这里就一目了然，这不就是传说中的<code>斐波那契数列</code>吗？（后话）<br>利用滚动数组的方法求解代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    q = <span class="number">0</span></span><br><span class="line">    r = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        p = q  <span class="comment"># q前移一位</span></span><br><span class="line">        q = r  <span class="comment"># r前移一位</span></span><br><span class="line">        r = p + q  <span class="comment"># 更新r</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>
<h5 id="方法2：斐波那契公式"><a href="#方法2：斐波那契公式" class="headerlink" title="方法2：斐波那契公式"></a>方法2：斐波那契公式</h5><p>$$f ( n ) = \frac { 1 } { \sqrt { 5 } } [ ( \frac { 1 + \sqrt { 5 } } { 2 } ) ^ { n } - ( \frac { 1 - \sqrt { 5 } } { 2 } ) ^ { n } ]<br>$$</p>
<hr>
<h4 id="删除链表的倒数第n个节点"><a href="#删除链表的倒数第n个节点" class="headerlink" title="删除链表的倒数第n个节点"></a>删除链表的倒数第n个节点</h4><h5 id="个人解答-C-两次遍历"><a href="#个人解答-C-两次遍历" class="headerlink" title="个人解答(C,两次遍历)"></a>个人解答(C,两次遍历)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cur = cur -&gt; next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==n)&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 如果删除头结点，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count-n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125; <span class="comment">// 如果不删除头结点，按照结点删除法删除对应节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="我的总结-1"><a href="#我的总结-1" class="headerlink" title="我的总结"></a>我的总结</h5><p>遍历2L-n次，时间复杂度 $O(L)$<br>空间复杂度$O(1)$</p>
<h5 id="优化：一次遍历法（双指针）"><a href="#优化：一次遍历法（双指针）" class="headerlink" title="优化：一次遍历法（双指针）"></a>优化：一次遍历法（双指针）</h5><p>哎呀，想了十分钟没想出来，一说双指针一下子明白了。双指针保持间隔为n，依次向前递推，直到快指针指向空，慢指针定位成功。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 定位快指针到第n+1个结点</span></span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 如果第n+1个结点为空，直接返回head-&gt;next</span></span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>free语句是必不可少的，这里为了省空间就没用q承载再删除</strong>。正解如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>


<hr>
<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><h5 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h5><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p>
<h5 id="个人解答-C"><a href="#个人解答-C" class="headerlink" title="个人解答(C)"></a>个人解答(C)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = numsSize<span class="number">-2</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= numsSize-i<span class="number">-1</span>)&#123; </span><br><span class="line">            <span class="comment">// 如果这个在尾元素之前的元素可以到达末尾，则以该元素为末尾</span></span><br><span class="line">            numsSize -= (numsSize-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numsSize==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<h5 id="标答-贪心法"><a href="#标答-贪心法" class="headerlink" title="标答(贪心法)"></a>标答(贪心法)</h5><p><strong>更新能跳到的最远位置</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n, rightmost = len(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &lt;= rightmost:</span><br><span class="line">                rightmost = max(rightmost, i + nums[i])</span><br><span class="line">                <span class="keyword">if</span> rightmost &gt;= n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两链表之和"><a href="#两链表之和" class="headerlink" title="两链表之和"></a>两链表之和</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>例如：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><p>本来想省一点空间，直接在L1上操作，现在导致前后两难：</p>
<ol>
<li>逻辑不清晰，可读性很差</li>
<li>时间复杂度提高的鸭子！！</li>
<li>代码冗长</li>
</ol>
<p>浪费了我俩小时，先睡了。/(ㄒoㄒ)/~~</p>
<p>2020.7.8..今天早上用c语言做出来了，直接贴代码。之前的思路（改变L1），造成了我遍历完其中一个链表，就会分类讨论出三种情况，无疑复杂化了原问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>; <span class="comment">// 进位位初始化</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>; <span class="comment">// 每位的加和</span></span><br><span class="line">    <span class="keyword">int</span> x,y; <span class="comment">// 每位的真实加法数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">L1</span>=<span class="title">l1</span>,*<span class="title">L2</span>=<span class="title">l2</span>,*<span class="title">result</span>,*<span class="title">cur</span>,*<span class="title">high</span>,*<span class="title">nextNode</span>;</span></span><br><span class="line">    result = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    cur = result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(L1!=<span class="literal">NULL</span> || L2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        x = L1!=<span class="literal">NULL</span> ? L1-&gt;val : <span class="number">0</span>;</span><br><span class="line">        y = L2!=<span class="literal">NULL</span> ? L2-&gt;val : <span class="number">0</span>;</span><br><span class="line">        nextNode = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        sum = x + y + temp;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            nextNode -&gt; val = sum%<span class="number">10</span>;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nextNode -&gt; val = sum;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            L1=L1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            L2=L2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = nextNode;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后排除多位问题</span></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">1</span>)&#123;</span><br><span class="line">        high = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        high -&gt; val = <span class="number">1</span>;</span><br><span class="line">        cur -&gt; next = high;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以以后再碰到类似的题目，要先想好自己要不要优化空间（时间），到底是先试着把题目做出来，还是就着一个优化空间的角度钻牛角尖，还是要衡量一下的。</strong>后面还看到了一个时间上比我快很多的算法，其实和我之前的思路有一点类似(当某一个链表遍历完，剩余的链接到后面，但是由于我一心只想改变L1，造成了很多不必要的麻烦，而且后面的关于进位位的处理也没人家想的好)大体讲一下思路，开阔一下视野。</p>
<ol>
<li>新建一个链表l3，用以存放l1+l2的和</li>
<li>分3种情况，在l1，l2都没到尾的前提下<ul>
<li>l1先结束，l2多出来的部分直接加入到l3</li>
<li>l2先结束，l1多出来的部分直接加到l3</li>
<li>两个一起结束，直接相加，不管结果是否大于10</li>
</ul>
</li>
<li>遍历l3，先不考虑链表最后一个数，<ul>
<li>如果l3.val&gt;10，减去10，并在下一个节点上加1</li>
<li>如果链表最后一个数大于10，则减去10，并新建一个节点存1</li>
</ul>
</li>
</ol>
<p>这个思路的<strong>对进位位的处理</strong>是很值得借鉴的，就是先不管进位位的情况下统一加完，再遍历链表实现进位位的加法，这种方法看似消耗了时间（相当于两次遍历），实际上居然比我那个要快很多，显然是因为我那个的条件判断语句有点过多了。</p>
<hr>
<h4 id="跳水板"><a href="#跳水板" class="headerlink" title="跳水板"></a>跳水板</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。<br>返回的长度需要<strong>从小到大排列</strong>。</p>
<h5 id="个人解答-1"><a href="#个人解答-1" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">divingBoard</span><span class="params">(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *newNode;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(longer==shorter)&#123;</span><br><span class="line">        newNode = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line">        *newNode = longer*k;</span><br><span class="line">        *returnSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(k+<span class="number">1</span>));</span><br><span class="line">    *returnSize = k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        newNode[k-i] = i*shorter + (k-i)*longer; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="删除排序链表里的重复元素II"><a href="#删除排序链表里的重复元素II" class="headerlink" title="删除排序链表里的重复元素II"></a>删除排序链表里的重复元素II</h4><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中<strong>没有重复出现</strong>的数字。</p>
<h5 id="个人原解答"><a href="#个人原解答" class="headerlink" title="个人原解答"></a>个人原解答</h5><p>思路：</p>
<ol>
<li>如果链表只有0/1个元素，返回head。 </li>
<li>将链表化为<strong>前两个元素一定不一样</strong>的模型。</li>
<li>设置快指针q，慢指针p。</li>
<li>p-&gt;next-&gt;val == q-&gt;val时是删除条件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// p是慢指针，q是快指针</span></span><br><span class="line">    <span class="comment">// 如果是开头重复：label=1</span></span><br><span class="line">    <span class="comment">// 如果是中间重复：label=0</span></span><br><span class="line">    <span class="comment">// 由于头结点和后面都不一样，我觉得先摘除头结点重复的前半部分，将链表化为“前两个一定不相同的模型”</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>=<span class="title">head</span>, *<span class="title">q</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> label = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next-&gt;val == head-&gt;val)&#123;</span><br><span class="line">        label = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next-&gt;val == head-&gt;val)&#123;</span><br><span class="line">            label = <span class="number">1</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(label)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;val == q-&gt;val)&#123; <span class="comment">// 若相等</span></span><br><span class="line">            <span class="keyword">if</span>(q-&gt;next==<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123; <span class="comment">// 到达链表尾，则删除</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 否则快指针后移</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 若不等</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;next == q)&#123; <span class="comment">// 不能删，要后移p</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 否则应该删掉中间结点</span></span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我感觉我想法挺好的啊！但真的做崩了，被各种细节卡了下来，提交了5次都没成功，我是真的垃圾。都说能用递归，那我用递归试试，半小时不行就劝退吧，现在是0：49，我很困。<br>1：01，爷想不出来，气死了，睡觉。</li>
</ol>
<h5 id="标准解法"><a href="#标准解法" class="headerlink" title="标准解法"></a>标准解法</h5><h6 id="方法1：递归"><a href="#方法1：递归" class="headerlink" title="方法1：递归"></a>方法1：递归</h6><ul>
<li><code>head</code>后面有值而且和<code>head</code>的值相等，那么就找到不相等为止，然后对后面一个结点去递归，这样就把前面重复的给删除了。</li>
<li><code>head</code>后面有值但和<code>head</code>的值不等，那么就递归后面一个结点，接在<code>head</code>的后面。</li>
<li>最后返回<code>head</code>。</li>
</ul>
<p>想法和我是一样的，但是我就……没能力实现出来？？其实中间很多循环条件判断条件也是完全一样的，，这个<code>return deleteDuplicates(head-&gt;next)</code>我服了，我当时怎么都没想出来解决(1,1,2,2)这种情况，人家一句就解决了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="方法2：hash表"><a href="#方法2：hash表" class="headerlink" title="方法2：hash表"></a>方法2：hash表</h6><p>hash_map 统计出现次数，如果出现次数等于1，那么就放在新链表后面。</p>
<h6 id="方法3：双指针"><a href="#方法3：双指针" class="headerlink" title="方法3：双指针"></a>方法3：双指针</h6><p><strong>先建一个哑结点真的省事儿</strong>，当建完哑结点后，删除就会和<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表里的重复元素I</a>这道题的方法基本一样–<strong>顺序遍历，若同则删</strong>，不同的是，<code>cur-&gt;next</code>是否为空要加以判断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哑结点指向head</span></span><br><span class="line">    ListNode* dummy = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode* pre = dummy;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">NULL</span> &amp;&amp; cur-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next!=<span class="literal">NULL</span> &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;                </span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h5><p>当这种情况下，可能有很多种情况，首先想能不能把这几个情况想个方法合并。比如法1的递归和法3的双指针的哑结点，都是<strong>为了排除特殊情情况而设计的</strong>。</p>
<hr>
<h4 id="恢复空格"><a href="#恢复空格" class="headerlink" title="恢复空格"></a>恢复空格</h4><h5 id="别人解答C"><a href="#别人解答C" class="headerlink" title="别人解答C"></a>别人解答C</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CMP</span><span class="params">(<span class="keyword">void</span> * a,<span class="keyword">void</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * S1 = *(<span class="keyword">char</span> **)a;</span><br><span class="line">    <span class="keyword">char</span> * S2 = *(<span class="keyword">char</span> **)b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(S1,S2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Binary</span><span class="params">(<span class="keyword">char</span> **dictionary,<span class="keyword">int</span> dictionarySize,<span class="keyword">char</span> * <span class="built_in">string</span>,<span class="keyword">int</span> lenth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = dictionarySize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>,ret2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;        <span class="comment">//mid是一个区间</span></span><br><span class="line">        ret = <span class="built_in">strncmp</span>(dictionary[mid],<span class="built_in">string</span>,lenth);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret2 = <span class="built_in">strlen</span>(dictionary[mid]);</span><br><span class="line">            <span class="keyword">if</span>(ret2 == lenth)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret2 &gt; lenth)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="keyword">char</span>** dictionary, <span class="keyword">int</span> dictionarySize, <span class="keyword">char</span>* sentence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    qsort(dictionary,dictionarySize,<span class="keyword">sizeof</span>(<span class="keyword">char</span> *),CMP);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(sentence);</span><br><span class="line">    <span class="keyword">int</span> * dp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    * dp = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *(dp + i) = *(dp + i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt;= i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Binary(dictionary,dictionarySize,sentence + j,i - j + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    *(dp + i) = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    *(dp + i) = MIN(dp[i],dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> answer = dp[len] - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(dp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我改进后的，用C语言基于动态规划的答案：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">substr</span><span class="params">(<span class="keyword">char</span>* sentence, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *substring = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        substring[i] = sentence[start+i];</span><br><span class="line">    &#125;</span><br><span class="line">    substring[len] = <span class="string">'\0'</span>; <span class="comment">// 这个结尾一定要赋'\0'要不比较不了</span></span><br><span class="line">    <span class="keyword">return</span> substring;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="keyword">char</span>** dictionary, <span class="keyword">int</span> dictionarySize, <span class="keyword">char</span>* sentence)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回的是字符数，不是单词数……</span></span><br><span class="line">    <span class="comment">// 这题应该能用动态规划解</span></span><br><span class="line">    <span class="comment">// 转移方程：f[i]=min&#123;f[i-word.length],f[i]&#125;</span></span><br><span class="line">    <span class="comment">// 之所以会有min函数是因为 </span></span><br><span class="line">    <span class="comment">// sentence:"looked" dictionary:["looked","oked"]这种情况，最后就会采取最小匹配</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(sentence); <span class="comment">// sentence长度</span></span><br><span class="line">    <span class="keyword">int</span> dp[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">// 单词长度</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        dp[i+<span class="number">1</span>] = dp[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; dictionarySize;j++)&#123;</span><br><span class="line">            <span class="built_in">size</span> = <span class="built_in">strlen</span>(dictionary[j]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">size</span>&lt;=i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dictionary[j], substr(sentence, i+<span class="number">1</span>-<span class="built_in">size</span>, <span class="built_in">size</span>))==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>] = dp[i+<span class="number">1</span>]&lt;dp[i+<span class="number">1</span>-<span class="built_in">size</span>] ? dp[i+<span class="number">1</span>] : dp[i+<span class="number">1</span>-<span class="built_in">size</span>];</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看别人家的题解，了解到了<strong>字典树</strong>（Trie树）这个概念，同时还有<strong>字符串hash</strong>的解法。<br><a href="https://leetcode-cn.com/problems/re-space-lcci/solution/jian-dan-dp-trieshu-bi-xu-miao-dong-by-sweetiee/" target="_blank" rel="noopener">甜姐的trie解法</a></p>
<hr>
<h4 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h4><p>编写一个程序，找到两个单链表相交的起始节点。<br>利用<strong>两个链表的总长是一样的</strong>这一看似弱智的现象，有点类似于那个前移n位的算法，就是将[0:m]的前[0:n]和后[n+1:m]分别反转，整体再反转，就能实现前移。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pA</span> = <span class="title">headA</span>, *<span class="title">pB</span> = <span class="title">headB</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(pA==<span class="literal">NULL</span> || pB==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">        pA = pA == <span class="literal">NULL</span> ? headB : pA-&gt;next;</span><br><span class="line">        pB = pB == <span class="literal">NULL</span> ? headA : pB-&gt;next; </span><br><span class="line">    &#125; <span class="comment">// 当无相交现象时，最后都为NULL时会直接跳出</span></span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p>判断给定链表是否有环。<br>设置快慢指针，快指针一次两步，慢指针一次一步。设置哑结点以优雅的处理边界(后来发现设置没有什么卵用)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummyhead</span>, *<span class="title">fast</span>, *<span class="title">slow</span>;</span> </span><br><span class="line">    dummyhead = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line"></span><br><span class="line">    dummyhead-&gt;next = head;</span><br><span class="line">    slow = dummyhead;</span><br><span class="line">    fast = dummyhead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">NULL</span> || fast-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="地下城与勇士"><a href="#地下城与勇士" class="headerlink" title="地下城与勇士"></a>地下城与勇士</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<ul>
<li>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</li>
<li>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</li>
<li>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</li>
</ul>
<h5 id="初代解法（失败）"><a href="#初代解法（失败）" class="headerlink" title="初代解法（失败）"></a>初代解法（失败）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>** dungeon, <span class="keyword">int</span> dungeonSize, <span class="keyword">int</span>* dungeonColSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[dungeonSize][*dungeonColSize]; <span class="comment">// 申请一个和原二维数组相同大小的二维空间</span></span><br><span class="line">    f[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>] = <span class="number">1</span> - dungeon[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>]; <span class="comment">// 初始化f</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = dungeonSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = *dungeonColSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==dungeonSize<span class="number">-1</span> &amp;&amp; j==*dungeonColSize<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == dungeonSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = f[i][j+<span class="number">1</span>] - dungeon[i][j]; <span class="comment">// 下边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(j == *dungeonColSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = f[i+<span class="number">1</span>][j] - dungeon[i][j]; <span class="comment">// 左边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            f[i][j] = fmin(f[i+<span class="number">1</span>][j], f[i][j+<span class="number">1</span>]) - dungeon[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二代解法（成功）"><a href="#二代解法（成功）" class="headerlink" title="二代解法（成功）"></a>二代解法（成功）</h5><p>这次只修改了代码中的一个逻辑，就是在每一次赋值的时候均将该值与1（生命最小值）相比较。<br>分析原来的算法可以知道，原来的算法对于某些情况的路径是适用的，即在递推过程中，没有一条路径中出现的f值会为负数，所以我用<code>[[-2,-3,-3],[-5,-10,-1],[-10,-30,-5]]</code>这个全负测试用例来测试一代解法是百试不爽的。但错就错在，我们的主角是有生命值限制的，中间一旦生命值&lt;1就会立即死亡。<br>因此，为了改进原算法，只需修改原来的赋值等号右侧，<strong>一旦值小于0，就将该值修改为1</strong>，即我们加入了一个限制条件，我们可以这么理解：按一代解法的主角开挂路径（就如同一个主角开了生命值掉为0都死不了的挂），主角走到该点单看生命值其实已经挂了，我们现在手里没有挂，那么我们为了求出满足条件的最低开局生命值，只能不断手动尽量让这个点的主角残血。那么一直向前推，开局的主角就将是满足当前条件的血量最小值（不断地残血逼近开头，最终达到目的），有点类似于递归思想。<br>这么看的话，一代解法似乎是一种极端，那么如果所有的房间都是治愈房间（值为非负数），那么开局必为残血，<code>f[0][0]=1</code>。感觉这竟然很像高中的数学极限法……不知道这个思路会不会有点用以后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>** dungeon, <span class="keyword">int</span> dungeonSize, <span class="keyword">int</span>* dungeonColSize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[dungeonSize][*dungeonColSize]; <span class="comment">// 申请一个和原二维数组相同大小的二维空间</span></span><br><span class="line">    f[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>] = fmax(<span class="number">1</span>, <span class="number">1</span> - dungeon[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>]); <span class="comment">// 初始化f</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = dungeonSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = *dungeonColSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==dungeonSize<span class="number">-1</span> &amp;&amp; j==*dungeonColSize<span class="number">-1</span>) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == dungeonSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = fmax(<span class="number">1</span>, f[i][j+<span class="number">1</span>] - dungeon[i][j]); <span class="comment">// 下边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(j == *dungeonColSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = fmax(<span class="number">1</span>, f[i+<span class="number">1</span>][j] - dungeon[i][j]); <span class="comment">// 左边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            f[i][j] = fmax(<span class="number">1</span>, fmin(f[i+<span class="number">1</span>][j], f[i][j+<span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<h5 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h5><p>一开始一直超时还纳闷，我这不就是个双层循环吗，至于这么被针对？？最后发现是倒数第二个节点应该在每次循环的时候都指向空，否则链表就有环了，<code>p = p-&gt;next</code>那里肯定要超时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span> || head-&gt;next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">head</span>, * <span class="title">cur</span> = <span class="title">head</span>, * <span class="title">q</span>, *<span class="title">lastTwo</span>;</span> <span class="comment">// p指向这一轮被移到前方的尾结点，cur指向当前的头结点</span></span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTwo = p; <span class="comment">// 找到倒数第二个结点</span></span><br><span class="line">        p = p-&gt;next; <span class="comment">// p现在是最后一个结点</span></span><br><span class="line">        q = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = p; <span class="comment">// 形成了这一轮的L0和Ln连接</span></span><br><span class="line">        p-&gt;next = q; <span class="comment">// 形成了L0，Ln，L1的连接</span></span><br><span class="line"></span><br><span class="line">        cur = cur-&gt;next-&gt;next; <span class="comment">// 更新cur</span></span><br><span class="line">        p = cur; <span class="comment">// 更新p</span></span><br><span class="line">        lastTwo-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 更新lastTwo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实做的时候就知道自己这个$O(n^2)$绝对性能贼差。</p>
<h5 id="别人解法"><a href="#别人解法" class="headerlink" title="别人解法"></a>别人解法</h5><ul>
<li>快慢指针定中点(慢一步，快两步，快到尾，慢到中)</li>
<li>后半部分链表反转</li>
<li>插空站队</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == null || head.next == null) <span class="keyword">return</span>;</span><br><span class="line">        ListNode s = head, f = head.next;</span><br><span class="line">        <span class="keyword">while</span> (f != null &amp;&amp; f.next != null) &#123;</span><br><span class="line">            s = s.next;</span><br><span class="line">            f = f.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出后，s指向链表中间节点</span></span><br><span class="line">        ListNode r = s.next; <span class="comment">// r保存s后面的队列</span></span><br><span class="line">        s.next = null;</span><br><span class="line">        ListNode prev = null, curr = r;</span><br><span class="line">        <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">            ListNode t = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时的prev就是反转后的头结点</span></span><br><span class="line">        ListNode c1 = head, c2 = prev, c3 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> le = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (c1 != null &amp;&amp; c2 != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (le % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                c3.next = c1;</span><br><span class="line">                c1 = c1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c3.next = c2;</span><br><span class="line">                c2 = c2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            le ++;</span><br><span class="line">            c3 = c3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c1 != null) c3.next = c1;</span><br><span class="line">        <span class="keyword">if</span> (c2 != null) c3.next = c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表反转通式(头结点为哑结点)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">r</span> = <span class="title">dummyhead</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// 保存头结点以后信息</span></span><br><span class="line">dummyhead-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头结点独立</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">curr</span> = <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">t</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// 保存当前结点后所有信息</span></span><br><span class="line">    curr-&gt;next = prev; <span class="comment">// curr结点的下一个为prev</span></span><br><span class="line">    prev = curr; <span class="comment">// prev更新为curr（前移一位）</span></span><br><span class="line">    curr = t; <span class="comment">// 当前结点更新为当前结点原来的后面信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = prev; <span class="comment">// 此时prev为头结点</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h4><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。</li>
<li>不必考虑输出顺序。</li>
</ul>
<h5 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h5><ul>
<li><code>breakLable</code>解决了p指向是空的情况。</li>
<li>遭遇死亡<code>stack-buffer-overflow</code>和<code>heap-buffer-overflow</code>，初始化<code>returnSize</code>得到结论（Leetcode这个对C的设定真的不好，非要弄<code>returnSize</code>）</li>
<li>提交发现空表出问题，修改了初始返回空数组。</li>
<li>发现一个奇怪的案例不行，本机调试发现对nums1的计数器有问题，问题出在<code>break</code>后，没有考虑中途<code>break</code>和最后<code>break</code>的差别，修改后终于成功。</li>
</ul>
<h5 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h5><p>hash表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 出现次数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span> *<span class="title">next</span>;</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">intersect</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为涉及到出现次数，用hash表</span></span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums1Size == <span class="number">0</span> || nums2Size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">0</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span> *<span class="title">head</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * fmin(nums1Size, nums2Size));</span><br><span class="line">    head = (struct hashNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct hashNode));</span><br><span class="line"></span><br><span class="line">    head-&gt;index = nums1[<span class="number">0</span>];</span><br><span class="line">    head-&gt;value = <span class="number">1</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums1Size; i++) &#123; <span class="comment">// 遍历nums1，得到hash表</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">int</span> breakLabel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] == p-&gt;index)&#123;</span><br><span class="line">                p-&gt;value++;</span><br><span class="line">                breakLabel = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] == p-&gt;index)&#123;</span><br><span class="line">                p-&gt;value++;</span><br><span class="line">                breakLabel = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(breakLabel == <span class="number">0</span>)&#123; <span class="comment">// 若hash表中没有该值，则新建</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span> *<span class="title">newNode</span> = (<span class="title">struct</span> <span class="title">hashNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">hashNode</span>));</span></span><br><span class="line">            newNode-&gt;index = nums1[i];</span><br><span class="line">            newNode-&gt;value = <span class="number">1</span>;</span><br><span class="line">            p-&gt;next = newNode;</span><br><span class="line">            newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2Size; j++) &#123; <span class="comment">// 检查第二个数组里面与hash表的对应情况</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2[j] == p-&gt;index &amp;&amp; p-&gt;value &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                p-&gt;value--;</span><br><span class="line">                res[(*returnSize)++] = nums2[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="双指针思路"><a href="#双指针思路" class="headerlink" title="双指针思路"></a>双指针思路</h5><ul>
<li>如果两个数组是有序的，则可以便捷地计算两个数组的交集。</li>
<li>首先对两个数组进行排序，然后使用两个指针遍历两个数组。</li>
<li>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* _a, <span class="keyword">const</span> <span class="keyword">void</span>* _b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = _a, *b = (<span class="keyword">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a == *b ? <span class="number">0</span> : *a &gt; *b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">intersect</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    qsort(nums1, nums1Size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line">    qsort(nums2, nums2Size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* intersection = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * fmin(nums1Size, nums2Size));</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index1 &lt; nums1Size &amp;&amp; index2 &lt; nums2Size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">            index1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intersection[(*returnSize)++] = nums1[index1];</span><br><span class="line">            index1++;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个思路真的很简单漂亮啊，不过老实说就算提示我排序后更简单，这个方法我也可能会想不到……</li>
</ul>
<hr>
<h4 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h4><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<h5 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>** triangle, <span class="keyword">int</span> triangleSize, <span class="keyword">int</span>* triangleColSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 相当于每行数组左对齐后，只能向右下走或向下走</span></span><br><span class="line">    <span class="comment">// f[i][j] = min&#123;f[i-1][j], f[i-1][j-1]&#125; + f[i][j]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangleSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangleColSize[i]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) &#123;</span><br><span class="line">                triangle[i][j] += triangle[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == triangleColSize[i] - <span class="number">1</span>) &#123;</span><br><span class="line">                triangle[i][j] += triangle[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                triangle[i][j] += fmin(triangle[i<span class="number">-1</span>][j], triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = triangle[triangleSize - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; triangleSize; k++) &#123; <span class="comment">// 逐一遍历最后一行输出最小值</span></span><br><span class="line">        res = triangle[triangleSize - <span class="number">1</span>][k] &lt; res ? triangle[triangleSize - <span class="number">1</span>][k] : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实答案给的一种从三角形下侧遍历到上侧的思路挺好的，因为不用考虑边界情况了（下侧结点多于上侧）。<br>转移方程：<br>$$f[i][j]=min{f[i+1][j], f[i+1][j+1]}$$</p>
<hr>
<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><p>给出n，输出[1:n]的序列能构成的不同的二叉搜索树的数量。</p>
<h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p>dp求解：<br>大体思路：将[1:n]的序列，选定其中一个数为<code>i</code>，以它为根节点，由于根节点不同，所以建出来的树具有唯一性。再具体考虑这个以<code>i</code>为根节点建造的树，左右子树分别是[1:i-1]和[i+1:n]，显然[i+1:n]可以直接转换为[1:n-i]，那么以<code>i</code>为根节点所建造的树就是[1:i-1]和[1:n-i]所建造的树的<strong>笛卡尔乘积</strong>。</p>
<p>具体分析：</p>
<ol>
<li>状态<ul>
<li>$G(n)$：长度为<code>n</code>的序列能构成的不同二叉搜索树的个数</li>
</ul>
</li>
<li>初始条件<br>$$G(0) = G(1) = 1$$</li>
<li>转移方程<br>$$G(n) = \sum_{i=1}^nG(i-1)*G(n-i)$$</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> G[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">    G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两数之和II-输入有序数组"><a href="#两数之和II-输入有序数组" class="headerlink" title="两数之和II-输入有序数组"></a>两数之和II-输入有序数组</h4><p>给定一个升序排列的数组，找到两个数的加和使它们的和为目标数。返回两个数的索引+1。</p>
<h5 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> numbersSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 双指针思路</span></span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> breakLabel = <span class="number">0</span>; <span class="comment">// 寻找到目标数的标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index2 &lt; numbersSize) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index1] + numbers[index2] &lt; target) &#123; <span class="comment">// 如果相邻加起来小于目标数，指针前移</span></span><br><span class="line">            index1++;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index1] + numbers[index2] == target) &#123; <span class="comment">// 如果等于，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果大于目标数</span></span><br><span class="line">            <span class="keyword">while</span>(index1 &gt; <span class="number">0</span>) &#123; <span class="comment">// 先试着逐步后移慢指针</span></span><br><span class="line">                index1--;</span><br><span class="line">                <span class="keyword">if</span>(numbers[index1] + numbers[index2] == target) &#123;</span><br><span class="line">                    breakLabel = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(breakLabel == <span class="number">0</span>) &#123; <span class="comment">// 如果慢指针到头了未找到，更新两个索引为此次循环开始时的位置再各前移一个位置</span></span><br><span class="line">                index2++;</span><br><span class="line">                index1 = index2<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(breakLabel == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳出循环意味着已找到答案</span></span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    res[<span class="number">0</span>] = index1 + <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">1</span>] = index2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题解解法"><a href="#题解解法" class="headerlink" title="题解解法"></a>题解解法</h5><p>双指针分别从两侧向内逼近遍历：</p>
<ul>
<li>如果加和小于<code>target</code>，慢指针前移。</li>
<li>如果加和大于<code>target</code>，慢指针后移。</li>
<li>如果相等，直接返回。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[low] + numbers[high];</span><br><span class="line">            <span class="keyword">if</span> (sum == target)</span><br><span class="line">                <span class="keyword">return</span> &#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                ++low;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</li>
</ul>
<hr>
<h4 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h4><p>给定一个整数，循环计算各位的平方和，直到和为0，输出true。若陷入死循环，输出false。</p>
<h5 id="解法（参照官方题解）"><a href="#解法（参照官方题解）" class="headerlink" title="解法（参照官方题解）"></a>解法（参照官方题解）</h5><p>思路：双指针，建造<strong>虚拟链表</strong><br>原理：当陷入死循环时，相当于之前所有的记录构成了一个含环的链表。快指针前进速率永远是慢指针的两倍，当最后行进相交时，可以证明该链表含环。并没有真的建造一个链表，而是通过累次计算的次数不一样，来逐步构建这个链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        res += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = n, fast = getNext(n);</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="number">1</span> &amp;&amp; slow != fast) &#123;</span><br><span class="line">        slow = getNext(slow);</span><br><span class="line">        fast = getNext(getNext(fast));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="存在重复元素II"><a href="#存在重复元素II" class="headerlink" title="存在重复元素II"></a>存在重复元素II</h4><p>给定一个整数数组和一个整数 <code>k</code>，判断数组中是否存在两个不同的索引 <code>i</code> 和 <code>j</code>，使得 <code>nums [i] = nums [j]</code>，并且 <code>i</code> 和 <code>j</code>的差的绝对值至多为 <code>k</code>。</p>
<h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><p>这个解法出自于官方题解，思路很简单，但主要是它的边界处理给了我一些启发。如果是以一个搜索框进行遍历操作的时候，越界的时候，以后可以用<code>max</code>或<code>min</code>这些函数来优雅地解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.max(i - k, <span class="number">0</span>); j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Time Limit Exceeded.</span></span><br></pre></td></tr></table></figure>

<h5 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h5><h6 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h6><p>通过散列表，即创造一个长度为k的表。<br>遍历数组，对于每个元素：</p>
<ul>
<li>在散列表中进行搜索，若存在，返回<code>true</code></li>
<li>在散列表中插入当前元素</li>
<li>如果当前大小超过了k，则将所待最久的元素移除</li>
</ul>
<p>相当于一个<strong>能遍历的队列</strong>。</p>
<h6 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h6><p>通过<code>hash</code>，<code>key</code>为<code>num</code>，<code>value</code>为其<code>index</code>。<br>遍历数组，对于每个元素：</p>
<ul>
<li>若元素在表中，判断<code>i-m[nums[i]] &lt;= k</code><ul>
<li>若<code>true</code>，返回<code>true</code></li>
<li>若<code>false</code>，更新其<code>m[nums[i]]</code>为<code>i</code></li>
</ul>
</li>
<li>若元素不在表中，更新其<code>m[nums[i]]</code>为<code>i</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter != m.<span class="built_in">end</span>() &amp;&amp; i - m[nums[i]] &lt;= k) &#123;</span><br><span class="line">                <span class="comment">// 若存在表中，且下标差符合要求</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="存在重复元素III"><a href="#存在重复元素III" class="headerlink" title="存在重复元素III"></a>存在重复元素III</h4><h5 id="个人解法（超时）"><a href="#个人解法（超时）" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// key:nums[i] value:i</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(nums[j]);</span><br><span class="line">            <span class="keyword">if</span>(iter != m.<span class="built_in">end</span>() &amp;&amp; j - iter-&gt;second &lt;= k)&#123; <span class="comment">// 如果新纳入的值已经存在表中 且 index差小于等于k 则返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">// 否则更新表</span></span><br><span class="line">                m[nums[j]] = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = nums[j]; <span class="comment">// temp表示当前的纳入表的数值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = temp-t; i &lt;= temp+t; ++i) &#123; </span><br><span class="line">                <span class="comment">// 然后在哈希表的[temp-t,temp+t]范围搜索是否这样的key为i</span></span><br><span class="line">                <span class="comment">// 使得 value存在(当前表中存在满足绝对值差&lt;=t条件的数) 且 m[nums[j]]-m[i] &lt;= k(存在的数也满足下标差&lt;=k)</span></span><br><span class="line">                <span class="keyword">if</span>(m.count(i) == <span class="number">1</span> &amp;&amp; m[temp] - m[i] &lt;= k &amp;&amp; i!=temp) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要是在<code>[temp-t,temp+t]</code>范围内查找的时候，如果t过大，会很慢很慢。</p>
<h5 id="他人解法"><a href="#他人解法" class="headerlink" title="他人解法"></a>他人解法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; <span class="built_in">set</span>;  <span class="comment">// 新建集合set</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;  <span class="comment">// 遍历nums</span></span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">set</span>.lower_bound((<span class="keyword">long</span>) nums[i] - t);  <span class="comment">// 将不小于nums[i] - t的迭代器返回给it</span></span><br><span class="line">            <span class="keyword">if</span>(it != <span class="built_in">set</span>.<span class="built_in">end</span>() &amp;&amp; *it &lt;= (<span class="keyword">long</span>) nums[i] + t)</span><br><span class="line">            <span class="comment">// 如果这个数存在，且不大于nums[i] + t</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">set</span>.insert(nums[i]);  <span class="comment">// 将nums[i]加入set集合</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">size</span>() == k + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">set</span>.erase(nums[i - k]); <span class="comment">//保证滑动窗口大小为k</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h4><p>给定字符串<code>s</code>和<code>t</code>，判断<code>s</code>是否为<code>t</code>的子序列。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<h5 id="个人解答-2"><a href="#个人解答-2" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n_s = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_s ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">n_t</span> = t.length();  <span class="comment">// 更新t的长度</span></span><br><span class="line">            <span class="keyword">auto</span> pos = t.<span class="built_in">find</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(pos != t.npos) &#123; <span class="comment">// 如果找到了，将t替换成其后的子串</span></span><br><span class="line">                t = t.substr(pos + <span class="number">1</span>, <span class="keyword">n_t</span> - pos - <span class="number">1</span>); <span class="comment">// 更新t</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="排列硬币"><a href="#排列硬币" class="headerlink" title="排列硬币"></a>排列硬币</h4><p>你总共有<code>n</code>枚硬币，你需要将它们摆成一个阶梯形状，第<code>k</code>行就必须正好有<code>k</code>枚硬币。</p>
<p>给定一个数字<code>n</code>，找出可形成完整阶梯行的总行数。</p>
<p><code>n</code>是一个非负整数，并且在32位有符号整型的范围内。</p>
<h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p>时间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt;= i) &#123;</span><br><span class="line">            n -= i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h5><p>时间复杂度：$O(log_2(n/2+1))$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找[1:n/2 + 1]中的一个中间数mid，使得(mid+1)*mid/2==n</span></span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">0</span>, <span class="built_in">end</span> = (<span class="keyword">long</span>)n / <span class="number">2</span> + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span> - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid * (mid + <span class="number">1</span>) == (<span class="keyword">long</span>)n * <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">int</span>(mid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid * (mid + <span class="number">1</span>) &lt; (<span class="keyword">long</span>)n * <span class="number">2</span>) &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">end</span> = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">end</span> * (<span class="built_in">end</span> + <span class="number">1</span>) == (<span class="keyword">long</span>)n * <span class="number">2</span>) ? (<span class="keyword">int</span>)<span class="built_in">end</span> : (<span class="keyword">int</span>)start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a>计数质数</h4><p>统计所有小于非负整数<code>n</code>的质数的数量。</p>
<h5 id="个人解法（超时）-1"><a href="#个人解法（超时）-1" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= (n<span class="number">-1</span>)/<span class="number">2</span>; ++i) &#123; </span><br><span class="line">            <span class="keyword">if</span>((n<span class="number">-1</span>) % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> countPrimes(n<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countPrimes(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="题解解法-1"><a href="#题解解法-1" class="headerlink" title="题解解法"></a>题解解法</h5><p>是排除法，排除从1到n-1范围内的所有质数（将其标志位置为0）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//n = 15</span></span><br><span class="line">        <span class="keyword">int</span> a[n+<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            a[i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i)</span><br><span class="line">                    a[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>没有想到有朝一日，这题居然也成了问题，但真没写对，555</p>
<h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><p>假设列表为：<br>$$n1\rightarrow…\rightarrow n_{k-1}\rightarrow n_k\rightarrow…\rightarrow n_m \rightarrow \varnothing$$<br>若$n_{k+1}$到$n_m$已经被反转，而我们已经处于$n_k$。<br>$$n1\rightarrow…\rightarrow n_{k-1}\rightarrow n_k\leftarrow…\leftarrow n_m$$<br>则只需将$n_{k+1}$的下一个结点指向$n_k$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="仅含1的字符串"><a href="#仅含1的字符串" class="headerlink" title="仅含1的字符串"></a>仅含1的字符串</h4><p>给你一个二进制字符串<code>s</code>（仅由<code>&#39;0&#39;</code>和<code>&#39;1&#39;</code>组成的字符串）。</p>
<p>返回所有字符都为<code>1</code>的子字符串的数目。</p>
<p>由于答案可能很大，请你将它对<code>10^9 + 7</code>取模后返回。</p>
<h5 id="个人解法-2"><a href="#个人解法-2" class="headerlink" title="个人解法"></a>个人解法</h5><p>hash表记录每段连续的1出现次数以及频次。<br>例如：<code>&quot;01101110111110011&quot;</code><br>对应的hash表为<br><code>m[2] = 2;
m[3] = 1;
m[5] = 1;</code><br>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSub</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oneCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// key:连续1出现的次数 value:这个次数出现的频次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                oneCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'0'</span> &amp;&amp; oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(m.count(oneCount) == <span class="number">0</span>) <span class="comment">// hash表中没有对应的键</span></span><br><span class="line">                    m[oneCount] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    m[oneCount]++;</span><br><span class="line">            &#125; </span><br><span class="line">            oneCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m.count(oneCount) == <span class="number">0</span>) <span class="comment">// hash表中没有对应的键</span></span><br><span class="line">                    m[oneCount] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m[oneCount]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;int,int&gt;&gt; v_map(m.begin(),m.end());</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, tn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tmp:v_map)&#123;</span><br><span class="line">            tn = ((<span class="keyword">long</span>)tmp.first + <span class="number">1</span>)*(<span class="keyword">long</span>)tmp.first / <span class="number">2</span>; <span class="comment">// 计算1+2+3+...+n</span></span><br><span class="line">            sum += ((<span class="keyword">long</span>)tmp.second*tn); <span class="comment">// 加等于 tn乘对应频次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(sum%MAXN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h5 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h5><p>不需要hash表，直接就地+=运算（瞬间感觉我用hash表，简直是脱裤子放p）<br>速度快了一倍多，，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">calValue</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * (n+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSub</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oneCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> MAXN = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                oneCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'0'</span> &amp;&amp; oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += calValue(oneCount);</span><br><span class="line">            &#125; </span><br><span class="line">            oneCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += calValue(oneCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(sum%MAXN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h4><p>有<code>n</code>个气球，编号为<code>0</code>到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p>
<p>现在要求你戳破所有的气球。如果你戳破气球<code>i</code>，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的<code>left</code>和<code>right</code>代表和<code>i</code>相邻的两个气球的序号。注意当你戳破了气球<code>i</code>后，气球<code>left</code>和气球<code>right</code>就变成了相邻的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>说明:</p>
<ul>
<li>你可以假设<code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li>
<li><code>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</code></li>
</ul>
<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>看了好几个大佬的题解，都是从回溯法到记忆递归向下一步步优化到动态规划的。<br><a href="https://qoogle.top/leetcode-312-burst-balloons/" target="_blank" rel="noopener">大佬1传送门</a><br><a href="https://www.cnblogs.com/niuyourou/p/11964842.html" target="_blank" rel="noopener">大佬2传送门</a></p>
<h5 id="动态规划代码"><a href="#动态规划代码" class="headerlink" title="动态规划代码"></a>动态规划代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>)); <span class="comment">// 新建一个dp二维数组</span></span><br><span class="line">        nums.push_back(<span class="number">1</span>);</span><br><span class="line">        nums.insert(nums.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k<span class="number">-1</span>] + dp[k+<span class="number">1</span>][j] + nums[k] * nums[i - <span class="number">1</span>] * nums[j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="旋转数组的最小值"><a href="#旋转数组的最小值" class="headerlink" title="旋转数组的最小值"></a>旋转数组的最小值</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 $[3,4,5,1,2]$ 为 $[1,2,3,4,5]$ 的一个旋转，该数组的最小值为1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分查找:找到该元素的左侧大于它，右侧大于等于它</span></span><br><span class="line">        <span class="keyword">int</span> n = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">end</span> &gt; start) &#123;</span><br><span class="line">            <span class="comment">//int mid = (start + end) / 2;</span></span><br><span class="line">            <span class="keyword">int</span> mid = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &lt; numbers[<span class="built_in">max</span>(<span class="number">0</span>, mid - <span class="number">1</span>)] <span class="comment">/*&amp;&amp; numbers[mid] &lt;= numbers[min(n - 1, mid + 1)]*/</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[mid];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[<span class="built_in">end</span>]) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[<span class="built_in">end</span>]) &#123;</span><br><span class="line">                <span class="built_in">end</span> = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">end</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="built_in">end</span>];       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个解法的边界处理非常值得总结一下，尤其是<code>start = mid + 1</code>和<code>end--</code>这两个地方非常容易出错。</p>
<ul>
<li><code>start = mid + 1</code>避免了形同$[3,1]$这种类型</li>
<li><code>end--</code>避免了$[1,1,1]$这样的结尾出现重复数的情形</li>
</ul>
<hr>
<p>Leetcode日记I就到这里啦，LeetcodeII日记再见~</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/C/" rel="tag"># C</a>
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/01/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="ES6学习笔记">
      <i class="fa fa-chevron-left"></i> ES6学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/03/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-2/" rel="next" title="python爬虫笔记_2">
      python爬虫笔记_2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制求和"><span class="nav-number">1.</span> <span class="nav-text">二进制求和</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#需求"><span class="nav-number">1.1.</span> <span class="nav-text">需求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解答-Python"><span class="nav-number">1.2.</span> <span class="nav-text">个人解答(Python)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#算法改进"><span class="nav-number">1.3.</span> <span class="nav-text">算法改进</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#法2：位运算"><span class="nav-number">1.4.</span> <span class="nav-text">法2：位运算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#爬楼梯"><span class="nav-number">2.</span> <span class="nav-text">爬楼梯</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#需求-1"><span class="nav-number">2.1.</span> <span class="nav-text">需求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解答-Python-1"><span class="nav-number">2.2.</span> <span class="nav-text">个人解答(Python)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#我的总结"><span class="nav-number">2.3.</span> <span class="nav-text">我的总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法1：动态规划！"><span class="nav-number">2.4.</span> <span class="nav-text">方法1：动态规划！</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法2：斐波那契公式"><span class="nav-number">2.5.</span> <span class="nav-text">方法2：斐波那契公式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除链表的倒数第n个节点"><span class="nav-number">3.</span> <span class="nav-text">删除链表的倒数第n个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解答-C-两次遍历"><span class="nav-number">3.1.</span> <span class="nav-text">个人解答(C,两次遍历)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#我的总结-1"><span class="nav-number">3.2.</span> <span class="nav-text">我的总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优化：一次遍历法（双指针）"><span class="nav-number">3.3.</span> <span class="nav-text">优化：一次遍历法（双指针）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跳跃游戏"><span class="nav-number">4.</span> <span class="nav-text">跳跃游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#需求-2"><span class="nav-number">4.1.</span> <span class="nav-text">需求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解答-C"><span class="nav-number">4.2.</span> <span class="nav-text">个人解答(C)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标答-贪心法"><span class="nav-number">4.3.</span> <span class="nav-text">标答(贪心法)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两链表之和"><span class="nav-number">5.</span> <span class="nav-text">两链表之和</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#题目"><span class="nav-number">5.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解答"><span class="nav-number">5.2.</span> <span class="nav-text">个人解答</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跳水板"><span class="nav-number">6.</span> <span class="nav-text">跳水板</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#题目-1"><span class="nav-number">6.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解答-1"><span class="nav-number">6.2.</span> <span class="nav-text">个人解答</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除排序链表里的重复元素II"><span class="nav-number">7.</span> <span class="nav-text">删除排序链表里的重复元素II</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#个人原解答"><span class="nav-number">7.1.</span> <span class="nav-text">个人原解答</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标准解法"><span class="nav-number">7.2.</span> <span class="nav-text">标准解法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#方法1：递归"><span class="nav-number">7.2.1.</span> <span class="nav-text">方法1：递归</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#方法2：hash表"><span class="nav-number">7.2.2.</span> <span class="nav-text">方法2：hash表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#方法3：双指针"><span class="nav-number">7.2.3.</span> <span class="nav-text">方法3：双指针</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#个人感悟"><span class="nav-number">7.3.</span> <span class="nav-text">个人感悟</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#恢复空格"><span class="nav-number">8.</span> <span class="nav-text">恢复空格</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#别人解答C"><span class="nav-number">8.1.</span> <span class="nav-text">别人解答C</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相交链表"><span class="nav-number">9.</span> <span class="nav-text">相交链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#环形链表"><span class="nav-number">10.</span> <span class="nav-text">环形链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地下城与勇士"><span class="nav-number">11.</span> <span class="nav-text">地下城与勇士</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#题目-2"><span class="nav-number">11.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#初代解法（失败）"><span class="nav-number">11.2.</span> <span class="nav-text">初代解法（失败）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二代解法（成功）"><span class="nav-number">11.3.</span> <span class="nav-text">二代解法（成功）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重排链表"><span class="nav-number">12.</span> <span class="nav-text">重排链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解法"><span class="nav-number">12.1.</span> <span class="nav-text">个人解法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#别人解法"><span class="nav-number">12.2.</span> <span class="nav-text">别人解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组交集"><span class="nav-number">13.</span> <span class="nav-text">数组交集</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#踩过的坑"><span class="nav-number">13.1.</span> <span class="nav-text">踩过的坑</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#我的解法"><span class="nav-number">13.2.</span> <span class="nav-text">我的解法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双指针思路"><span class="nav-number">13.3.</span> <span class="nav-text">双指针思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三角形最小路径和"><span class="nav-number">14.</span> <span class="nav-text">三角形最小路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#我的解法-1"><span class="nav-number">14.1.</span> <span class="nav-text">我的解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同的二叉搜索树"><span class="nav-number">15.</span> <span class="nav-text">不同的二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#题目-3"><span class="nav-number">15.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#题目分析"><span class="nav-number">15.2.</span> <span class="nav-text">题目分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两数之和II-输入有序数组"><span class="nav-number">16.</span> <span class="nav-text">两数之和II-输入有序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解法-1"><span class="nav-number">16.1.</span> <span class="nav-text">个人解法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#题解解法"><span class="nav-number">16.2.</span> <span class="nav-text">题解解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快乐数"><span class="nav-number">17.</span> <span class="nav-text">快乐数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#解法（参照官方题解）"><span class="nav-number">17.1.</span> <span class="nav-text">解法（参照官方题解）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存在重复元素II"><span class="nav-number">18.</span> <span class="nav-text">存在重复元素II</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#暴力解法"><span class="nav-number">18.1.</span> <span class="nav-text">暴力解法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优化解法"><span class="nav-number">18.2.</span> <span class="nav-text">优化解法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#解法1"><span class="nav-number">18.2.1.</span> <span class="nav-text">解法1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#解法2"><span class="nav-number">18.2.2.</span> <span class="nav-text">解法2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存在重复元素III"><span class="nav-number">19.</span> <span class="nav-text">存在重复元素III</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解法（超时）"><span class="nav-number">19.1.</span> <span class="nav-text">个人解法（超时）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#他人解法"><span class="nav-number">19.2.</span> <span class="nav-text">他人解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断子序列"><span class="nav-number">20.</span> <span class="nav-text">判断子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解答-2"><span class="nav-number">20.1.</span> <span class="nav-text">个人解答</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排列硬币"><span class="nav-number">21.</span> <span class="nav-text">排列硬币</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代法"><span class="nav-number">21.1.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二分法"><span class="nav-number">21.2.</span> <span class="nav-text">二分法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计数质数"><span class="nav-number">22.</span> <span class="nav-text">计数质数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解法（超时）-1"><span class="nav-number">22.1.</span> <span class="nav-text">个人解法（超时）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#题解解法-1"><span class="nav-number">22.2.</span> <span class="nav-text">题解解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反转链表"><span class="nav-number">23.</span> <span class="nav-text">反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#递归法"><span class="nav-number">23.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代法-1"><span class="nav-number">23.2.</span> <span class="nav-text">迭代法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#仅含1的字符串"><span class="nav-number">24.</span> <span class="nav-text">仅含1的字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#个人解法-2"><span class="nav-number">24.1.</span> <span class="nav-text">个人解法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#算法优化"><span class="nav-number">24.2.</span> <span class="nav-text">算法优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#戳气球"><span class="nav-number">25.</span> <span class="nav-text">戳气球</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#解法"><span class="nav-number">25.1.</span> <span class="nav-text">解法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态规划代码"><span class="nav-number">25.2.</span> <span class="nav-text">动态规划代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#旋转数组的最小值"><span class="nav-number">26.</span> <span class="nav-text">旋转数组的最小值</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Michael Johnson"
      src="/images/%E7%A8%8B%E5%BA%8F%E7%8C%BF.jpg">
  <p class="site-author-name" itemprop="name">Michael Johnson</p>
  <div class="site-description" itemprop="description">小白的个人网站</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/shmilyiris" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shmilyiris" rel="noopener" target="_blank"><i class="我的github主页 fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Michael Johnson</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <i class="fa fa-user-md"></i>
    <span id="busuanzi_container_site_uv">
        本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_pv">
        本站访问量<span id="busuanzi_value_site_pv"></span>
    </span>
</div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"llRolgqGW9Ba4yUFTcxq9h8k-gzGzoHsz","app_key":"VmrmbmRVQov7ocjkzavv3vx2","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
