<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020暑假第一阶段学习</title>
    <url>/2020/07/04/2020%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>这是个大二升大三的关键暑假，下学期各类与计算机专业无关的课真的烦，必须要再这个暑假抽出时间来学习计算机。我暑期的学习目标就是<strong>完成并巩固基础课的学习</strong>并以兴趣带动学习<strong>完成一个小项目(暂定前端开发)</strong>。这个文档来规划和督促我的这个第一阶段的学习。</p>
<a id="more"></a>
<h3 id="事项交代"><a href="#事项交代" class="headerlink" title="事项交代"></a>事项交代</h3><h4 id="暑期学习表（不断更新）"><a href="#暑期学习表（不断更新）" class="headerlink" title="暑期学习表（不断更新）"></a>暑期学习表（不断更新）</h4><p>开局暴击！！！<br>暑期待学课程以及学习时间表：</p>
<table>
<thead>
<tr>
<th align="center">课程</th>
<th align="center">学习方式</th>
<th align="center">视频时长</th>
<th align="center">学习时长</th>
<th align="center">时长明细</th>
<th align="center">阶段安排</th>
</tr>
</thead>
<tbody><tr>
<td align="center">六级刷题</td>
<td align="center">刷题</td>
<td align="center">0</td>
<td align="center">16h</td>
<td align="center">2h*8套</td>
<td align="center">各阶段</td>
</tr>
<tr>
<td align="center">爬虫</td>
<td align="center">课程+实战</td>
<td align="center">3h</td>
<td align="center">3h</td>
<td align="center">3h+3h</td>
<td align="center">1阶段</td>
</tr>
<tr>
<td align="center">Vue</td>
<td align="center">课程</td>
<td align="center">5h</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1阶段</td>
</tr>
<tr>
<td align="center">数据结构</td>
<td align="center">课件+实验回顾+blog</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">各阶段</td>
</tr>
<tr>
<td align="center">数据分析</td>
<td align="center">课程+实战</td>
<td align="center">28h</td>
<td align="center"></td>
<td align="center">28+</td>
<td align="center">1、2阶段</td>
</tr>
<tr>
<td align="center">操作系统</td>
<td align="center">课程+实验</td>
<td align="center">22h</td>
<td align="center"></td>
<td align="center">22+</td>
<td align="center">1、2阶段</td>
</tr>
<tr>
<td align="center">数据结构+算法</td>
<td align="center">课件+实验回顾</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">各阶段</td>
</tr>
<tr>
<td align="center">计算机网络</td>
<td align="center">课程</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2、3阶段</td>
</tr>
<tr>
<td align="center">计组</td>
<td align="center">课程+实验</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2、3阶段</td>
</tr>
<tr>
<td align="center">人工智能</td>
<td align="center">课件+实验回顾</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2、3阶段</td>
</tr>
</tbody></table>
<h4 id="该阶段主要目标"><a href="#该阶段主要目标" class="headerlink" title="该阶段主要目标"></a>该阶段主要目标</h4><p>第一阶段暂定日期 <strong>7.4~7.26</strong>共三周时间完成！<br>第一阶段的主要目标是至少完成：</p>
<ul>
<li>爬虫</li>
<li>Vue</li>
<li>操作系统的理论部分</li>
<li>数据分析的Excel和MySQL部分</li>
<li>Leetcode(每日一题)</li>
</ul>
<p>其余的像六级刷题、数据结构、Leetcode这几个贯穿整个暑假始终的学习项目也不能落下！</p>
<p>第一阶段要完成的大作业有：</p>
<ul>
<li>基于Vue的仿制音乐播放</li>
<li>blog部分 数据结构树图部分以前的大作业汇总</li>
<li>3套六级试题</li>
</ul>
<p>blog每天更新，记录自己一天干了什么，以及个人总结！<br>冲冲冲！！</p>
<h3 id="日志部分"><a href="#日志部分" class="headerlink" title="日志部分"></a>日志部分</h3><p>以下为这阶段的学习日记</p>
<hr>
<h4 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h4><h5 id="小笔记"><a href="#小笔记" class="headerlink" title="小笔记"></a>小笔记</h5><h6 id="HTML-DOM节点"><a href="#HTML-DOM节点" class="headerlink" title="HTML DOM节点"></a>HTML DOM节点</h6><p>在HTML DOM中，每个东西都是<strong>节点</strong>：</p>
<ul>
<li>文档本身是一个文档对象</li>
<li>所有HTML元素都是元素节点</li>
<li>所有HTML属性都是属性节点</li>
<li>插入到HTML元素文本时文本节点</li>
<li>注释是注释节点</li>
</ul>
<h5 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h5><p>今天购买了<strong>机器学习实战</strong>这本书，当作这个暑假的入门教材来读！可以在2、3阶段重点学习一下经典的代码实现。</p>
<h6 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h6><p>8:00~9:00，刷了两道Leetcode。分别是<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">求x的平方根</a>和<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a>，都比较简单。前者运用基本不等式，后者是逻辑简单的遍历链表。</p>
<p>9:00~10:30，学习了操作系统的有关内存这部分的内容。主要搞清楚了逻辑地址和物理地址的生成方法，以及os在这之中到底起到了什么样的作用。除此以外，内存分层结构也体现了计算机存储数据的一个层次关系（从CPU到物理内存到磁盘，容量正三角，速度倒三角）。最后就是有关连续内存分配的内存碎片的处理的简单知识。</p>
<p>附上7.3的重点：</p>
<ul>
<li>BIOS,bootloader,os在启动过程中的行为和作用</li>
<li>系统调用、异常和中断三个定义和大体过程</li>
<li>应用程序,os,外设之间的简单逻辑关系</li>
</ul>
<p>附上7.4重点：</p>
<ul>
<li>内存层次结构</li>
<li>逻辑地址生成</li>
<li>物理地址生成</li>
<li>内存调度三个方法</li>
<li>交换式碎片整理</li>
</ul>
<p>11:00~12:00，复习整理了数据结构单链表一块的知识，巩固了malloc和free的用法。</p>
<p>13:00~15:00，观看了<a href="https://www.bilibili.com/video/BV1xb411e7ww" target="_blank" rel="noopener">动态规划入门视频</a>，完成了一个分配钱实例，从中了解到了动态规划的精妙之处，单论这一个实例简直是完爆了递归和贪心算法。同时得知了<strong>动态规划的重要性，极其极其大！</strong>所以后期这部分的学习可以更精致一些，今天看完了前40分钟，明天继续。</p>
<p>16:00~17:00，完成了python的requests库到bs4库的全部学习，完成了大学排名爬取的小实验，直接深刻的掌握了标签树的相关关系。但是中文对齐这方面，发现pycharm的输出和idle的输出有一些偏差，表头由于全中文整体偏右。</p>
<p>20:00~21:00，观看完了<a href="https://www.bilibili.com/video/BV12J411m7MG" target="_blank" rel="noopener">vue入门视频</a>的前五节，从官方文档体会到了vue的类似字符串模板的一种理念。<code>Vue</code>是一个构造函数，该函数的参数（从语法上，我是直观上这样理解的不知道对不对）是一个包含<code>el</code>和<code>data</code>属性的对象。</p>
<ul>
<li><code>el</code>:设置挂载点，通过css选择器设置vue实例管理元素，el命中元素的内部的大括号内数据被同名的data替换</li>
<li><code>data</code>:数据对象，object、string、array……</li>
</ul>
<p>22:00~23:00，完成了Leetcode上的<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第n个节点</a>，算是一个对今天链表复习的巩固。而且又一次遇到了双指针，下次我一定能想出来双指针。</p>
<h6 id="今日感悟"><a href="#今日感悟" class="headerlink" title="今日感悟"></a>今日感悟</h6><p>以后Leetcode上刷题，要刷今天学的知识，就当是巩固啦~</p>
<hr>
<h4 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h4><p>今天比昨天懒了许多，这才第二天啊，反省！</p>
<h5 id="小笔记-1"><a href="#小笔记-1" class="headerlink" title="小笔记"></a>小笔记</h5><p>地址空间是操作系统如何跟踪分配给每个程序的内存的方式。</p>
<p>内存空间是堆中的实际物理内存。</p>
<p>地址空间映射到内存空间，当程序终止时，内存空间被释放回堆。</p>
<p>地址空间是虚拟的，也称为虚拟内存。</p>
<p>虚拟内存给人的印象是计算机内存很大，但是它一直在重复使用内存空间。</p>
<h5 id="时间线-1"><a href="#时间线-1" class="headerlink" title="时间线"></a>时间线</h5><p>9:30~11:30，学习了操作系统非连续内存分配这部分内容。将之前学过的分段和分页机制尤其是<strong>分页机制的如何将逻辑地址空间映射到物理地址空间</strong>这方面搞得很明白了。关键的几个流程图都记在了Goodnotes上，课下要经常翻阅这部分的内容。</p>
<ul>
<li>分段机制</li>
<li>分页机制</li>
<li>页寻址机制</li>
<li><a href="https://blog.csdn.net/qq_37924084/article/details/78360003" target="_blank" rel="noopener">分段与分页</a></li>
</ul>
<p>13:00~15:00, 继续动态规划，掌握了动态规划3问题中的两个：最值问题、计数问题，并完成了两个实例。</p>
<p>16:00~17:00，爬虫的正则表达式库的学习，掌握了正则表达式的语法。还未进入re库的学习。</p>
<p>19:30~20:30，继续学习了一小部分Vue的内容。还未感受到Vue的简单之处，可能是之前并未做过类似的前端大作业，对原来直接操作DOM和现在这种挂载的方式并未感受到其强大。</p>
<p>21:00~22:00，Leetcode做了一道动态规划的题，正好遇到了一个明天要学的题，按照思路做出来了，明天看完那位大神的教程之后再写这个Leetcode的总结。</p>
<hr>
<h4 id="7-6-7-7"><a href="#7-6-7-7" class="headerlink" title="7.6-7.7"></a>7.6-7.7</h4><h5 id="小笔记-2"><a href="#小笔记-2" class="headerlink" title="小笔记"></a>小笔记</h5><p>有关TLB的相关知识：</p>
<p>页表一般都很大，并且存放在内存中，所以处理器引入MMU后，读取指令、数据<strong>需要访问两次内存：首先通过查询页表得到物理地址，然后访问该物理地址读取指令、数据</strong>。为了减少因为MMU导致的处理器性能下降，引入了TLB，TLB是Translation Lookaside Buffer的简称，可翻译为“地址转换后援缓冲器”，也可简称为“快表”。简单地说，<strong>TLB就是页表的Cache</strong>，其中<strong>存储了当前最可能被访问到的页表项</strong>，其内容是<strong>部分页表项的一个<em>副本</em></strong>。只有在TLB无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。</p>
<p>TLB中的项由两部分组成：<strong>标识和数据</strong>。标识中存放的是虚地址的一部分，而数据部分中存放物理页号、存储保护信息以及其他一些辅助信息。</p>
<p>因为页大小是8KB，所以虚拟地址的0-12bit作为页内地址偏移。TLB表有64项，所以虚拟地址的13-18bit作为TLB表项的索引。假如虚拟地址的13-18bit是1，那么就会查询TLB的第1项，从中取出标识，与虚拟地址的19-31位作比较，如果相等，表示TLB命中，反之，表示TLB失靶。TLB失靶时，可以由硬件将需要的页表项加载入TLB，也可由软件加载，具体取决于处理器设计，OR1200没有提供硬件加载页表项的功能，只能由软件实现。TLB命中时，此时翻译得到的物理地址就是TLB第1项中的标识（即物理地址13-31位）与虚拟地址0-12bit的结合。在地址翻译的过程中还会结合TLB项中的辅助信息判断是否发生违反安全策略的情况，比如：要修改某一页，但该页是禁止修改的，此时就违反了安全策略，会触发异常。</p>
<h5 id="时间线-2"><a href="#时间线-2" class="headerlink" title="时间线"></a>时间线</h5><p>10:00~12:00，完成操作系统的非连续内存分配内容，虚拟内存单元开了个小头。重点学习了页表的机制。</p>
<ul>
<li>页表内容(resident bit)</li>
<li>TLB引入</li>
<li>内存覆盖技术</li>
</ul>
<p>14:00~15:30，完成了re库爬虫的理论部分，正则表达式使用起来非常方便，具体语法还需加深记忆。</p>
<p>17:00~18:00，完成了动态规划的网课学习。理论上已经知道如何解决动态规划的三类题，具体解决还需勤加练习。另外的，某些题目(跳跃游戏)更适配贪心法，并不是所有题目都适配动态规划。贪心法和动态规划法的理论部分了解不够深入，还需回溯定义。</p>
<p>19:00~21:00，磕了一道Leetcode，具体见Leetcode日记。</p>
<hr>
<h4 id="7-8"><a href="#7-8" class="headerlink" title="7.8"></a>7.8</h4><h5 id="时间线-3"><a href="#时间线-3" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~11:30，Leetcode。</p>
<p>12:30~14:00，操作系统的交换技术和虚存技术。这部分内容和前边的分配内存关系非常大，主要目的都是实现<strong>小内存运行大程序</strong>的目标，让程序用着几M的内存以为自己畅游在几G的内存空间里，这就是所谓的虚拟内存。</p>
<ul>
<li>内存交换技术</li>
<li>虚存技术的原理</li>
</ul>
<p>16:00~17:30，Python实现淘宝比价定向爬取实例，运行之后居然都没爬出来？查看了网页源代码，应该是网页格式已经更新换代了，raw_title和raw_value的键值对已经不存在了。。明天再搞吧。</p>
<p>19:00~21:00，Leetcode跳水板问题，循环居然写反了，反思反思！</p>
<p>22:30~1:00，我又愉快的做了道力扣，法克，快被气死了，为啥中级题老是写不对啊，我真垃圾。</p>
<h5 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h5><p>Leetcode的题真的很值得玩味，有的看似简单……双指针问题还需要继续练啊，我考虑边界问题的能力简直弱爆了。。</p>
<hr>
<h4 id="7-9"><a href="#7-9" class="headerlink" title="7.9"></a>7.9</h4><h5 id="时间线-4"><a href="#时间线-4" class="headerlink" title="时间线"></a>时间线</h5><p>9:30~11:00，总结Leetcode题目。</p>
<p>11:40~13:00，操作系统之虚存技术的实现。虚存技术的实现流程就是在页式的基础上增加请求调页和页面换入换出操作。精髓是，在运行的过程中不断地调入需要的页和数据，这一技术的实现，首先要求局部性原理要好(参照双循环按列遍历和按行遍历的区别)，这样在性能计算上参数<code>p</code>（缺页概率）才会尽可能小，效率才理想。</p>
<ul>
<li>缺页中断的处理</li>
<li>虚拟内存的性能</li>
</ul>
<p>15:00~17:00，听项目组会。以后每周要向老师汇报啊，哭-_-</p>
<p>18:00~20:00，一直检查那道Leetcode题目–恢复空格。<br>注意：在C语言中，要想运用<code>strcmp</code>判断字符数组和一个字符串是否相等，一定要在字符数组的结尾添加一个<code>&#39;\0&#39;</code>元素才可以！<br>另外：Hash表好🐂🍺，这周完了我再不会hash我就是🐕！</p>
<p>plus：总结的有关c语言的各种初始化：</p>
<ol>
<li><p>字符数组</p>
<ul>
<li>动态构建时，结尾必须有<code>&#39;\0&#39;</code>(还可以直接<code>scanf</code>输入)</li>
<li>静态构建时，这两个方法是等价的哦<ol>
<li><code>char sentence[] = &quot;justdoit&quot;;</code></li>
<li><code>char sentence[] = {&#39;j&#39;,&#39;u&#39;,&#39;s&#39;...&#39;t&#39;,&#39;\0&#39;}</code></li>
<li><code>char sentence[7] = {&#39;j&#39;,&#39;u&#39;,&#39;s&#39;...&#39;t&#39;,&#39;\0&#39;}</code></li>
</ol>
</li>
</ul>
</li>
<li><p>字符串数组</p>
<ul>
<li>静态构建:<code>const char* dictionary[5] = { &quot;just&quot;, &quot;do&quot;, &quot;it&quot; };</code></li>
<li><a href="https://blog.csdn.net/qq_39516859/article/details/83384880" target="_blank" rel="noopener">动态构建</a>：一般应该是用那个for循环来。</li>
</ul>
</li>
</ol>
<p>20:00~21:30，爬虫的实例完成，原来没有完成的原因是该宝变严了，具体解决方法参见python爬虫笔记-3。</p>
<p>21:30~22:30，hash表的部分学习，唤醒了之前的不少记忆，应该能很快掌握。</p>
<hr>
<h4 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h4><h5 id="时间线-5"><a href="#时间线-5" class="headerlink" title="时间线"></a>时间线</h5><p>9:00~11:00，操作系统的四个页面置换算法，这段比较好理解。</p>
<ul>
<li>OPT算法</li>
<li>FIFO算法</li>
<li>LRU算法</li>
<li>Clock置换算法</li>
</ul>
<p>12:00~13:30，Leetcode的一道dp题，这次的dp是多状态的，总结在Leetcode笔记里了。</p>
<p>16:00~17:00，Hash表的学习。<br>plus：买了一本考研机试的书，希望能提高应试能力吧。</p>
<p>19:00~20:00，一道简单的Leetcode题目，合并两个有序数组。</p>
<h5 id="今日感悟-1"><a href="#今日感悟-1" class="headerlink" title="今日感悟"></a>今日感悟</h5><p>最近真的懒了好多，最近几天说好的MySQL和Vue都没有看，接下来的阶段打算变动一部分学习计划</p>
<ol>
<li>新加入：<ul>
<li>Javascript 30天小项目</li>
<li>MySQL每天学习</li>
<li>数据结构加快学习</li>
</ul>
</li>
<li>删除：<ul>
<li>Vue</li>
</ul>
</li>
</ol>
<hr>
<h4 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h4><h5 id="时间线-6"><a href="#时间线-6" class="headerlink" title="时间线"></a>时间线</h5><p>10:00~12:00，操作系统。</p>
<ul>
<li>二次机会算法（加入dirty bit判断）</li>
<li>LFU算法</li>
<li>Belady现象</li>
<li>Clock、FIFO、LRU算法对比</li>
</ul>
<p>13:00~14:00，Leetcode每日一题，今天的太难，能力它不够呀。。</p>
<p>15:00~19:00，<strong>天那我承认我没咋学，我再也不这样了</strong>。</p>
<p>19:00~21:00，JS项目1_DrumKit。</p>
<p>21:30~22:30，一道Leetcode，浪漫的相交链表。</p>
<p>23:00~24:00，一道Leetcode，环形链表。</p>
<h5 id="今日遗留"><a href="#今日遗留" class="headerlink" title="今日遗留"></a>今日遗留</h5><p>hash表的C语言实现</p>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>30个JS小项目</title>
    <url>/2020/07/11/30%E4%B8%AAJS%E5%B0%8F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>一个对Javascript学习很有帮助的实操项目。</p>
<a id="more"></a>
<h2 id="打鼓点"><a href="#打鼓点" class="headerlink" title="打鼓点"></a>打鼓点</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li><code>querySelector()</code>方法返回文档中匹配指定CSS选择器的一个元素。<code>querySelectorAll()</code>返回全部元素。</li>
<li><code>&lt;kbd&gt;</code>标签用于指定该字符是从键盘输入的。</li>
<li><code>keyCode</code>65-90对应的是键盘上A-Z。</li>
<li><code>element.classList.add()</code>添加一个或多个类名。对应的<code>remove()</code>删除。</li>
<li>当发生<code>transitionend</code>事件时，<code>propertyName</code>属性返回<strong>与转换关联的CSS属性的名称</strong>。此属性是只读的。</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>加入对键盘按键的事件监听，每当按下一个按键时<ul>
<li>audio要play</li>
<li>加入playing类，从而使得样式改变。</li>
</ul>
</li>
<li>加入对每一个key的监听，若事件结束，则remove playing类从而返回初始状态。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTransition</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.propertyName !== <span class="string">'transform'</span>) <span class="keyword">return</span>; <span class="comment">// 只有监听到transition结束时，才remove playing</span></span><br><span class="line">  e.target.classList.remove(<span class="string">'playing'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playSound</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// audio和key承载了整个标签和标签里的内容</span></span><br><span class="line">  <span class="keyword">const</span> audio = <span class="built_in">document</span>.querySelector(<span class="string">`audio[data-key="<span class="subst">$&#123;e.keyCode&#125;</span>"]`</span>);</span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">document</span>.querySelector(<span class="string">`div[data-key="<span class="subst">$&#123;e.keyCode&#125;</span>"]`</span>);</span><br><span class="line">  <span class="keyword">if</span> (!audio) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  key.classList.add(<span class="string">'playing'</span>);</span><br><span class="line">  audio.currentTime = <span class="number">0</span>; <span class="comment">// 使时间归零，重新播放当前鼓点</span></span><br><span class="line">  audio.play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'.key'</span>));</span><br><span class="line">keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> key.addEventListener(<span class="string">'transitionend'</span>, removeTransition));</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'keydown'</span>, playSound);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6学习笔记</title>
    <url>/2020/07/01/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/es6/" target="_blank" rel="noopener">这是ES 6的FCC链接</a><br><a href="https://www.runoob.com/w3cnote/es6-concise-tutorial.html" target="_blank" rel="noopener">ES 6</a>是Javascript语言的新一代标准，加入了很多新的功能和语法。</p>
<a id="more"></a>
<h2 id="ES-6"><a href="#ES-6" class="headerlink" title="ES 6"></a>ES 6</h2><h3 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h3><ul>
<li><strong>let关键字只在let命令所在的代码块里有效</strong><br>为了帮助理解这个<code>代码块</code>的概念，下面介绍一个实例：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'function scope'</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="string">'block scope'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Block scope i is: '</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Function scope i is: '</span>, i);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码最后会返回结果<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Block scope i is block scope</span><br><span class="line">Function scope is fuction scope</span><br></pre></td></tr></table></figure>
也就是i的赋值只在对应声明的function大模块和if模块里才会生效，let关键字可以连续声明两次变量而不报错，原因也是<strong>这两次let在不同的模块里</strong>。</li>
</ul>
<hr>
<h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>const声明的常量类似于一个指针，指向一个引用，而且const关键字也是在<strong>块区域内有效</strong>。另外我之前以为能够完全锁定一个变量，实则不然：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// 不合法</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">8</span>;  <span class="comment">// 合法，s被改为[5, 6, 8]</span></span><br></pre></td></tr></table></figure>
<p>也就是类似于这种对象，const只能保证无法直接更改原对象，但是像这种逐一修改的方式仍能改变原对象。<br>那么有没有更保险的方法，能够“锁住”对象呢？Javascript提供了一种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.freeze(obj);  </span><br><span class="line"><span class="comment">// Object.freeze()函数能够使得针对obj的修改全部被忽视</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在JavaScript中，通常不需要为函数命名，特别是在将一个函数作为参数传递给另一个函数时。取而代之的是，我们创建内联函数。从而不需要命名这些函数，因为我们不会在其他地方重用它们。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="string">"default name"</span>;</span><br><span class="line">    <span class="keyword">return</span> myVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段简单的函数可以被替换成下面的类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="string">"default name"</span>;</span><br><span class="line">    <span class="keyword">return</span> myVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而当函数只有返回值语句是，以上写法仍能够被简化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"default name"</span>;</span><br></pre></td></tr></table></figure>
<p>这三段代码都是等效的，显然第三种是最高效的写法。</p>
<p>若这个内联函数有参数，则应该被写成如下的样子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = <span class="function">(<span class="params">name = <span class="string">"default"</span></span>) =&gt;</span> name + <span class="string">"name"</span>;</span><br></pre></td></tr></table></figure>
<p>和其他语言一样，若传递了一个有意义的实参，参数值以传递值为准。</p>
<hr>
<h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>为了帮助我们创建更灵活的函数，ES6为函数参数引入了rest参数。使用rest参数，您可以创建具有可变数量参数的函数。这些参数存储在一个<strong>数组</strong>中，<strong>以后可以从函数内部访问该数组</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">howMany</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"You have passed "</span> + args.length + <span class="string">" arguments."</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(howMany(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)); </span><br><span class="line"><span class="comment">// You have passed 3 arguments.</span></span><br><span class="line"><span class="built_in">console</span>.log(howMany(<span class="string">"string"</span>, <span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123; &#125;)); </span><br><span class="line"><span class="comment">// You have passed 4 arguments.</span></span><br></pre></td></tr></table></figure>
<p>从这个FCC的实例中，可以看出来…args的length是与传入参数的数量有关的，而传入的参数共同构成了一个数组，数组名为<code>args</code>。</p>
<hr>
<h3 id="spread操作符"><a href="#spread操作符" class="headerlink" title="spread操作符"></a>spread操作符</h3><p>ES6引入了spread操作符，它允许我们在需要多个参数或元素的地方展开数组和其他表达式，这增强了代码的可读性和高效性。<code>···arr</code>返回一个未打包的数组。换句话说，它分散了数组。但是，spread操作符只能就地工作，比如在函数的参数或数组文字中。下面来看两个实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">6</span>, <span class="number">89</span>, <span class="number">3</span>, <span class="number">45</span>];</span><br><span class="line"><span class="keyword">const</span> maximus = <span class="built_in">Math</span>.max(...arr); <span class="comment">// returns 89</span></span><br><span class="line"><span class="keyword">const</span> spreaded = ...arr; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="析构赋值-destructing-assignment"><a href="#析构赋值-destructing-assignment" class="headerlink" title="析构赋值(destructing assignment)"></a>析构赋值(destructing assignment)</h3><p>析构赋值这部分涉及到的知识点比较多，我直接上实例：</p>
<h4 id="针对对象的赋值方式"><a href="#针对对象的赋值方式" class="headerlink" title="针对对象的赋值方式"></a>针对对象的赋值方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">name</span>:<span class="string">'John Doe'</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统的赋值方式</span></span><br><span class="line"><span class="keyword">const</span> userName = user.name;</span><br><span class="line"><span class="keyword">const</span> userAge = user.age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值方式一</span></span><br><span class="line"><span class="keyword">const</span> &#123;userName1, userAge1&#125; = user;</span><br><span class="line"><span class="comment">//赋值方式二</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>:userName2, <span class="attr">age</span>:userAge2&#125; = user;</span><br></pre></td></tr></table></figure>
<p>同理，这样的方式对嵌套的对象仍适用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  johnDoe: &#123; </span><br><span class="line">    age: <span class="number">34</span>,</span><br><span class="line">    email: <span class="string">'johnDoe@freeCodeCamp.com'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">johnDoe</span>: &#123; age, email &#125;&#125; = user;</span><br><span class="line"><span class="comment">//赋值方式一</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">johnDoe</span>: &#123; <span class="attr">age</span>: userAge, <span class="attr">email</span>: userEmail &#125;&#125; = user;</span><br><span class="line"><span class="comment">//赋值方式二</span></span><br></pre></td></tr></table></figure>

<h4 id="针对数组的赋值方式"><a href="#针对数组的赋值方式" class="headerlink" title="针对数组的赋值方式"></a>针对数组的赋值方式</h4><p>我们可以把这种方式看成是”省略”，这在python的编程思想中也比较常见（个人认为）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b,,, c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1,2,5</span></span><br></pre></td></tr></table></figure>
<p>除此以外rest参数在数组中也是适用的，如果将中间的三个逗号替换成rest：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>[a, b, ...arr] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [3,4,5,6,7]</span></span><br></pre></td></tr></table></figure>

<h4 id="针对函数参数的赋值方式"><a href="#针对函数参数的赋值方式" class="headerlink" title="针对函数参数的赋值方式"></a>针对函数参数的赋值方式</h4><p>修改前的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">profileData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age, nationality, location &#125; = profileData;</span><br><span class="line">  <span class="comment">// do something with these variables</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">&#123; name, age, nationality, location &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* do something with these fields */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这删除了一些额外的行，使我们的代码看起来整洁。这样做的另一个好处是<strong>不必在函数中操作整个对象，只需要在函数中复制所需的字段</strong>。<br>利用第二个好处我们再来修改一个实例，已知<code>stats</code>是一个<code>max</code>和<code>min</code>属性的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">stats</span>) =&gt;</span> (stats.max + stats.min) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">&#123;max, min&#125;</span>) =&gt;</span> (max + min) / <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，此处<code>max</code>和<code>min</code>并不一定是<code>stats</code>的全部属性，只要其属性名在<code>stats</code>中有同名的就可以。</p>
<hr>
<h3 id="模板语法和分隔符"><a href="#模板语法和分隔符" class="headerlink" title="模板语法和分隔符"></a>模板语法和分隔符</h3><p>这涉及到<code>$</code>和<code>`</code>两个符号，在<code>`</code>包围下的<code>$</code>符号才会生效：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Zodiac Hasbro"</span>,</span><br><span class="line">  age: <span class="number">56</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template literal with multi-line and string interpolation</span></span><br><span class="line"><span class="keyword">const</span> greeting = <span class="string">`Hello, my name is <span class="subst">$&#123;person.name&#125;</span>!</span></span><br><span class="line"><span class="string">I am <span class="subst">$&#123;person.age&#125;</span> years old.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting); <span class="comment">// prints</span></span><br><span class="line"><span class="comment">// Hello, my name is Zodiac Hasbro!</span></span><br><span class="line"><span class="comment">// I am 56 years old.</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="对象词法扩展"><a href="#对象词法扩展" class="headerlink" title="对象词法扩展"></a>对象词法扩展</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCar</span>(<span class="params">make, model, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 简写变量</span></span><br><span class="line">    make,  <span class="comment">// 等同于 make: make</span></span><br><span class="line">    model, <span class="comment">// 等同于 model: model</span></span><br><span class="line">    value, <span class="comment">// 等同于 value: value</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 属性可以使用表达式计算值</span></span><br><span class="line">    [<span class="string">'make'</span> + make]: <span class="literal">true</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 忽略 `function` 关键词简写对象函数</span></span><br><span class="line">    depreciate() &#123;</span><br><span class="line">      <span class="keyword">this</span>.value -= <span class="number">2500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car = getCar(<span class="string">'Barret'</span>, <span class="string">'Lee'</span>, <span class="number">40000</span>);</span><br><span class="line"><span class="comment">// output: &#123;</span></span><br><span class="line"><span class="comment">//     make: 'Barret',</span></span><br><span class="line"><span class="comment">//     model:'Lee',</span></span><br><span class="line"><span class="comment">//     value: 40000,</span></span><br><span class="line"><span class="comment">//     makeBarret: true,</span></span><br><span class="line"><span class="comment">//     depreciate: [Function: depreciate]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>可以达到的目的：</p>
<ol>
<li><strong>简写变量</strong></li>
<li>属性可以使用表达式计算值</li>
<li>忽略<code>function</code>关键词简写对象函数</li>
</ol>
<p>针对第三点可以参照下面的实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES 5写法</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Taylor"</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//ES 6写法</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Taylor"</span>,</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是ES 6提供的创建一个新对象的关键字。需要注意的是，类语法只是语法，而不是面向对象范式的成熟的基于类的实现，这与Java、Python、Ruby等语言不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShuttle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(targetPlanet) &#123;</span><br><span class="line">    <span class="keyword">this</span>.targetPlanet = targetPlanet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zeus = <span class="keyword">new</span> SpaceShuttle(<span class="string">'Jupiter'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>实例中的<code>constructor</code>相当于一个构造函数</li>
<li>类的命名一般采用UpperCamelCase的方式命名</li>
</ul>
<p>我们还可以从对象中获取值并设置对象中的属性值。这些通常称为getter和setter。Getter函数只是将对象私有变量的值返回(获取)给用户，而不需要用户直接访问私有变量。Setter函数用于根据传入Setter函数的值修改(设置)对象私有变量的值。这种更改可能涉及计算，甚至完全覆盖以前的值。这两种计算只要稍微熟悉C++和python的应该都不陌生。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(author) &#123;</span><br><span class="line">    <span class="keyword">this</span>._author = author;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> writer() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._author;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> writer(updatedAuthor) &#123;</span><br><span class="line">    <span class="keyword">this</span>._author = updatedAuthor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lol = <span class="keyword">new</span> Book(<span class="string">'anonymous'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lol.writer);  <span class="comment">// anonymous</span></span><br><span class="line">lol.writer = <span class="string">'wut'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(lol.writer);  <span class="comment">// wut</span></span><br></pre></td></tr></table></figure>
<p>这样就能实现对象的writer属性既可以被访问也可以被更改了。<br>下面是利用这个原理，写出的摄氏度单位转换实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thermostat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fahrenheit) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fahrenheit = fahrenheit;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> temperature() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">5</span> / <span class="number">9</span>) * (<span class="keyword">this</span>.fahrenheit - <span class="number">32</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> temperature(celsius) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fahrenheit = (celsius * <span class="number">9.0</span>) / <span class="number">5</span> + <span class="number">32</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="export-amp-import"><a href="#export-amp-import" class="headerlink" title="export&amp;import"></a><code>export</code>&amp;<code>import</code></h3><p>直接上实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math_function.js</span></span><br><span class="line"><span class="keyword">export</span>&#123;add, subtract&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;add,subtract&#125; <span class="keyword">from</span> <span class="string">'./math_functions'</span> ;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myMathModule <span class="keyword">from</span> <span class="string">'./math_functions'</span> ; <span class="comment">// import everything</span></span><br></pre></td></tr></table></figure>
<p>而当只用到该文件的一个函数时，我们有一种简单的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math_function.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">multiple</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125; <span class="comment">// 当只用从该文件中导出一个函数时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> multiple <span class="keyword">from</span> <span class="string">'./math_functions'</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Promise构造"><a href="#Promise构造" class="headerlink" title="Promise构造"></a>Promise构造</h3><p>一个promise有三种状态：<code>pending</code>,<code>fulfilled</code>和<code>rejected</code>。您在上一个挑战中创建的承诺将永远处于挂起状态，因为您没有添加完成该承诺的方法。提供给promise参数的<code>resolve</code>和<code>reject</code>参数用于执行此操作。当你希望你的承诺成功时，就用<code>resolve</code>，而当你希望它失败时，就用<code>reject</code>。<br>以下是promise的使用模板：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(condition here) &#123;</span><br><span class="line">    resolve(<span class="string">"Promise was fulfilled"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">"Promise was rejected"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>承诺在当你有一个进程在你的代码中花费了未知的时间(例如一些异步的事情，通常是一个服务器请求)是管用的。当您发出一个服务器请求时，它会花费一定的时间，在请求完成后，您通常需要对服务器的响应进行处理。这可以通过使用<code>then</code>方法来实现。<code>then</code>方法会在您的承诺被坚定地实现之后立即执行。这是它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myPromise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something with the result.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>与<code>then</code>相对应的有<code>catch</code>，<code>catch</code>是当你的承诺被拒绝时使用的方法。它在调用承诺的<code>reject</code>方法后立即执行。下面是它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myPromise.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something with the error.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>所以一个promise的完整架构为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> makeServerRequest = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// responseFromServer is set to false to represent an unsuccessful response from a server</span></span><br><span class="line">  <span class="keyword">let</span> responseFromServer = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(responseFromServer) &#123;</span><br><span class="line">    resolve(<span class="string">"We got the data"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    reject(<span class="string">"Data not received"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">makeServerRequest.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br><span class="line">makeServerRequest.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<p>到这里就是ES6课程的全部内容了，完结撒花~</p>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记_1</title>
    <url>/2020/07/01/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>主要介绍python的第三方库Requests库的应用场景。</p>
<a id="more"></a>
<h3 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h3><p>requests是使用Apache2 licensed 许可证的HTTP库，用python编写，比urllib2模块更简洁。主要用于<strong>自动爬取HTML页面&amp;自动网络请求提交</strong>。Requests一般掌握<code>get()</code>和<code>head()</code>两个方法就足够使用。</p>
<p>请看Requests库的主要七个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.request()  <span class="comment">#构造一个请求，支撑以下各方法的基础方法</span></span><br><span class="line">requests.get()  <span class="comment"># 获取HTML网页的主要方法，对应于HTTP的GET</span></span><br><span class="line">requests.head()  <span class="comment"># 获取HTML网页头信息的方法，对应于HTTP的HEAD</span></span><br><span class="line">requests.post()  <span class="comment"># 向HTML网页提交POST请求的方法，对应于HTTP的POST</span></span><br><span class="line">requests.put()  <span class="comment"># 向HTML网页提交PUT请求的方法，对应于HTTP的PUT</span></span><br><span class="line">requstes.patch()  <span class="comment"># 向HTML网页提交局部修改请求，对应于HTTP的PATCH</span></span><br><span class="line">requests.delete()  <span class="comment">#向HTML页面提交删除请求，对应于HTTP的DELETE</span></span><br></pre></td></tr></table></figure>
<p>上图七种方法所对应的HTTP协议对资源的操作其实与Requests库的方法是一致的，不必深究。<br>值得一提的是，<code>patch()</code>相对于<code>put()</code>的好处就是，只用修改局部字段即可。</p>
<hr>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(url)</span><br><span class="line"><span class="comment"># r是爬虫返回的内容，称为Response对象</span></span><br></pre></td></tr></table></figure>

<p>Response对象具有很多有用的属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>r.status_code</code></td>
<td align="center">HTTP请求的返回状态，200表示成功</td>
</tr>
<tr>
<td align="center"><code>r.text</code></td>
<td align="center">HTTP响应内容的字符串形式–url对应的页面内容</td>
</tr>
<tr>
<td align="center"><code>r.encoding</code></td>
<td align="center">从HTTP header中猜测的响应内容编码方式</td>
</tr>
<tr>
<td align="center"><code>r.apparent_encoding</code></td>
<td align="center">从内容中分析出响应内容编码方式（备选内容编码方式）</td>
</tr>
<tr>
<td align="center"><code>r.content</code></td>
<td align="center">HTTP响应内容的二进制形式</td>
</tr>
<tr>
<td align="center"><code>r.raise_for_status()</code></td>
<td align="center">如果不是200，产生异常（类型为requests.HTTPError）</td>
</tr>
</tbody></table>
<p>基于以上介绍的Response对象的属性，利用try-except方法爬取页面的的通用代码的框架基本形成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout = <span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="head-方法"><a href="#head-方法" class="headerlink" title="head()方法"></a>head()方法</h4><p><code>head()</code>方法适合只访问头部信息的这种场景，此时调用<code>r.text</code>返回的内容为空：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://www.baidu.com"</span></span><br><span class="line">r = requests.head(url)</span><br><span class="line">print(r.headers)  <span class="comment"># 返回头部信息内容</span></span><br><span class="line">print(r.text)  <span class="comment"># 空</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="post-方法"><a href="#post-方法" class="headerlink" title="post()方法"></a>post()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/put'</span>,data = payload)</span><br><span class="line">print(r.text)</span><br><span class="line"><span class="comment"># 此时的r.text将是原内容加上payload的内容</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="request-方法"><a href="#request-方法" class="headerlink" title="request()方法"></a>request()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.request(method, url, **kwargs)</span><br><span class="line"><span class="comment"># method:请求方式，对应get,post...</span></span><br><span class="line"><span class="comment"># **kwargs:控制访问的参数，共13个</span></span><br></pre></td></tr></table></figure>
<p>以下是可选的参数（只列出9个）：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>params</code></td>
<td align="center">字典或字节序列，作为参数<strong>增加到url中</strong></td>
</tr>
<tr>
<td align="center"><code>data</code></td>
<td align="center">字典、字节序列或文件对象，作为<strong>Request的内容</strong></td>
</tr>
<tr>
<td align="center"><code>json</code></td>
<td align="center">JSON格式数据，作为<strong>Request的内容</strong></td>
</tr>
<tr>
<td align="center"><code>headers</code></td>
<td align="center">字典，HTTP定制头</td>
</tr>
<tr>
<td align="center"><code>cookies</code></td>
<td align="center">字典或CookieJar，Request中的cookie</td>
</tr>
<tr>
<td align="center"><code>auth</code></td>
<td align="center">元组，支持HTTP认证功能</td>
</tr>
<tr>
<td align="center"><code>files</code></td>
<td align="center">字典类型，传输文件</td>
</tr>
<tr>
<td align="center"><code>timeout</code></td>
<td align="center">设定超时时间，秒为单位</td>
</tr>
<tr>
<td align="center"><code>proxies</code></td>
<td align="center">字典类型，设定访问代理服务器，可增加登录认证</td>
</tr>
</tbody></table>
<hr>
<h4 id="爬虫实例"><a href="#爬虫实例" class="headerlink" title="爬虫实例"></a>爬虫实例</h4><h5 id="爬取亚马逊商品页面（更改用户代理）"><a href="#爬取亚马逊商品页面（更改用户代理）" class="headerlink" title="爬取亚马逊商品页面（更改用户代理）"></a>爬取亚马逊商品页面（更改用户代理）</h5><p><code>User-Agent</code>会告诉网站服务器，访问者是通过什么工具来请求的，如果是爬虫请求，一般会拒绝，如果是用户浏览器，就会应答。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://www.amazon.cn/gp/product/B01M8L5Z3Y"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">    r = requests.get(url, headers=kv)  <span class="comment"># 将User-Agent由python请求修改为用户请求</span></span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[<span class="number">1000</span>:<span class="number">2000</span>])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="百度搜索关键词提交"><a href="#百度搜索关键词提交" class="headerlink" title="百度搜索关键词提交"></a>百度搜索关键词提交</h5><p><em>注意：不同的搜索引擎关键词接口(wd)不一样</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">keyword = <span class="string">"Python"</span></span><br><span class="line">url = <span class="string">"https://www.baidu.com"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'Wd'</span>:keyword&#125;</span><br><span class="line">    r = requests.get(url, params = kv)</span><br><span class="line">    print(r.request.url)</span><br><span class="line">    <span class="comment"># 'https://www.baidu.com/s?wd=Python'</span></span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    print(len(r.text))</span><br><span class="line">    <span class="comment"># 302829</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="网络图片爬取"><a href="#网络图片爬取" class="headerlink" title="网络图片爬取"></a>网络图片爬取</h5><ul>
<li>os库用于判断路径是否存在</li>
<li>保存的文件名为网站源文件的名称</li>
<li>将图片以二进制的形式<code>r.content</code>写入<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://image.nationalgeographic.com.cn/2017/0211/20170211061910157.jpg"</span></span><br><span class="line">root = <span class="string">"D://pic//"</span></span><br><span class="line">path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">        os.mkdir(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">            f.close()</span><br><span class="line">            print(<span class="string">"文件保存成功"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"文件已存在"</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="IP地址查询代码"><a href="#IP地址查询代码" class="headerlink" title="IP地址查询代码"></a>IP地址查询代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://m.ip138.com/ip.asp?ip="</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url + <span class="string">'202.204.80.112'</span>)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[<span class="number">-500</span>:])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode日记</title>
    <url>/2020/07/02/LeetCode%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>偶尔在力扣上刷刷题碰到些有价值的题目随手都记录到这里了。</p>
<a id="more"></a>
<hr>
<h4 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h4><h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><p>输入：两个二进制字符串<br>输出：加法后得到的二进制字符串</p>
<h5 id="个人解答-Python"><a href="#个人解答-Python" class="headerlink" title="个人解答(Python)"></a>个人解答(Python)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        carry = <span class="number">0</span>  <span class="comment"># 进位初始化为0</span></span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        n = max(len(a),len(b))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(i &gt; len(a)<span class="number">-1</span>):  <span class="comment"># 当b未遍历完，a遍历完</span></span><br><span class="line">                result += str((int(b[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">                carry = (int(b[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; len(b)<span class="number">-1</span>):  <span class="comment"># 当a未遍历完，b遍历完</span></span><br><span class="line">                result += str((int(a[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">                carry = (int(a[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            result += str((int(a[-i<span class="number">-1</span>])+int(b[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">            carry = (int(a[-i<span class="number">-1</span>])+int(b[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>):  <span class="comment"># 如果最后进位是1，补位</span></span><br><span class="line">            result += str(carry)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h5 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h5><p>当两个数字位数较小的一个，直接用0补齐，使得两个字符串的位数相同，可以节省代码空间，减少判断次数，降低运行时间。</p>
<h5 id="法2：位运算"><a href="#法2：位运算" class="headerlink" title="法2：位运算"></a>法2：位运算</h5><p><a href="https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/" target="_blank" rel="noopener">戳我看解法</a></p>
<br/>
<br/>

<hr>
<h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><h5 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h5><p>人一次只能爬1个或2个楼梯<br>输入：楼梯个数<br>输出：爬楼梯共有多少种爬法</p>
<h5 id="个人解答-Python-1"><a href="#个人解答-Python-1" class="headerlink" title="个人解答(Python)"></a>个人解答(Python)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * f(n<span class="number">-1</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = (n//<span class="number">2</span>)+<span class="number">1</span>  <span class="comment"># 共有多少种不重复的已经确定的1，2个数分布</span></span><br><span class="line">        j = n  <span class="comment"># 排列组合公式的底数</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">            result += f(j)/(f(i)*f(j-i))</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h5 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结"></a>我的总结</h5><p>我的思路是先找到1，2个数的所有组合，举个例子：<br>比如n=6，那么楼梯的1，2组合只能是以下四种：</p>
<ul>
<li>111111</li>
<li>11112</li>
<li>1122</li>
<li>222</li>
</ul>
<p>那么只需要找到2的排列组合数就行：</p>
<ul>
<li>0/6 111111</li>
<li>1/5 11112</li>
<li>2/4 1122</li>
<li>3/3 222</li>
</ul>
<p>虽然找到了公式，但不得不说，我这个不论空间还是时间都垃圾的很……直接看标答吧…<br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">戳我看完整答案</a></p>
<h5 id="方法1：动态规划！"><a href="#方法1：动态规划！" class="headerlink" title="方法1：动态规划！"></a>方法1：动态规划！</h5><p>我们用 <code>f(x)</code> 表示爬到第 <code>x</code> 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：<br>$$f(x) = f(x-1) + f(x-2)$$</p>
<p>这个公式的意思是，爬到第n级台阶只能是爬到n-1级（爬到第n级用了一步）或是爬到n-2级（爬到n级用了两步）的方案的集合。看到这里就一目了然，这不就是传说中的<code>斐波那契数列</code>吗？（后话）<br>利用滚动数组的方法求解代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    q = <span class="number">0</span></span><br><span class="line">    r = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        p = q  <span class="comment"># q前移一位</span></span><br><span class="line">        q = r  <span class="comment"># r前移一位</span></span><br><span class="line">        r = p + q  <span class="comment"># 更新r</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>
<h5 id="方法2：斐波那契公式"><a href="#方法2：斐波那契公式" class="headerlink" title="方法2：斐波那契公式"></a>方法2：斐波那契公式</h5><p>$$f ( n ) = \frac { 1 } { \sqrt { 5 } } [ ( \frac { 1 + \sqrt { 5 } } { 2 } ) ^ { n } - ( \frac { 1 - \sqrt { 5 } } { 2 } ) ^ { n } ]<br>$$</p>
<hr>
<h4 id="删除链表的倒数第n个节点"><a href="#删除链表的倒数第n个节点" class="headerlink" title="删除链表的倒数第n个节点"></a>删除链表的倒数第n个节点</h4><h5 id="个人解答-C-两次遍历"><a href="#个人解答-C-两次遍历" class="headerlink" title="个人解答(C,两次遍历)"></a>个人解答(C,两次遍历)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cur = cur -&gt; next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==n)&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 如果删除头结点，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count-n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125; <span class="comment">// 如果不删除头结点，按照结点删除法删除对应节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="我的总结-1"><a href="#我的总结-1" class="headerlink" title="我的总结"></a>我的总结</h5><p>遍历2L-n次，时间复杂度 $O(L)$<br>空间复杂度$O(1)$</p>
<h5 id="优化：一次遍历法（双指针）"><a href="#优化：一次遍历法（双指针）" class="headerlink" title="优化：一次遍历法（双指针）"></a>优化：一次遍历法（双指针）</h5><p>哎呀，想了十分钟没想出来，一说双指针一下子明白了。双指针保持间隔为n，依次向前递推，直到快指针指向空，慢指针定位成功。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 定位快指针到第n+1个结点</span></span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 如果第n+1个结点为空，直接返回head-&gt;next</span></span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>free语句是必不可少的，这里为了省空间就没用q承载再删除</strong>。正解如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>


<hr>
<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><h5 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h5><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p>
<h5 id="个人解答-C"><a href="#个人解答-C" class="headerlink" title="个人解答(C)"></a>个人解答(C)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = numsSize<span class="number">-2</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= numsSize-i<span class="number">-1</span>)&#123; </span><br><span class="line">            <span class="comment">// 如果这个在尾元素之前的元素可以到达末尾，则以该元素为末尾</span></span><br><span class="line">            numsSize -= (numsSize-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numsSize==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<h5 id="标答-贪心法"><a href="#标答-贪心法" class="headerlink" title="标答(贪心法)"></a>标答(贪心法)</h5><p><strong>更新能跳到的最远位置</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n, rightmost = len(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &lt;= rightmost:</span><br><span class="line">                rightmost = max(rightmost, i + nums[i])</span><br><span class="line">                <span class="keyword">if</span> rightmost &gt;= n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两链表之和"><a href="#两链表之和" class="headerlink" title="两链表之和"></a>两链表之和</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>例如：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><p>本来想省一点空间，直接在L1上操作，现在导致前后两难：</p>
<ol>
<li>逻辑不清晰，可读性很差</li>
<li>时间复杂度提高的鸭子！！</li>
<li>代码冗长</li>
</ol>
<p>浪费了我俩小时，先睡了。/(ㄒoㄒ)/~~</p>
<p>2020.7.8..今天早上用c语言做出来了，直接贴代码。之前的思路（改变L1），造成了我遍历完其中一个链表，就会分类讨论出三种情况，无疑复杂化了原问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>; <span class="comment">// 进位位初始化</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>; <span class="comment">// 每位的加和</span></span><br><span class="line">    <span class="keyword">int</span> x,y; <span class="comment">// 每位的真实加法数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">L1</span>=<span class="title">l1</span>,*<span class="title">L2</span>=<span class="title">l2</span>,*<span class="title">result</span>,*<span class="title">cur</span>,*<span class="title">high</span>,*<span class="title">nextNode</span>;</span></span><br><span class="line">    result = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    cur = result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(L1!=<span class="literal">NULL</span> || L2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        x = L1!=<span class="literal">NULL</span> ? L1-&gt;val : <span class="number">0</span>;</span><br><span class="line">        y = L2!=<span class="literal">NULL</span> ? L2-&gt;val : <span class="number">0</span>;</span><br><span class="line">        nextNode = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        sum = x + y + temp;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            nextNode -&gt; val = sum%<span class="number">10</span>;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nextNode -&gt; val = sum;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            L1=L1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            L2=L2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = nextNode;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后排除多位问题</span></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">1</span>)&#123;</span><br><span class="line">        high = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        high -&gt; val = <span class="number">1</span>;</span><br><span class="line">        cur -&gt; next = high;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以以后再碰到类似的题目，要先想好自己要不要优化空间（时间），到底是先试着把题目做出来，还是就着一个优化空间的角度钻牛角尖，还是要衡量一下的。</strong>后面还看到了一个时间上比我快很多的算法，其实和我之前的思路有一点类似(当某一个链表遍历完，剩余的链接到后面，但是由于我一心只想改变L1，造成了很多不必要的麻烦，而且后面的关于进位位的处理也没人家想的好)大体讲一下思路，开阔一下视野。</p>
<ol>
<li>新建一个链表l3，用以存放l1+l2的和</li>
<li>分3种情况，在l1，l2都没到尾的前提下<ul>
<li>l1先结束，l2多出来的部分直接加入到l3</li>
<li>l2先结束，l1多出来的部分直接加到l3</li>
<li>两个一起结束，直接相加，不管结果是否大于10</li>
</ul>
</li>
<li>遍历l3，先不考虑链表最后一个数，<ul>
<li>如果l3.val&gt;10，减去10，并在下一个节点上加1</li>
<li>如果链表最后一个数大于10，则减去10，并新建一个节点存1</li>
</ul>
</li>
</ol>
<p>这个思路的<strong>对进位位的处理</strong>是很值得借鉴的，就是先不管进位位的情况下统一加完，再遍历链表实现进位位的加法，这种方法看似消耗了时间（相当于两次遍历），实际上居然比我那个要快很多，显然是因为我那个的条件判断语句有点过多了。</p>
<hr>
<h4 id="跳水板"><a href="#跳水板" class="headerlink" title="跳水板"></a>跳水板</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。<br>返回的长度需要<strong>从小到大排列</strong>。</p>
<h5 id="个人解答-1"><a href="#个人解答-1" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">divingBoard</span><span class="params">(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *newNode;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(longer==shorter)&#123;</span><br><span class="line">        newNode = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line">        *newNode = longer*k;</span><br><span class="line">        *returnSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(k+<span class="number">1</span>));</span><br><span class="line">    *returnSize = k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        newNode[k-i] = i*shorter + (k-i)*longer; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除排序链表里的重复元素II"><a href="#删除排序链表里的重复元素II" class="headerlink" title="删除排序链表里的重复元素II"></a>删除排序链表里的重复元素II</h4><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中<strong>没有重复出现</strong>的数字。</p>
<h5 id="个人原解答"><a href="#个人原解答" class="headerlink" title="个人原解答"></a>个人原解答</h5><p>思路：</p>
<ol>
<li>如果链表只有0/1个元素，返回head。 </li>
<li>将链表化为<strong>前两个元素一定不一样</strong>的模型。</li>
<li>设置快指针q，慢指针p。</li>
<li>p-&gt;next-&gt;val == q-&gt;val时是删除条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// p是慢指针，q是快指针</span></span><br><span class="line">    <span class="comment">// 如果是开头重复：label=1</span></span><br><span class="line">    <span class="comment">// 如果是中间重复：label=0</span></span><br><span class="line">    <span class="comment">// 由于头结点和后面都不一样，我觉得先摘除头结点重复的前半部分，将链表化为“前两个一定不相同的模型”</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>=<span class="title">head</span>, *<span class="title">q</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> label = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next-&gt;val == head-&gt;val)&#123;</span><br><span class="line">        label = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next-&gt;val == head-&gt;val)&#123;</span><br><span class="line">            label = <span class="number">1</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(label)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;val == q-&gt;val)&#123; <span class="comment">// 若相等</span></span><br><span class="line">            <span class="keyword">if</span>(q-&gt;next==<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123; <span class="comment">// 到达链表尾，则删除</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 否则快指针后移</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 若不等</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;next == q)&#123; <span class="comment">// 不能删，要后移p</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 否则应该删掉中间结点</span></span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我感觉我想法挺好的啊！但真的做崩了，被各种细节卡了下来，提交了5次都没成功，我是真的垃圾。都说能用递归，那我用递归试试，半小时不行就劝退吧，现在是0：49，我很困。<br>1：01，爷想不出来，气死了，睡觉。</li>
</ol>
<h5 id="标准解法"><a href="#标准解法" class="headerlink" title="标准解法"></a>标准解法</h5><h6 id="方法1：递归"><a href="#方法1：递归" class="headerlink" title="方法1：递归"></a>方法1：递归</h6><ul>
<li><code>head</code>后面有值而且和<code>head</code>的值相等，那么就找到不相等为止，然后对后面一个结点去递归，这样就把前面重复的给删除了。</li>
<li><code>head</code>后面有值但和<code>head</code>的值不等，那么就递归后面一个结点，接在<code>head</code>的后面。</li>
<li>最后返回<code>head</code>。</li>
</ul>
<p>想法和我是一样的，但是我就……没能力实现出来？？其实中间很多循环条件判断条件也是完全一样的，，这个<code>return deleteDuplicates(head-&gt;next)</code>我服了，我当时怎么都没想出来解决(1,1,2,2)这种情况，人家一句就解决了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="方法2：hash表"><a href="#方法2：hash表" class="headerlink" title="方法2：hash表"></a>方法2：hash表</h6><p>hash_map 统计出现次数，如果出现次数等于1，那么就放在新链表后面。</p>
<h6 id="方法3：双指针"><a href="#方法3：双指针" class="headerlink" title="方法3：双指针"></a>方法3：双指针</h6><p><strong>先建一个哑结点真的省事儿</strong>，当建完哑结点后，删除就会和<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表里的重复元素I</a>这道题的方法基本一样–<strong>顺序遍历，若同则删</strong>，不同的是，<code>cur-&gt;next</code>是否为空要加以判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哑结点指向head</span></span><br><span class="line">    ListNode* dummy = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode* pre = dummy;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">NULL</span> &amp;&amp; cur-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next!=<span class="literal">NULL</span> &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;                </span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h5><p>当这种情况下，可能有很多种情况，首先想能不能把这几个情况想个方法合并。比如法1的递归和法3的双指针的哑结点，都是<strong>为了排除特殊情情况而设计的</strong>。</p>
<h4 id="恢复空格"><a href="#恢复空格" class="headerlink" title="恢复空格"></a>恢复空格</h4><h5 id="别人解答C"><a href="#别人解答C" class="headerlink" title="别人解答C"></a>别人解答C</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CMP</span><span class="params">(<span class="keyword">void</span> * a,<span class="keyword">void</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * S1 = *(<span class="keyword">char</span> **)a;</span><br><span class="line">    <span class="keyword">char</span> * S2 = *(<span class="keyword">char</span> **)b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(S1,S2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Binary</span><span class="params">(<span class="keyword">char</span> **dictionary,<span class="keyword">int</span> dictionarySize,<span class="keyword">char</span> * <span class="built_in">string</span>,<span class="keyword">int</span> lenth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = dictionarySize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>,ret2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;        <span class="comment">//mid是一个区间</span></span><br><span class="line">        ret = <span class="built_in">strncmp</span>(dictionary[mid],<span class="built_in">string</span>,lenth);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret2 = <span class="built_in">strlen</span>(dictionary[mid]);</span><br><span class="line">            <span class="keyword">if</span>(ret2 == lenth)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret2 &gt; lenth)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="keyword">char</span>** dictionary, <span class="keyword">int</span> dictionarySize, <span class="keyword">char</span>* sentence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    qsort(dictionary,dictionarySize,<span class="keyword">sizeof</span>(<span class="keyword">char</span> *),CMP);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(sentence);</span><br><span class="line">    <span class="keyword">int</span> * dp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    * dp = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *(dp + i) = *(dp + i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt;= i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Binary(dictionary,dictionarySize,sentence + j,i - j + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    *(dp + i) = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    *(dp + i) = MIN(dp[i],dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> answer = dp[len] - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(dp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我改进后的，用C语言基于动态规划的答案：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">substr</span><span class="params">(<span class="keyword">char</span>* sentence, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *substring = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        substring[i] = sentence[start+i];</span><br><span class="line">    &#125;</span><br><span class="line">    substring[len] = <span class="string">'\0'</span>; <span class="comment">// 这个结尾一定要赋'\0'要不比较不了</span></span><br><span class="line">    <span class="keyword">return</span> substring;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="keyword">char</span>** dictionary, <span class="keyword">int</span> dictionarySize, <span class="keyword">char</span>* sentence)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回的是字符数，不是单词数……</span></span><br><span class="line">    <span class="comment">// 这题应该能用动态规划解</span></span><br><span class="line">    <span class="comment">// 转移方程：f[i]=min&#123;f[i-word.length],f[i]&#125;</span></span><br><span class="line">    <span class="comment">// 之所以会有min函数是因为 </span></span><br><span class="line">    <span class="comment">// sentence:"looked" dictionary:["looked","oked"]这种情况，最后就会采取最小匹配</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(sentence); <span class="comment">// sentence长度</span></span><br><span class="line">    <span class="keyword">int</span> dp[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">// 单词长度</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        dp[i+<span class="number">1</span>] = dp[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; dictionarySize;j++)&#123;</span><br><span class="line">            <span class="built_in">size</span> = <span class="built_in">strlen</span>(dictionary[j]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">size</span>&lt;=i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dictionary[j], substr(sentence, i+<span class="number">1</span>-<span class="built_in">size</span>, <span class="built_in">size</span>))==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>] = dp[i+<span class="number">1</span>]&lt;dp[i+<span class="number">1</span>-<span class="built_in">size</span>] ? dp[i+<span class="number">1</span>] : dp[i+<span class="number">1</span>-<span class="built_in">size</span>];</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看别人家的题解，了解到了<strong>字典树</strong>（Trie树）这个概念，同时还有<strong>字符串hash</strong>的解法。<br><a href="https://leetcode-cn.com/problems/re-space-lcci/solution/jian-dan-dp-trieshu-bi-xu-miao-dong-by-sweetiee/" target="_blank" rel="noopener">甜姐的trie解法</a></p>
<h4 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h4><p>编写一个程序，找到两个单链表相交的起始节点。<br>利用<strong>两个链表的总长是一样的</strong>这一看似弱智的现象，有点类似于那个前移n位的算法，就是将[0:m]的前[0:n]和后[n+1:m]分别反转，整体再反转，就能实现前移。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pA</span> = <span class="title">headA</span>, *<span class="title">pB</span> = <span class="title">headB</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(pA==<span class="literal">NULL</span> || pB==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">        pA = pA == <span class="literal">NULL</span> ? headB : pA-&gt;next;</span><br><span class="line">        pB = pB == <span class="literal">NULL</span> ? headA : pB-&gt;next; </span><br><span class="line">    &#125; <span class="comment">// 当无相交现象时，最后都为NULL时会直接跳出</span></span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p>判断给定链表是否有环。<br>设置快慢指针，快指针一次两步，慢指针一次一步。设置哑结点以优雅的处理边界(后来发现设置没有什么卵用)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummyhead</span>, *<span class="title">fast</span>, *<span class="title">slow</span>;</span> </span><br><span class="line">    dummyhead = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line"></span><br><span class="line">    dummyhead-&gt;next = head;</span><br><span class="line">    slow = dummyhead;</span><br><span class="line">    fast = dummyhead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">NULL</span> || fast-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Basic Javascript学习笔记</title>
    <url>/2020/06/30/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>　　昨天刚刚搭建了自己的博客，这也算是自己写的第一个blog吧（正好也是第一次markdown，顺便感受一下哈哈）。</p>
<p>　　最近刚刚学习到前端的相关知识，在<a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="noopener">FreeCodeCamp</a>上练习<a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/basic-javascript/" target="_blank" rel="noopener">Basic Javascript</a>的基础知识，知识体系有点混乱，这篇笔记也是帮助自己理清一下思路。那么就让我开始吧~（麦子式破音）</p>
<a id="more"></a>

<h2 id="Basic-javascript"><a href="#Basic-javascript" class="headerlink" title="Basic javascript"></a>Basic javascript</h2><p><em>注：不按系统知识记，只记录自己不熟的知识点</em></p>
<hr>
<h3 id="字符串不变性"><a href="#字符串不变性" class="headerlink" title="字符串不变性"></a>字符串不变性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> usedString = <span class="string">"Bob"</span>;</span><br><span class="line">usedString[<span class="number">0</span>] = <span class="string">'J'</span>;</span><br></pre></td></tr></table></figure>
<p>以上这段代码并不能修改<code>usedString</code> 为<code>&quot;Job&quot;</code>的输出，这就是字符串的不变性。要想实现替换的话，只能将字符串重新赋值。</p>
<hr>
<h3 id="push-pop-shift-unshift方法"><a href="#push-pop-shift-unshift方法" class="headerlink" title="push, pop, shift, unshift方法"></a>push, pop, shift, unshift方法</h3><ul>
<li>push()将括号中的数据追加到数组的末尾</li>
<li>pop()用来抛出数组的末尾数据，同时还可以将该数据赋给一个变量</li>
<li>shift()抛出第一个数据，其他和pop()一样</li>
<li>unshift()将该数据移到数组的开头</li>
</ul>
<p><strong>用这些方法能够很容易的实现经典的数据结构–堆栈</strong></p>
<hr>
<h3 id="对象（python的字典）"><a href="#对象（python的字典）" class="headerlink" title="对象（python的字典）"></a>对象（python的字典）</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="new详解"><a href="#new详解" class="headerlink" title="new详解"></a>new详解</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">constructor</span>[([arguments])]; //new的声明</span><br></pre></td></tr></table></figure>
<p>对两个参数的解释为</p>
<ul>
<li><code>constructor</code>一个指定对象实例的类型的<strong>类或函数</strong>。</li>
<li><code>arguments</code>一个用于被 constructor 调用的参数列表。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">&#125; <span class="comment">// 这个function其实就是个(构造)函数，ES6中改进成了类中的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car(<span class="string">'Eagle'</span>, <span class="string">'Talon TSi'</span>, <span class="number">1993</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car1.make);</span><br><span class="line"><span class="comment">// expected output: "Eagle"</span></span><br></pre></td></tr></table></figure>
<p><code>new</code>操作符做了什么？</p>
<ol>
<li>创建obj{}对象</li>
<li>将函数的作用域赋给新对象</li>
<li>执行函数（为对象初始化，添加..）</li>
<li>考察第3步返回的返回值，无返回值或者返回一个非对象值时，则将创建的新对象返回，否则会将返回值作为新对象返回。</li>
</ol>
<p>如果代码层面看的更深，当<code>new Foo(..)</code>执行时：</p>
<ol>
<li>一个继承自<code>Foo.prototype</code>的新对象被创建。（<code>prototype</code>-&gt;原型对象）</li>
<li>使用指定参数调用构造函数<code>Foo</code>，并<strong>将<code>this</code>绑定到新创建的对象，也就是没有指定参数列表，<code>Foo</code>不带任何参数调用的情况</strong>（然后开始执行函数）。</li>
<li>由构造函数返回的对象就是<code>new</code>表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li>
</ol>
<h4 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h4><h5 id="中括号访问"><a href="#中括号访问" class="headerlink" title="中括号访问"></a>中括号访问</h5><p>中括号访问可以进行多层寻找，而且中间的属性名称可以是来自于某个变量的值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> johnsonOneOfTheSportHobby;</span><br><span class="line"><span class="keyword">var</span> myInfo=&#123;</span><br><span class="line">    name: <span class="string">"Johnson"</span>,</span><br><span class="line">    sex: <span class="string">"male"</span>,</span><br><span class="line">    hobby_sport: &#123;<span class="string">"basketball"</span>, <span class="string">"swimming"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">johnsonOneOfTheSportHobby = myInfo[hobby_sport][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h5 id="点操作符访问"><a href="#点操作符访问" class="headerlink" title="点操作符访问"></a>点操作符访问</h5><p>点操作符的使用场景比较局限。只有属性名称已知的话，才可以使用点操作符，<strong>变量名+点操作符访问变量的操作不合法</strong>，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> johnsonOneOfTheSportHobby;</span><br><span class="line"><span class="keyword">var</span> property = sex;</span><br><span class="line"><span class="keyword">var</span> myInfo=&#123;</span><br><span class="line">    name: <span class="string">"Johnson"</span>,</span><br><span class="line">    sex: <span class="string">"male"</span>,</span><br><span class="line">    hobby_sport: &#123;<span class="string">"basketball"</span>, <span class="string">"swimming"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">johnsonSex = myInfo.property; <span class="comment">// 不正确</span></span><br><span class="line">johnsonSex = myInfo.sex; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="更新方式"><a href="#更新方式" class="headerlink" title="更新方式"></a>更新方式</h4><p><em>以下中括号方式修改也可</em></p>
<h5 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> myInfo.sex; <span class="comment">// 删除myInfo的sex属性</span></span><br></pre></td></tr></table></figure>
<h5 id="更改数据"><a href="#更改数据" class="headerlink" title="更改数据"></a>更改数据</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myInfo.sex = <span class="string">"female"</span>; <span class="comment">// 更改Info中的属性</span></span><br></pre></td></tr></table></figure>
<h5 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myInfo.job = <span class="string">"coder"</span>;  <span class="comment">// 添加job属性，并将数据初始化为coder</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="判断方式"><a href="#判断方式" class="headerlink" title="判断方式"></a>判断方式</h4><h5 id="判断属性是否存在"><a href="#判断属性是否存在" class="headerlink" title="判断属性是否存在"></a>判断属性是否存在</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(myInfo.hasOwnProperty(job) == <span class="literal">false</span>)&#123;</span><br><span class="line">    myInfo.job = <span class="string">"coder"</span>;  </span><br><span class="line">    <span class="comment">// 如果没有job属性，则添加该属性并初始化为coder</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="JavaScript-Object-Notation-JSON"><a href="#JavaScript-Object-Notation-JSON" class="headerlink" title="JavaScript Object Notation(JSON)"></a>JavaScript Object Notation(JSON)</h4><p><strong>JSON使用Javascript对象的格式来存储数据</strong>，JSON是灵活的，因为它允许多种数据结构的任意组合，下面来看一个JSON的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyFriend=[</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">"Iris"</span>,</span><br><span class="line">        sex: <span class="string">"female"</span>,</span><br><span class="line">        hobby_sport: [<span class="string">"basketball"</span>, <span class="string">"movie"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">"Kevin Durant"</span>,</span><br><span class="line">        sex: <span class="string">"male"</span>,</span><br><span class="line">        hobby_sport: [<span class="string">"basketball"</span>, <span class="string">"chatting"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>JSON可以按一种类似串联的方式，来访问格式中的某个数据，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">girlfriendHobby = MyFriend[<span class="number">0</span>].hobby_sport[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记-3</title>
    <url>/2020/07/05/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<p>主要介绍re库和相关实例。</p>
<a id="more"></a>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="正则表达式的概述"><a href="#正则表达式的概述" class="headerlink" title="正则表达式的概述"></a>正则表达式的概述</h4><p>正则表达式是用来<strong>简洁</strong>表达一组字符串的表达式。</p>
<p>正则表达式的使用：通过编译，将符合正则表达式语法的字符串转换成正则表达式特征。</p>
<h4 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h4><p>语法表</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.</code></td>
<td align="center">表示任何单个字符</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center"><code>[]</code></td>
<td align="center">字符集，对单个字符给出取值范围</td>
<td align="center">[abc]/[a-z]</td>
</tr>
<tr>
<td align="center"><code>[^]</code></td>
<td align="center">非字符集，对单个字符给出排除范围</td>
<td align="center">[^abc]表示非a非b非c的单个字符</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">前一个字符0次或无限次扩展</td>
<td align="center">abc*-&gt;ab、abc、abcc……</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center">前一个字符1次或无限次扩展</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center"><code>?</code></td>
<td align="center">前一个字符0次或1次扩展</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center">`</td>
<td align="center">左右表达式任意一个</td>
</tr>
<tr>
<td align="center"><code>{m}</code></td>
<td align="center">扩展前一个字符m次</td>
<td align="center">ab{2}c-&gt;abbc</td>
</tr>
<tr>
<td align="center"><code>{m,n}</code></td>
<td align="center">扩展前一个字符m至n次(含n)</td>
<td align="center">ab{1,2}c-&gt;abc、abbc</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">匹配字符串开头</td>
<td align="center">^abc表示abc且在一个字符串的开头</td>
</tr>
<tr>
<td align="center"><code>$</code></td>
<td align="center">匹配字符串结尾</td>
<td align="center">abc$表示abc且在一个字符串的结尾</td>
</tr>
<tr>
<td align="center"><code>()</code></td>
<td align="center">分组标记，内部只能用`</td>
<td align="center">`</td>
</tr>
<tr>
<td align="center"><code>\d</code></td>
<td align="center">数字，等价于[0-9]</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center"><code>\w</code></td>
<td align="center">单词字符，等价于[A-Za-z0-9_]</td>
<td align="center">略</td>
</tr>
</tbody></table>
<p>经典正则表达式实例：<br>|表达式|意义|<br>|:–:|:–:|<br>|<code>^[A-Za-z]+$</code>|26个字母组成的字符串|<br>|<code>^-?\d+$</code>|整数形式的字符串|<br>|<code>^[0-9]*[1-9][0-9]*$</code>|正整数形式字符串|<br>|<code>[1-9]\d{5}</code>|中国境内邮政编码，6位|<br>|<code>[\u4e00-\u9fa5]</code>|匹配中文字符|<br>|<code>\d{3}-\d{8}|\d{4}-\d{7}</code>|国内电话号码|<br>|<code>[1-9]?\d</code>|0-99|<br>|<code>1\d{2}</code>|100-199|</p>
<p>表示0-255：<br><code>([1‐9]?\d | 1\d{2} | 2[0‐4]\d | 25[0‐5])</code></p>
<p>表示IP地址：<br><code>(([1‐9]?\d|1\d{2}|2[0‐4]\d|25[0‐5]).){3}([1‐9]?\d|1\d{2}|2[0‐4]\d|25[0‐5])</code></p>
<h3 id="re库"><a href="#re库" class="headerlink" title="re库"></a>re库</h3><p>正则表达式的表示类型：<br><strong>raw string</strong>类型：<code>r&#39;text&#39;</code>–不包含转义符的类型</p>
<h4 id="re库主要功能函数"><a href="#re库主要功能函数" class="headerlink" title="re库主要功能函数"></a>re库主要功能函数</h4><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>re.search()</code></td>
<td align="center">在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象</td>
</tr>
<tr>
<td align="center"><code>re.match()</code></td>
<td align="center">从一个字符串的开始位置起匹配正则表达式，返回match对象</td>
</tr>
<tr>
<td align="center"><code>re.findall()</code></td>
<td align="center">搜索字符串，以列表类型返回全部能匹配的子串</td>
</tr>
<tr>
<td align="center"><code>re.split()</code></td>
<td align="center">将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td>
</tr>
<tr>
<td align="center"><code>re.finditer()</code></td>
<td align="center">搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象</td>
</tr>
<tr>
<td align="center"><code>re.sub()</code></td>
<td align="center">在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">常用标记</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>re.I</code></td>
<td align="center">忽略正则表达式的大小写，<code>[A‐Z]</code>能够匹配小写字符</td>
</tr>
<tr>
<td align="center"><code>re.M</code></td>
<td align="center">正则表达式中的<code>^</code>操作符能够将给定字符串的每行当作匹配开始</td>
</tr>
<tr>
<td align="center"><code>re.S</code></td>
<td align="center">正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符</td>
</tr>
</tbody></table>
<h4 id="re库面向对象用法"><a href="#re库面向对象用法" class="headerlink" title="re库面向对象用法"></a>re库面向对象用法</h4><p>一次编译后，可以多次使用该正则表达式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pat = re.compile(<span class="string">r'[1-9]\d&#123;5&#125;'</span>)</span><br><span class="line">rst = pat.research(<span class="string">'BIT 100081'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="match对象"><a href="#match对象" class="headerlink" title="match对象"></a>match对象</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.string</code></td>
<td align="center">带匹配的文本</td>
</tr>
<tr>
<td align="center"><code>.re</code></td>
<td align="center">匹配时使用的patter对象（正则表达式）</td>
</tr>
<tr>
<td align="center"><code>.pos</code></td>
<td align="center">正则表达式搜索文本的开始位置</td>
</tr>
<tr>
<td align="center"><code>.endpos</code></td>
<td align="center">正则表达式搜索文本的结束位置</td>
</tr>
<tr>
<td align="center"><code>.group(0)</code></td>
<td align="center">获得匹配后的字符串</td>
</tr>
<tr>
<td align="center"><code>.start()</code></td>
<td align="center">匹配字符串在原始字符串的开始位置</td>
</tr>
<tr>
<td align="center"><code>.end()</code></td>
<td align="center">匹配字符串在原始字符串的结束位置</td>
</tr>
<tr>
<td align="center"><code>.span()</code></td>
<td align="center">返回(<code>.start()</code>,<code>.end()</code>)</td>
</tr>
</tbody></table>
<h4 id="贪婪匹配和最小匹配"><a href="#贪婪匹配和最小匹配" class="headerlink" title="贪婪匹配和最小匹配"></a>贪婪匹配和最小匹配</h4><p>Re库默认采用贪婪匹配，即输出匹配最长的子串。<br>最小匹配需要引入最小匹配操作符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>*?</code></td>
<td align="center">最小的..</td>
</tr>
<tr>
<td align="center"><code>+?</code></td>
<td align="center">最小的..</td>
</tr>
<tr>
<td align="center"><code>??</code></td>
<td align="center">最小的..</td>
</tr>
<tr>
<td align="center"><code>{m,n}?</code></td>
<td align="center">最小的..</td>
</tr>
</tbody></table>
<h3 id="实例：淘宝商品比价定向爬取"><a href="#实例：淘宝商品比价定向爬取" class="headerlink" title="实例：淘宝商品比价定向爬取"></a>实例：淘宝商品比价定向爬取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        header = &#123;</span><br><span class="line">            <span class="string">'authority'</span>: <span class="string">'s.taobao.com'</span>,</span><br><span class="line">            <span class="string">'cache-control'</span>: <span class="string">'max-age=0'</span>,</span><br><span class="line">            <span class="string">'upgrade-insecure-requests'</span>: <span class="string">'1'</span>,</span><br><span class="line">            <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-site'</span>: <span class="string">'same-origin'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-mode'</span>: <span class="string">'navigate'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-user'</span>: <span class="string">'?1'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-dest'</span>: <span class="string">'document'</span>,</span><br><span class="line">            <span class="string">'referer'</span>: <span class="string">'https://s.taobao.com/search?q=%E4%B9%A6%E5%8C%85'</span>,</span><br><span class="line">            <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">            <span class="string">'cookie'</span>: <span class="string">'cna=4gSsFiILVA8CAbRPiIEJDXhF; miid=1778120109322818651; t=a3a888add051197e89322f6ac86403c5; sgcookie=EELv%2B4XJBYFwT%2Bhuy%2FTQ%2B; uc3=id2=UNkwd%2Ftz5MUGAw%3D%3D&amp;lg2=VFC%2FuZ9ayeYq2g%3D%3D&amp;nk2=F5REODHw3K6Q%2BD8%3D&amp;vt3=F8dBxGJrlnv3T4HD81o%3D; lgc=tb162242636; uc4=nk4=0%40FY4Pam9Lwk6E41txt%2F1TC19ozrosnQ%3D%3D&amp;id4=0%40Ug46uCfrf6NfVRrSuV4vCECMhqce; tracknick=tb162242636; _cc_=URm48syIZQ%3D%3D; tfstk=c7F5BRa8S3x7eJWeaz_q4yEfcjGFaejjoTi8P--2OluGb34SDsYH_cGl7JxDMA3f.; enc=qCR4%2Bv6cUjkOuvgrakFshhE%2F46cDPAwDb8Gev5FH7UI1LN0ry3vlgtuMnhJU%2BKlc%2FspoGvT9CB7NKS2BEruk%2Fg%3D%3D; mt=ci=22_1; thw=cn; cookie2=7d4e0cb8e8f704666b1c1961f5f55cd9; _tb_token_=3bb5e05733efb; v=0; uc1=cookie14=UoTV6OIrH78%2Bvw%3D%3D; JSESSIONID=CAB751B32AF7D64E317AA254FB07BFB2; l=eBaLBPIVqovCAMUoBOfanurza77tbIRYSuPzaNbMiOCP_bCH59jdWZlodgLMCnGVhs9BR3ow4YKgBeYBqS24n5U62j-laTDmn; isg=BLGxbgYJSkcl6-TbYQmF-OWzwD1LniUQmN7K7JPGuniXutEM2-xT4FtY2E7cd71I'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        r = requests.get(url, headers = header)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"get_false"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(ilt, html)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        plt = re.findall(<span class="string">r'\"view_price\":\"\d+\.\d*\"'</span>, html)</span><br><span class="line">        tlt = re.findall(<span class="string">r'\"raw_title\":\".*?\"'</span>, html)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plt)):</span><br><span class="line">            price = eval(plt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])</span><br><span class="line">            title = eval(tlt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])</span><br><span class="line">            ilt.append([price, title])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"parse_falut"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGoodsList</span><span class="params">(ilt)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"序号"</span>, <span class="string">"价格"</span>, <span class="string">"商品名称"</span>))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> g <span class="keyword">in</span> ilt:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        print(tplt.format(count, g[<span class="number">0</span>], g[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    goods = <span class="string">'书包'</span></span><br><span class="line">    depth = <span class="number">3</span></span><br><span class="line">    start_url = <span class="string">'https://s.taobao.com/search?q='</span> + goods</span><br><span class="line">    infoList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(depth):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            url = start_url + <span class="string">'&amp;s='</span> + str(<span class="number">44</span> * i)</span><br><span class="line">            html = getHTMLText(url)</span><br><span class="line">            parsePage(infoList, html)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            print(<span class="string">"&#123;&#125;层fault"</span>.format(depth))</span><br><span class="line">    printGoodsList(infoList)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>与MOOC上的有些许出入，主要是淘宝最近增加了反爬虫机制（是不是教学视频火了，让学习狗把淘宝爬急了hh），参照这位大神的方法可成<br><a href="https://blog.csdn.net/Guanhai1617/article/details/104120581" target="_blank" rel="noopener">入口</a></p>
<p>实例中的正则表达式：</p>
<table>
<thead>
<tr>
<th align="center">原式</th>
<th align="center">正则语法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“raw_title”=”某某书包”</td>
<td align="center"><code>r&#39;\&quot;view_price\&quot;:\&quot;\d+\.\d*\&quot;&#39;</code></td>
</tr>
<tr>
<td align="center">“view_price”=”125.00”</td>
<td align="center"><code>r&#39;\&quot;raw_title\&quot;:\&quot;.*?\&quot;&#39;</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆栈</title>
    <url>/2020/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<a id="more"></a>

]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记_2</title>
    <url>/2020/07/03/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>主要介绍python的第三方库BS4库的应用场景。</p>
<a id="more"></a>
<h3 id="BS4库"><a href="#BS4库" class="headerlink" title="BS4库"></a>BS4库</h3><p>BS4库主要用于<strong>HTML页面的解析</strong>。是解析、遍历、维护“标签树”的功能库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">demo = requests.get(url).text</span><br><span class="line">soup = BeautifulSoup(demo, <span class="string">"html.parser"</span>)</span><br></pre></td></tr></table></figure>
<p><code>soup</code>便承载了解析后的<code>标签树</code>。</p>
<table>
<thead>
<tr>
<th align="center">基本元素</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Tag</td>
<td align="center">标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾</td>
</tr>
<tr>
<td align="center">Name</td>
<td align="center">标签的名字，格式：<code>&lt;tag&gt;.name</code></td>
</tr>
<tr>
<td align="center">Attributes</td>
<td align="center">标签的属性，字典形式组织，格式：<code>&lt;tag&gt;.attrs</code></td>
</tr>
<tr>
<td align="center">NavigableString</td>
<td align="center">标签内非属性字符串，格式：<code>&lt;tag&gt;.string</code></td>
</tr>
<tr>
<td align="center">Comment</td>
<td align="center">标签内字符串的注释部分，一种特殊的Comment类型</td>
</tr>
</tbody></table>
<h4 id="标签树的遍历"><a href="#标签树的遍历" class="headerlink" title="标签树的遍历"></a>标签树的遍历</h4><h5 id="下行遍历"><a href="#下行遍历" class="headerlink" title="下行遍历"></a>下行遍历</h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.contents</code></td>
<td align="center">子节点的列表，将<code>&lt;tag&gt;</code>所有儿子节点存入列表</td>
</tr>
<tr>
<td align="center"><code>.children</code></td>
<td align="center">子节点的迭代类型，与<code>contents</code>类似，用于循环遍历儿子节点</td>
</tr>
<tr>
<td align="center"><code>.descendants</code></td>
<td align="center">子孙节点的迭代类型，包含所有子孙节点</td>
</tr>
</tbody></table>
<p>迭代类型的下行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> demoSoup.body.children: <span class="comment"># descendants是子孙结点</span></span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure>

<h5 id="上行遍历"><a href="#上行遍历" class="headerlink" title="上行遍历"></a>上行遍历</h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.parent</code></td>
<td align="center">节点的父亲标签</td>
</tr>
<tr>
<td align="center"><code>.parents</code></td>
<td align="center">节点先辈标签的迭代类型，用于循环遍历先辈节点</td>
</tr>
</tbody></table>
<p>迭代类型的上行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> demoSoup.a.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(parent.name)</span><br></pre></td></tr></table></figure>

<h5 id="平行遍历"><a href="#平行遍历" class="headerlink" title="平行遍历"></a>平行遍历</h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.next_sibling</code></td>
<td align="center">返回按照HTML文本顺序的下一个平行节点标签</td>
</tr>
<tr>
<td align="center"><code>.previous_sibling</code></td>
<td align="center">返回按照HTML文本顺序的上一个平行节点标签</td>
</tr>
<tr>
<td align="center"><code>.next_siblings</code></td>
<td align="center">迭代类型，返回按照HTML文本顺序的后续所有平行节点标签</td>
</tr>
<tr>
<td align="center"><code>.previous_siblings</code></td>
<td align="center">迭代类型，返回按照HTML文本顺序的前续所有平行节点标签</td>
</tr>
</tbody></table>
<p>迭代类型的上行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> demoSoup.a.next_siblings:  <span class="comment"># or previous_siblings</span></span><br><span class="line">    print(sibling)</span><br></pre></td></tr></table></figure>

<h4 id="美化标签"><a href="#美化标签" class="headerlink" title="美化标签"></a>美化标签</h4><p><code>soup.prettify()</code></p>
<h4 id="信息提取方法"><a href="#信息提取方法" class="headerlink" title="信息提取方法"></a>信息提取方法</h4><p>信息标记的三种形式XML,JSON和YAML<br><code>.find_all</code>方法，返回一个列表类型，存储查找的结果。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>name</code></td>
<td align="center">对标签名称的检索字符串</td>
</tr>
<tr>
<td align="center"><code>attrs</code></td>
<td align="center">对标签属性值的检索字符串，可标注属性检索</td>
</tr>
<tr>
<td align="center"><code>recursive</code></td>
<td align="center">是否对子孙全部检索，默认True</td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td align="center">&lt;&gt;…&lt;/&gt;中字符串区域的检索字符串</td>
</tr>
</tbody></table>
<h3 id="实例：全球大学学术排名"><a href="#实例：全球大学学术排名" class="headerlink" title="实例：全球大学学术排名"></a>实例：全球大学学术排名</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"爬取失败"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):  <span class="comment"># Tag是bs4定义的标签类型</span></span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">4</span>].string])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt1 = <span class="string">"&#123;0:^10&#125;\t&#123;1:^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    tplt2 = <span class="string">"&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(<span class="string">"全球大学学术排名情况\n"</span>)</span><br><span class="line">    ls = [<span class="string">"排名"</span>,<span class="string">"学校名称"</span>,<span class="string">"得分"</span>]</span><br><span class="line">    print(tplt1.format(ls[<span class="number">0</span>], ls[<span class="number">1</span>], ls[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(tplt2.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">"http://www.zuihaodaxue.cn/ARWU2019.html"</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>涉及知识点：</p>
<ul>
<li>下行遍历<ol>
<li>遍历tsbody中的tr，并依次输出每个tr下的td</li>
<li>遍历时不只有td这样的标签，还会有像<code>navigablestring</code>..所以要先check是否是bs4定义的标签类型</li>
</ol>
</li>
<li>中文对齐–char(12288)来控制中文对齐</li>
</ul>
]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/07/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，创立了解决这类过程优化问题的新方法——<strong>动态规划</strong>。</p>
<a id="more"></a>
<p><a href="https://www.bilibili.com/video/BV1xb411e7ww?from=search&seid=6405207412150244964" target="_blank" rel="noopener">动态规划入门链接</a></p>
<h3 id="动态规划题目特点"><a href="#动态规划题目特点" class="headerlink" title="动态规划题目特点"></a>动态规划题目特点</h3><ol>
<li>计数</li>
<li>求最值</li>
<li>求存在性</li>
</ol>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="实例1–求最值"><a href="#实例1–求最值" class="headerlink" title="实例1–求最值"></a>实例1–求最值</h4><p>结账时，需要交价值27元，要求用2元、5元、7元想出一种使得<strong>纸币数最少</strong>的交钱方法。</p>
<h4 id="实例2–计数"><a href="#实例2–计数" class="headerlink" title="实例2–计数"></a>实例2–计数</h4><p>给定m行n列(m=4,n=8)的网络，有一个机器人从左上角(0,0)出发，每一步可以向下或者向右走一步。问有多少种不同的方式走到右下角？</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">起点</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">终点</td>
</tr>
</tbody></table>
<h4 id="实例3–存在性"><a href="#实例3–存在性" class="headerlink" title="实例3–存在性"></a>实例3–存在性</h4><p>有n块石头分别在x轴的0,1,…,n-1位置，一只青蛙在石头0，想跳到石头n-1。如果青蛙在第i块石头上，它最多可以向右跳距离$a_i$，问青蛙能否跳到石头n-1?</p>
<h4 id="实例4–求最值–多状态"><a href="#实例4–求最值–多状态" class="headerlink" title="实例4–求最值–多状态"></a>实例4–求最值–多状态</h4><p>出处：Leetcode309<br>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<h3 id="动态规划四组成"><a href="#动态规划四组成" class="headerlink" title="动态规划四组成"></a>动态规划四组成</h3><h4 id="动态规划组成部分一：确定状态"><a href="#动态规划组成部分一：确定状态" class="headerlink" title="动态规划组成部分一：确定状态"></a>动态规划组成部分一：确定状态</h4><h5 id="两个意识"><a href="#两个意识" class="headerlink" title="两个意识"></a>两个意识</h5><ul>
<li>最后一步</li>
<li>子问题</li>
</ul>
<p>状态由<br>$$ f(x)=最少用多少枚硬币拼出27 $$<br>转换为<br>$$f(x)=最少用多少枚硬币拼出27-a_{k}$$<br>归纳为<br>$$状态f(x)=最少用多少枚硬币拼出x$$</p>
<p>根据最后一步分部考虑： </p>
<p>$$f(27) = min{f(27-2)+1, f(27-5)+1, f(27-7)+1}$$</p>
<p>我们根据这个公式可以写出一种递归算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res=np.inf  <span class="comment"># res初始化为极大值</span></span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">2</span>:</span><br><span class="line">        res=min(f(x<span class="number">-2</span>)+<span class="number">1</span>,res)</span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">5</span>:</span><br><span class="line">        res=min(f(x<span class="number">-5</span>)+<span class="number">1</span>,res)</span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">7</span>:</span><br><span class="line">        res=min(f(x<span class="number">-7</span>)+<span class="number">1</span>,res)</span><br><span class="line">    <span class="keyword">return</span> res  <span class="comment"># 当传入的x为1时，res返回的是inf，也就相当于不成立！！</span></span><br><span class="line">print(f(<span class="number">27</span>))</span><br></pre></td></tr></table></figure>

<h4 id="动态规划组成部分二：转移方程"><a href="#动态规划组成部分二：转移方程" class="headerlink" title="动态规划组成部分二：转移方程"></a>动态规划组成部分二：转移方程</h4><p>$$f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}$$</p>
<h4 id="动态规划组成部分三：初始条件和边界情况"><a href="#动态规划组成部分三：初始条件和边界情况" class="headerlink" title="动态规划组成部分三：初始条件和边界情况"></a>动态规划组成部分三：初始条件和边界情况</h4><p>初始条件：</p>
<p>$$f[0] = 0$$</p>
<p>边界情况：</p>
<p align="center">数组不越界</p>

<h4 id="动态规划组成部分四：计算顺序"><a href="#动态规划组成部分四：计算顺序" class="headerlink" title="动态规划组成部分四：计算顺序"></a>动态规划组成部分四：计算顺序</h4><ul>
<li>正序</li>
<li>逆序</li>
<li>其他</li>
</ul>
<p>判断标准：当前的数据在已经算出后，前面（后面）的数据是否已经得出了。</p>
<h4 id="实例1解答"><a href="#实例1解答" class="headerlink" title="实例1解答"></a>实例1解答</h4><p>个人解答</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">f = [<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">28</span>)]</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">f[<span class="number">1</span>] = np.inf</span><br><span class="line">n = <span class="number">27</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>): <span class="comment"># 时间复杂度O(n)</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">7</span>):</span><br><span class="line">        f[i] = min(f[i<span class="number">-2</span>]+<span class="number">1</span>,f[i<span class="number">-5</span>]+<span class="number">1</span>,f[i<span class="number">-7</span>]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">7</span>&gt;i&gt;=<span class="number">5</span>):</span><br><span class="line">        f[i] = min(f[i<span class="number">-2</span>]+<span class="number">1</span>, f[i<span class="number">-5</span>]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">5</span>):</span><br><span class="line">        f[i] = f[i<span class="number">-2</span>]+<span class="number">1</span></span><br><span class="line">print(f[<span class="number">27</span>])</span><br></pre></td></tr></table></figure>
<p>完美改进</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *fun;</span><br><span class="line">    fun = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(M+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A)/<span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    fun[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= A[j] &amp;&amp; fun[i-A[j]] != INT_MAX)&#123; </span><br><span class="line">                <span class="comment">// 防止下标溢出；防止无穷大加法溢出！！</span></span><br><span class="line">                fun[i] = <span class="built_in">min</span>(fun[i-A[j]]+<span class="number">1</span>, fun[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fun[M]==INT_MAX)&#123;</span><br><span class="line">        fun[M] = <span class="number">-1</span>; <span class="comment">// 题目要求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态规划组成部分概括"><a href="#动态规划组成部分概括" class="headerlink" title="动态规划组成部分概括"></a>动态规划组成部分概括</h4><ol>
<li>确定状态<ul>
<li>最后一步（最优策略中使用的最后一枚硬币$a_k$）</li>
<li>化成子问题（最少的硬币拼出来更小的面值$27-a_k$）</li>
</ul>
</li>
<li>转移方程<ul>
<li>$f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}$</li>
</ul>
</li>
<li>初始条件和边界情况<ul>
<li>f[0] = 0，如果不能拼出Y，f[Y]=inf</li>
</ul>
</li>
<li>计算顺序<ul>
<li>正序</li>
</ul>
</li>
</ol>
<h3 id="利用动态规划解实例2"><a href="#利用动态规划解实例2" class="headerlink" title="利用动态规划解实例2"></a>利用动态规划解实例2</h3><ol>
<li>确定状态<ul>
<li>最后一步：到达(m-1,n-1)前的方法是以M种方法到(m-2,n-1)加上以N种方法到(m-1,n-2)</li>
<li>化成子问题：有多少种方法到达(m-2,n-1)或(m-1,n-2)</li>
<li>状态：设$f[i][j]$为从左上角有多少种路径走到$(i,j)$</li>
</ul>
</li>
<li>转移方程<ul>
<li>$f[i][j] = f[i-1][j] + f[i][j-1]$</li>
</ul>
</li>
<li>初始条件和边界情况<ul>
<li>初始条件：$f[0][0]=1$</li>
<li>边界情况：$i=j=0$时，$f[i][j]=1$</li>
</ul>
</li>
<li>计算顺序<ul>
<li>由左到右，逐行计算</li>
</ul>
</li>
</ol>
<p>代码解答：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePath</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[m][n];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i = <span class="number">0</span> || j = <span class="number">0</span>)&#123;</span><br><span class="line">                f[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j] + f[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用动态规划解实例3"><a href="#利用动态规划解实例3" class="headerlink" title="利用动态规划解实例3"></a>利用动态规划解实例3</h3><ol>
<li>确定状态<ul>
<li>最后一步：到达n-1之前已经到达i</li>
<li>化成子问题：跳到n-1 -&gt; 跳到i</li>
<li>状态：设$f[j]$为青蛙能不能跳到石头j</li>
</ul>
</li>
<li>转移方程<ul>
<li>$f[j]=OR_{0&lt;=i&lt;j}(f[i] AND i +a[i]&gt;=j)$</li>
</ul>
</li>
<li>初始条件和边界情况<ul>
<li>初始条件：$f[0]=true$</li>
</ul>
</li>
<li>计算顺序<ul>
<li>从小到大</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span> *A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="keyword">sizeof</span>(A)/<span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> *f;</span><br><span class="line">    f = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        f[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[j] &amp;&amp; j+A[j] &gt;= i)&#123;</span><br><span class="line">                <span class="comment">// 能到达目标点前的这个点，并且还能跳到目标点，则能到达目标点</span></span><br><span class="line">                f[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^2)$<br>空间复杂度：$O(n)$</p>
<h3 id="利用动态规划解实例4"><a href="#利用动态规划解实例4" class="headerlink" title="利用动态规划解实例4"></a>利用动态规划解实例4</h3><ol>
<li><p>确定状态<br>用$f[i]$表示第i天结束后的累计最大收益，状态分为三种：</p>
<ul>
<li>持股状态：目前持有一种股票，累计最大收益为$f[i][0]$</li>
<li>冷冻期状态：该天结束后处于冷冻期，对应的累计最大收益为$f[i][1]$</li>
<li>双非状态：既不持有股票也不处于冷冻期状态，对应$f[i][2]$</li>
</ul>
</li>
<li><p>转移方程<br> 状态转移：<br>$$f[i][0] = max{f[i-1][0], f[i-1][2]-prices[i]}$$<br>$$f[i][1] = f[i-1][0] + prices[i]$$<br>$$f[i][2] = max{f[i-1][2], f[i-1][1]}$$<br> 结果：<br>$$result = max{f[n-1][1],f[n-1][2]}$$</p>
</li>
<li><p>初始条件和边界情况<br>$$f[0][0] = -prices[0]$$<br>$$f[0][1] = 0$$<br>$$f[0][2] = 0$$</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// f[i][0]代表目前持有一支股票</span></span><br><span class="line">    <span class="comment">// f[i][1]代表第i天结束后，位于冷冻期</span></span><br><span class="line">    <span class="comment">// f[i][2]代表当前不持股，也不位于冷冻期</span></span><br><span class="line">    <span class="keyword">if</span>(pricesSize==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[pricesSize][<span class="number">3</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; pricesSize; i++)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = fmax(f[i<span class="number">-1</span>][<span class="number">0</span>], f[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">        f[i][<span class="number">2</span>] = fmax(f[i<span class="number">-1</span>][<span class="number">2</span>], f[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmax(f[pricesSize<span class="number">-1</span>][<span class="number">1</span>],f[pricesSize<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之查找</title>
    <url>/2020/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>查找这部分是跟着郭老师学的，临近期末，又要复习这部分涉及到的内容又多，掌握的几乎为0。</p>
<a id="more"></a>
<h3 id="hash表查找"><a href="#hash表查找" class="headerlink" title="hash表查找"></a>hash表查找</h3><h4 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>目标：不需要把待查记录的关键字与查找表的某些记录进行逐个比较。而是<strong>根据待查记录的关键字值，直接找到该记录的存储地址</strong>。<br>思想：建立一个确定的函数关系H(称为散列函数，或哈希函数)：</p>
<ul>
<li>以结点关键字key作为自变量</li>
<li>以函数值H(key)作为结点的存储地址</li>
<li>通常散列表的存储空间是一个一维数组，散列地址是数组的下标。</li>
</ul>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h6 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h6><p>题目：已知一长度为14的线性表关键字集合<code>S = { and,
begin, do, end, for, go, if, repeat, then, until, while,
else, array, when }</code>。设查找表中每个关键字表示为<br><code>key[8]</code>。</p>
<p>设计：</p>
<ul>
<li>散列表表示为<code>char ht[26][8];</code></li>
<li>散列函数H(key)的值取为关键字key中的第一个字母在字母表中的序号</li>
</ul>
<p>总结：显然a、e、w开头的单词均在其地址内有冲突。</p>
<h6 id="例题改进"><a href="#例题改进" class="headerlink" title="例题改进"></a>例题改进</h6><p>在例1的基础上，修改散列函数H(key)：<strong>值为key中首尾字母在字母表中序号的平均值</strong>，此时地址不产生冲突。</p>
<h4 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p><strong>散列函数H</strong>：<br>$$Address=H(key)$$<br><strong>装载因子</strong>：<br>$$a=n/m$$<br>其中，m为散列表的空间大小，n为散列表中的记录数。</p>
<h5 id="hash函数的构造方法"><a href="#hash函数的构造方法" class="headerlink" title="hash函数的构造方法"></a>hash函数的构造方法</h5><h6 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h6><p>$$H(key)=key%p$$<br>其中p一般取&lt;=m的最大素数。</p>
<h6 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h6><ul>
<li>取关键字作为其hash地址</li>
<li>取关键字的某个线性函数：$H(key)=a*key+b$<h6 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h6>根据散列表的大小，选取其中各种符号分布均匀的若干位作为散列地址。<h6 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h6>先通过求关键字的平方值来扩大差别，<br>再取其中的几位或其组合作为散列地址。<br>具体取几位，由hash表的表长决定。<h6 id="分段叠加法"><a href="#分段叠加法" class="headerlink" title="分段叠加法"></a>分段叠加法</h6></li>
<li>将关键字分割成位数相同的几部分（最后一部分位数可不同）</li>
<li>然后取这几部分的叠加和舍去进位作为散列地址。</li>
</ul>
<h4 id="冲突解决方法"><a href="#冲突解决方法" class="headerlink" title="冲突解决方法"></a>冲突解决方法</h4><h5 id="开放地址法–找下一个空位"><a href="#开放地址法–找下一个空位" class="headerlink" title="开放地址法–找下一个空位"></a>开放地址法–找下一个空位</h5><p>当冲突发生时，使用某种方法为R的关键字key生成一个散列地址序列，其中第i次冲突散列地址：<br>$$d_i = (d_{i-1}+D)%m$$</p>
<h6 id="线性探测再散列"><a href="#线性探测再散列" class="headerlink" title="线性探测再散列"></a>线性探测再散列</h6><p>$D=i$，i表示探测次数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="二次探测再散列"><a href="#二次探测再散列" class="headerlink" title="二次探测再散列"></a>二次探测再散列</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(i*i/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i+<span class="number">1</span>)*(i+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="伪随机探测再散列"><a href="#伪随机探测再散列" class="headerlink" title="伪随机探测再散列"></a>伪随机探测再散列</h6>]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之链表</title>
    <url>/2020/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表的内容非常非常的基础，快速回顾~</p>
<a id="more"></a>
<h2 id="绕不开的malloc和free"><a href="#绕不开的malloc和free" class="headerlink" title="绕不开的malloc和free"></a>绕不开的malloc和free</h2><p>C没有虚浮的<code>new</code>关键字，只能用使用起来不是很直观的<code>malloc</code>关键字进行内存分配。</p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>声明：<code>malloc</code>向系统申请分配指定<code>size</code>个字节的内存空间。返回类型是 <code>void*</code> 类型。<code>void*</code> 表示未确定类型的指针。C,C++规定，<code>void*</code> 类型可以强制转换为<strong>任何其它类型的指针</strong>。</p>
<h4 id="malloc函数标准用法"><a href="#malloc函数标准用法" class="headerlink" title="malloc函数标准用法"></a>malloc函数标准用法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以申请一个链表SLNode数据为例，此处head已经声明过，为SLNode的二级指针</span></span><br><span class="line"><span class="keyword">if</span> ((*head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请一段连续的内存空间</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">100</span> );</span><br></pre></td></tr></table></figure>

<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h4 id="函数声明-1"><a href="#函数声明-1" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *block)</span></span>;</span><br><span class="line"><span class="comment">// 即 void free(指针变量)</span></span><br></pre></td></tr></table></figure>

<h2 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h2><h3 id="链表vs顺序表"><a href="#链表vs顺序表" class="headerlink" title="链表vs顺序表"></a>链表vs顺序表</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">顺序表</th>
<th align="center">链表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">增删改</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center">访问</td>
<td align="center">$O(1)$</td>
<td align="center">$O(n)$</td>
</tr>
</tbody></table>
<h3 id="单链表操作"><a href="#单链表操作" class="headerlink" title="单链表操作"></a>单链表操作</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SLNode **head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    (*head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="统计元素个数-核心思想"><a href="#统计元素个数-核心思想" class="headerlink" title="统计元素个数(核心思想)"></a>统计元素个数(核心思想)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;next!=null)&#123;</span><br><span class="line">    <span class="built_in">size</span>++;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找算法-略"><a href="#查找算法-略" class="headerlink" title="查找算法(略)"></a>查找算法(略)</h4><h4 id="添加算法"><a href="#添加算法" class="headerlink" title="添加算法"></a>添加算法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = q;</span><br></pre></td></tr></table></figure>
<h4 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q)</span><br></pre></td></tr></table></figure>

<h4 id="头插法建表（反向）"><a href="#头插法建表（反向）" class="headerlink" title="头插法建表（反向）"></a>头插法建表（反向）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creatlist1</span><span class="params">(SLNode **head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 从键盘输入n个整数，建立以head为头指针的带头结点的单链表*/</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    SLNode *p;</span><br><span class="line">    <span class="keyword">if</span> ((*head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    (*head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((p=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p-&gt;data);</span><br><span class="line">        p-&gt;next=(*head)-&gt;next;</span><br><span class="line">        (*head)-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="尾插法建表（正向）"><a href="#尾插法建表（正向）" class="headerlink" title="尾插法建表（正向）"></a>尾插法建表（正向）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SLNode * <span class="title">createlist2</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch; </span><br><span class="line">    SLNode * head,*s,*r;</span><br><span class="line">    <span class="keyword">if</span> ((head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    (head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r=head;</span><br><span class="line">    <span class="keyword">while</span>((ch=getchar( ))!=‘\n’)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((s=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        s–&gt;data=ch;</span><br><span class="line">        r–&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">    &#125;</span><br><span class="line">    r–&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表操作"><a href="#双向链表操作" class="headerlink" title="双向链表操作"></a>双向链表操作</h3>]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
