<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020暑假第三阶段学习</title>
    <url>/2020/08/11/2020%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>暑假的最后一段时间了，可能开学之后学业繁重就没时间弄计算机了，要抓紧最后的时间突破呀！8.12$\rightarrow$8.31.</p>
<a id="more"></a>

<h1 id="上期总结"><a href="#上期总结" class="headerlink" title="上期总结"></a>上期总结</h1><ol>
<li>计组剩余96节网课</li>
<li>汇编刚开了个头</li>
<li>Leetcode刷题已经达到177题</li>
<li>周赛已经参加4次</li>
<li>matlab基本语法已经掌握</li>
<li>操作系统已经学完了</li>
<li>学习的新算法<ol>
<li>滑动窗口（寻找局部最优解）</li>
<li>字典树（应用于对一组字符串进行快速匹配查询）</li>
<li>树状数组</li>
<li>位运算</li>
<li>前缀和思想</li>
<li>堆排序</li>
</ol>
</li>
</ol>
<p>由于这段时间执着于刷题，并没有对自己的时间表进行好好的规划，导致部分时间不知道自己要干什么了。下一段时间我要让自己每天都明确自己应该干啥，别盲目的学。</p>
<h1 id="本期任务"><a href="#本期任务" class="headerlink" title="本期任务"></a>本期任务</h1><p>以下时间表从回北京后开始实行</p>
<table>
<thead>
<tr>
<th></th>
<th>1245</th>
<th>36</th>
<th>7</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>9:00~10:00</td>
<td>晨刷</td>
<td>晨刷</td>
<td>晨刷</td>
<td>2easy or 1medium</td>
</tr>
<tr>
<td>10:30~12:00</td>
<td>汇编</td>
<td>学新算法</td>
<td>周赛</td>
<td></td>
</tr>
<tr>
<td>13:00~14:00</td>
<td>matlab</td>
<td>固体物理</td>
<td>–</td>
<td>matlab要适当完成小项目</td>
</tr>
<tr>
<td>14:30~16:00</td>
<td>Linux</td>
<td>刷新算法</td>
<td>Linux</td>
<td>多利用自己的虚拟机玩一玩</td>
</tr>
<tr>
<td>17:00~18:30</td>
<td>汇编</td>
<td>刷新算法</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>19:30~22:00</td>
<td>六级专项</td>
<td>–</td>
<td>周赛总结</td>
<td>六级专项主要是阅读、翻译和作文</td>
</tr>
<tr>
<td>22:00~24:00</td>
<td>计组</td>
<td>计组</td>
<td>计组</td>
<td>一天至少走三节课</td>
</tr>
<tr>
<td>0:30~1:30</td>
<td></td>
<td></td>
<td></td>
<td>每日一题</td>
</tr>
<tr>
<td>1:30~2:00</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>看书or听力 and 写总结</td>
</tr>
</tbody></table>
<p>剩余算法：</p>
<ol>
<li>归并排序、快速排序 √</li>
<li>KMP √</li>
<li>红黑树</li>
<li>最短路径</li>
<li>状态压缩</li>
<li>Morris遍历</li>
<li>马拉车算法</li>
</ol>
<h1 id="每日总结"><a href="#每日总结" class="headerlink" title="每日总结"></a>每日总结</h1><h2 id="8-12"><a href="#8-12" class="headerlink" title="8.12"></a>8.12</h2><p>0:30~1:30，每日一题，今天这题好非主流。</p>
<ul>
<li>克隆图</li>
</ul>
<p>10:00~12:00，三道Leetcode。</p>
<ul>
<li>奇偶链表(双指针)</li>
<li>猜数字大小(二分)</li>
<li>猜数字大小II(dp)</li>
</ul>
<p>13:30~14:30，六级阅读，错一个选词，两个阅读。</p>
<p>15:00~16:30，总结快速排序和归并排序算法。</p>
<p>17:00~17:40，matlab矩阵基本运算。</p>
<p>18:00~19:00，一道Leetcode，性能贼差，不想优化了。</p>
<ul>
<li>设计推特(hash+list)</li>
</ul>
<p>20:00~21:00，汇编语言两节。</p>
<ul>
<li><p>存储器</p>
</li>
<li><p>堆栈操作</p>
</li>
</ul>
<p>21:30~22:30，看计组，终于放弃了晦涩难懂的哈工大，转王道了。</p>
<p>22:40~23:00，找到了一个宝藏数据结构网课，讲的贼清楚。</p>
<ul>
<li>LCS问题（最长公共子序列）</li>
</ul>
<h2 id="8-13"><a href="#8-13" class="headerlink" title="8.13"></a>8.13</h2><p>0:00~1:40，Leetcode每日一题，只会用竖式做。</p>
<ul>
<li>字符串乘法</li>
</ul>
<p>10:00~14:30，全程淦kmp，反复看了25P视频，我只能说基本搞懂了。</p>
<p>15:30~16:30，两道Leetcode，与字符串匹配有关。</p>
<ul>
<li>实现strStr()</li>
<li>数组中的字符串匹配</li>
</ul>
<p>17:00~18:30，回北京，做六级阅读。</p>
<p>21:00~23:00，一道Leetcode简单题，但是很坑。</p>
<ul>
<li>重复叠加字符串匹配</li>
</ul>
<h2 id="8-14"><a href="#8-14" class="headerlink" title="8.14"></a>8.14</h2><p>0:30~0:40，Leetcode每日一题。</p>
<p>10:30~12:00，三道Leetcode。</p>
<ul>
<li>有效的完全平方数（完全平方数是奇数的和）</li>
<li>字符串中第一个唯一字符（hash）</li>
<li>数字转换为16进制数（位运算）</li>
</ul>
<p>17:00~21:00，三道Leetcode。</p>
<ul>
<li>根据身高重建队列（脑筋急转弯+插入排序）</li>
<li>二进制矩阵中的路径（BFS）</li>
<li>两数之和II</li>
</ul>
<p>21:30~23:00，冲浪，找到一个Linux的学习链接，在学完这个链接后立即上手做os实验。</p>
<p><a href="https://www.bilibili.com/video/BV12a4y1a7gQ?p=10" target="_blank" rel="noopener">Ubuntu 20.04 乌班图Linux课程_60集教学视频</a></p>
<p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_2_1_1_ex1.html" target="_blank" rel="noopener">os实验gitbook</a></p>
<h2 id="8-15"><a href="#8-15" class="headerlink" title="8.15"></a>8.15</h2><p>0:30~1:00，看了半天这个每日一题，懂了啥意思了，下次做铁定还不会。</p>
<ul>
<li>移除盒子</li>
</ul>
<p>10:30~11:30，三道Leetcode。</p>
<ul>
<li>FizzBuzz</li>
<li>找到所有数组中消失的数字</li>
<li>最长回文串</li>
</ul>
<p>17:00~19:30，三道Leetcode。</p>
<ul>
<li>四数之和</li>
<li>四数相加II</li>
<li>重复的子字符串</li>
</ul>
<p>21:30~23:00，三道Leetcode。</p>
<ul>
<li>斐波那契数</li>
<li>最长特殊序列I</li>
<li>最长特殊序列II（读不懂题我就是）</li>
</ul>
<h2 id="8-16"><a href="#8-16" class="headerlink" title="8.16"></a>8.16</h2><p>10:30~12:00，Leetcode周赛，前两道题秒速，第三题没思路，第四题4种思路都超时/溢出（bfs，dfs，递归，dp）。</p>
<ul>
<li>存在连续三个奇数的数组（暴力）</li>
<li>使数组中所有元素相等的最小操作数（数学）</li>
</ul>
<p>12:30~14:30，总结周赛，问题还是挺多的，主要是二分法的边界问题还没有彻底通透。</p>
<ul>
<li>两球之间的磁力（二分）</li>
<li>吃掉N个橘子的最小天数（bfs/贪心）</li>
</ul>
<p>15:00~16:15，我又研究了半天二分边界的问题，终于搞懂了！</p>
<p>19:30~23:00，Linux网课视频P10-P16。</p>
<ul>
<li>文件系统基本操作。</li>
</ul>
<h2 id="8-17"><a href="#8-17" class="headerlink" title="8.17"></a>8.17</h2><p>0:00~0:40，Leetcode每日一题。</p>
<ul>
<li>平衡二叉树</li>
</ul>
<p>0:40~1:40，两道Leetcode。</p>
<ul>
<li>相对名次（map）</li>
<li>最长回文子序列（dp）</li>
</ul>
<p>10:30~晚上，基本都在乱搞，罗列一下今天的Leetcode的题得了。</p>
<ul>
<li>学生出勤记录I</li>
<li>学生出勤记录II（不会）</li>
<li>回文子串（暴力/dp）</li>
<li>根据二叉树创建字符串（递归）</li>
</ul>
<h2 id="8-18"><a href="#8-18" class="headerlink" title="8.18"></a>8.18</h2><p>0:30~1:10，三道Leetcode。</p>
<ul>
<li>在二叉树中增加一行（bfs）</li>
<li>最长连续递增序列</li>
<li>寻找重复的子树（序列化，dfs）</li>
</ul>
<p>11:00~17:00，四道Leetcode。</p>
<ul>
<li>输出二叉树（bfs）</li>
<li>机器人能否返回原点</li>
<li>找到K个最接近的元素（二分+双指针）</li>
<li>分割数组为连续子序列（贪心）</li>
</ul>
<p>这两天学的有点乱啊，为了跟上学校的节奏，得开始早睡早起了。更新时间表吧，最后两周还是要坚持下去啊啊啊啊！（原则上要七点起床了）</p>
<table>
<thead>
<tr>
<th></th>
<th>1245</th>
<th>36</th>
<th>7</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>7:30~8:30</td>
<td>晨刷</td>
<td>晨刷</td>
<td>晨刷</td>
<td>2easy or 1medium</td>
</tr>
<tr>
<td>9:00~10:30</td>
<td>一套六级</td>
<td>新算法</td>
<td>回顾题解保持手感</td>
<td></td>
</tr>
<tr>
<td>10:30~12:00</td>
<td>汇编</td>
<td>新算法</td>
<td>周赛</td>
<td></td>
</tr>
<tr>
<td>13:00~14:00</td>
<td>matlab</td>
<td>固体物理</td>
<td>–</td>
<td>matlab要适当完成小项目</td>
</tr>
<tr>
<td>14:30~16:00</td>
<td>Linux</td>
<td>刷新算法</td>
<td>Linux</td>
<td>多利用自己的虚拟机玩一玩</td>
</tr>
<tr>
<td>17:00~18:30</td>
<td>汇编</td>
<td>刷新算法</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>19:30~22:00</td>
<td>六级专项</td>
<td>–</td>
<td>周赛总结</td>
<td>六级专项主要是翻译和作文</td>
</tr>
<tr>
<td>22:00~24:00</td>
<td>计组</td>
<td>计组</td>
<td>计组</td>
<td>一天至少走三节课</td>
</tr>
<tr>
<td>0:30~1:00</td>
<td>每日一题</td>
<td>每日一题</td>
<td>每日一题</td>
<td>完成就睡</td>
</tr>
</tbody></table>
<p>21:00~22:30，汇编语言。</p>
<ul>
<li>寻址方式</li>
</ul>
<p>23:00~24:00，一道Leetcode。</p>
<ul>
<li>最长上升子序列</li>
</ul>
<h2 id="8-19"><a href="#8-19" class="headerlink" title="8.19"></a>8.19</h2><p>0:45~1:20，一道Leetcode。</p>
<ul>
<li>最长递增子序列的个数</li>
</ul>
<p>11:00~24:00，全天Leetcode。</p>
<ul>
<li><p>二叉树最大宽度（bfs/递归）</p>
</li>
<li><p>验证回文字符串</p>
</li>
<li><p>二叉搜索树中的搜索</p>
</li>
<li><p>字符串解码（栈/递归）</p>
</li>
<li><p>删除字符串中所有相邻重复项（栈）</p>
</li>
</ul>
<p>我的电脑开始报警了，害怕😰</p>
<h2 id="8-20"><a href="#8-20" class="headerlink" title="8.20"></a>8.20</h2><p>0:00~2:00，两道Leetcode。</p>
<ul>
<li>链表中的下一个更大元素（单调栈）</li>
<li>扫雷游戏（dfs）</li>
</ul>
<p>11:00~17:00，一道Leetcode。</p>
<ul>
<li>冗余连接（dfs/拓扑排序/并查集）</li>
</ul>
<p>20:00~24:00，由于一个再次蓝屏影响了任务进度，考虑要不要换成Linux系统了。</p>
<ul>
<li>寻址方式</li>
</ul>
<h2 id="8-21-8-23"><a href="#8-21-8-23" class="headerlink" title="8.21-8.23"></a>8.21-8.23</h2><p>由于这两天考虑给小宝宝做视频，所以学习有点搁置了，不过还是抽空做了两次周练的题</p>
<ul>
<li>设计哈希集合（开放链表寻址法）</li>
<li>设计链表</li>
</ul>
<p>双周赛</p>
<ul>
<li>千位分隔数（模拟）</li>
<li>可以到达所有点的最少点数目（找入度为0）</li>
<li>得到目标数组的最少函数调用次数（模拟）</li>
<li>二维网格图中探测环（dfs）</li>
</ul>
<p>周赛</p>
<ul>
<li>圆形赛道上经过次数最多的扇区（模拟）</li>
<li>你可以获得的最大硬币数目（脑筋急转弯）</li>
<li>查找大小为M的最新分组（并查集/链表/倒序map）</li>
<li>石子游戏V（dp）</li>
</ul>
<h2 id="8-24-8-27"><a href="#8-24-8-27" class="headerlink" title="8.24-8.27"></a>8.24-8.27</h2><p>Leetcode刷题13道。</p>
<ul>
<li>重复的子字符串</li>
<li>将数据流变成多个不相交区间（平衡树，类似周赛203的第三题）</li>
<li>递增子序列（dfs）</li>
<li>最长重复子数组（dp）</li>
<li>电话号码的字母组合（dfs回溯，类似递增子序列的简化版？）</li>
<li>情侣牵手（分类讨论模拟）</li>
<li>二叉搜索树节点最小距离（中序遍历）</li>
<li>重新安排行程（dfs，但是不太好想）</li>
<li>在LR字符串中交换相邻字符（脑筋急转弯模拟）</li>
<li>叶子相似的树（中序遍历）</li>
<li>有序数组的平方（双指针）</li>
<li>最接近的三数之和（双指针（定一议二模型）/暴力）</li>
<li>账户合并（并查集）</li>
</ul>
<p>汇编语言，指令系统。</p>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>2020暑假第一阶段学习</title>
    <url>/2020/07/04/2020%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>这是个大二升大三的关键暑假，下学期各类与计算机专业无关的课真的烦，必须要再这个暑假抽出时间来学习计算机。我暑期的学习目标就是<strong>完成并巩固基础课的学习</strong>并以兴趣带动学习<strong>完成一个小项目(暂定前端开发)</strong>。这个文档来规划和督促我的这个第一阶段的学习。</p>
<a id="more"></a>
<h3 id="事项交代"><a href="#事项交代" class="headerlink" title="事项交代"></a>事项交代</h3><h4 id="暑期学习表（不断更新）"><a href="#暑期学习表（不断更新）" class="headerlink" title="暑期学习表（不断更新）"></a>暑期学习表（不断更新）</h4><p>暑期待学课程以及学习时间表：</p>
<table>
<thead>
<tr>
<th align="center">课程</th>
<th align="center">学习方式</th>
<th align="center">视频时长</th>
<th align="center">学习时长</th>
<th align="center">时长明细</th>
<th align="center">阶段安排</th>
</tr>
</thead>
<tbody><tr>
<td align="center">六级刷题</td>
<td align="center">刷题</td>
<td align="center">0</td>
<td align="center">16h</td>
<td align="center">2h*8套</td>
<td align="center">各阶段</td>
</tr>
<tr>
<td align="center">爬虫</td>
<td align="center">课程+实战</td>
<td align="center">3h</td>
<td align="center">3h</td>
<td align="center">3h+3h</td>
<td align="center">1阶段</td>
</tr>
<tr>
<td align="center">Vue</td>
<td align="center">课程</td>
<td align="center">5h</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1阶段</td>
</tr>
<tr>
<td align="center">数据结构</td>
<td align="center">课件+实验回顾+blog</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">各阶段</td>
</tr>
<tr>
<td align="center">数据分析</td>
<td align="center">课程+实战</td>
<td align="center">28h</td>
<td align="center"></td>
<td align="center">28+</td>
<td align="center">1、2阶段</td>
</tr>
<tr>
<td align="center">操作系统</td>
<td align="center">课程+实验</td>
<td align="center">22h</td>
<td align="center"></td>
<td align="center">22+</td>
<td align="center">1、2阶段</td>
</tr>
<tr>
<td align="center">数据结构+算法</td>
<td align="center">课件+实验回顾</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">各阶段</td>
</tr>
<tr>
<td align="center">计算机网络</td>
<td align="center">课程</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2、3阶段</td>
</tr>
<tr>
<td align="center">计组</td>
<td align="center">课程+实验</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2、3阶段</td>
</tr>
<tr>
<td align="center">人工智能</td>
<td align="center">课件+实验回顾</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2、3阶段</td>
</tr>
</tbody></table>
<h4 id="该阶段主要目标"><a href="#该阶段主要目标" class="headerlink" title="该阶段主要目标"></a>该阶段主要目标</h4><p>第一阶段暂定日期 <strong>7.4~7.26</strong>共三周时间完成！<br>第一阶段的主要目标是至少完成：</p>
<ul>
<li>爬虫</li>
<li>Vue</li>
<li>操作系统的理论部分</li>
<li>数据分析的Excel和MySQL部分</li>
<li>Leetcode(每日一题)</li>
</ul>
<p>其余的像六级刷题、数据结构、Leetcode这几个贯穿整个暑假始终的学习项目也不能落下！</p>
<p>第一阶段要完成的大作业有：</p>
<ul>
<li>基于Vue的仿制音乐播放</li>
<li>blog部分 数据结构树图部分以前的大作业汇总</li>
<li>3套六级试题</li>
</ul>
<p>blog每天更新，记录自己一天干了什么，以及个人总结！<br>冲冲冲！！</p>
<h3 id="日志部分"><a href="#日志部分" class="headerlink" title="日志部分"></a>日志部分</h3><p>以下为这阶段的学习日记</p>
<hr>
<h4 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h4><h5 id="小笔记"><a href="#小笔记" class="headerlink" title="小笔记"></a>小笔记</h5><h6 id="HTML-DOM节点"><a href="#HTML-DOM节点" class="headerlink" title="HTML DOM节点"></a>HTML DOM节点</h6><p>在HTML DOM中，每个东西都是<strong>节点</strong>：</p>
<ul>
<li>文档本身是一个文档对象</li>
<li>所有HTML元素都是元素节点</li>
<li>所有HTML属性都是属性节点</li>
<li>插入到HTML元素文本时文本节点</li>
<li>注释是注释节点</li>
</ul>
<h5 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h5><p>今天购买了<strong>机器学习实战</strong>这本书，当作这个暑假的入门教材来读！可以在2、3阶段重点学习一下经典的代码实现。</p>
<h5 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h5><p>8:00~9:00，刷了两道Leetcode。分别是<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">求x的平方根</a>和<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a>，都比较简单。前者运用基本不等式，后者是逻辑简单的遍历链表。</p>
<p>9:00~10:30，学习了操作系统的有关内存这部分的内容。主要搞清楚了逻辑地址和物理地址的生成方法，以及os在这之中到底起到了什么样的作用。除此以外，内存分层结构也体现了计算机存储数据的一个层次关系（从CPU到物理内存到磁盘，容量正三角，速度倒三角）。最后就是有关连续内存分配的内存碎片的处理的简单知识。</p>
<p>附上7.3的重点：</p>
<ul>
<li>BIOS,bootloader,os在启动过程中的行为和作用</li>
<li>系统调用、异常和中断三个定义和大体过程</li>
<li>应用程序,os,外设之间的简单逻辑关系</li>
</ul>
<p>附上7.4重点：</p>
<ul>
<li>内存层次结构</li>
<li>逻辑地址生成</li>
<li>物理地址生成</li>
<li>内存调度三个方法</li>
<li>交换式碎片整理</li>
</ul>
<p>11:00~12:00，复习整理了数据结构单链表一块的知识，巩固了malloc和free的用法。</p>
<p>13:00~15:00，观看了<a href="https://www.bilibili.com/video/BV1xb411e7ww" target="_blank" rel="noopener">动态规划入门视频</a>，完成了一个分配钱实例，从中了解到了动态规划的精妙之处，单论这一个实例简直是完爆了递归和贪心算法。同时得知了<strong>动态规划的重要性，极其极其大！</strong>所以后期这部分的学习可以更精致一些，今天看完了前40分钟，明天继续。</p>
<p>16:00~17:00，完成了python的requests库到bs4库的全部学习，完成了大学排名爬取的小实验，直接深刻的掌握了标签树的相关关系。但是中文对齐这方面，发现pycharm的输出和idle的输出有一些偏差，表头由于全中文整体偏右。</p>
<p>20:00~21:00，观看完了<a href="https://www.bilibili.com/video/BV12J411m7MG" target="_blank" rel="noopener">vue入门视频</a>的前五节，从官方文档体会到了vue的类似字符串模板的一种理念。<code>Vue</code>是一个构造函数，该函数的参数（从语法上，我是直观上这样理解的不知道对不对）是一个包含<code>el</code>和<code>data</code>属性的对象。</p>
<ul>
<li><code>el</code>:设置挂载点，通过css选择器设置vue实例管理元素，el命中元素的内部的大括号内数据被同名的data替换</li>
<li><code>data</code>:数据对象，object、string、array……</li>
</ul>
<p>22:00~23:00，完成了Leetcode上的<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第n个节点</a>，算是一个对今天链表复习的巩固。而且又一次遇到了双指针，下次我一定能想出来双指针。</p>
<h6 id="今日感悟"><a href="#今日感悟" class="headerlink" title="今日感悟"></a>今日感悟</h6><p>以后Leetcode上刷题，要刷今天学的知识，就当是巩固啦~</p>
<hr>
<h4 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h4><p>今天比昨天懒了许多，这才第二天啊，反省！</p>
<h5 id="小笔记-1"><a href="#小笔记-1" class="headerlink" title="小笔记"></a>小笔记</h5><p>地址空间是操作系统如何跟踪分配给每个程序的内存的方式。</p>
<p>内存空间是堆中的实际物理内存。</p>
<p>地址空间映射到内存空间，当程序终止时，内存空间被释放回堆。</p>
<p>地址空间是虚拟的，也称为虚拟内存。</p>
<p>虚拟内存给人的印象是计算机内存很大，但是它一直在重复使用内存空间。</p>
<h5 id="时间线-1"><a href="#时间线-1" class="headerlink" title="时间线"></a>时间线</h5><p>9:30~11:30，学习了操作系统非连续内存分配这部分内容。将之前学过的分段和分页机制尤其是<strong>分页机制的如何将逻辑地址空间映射到物理地址空间</strong>这方面搞得很明白了。关键的几个流程图都记在了Goodnotes上，课下要经常翻阅这部分的内容。</p>
<ul>
<li>分段机制</li>
<li>分页机制</li>
<li>页寻址机制</li>
<li><a href="https://blog.csdn.net/qq_37924084/article/details/78360003" target="_blank" rel="noopener">分段与分页</a></li>
</ul>
<p>13:00~15:00, 继续动态规划，掌握了动态规划3问题中的两个：最值问题、计数问题，并完成了两个实例。</p>
<p>16:00~17:00，爬虫的正则表达式库的学习，掌握了正则表达式的语法。还未进入re库的学习。</p>
<p>19:30~20:30，继续学习了一小部分Vue的内容。还未感受到Vue的简单之处，可能是之前并未做过类似的前端大作业，对原来直接操作DOM和现在这种挂载的方式并未感受到其强大。</p>
<p>21:00~22:00，Leetcode做了一道动态规划的题，正好遇到了一个明天要学的题，按照思路做出来了，明天看完那位大神的教程之后再写这个Leetcode的总结。</p>
<hr>
<h4 id="7-6-7-7"><a href="#7-6-7-7" class="headerlink" title="7.6-7.7"></a>7.6-7.7</h4><h5 id="小笔记-2"><a href="#小笔记-2" class="headerlink" title="小笔记"></a>小笔记</h5><p>有关TLB的相关知识：</p>
<p>页表一般都很大，并且存放在内存中，所以处理器引入MMU后，读取指令、数据<strong>需要访问两次内存：首先通过查询页表得到物理地址，然后访问该物理地址读取指令、数据</strong>。为了减少因为MMU导致的处理器性能下降，引入了TLB，TLB是Translation Lookaside Buffer的简称，可翻译为“地址转换后援缓冲器”，也可简称为“快表”。简单地说，<strong>TLB就是页表的Cache</strong>，其中<strong>存储了当前最可能被访问到的页表项</strong>，其内容是<strong>部分页表项的一个<em>副本</em></strong>。只有在TLB无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。</p>
<p>TLB中的项由两部分组成：<strong>标识和数据</strong>。标识中存放的是虚地址的一部分，而数据部分中存放物理页号、存储保护信息以及其他一些辅助信息。</p>
<p>因为页大小是8KB，所以虚拟地址的0-12bit作为页内地址偏移。TLB表有64项，所以虚拟地址的13-18bit作为TLB表项的索引。假如虚拟地址的13-18bit是1，那么就会查询TLB的第1项，从中取出标识，与虚拟地址的19-31位作比较，如果相等，表示TLB命中，反之，表示TLB失靶。TLB失靶时，可以由硬件将需要的页表项加载入TLB，也可由软件加载，具体取决于处理器设计，OR1200没有提供硬件加载页表项的功能，只能由软件实现。TLB命中时，此时翻译得到的物理地址就是TLB第1项中的标识（即物理地址13-31位）与虚拟地址0-12bit的结合。在地址翻译的过程中还会结合TLB项中的辅助信息判断是否发生违反安全策略的情况，比如：要修改某一页，但该页是禁止修改的，此时就违反了安全策略，会触发异常。</p>
<h5 id="时间线-2"><a href="#时间线-2" class="headerlink" title="时间线"></a>时间线</h5><p>10:00~12:00，完成操作系统的非连续内存分配内容，虚拟内存单元开了个小头。重点学习了页表的机制。</p>
<ul>
<li>页表内容(resident bit)</li>
<li>TLB引入</li>
<li>内存覆盖技术</li>
</ul>
<p>14:00~15:30，完成了re库爬虫的理论部分，正则表达式使用起来非常方便，具体语法还需加深记忆。</p>
<p>17:00~18:00，完成了动态规划的网课学习。理论上已经知道如何解决动态规划的三类题，具体解决还需勤加练习。另外的，某些题目(跳跃游戏)更适配贪心法，并不是所有题目都适配动态规划。贪心法和动态规划法的理论部分了解不够深入，还需回溯定义。</p>
<p>19:00~21:00，磕了一道Leetcode，具体见Leetcode日记。</p>
<hr>
<h4 id="7-8"><a href="#7-8" class="headerlink" title="7.8"></a>7.8</h4><h5 id="时间线-3"><a href="#时间线-3" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~11:30，Leetcode。</p>
<p>12:30~14:00，操作系统的交换技术和虚存技术。这部分内容和前边的分配内存关系非常大，主要目的都是实现<strong>小内存运行大程序</strong>的目标，让程序用着几M的内存以为自己畅游在几G的内存空间里，这就是所谓的虚拟内存。</p>
<ul>
<li>内存交换技术</li>
<li>虚存技术的原理</li>
</ul>
<p>16:00~17:30，Python实现淘宝比价定向爬取实例，运行之后居然都没爬出来？查看了网页源代码，应该是网页格式已经更新换代了，raw_title和raw_value的键值对已经不存在了。。明天再搞吧。</p>
<p>19:00~21:00，Leetcode跳水板问题，循环居然写反了，反思反思！</p>
<p>22:30~1:00，我又愉快的做了道力扣，法克，快被气死了，为啥中级题老是写不对啊，我真垃圾。</p>
<h5 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h5><p>Leetcode的题真的很值得玩味，有的看似简单……双指针问题还需要继续练啊，我考虑边界问题的能力简直弱爆了。。</p>
<hr>
<h4 id="7-9"><a href="#7-9" class="headerlink" title="7.9"></a>7.9</h4><h5 id="时间线-4"><a href="#时间线-4" class="headerlink" title="时间线"></a>时间线</h5><p>9:30~11:00，总结Leetcode题目。</p>
<p>11:40~13:00，操作系统之虚存技术的实现。虚存技术的实现流程就是在页式的基础上增加请求调页和页面换入换出操作。精髓是，在运行的过程中不断地调入需要的页和数据，这一技术的实现，首先要求局部性原理要好(参照双循环按列遍历和按行遍历的区别)，这样在性能计算上参数<code>p</code>（缺页概率）才会尽可能小，效率才理想。</p>
<ul>
<li>缺页中断的处理</li>
<li>虚拟内存的性能</li>
</ul>
<p>15:00~17:00，听项目组会。以后每周要向老师汇报啊，哭-_-</p>
<p>18:00~20:00，一直检查那道Leetcode题目–恢复空格。<br>注意：在C语言中，要想运用<code>strcmp</code>判断字符数组和一个字符串是否相等，一定要在字符数组的结尾添加一个<code>&#39;\0&#39;</code>元素才可以！<br>另外：Hash表好🐂🍺，这周完了我再不会hash我就是🐕！</p>
<p>plus：总结的有关c语言的各种初始化：</p>
<ol>
<li><p>字符数组</p>
<ul>
<li>动态构建时，结尾必须有<code>&#39;\0&#39;</code>(还可以直接<code>scanf</code>输入)</li>
<li>静态构建时，这两个方法是等价的哦<ol>
<li><code>char sentence[] = &quot;justdoit&quot;;</code></li>
<li><code>char sentence[] = {&#39;j&#39;,&#39;u&#39;,&#39;s&#39;...&#39;t&#39;,&#39;\0&#39;}</code></li>
<li><code>char sentence[7] = {&#39;j&#39;,&#39;u&#39;,&#39;s&#39;...&#39;t&#39;,&#39;\0&#39;}</code></li>
</ol>
</li>
</ul>
</li>
<li><p>字符串数组</p>
<ul>
<li>静态构建:<code>const char* dictionary[5] = { &quot;just&quot;, &quot;do&quot;, &quot;it&quot; };</code></li>
<li><a href="https://blog.csdn.net/qq_39516859/article/details/83384880" target="_blank" rel="noopener">动态构建</a>：一般应该是用那个for循环来。</li>
</ul>
</li>
</ol>
<p>20:00~21:30，爬虫的实例完成，原来没有完成的原因是该宝变严了，具体解决方法参见python爬虫笔记-3。</p>
<p>21:30~22:30，hash表的部分学习，唤醒了之前的不少记忆，应该能很快掌握。</p>
<hr>
<h4 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h4><h5 id="时间线-5"><a href="#时间线-5" class="headerlink" title="时间线"></a>时间线</h5><p>9:00~11:00，操作系统的四个页面置换算法，这段比较好理解。</p>
<ul>
<li>OPT算法</li>
<li>FIFO算法</li>
<li>LRU算法</li>
<li>Clock置换算法</li>
</ul>
<p>12:00~13:30，Leetcode的一道dp题，这次的dp是多状态的，总结在Leetcode笔记里了。</p>
<p>16:00~17:00，Hash表的学习。<br>plus：买了一本考研机试的书，希望能提高应试能力吧。</p>
<p>19:00~20:00，一道简单的Leetcode题目，合并两个有序数组。</p>
<h5 id="今日感悟-1"><a href="#今日感悟-1" class="headerlink" title="今日感悟"></a>今日感悟</h5><p>最近真的懒了好多，最近几天说好的MySQL和Vue都没有看，接下来的阶段打算变动一部分学习计划</p>
<ol>
<li>新加入：<ul>
<li>Javascript 30天小项目</li>
<li>看人工智能的书</li>
<li>数据结构加快学习</li>
</ul>
</li>
<li>删除：<ul>
<li>Vue</li>
</ul>
</li>
</ol>
<hr>
<h4 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h4><h5 id="时间线-6"><a href="#时间线-6" class="headerlink" title="时间线"></a>时间线</h5><p>10:00~12:00，操作系统。</p>
<ul>
<li>二次机会算法（加入dirty bit判断）</li>
<li>LFU算法</li>
<li>Belady现象</li>
<li>Clock、FIFO、LRU算法对比</li>
</ul>
<p>13:00~14:00，Leetcode每日一题，今天的太难，能力它不够呀。。</p>
<p>15:00~19:00，<strong>天那我承认我没咋学，我再也不这样了</strong>。</p>
<p>19:00~21:00，JS项目1_DrumKit。</p>
<p>21:30~22:30，一道Leetcode，浪漫的相交链表。</p>
<p>23:00~24:00，一道Leetcode，环形链表。</p>
<h5 id="今日遗留"><a href="#今日遗留" class="headerlink" title="今日遗留"></a>今日遗留</h5><p>hash表的C语言实现</p>
<hr>
<h4 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h4><h5 id="时间线-7"><a href="#时间线-7" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~12:30，操作系统。终于完成了虚拟内存部分的内容。这部分重点就是学习逻辑地址转换成物理地址过程中，产生的缺页中断如何用页面置换算法加以解决。</p>
<ul>
<li>工作集页置换算法</li>
<li>缺页率置换算法</li>
<li>页面抖动问题</li>
</ul>
<p>13:00~15:00，两道Leetcode。一道SQL查询，一道每日一题，今天的这道地下城与勇士太快乐了，最后几乎是自己做出来了一道困难难度的题目。</p>
<p>15:30~16:00，看机试的书。听王道叔叔说要用C With STL的风格编程了。</p>
<p>16:30~17:30，python爬虫re库实例2，股票信息爬取。</p>
<p>19:00~20:30，JS项目2_Clock。</p>
<p>21:00~22:30，一道Leetcode，重排链表。</p>
<hr>
<h4 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h4><h5 id="时间线-8"><a href="#时间线-8" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~12:30，操作系统的进程部分所有内容。</p>
<ul>
<li>进程概念</li>
<li>进程组成</li>
<li>进程状态</li>
</ul>
<p>13:00~16:30，Leetcode每日一题，求数组的交集。<br>做题过程：<br>首先觉得好简单-&gt;开始做-&gt;不简单做不做出来-&gt;发现题目理解错了-&gt;接着做-&gt;还是做不出来-&gt;浑身难受-&gt;浑身难受中-&gt;有了思路哈希表-&gt;开始实现-&gt;踩坑1-&gt;踩坑2-&gt;踩坑3……-&gt;踩坑6-&gt;做出来了。<br>太难了8(不过确实找到了很多不足，这个坑踩得还是比较有意义的)</p>
<p>18:00~20:00，看书，王道机试和机器学习，记笔记。</p>
<p>22:00~23:20，JS项目3_Update CSS Variable With JS。</p>
<p>23:40~24:00，看数据结构。</p>
<hr>
<h4 id="7-14"><a href="#7-14" class="headerlink" title="7.14"></a>7.14</h4><h5 id="时间线-9"><a href="#时间线-9" class="headerlink" title="时间线"></a>时间线</h5><p>8:30~8:50，Leetcode每日一题，一道非常经典的路径最短dp。</p>
<p>9:00~9:30，总结二维数组申请空间问题。</p>
<p>10:00~12:00，操作系统，线程的知识和上下文切换。线程与进程的状态和生命周期等方面有很多相似之处，而线程实际上是比进程更小的可以独立运行单位，这使得进程的功能组成可以被进一步细化成管理资源+多线程的模型，线程在其中主要负责代码部分的执行。</p>
<ul>
<li>线程概念</li>
<li>线程的实现<ul>
<li>用户线程</li>
<li>内核线程</li>
<li>轻量级进程</li>
</ul>
</li>
<li>上下文切换</li>
</ul>
<p>13:00~16:30，写论文。</p>
<p>17:00~19:00，栈部分的相关总结。</p>
<p>20:00~21:30，爷哭了，简单力扣，堆栈基础，做崩了。（没有<code>dummyhead</code>，这个入栈我真的穷尽脑汁没想到咋弄）</p>
<p>22:40~24:00，JS项目_4 数组练习1，干货满满。</p>
<h5 id="今日遗留-1"><a href="#今日遗留-1" class="headerlink" title="今日遗留"></a>今日遗留</h5><ul>
<li><code>array.reduce()</code>方法是类似于C的递归吗。</li>
<li><code>memset()</code>方法总结</li>
</ul>
<hr>
<h4 id="7-15"><a href="#7-15" class="headerlink" title="7.15"></a>7.15</h4><h5 id="时间线-10"><a href="#时间线-10" class="headerlink" title="时间线"></a>时间线</h5><p>0:05~0:30，Leetcode每日一题，不同的二叉搜索树。</p>
<p>10:00~12:00，操作系统，进程控制内容。</p>
<ul>
<li><code>fork()</code>–进程的创建</li>
<li><code>exec()</code>–函数簇，加载程序替换当前进程</li>
<li><code>wait()</code>–等待子进程返回</li>
<li><code>exit()</code>–终止进程，资源回收</li>
</ul>
<p>12:50~13:30，一道Leetcode，两数之和II-输入有序数组。</p>
<p>14:00~15:00，一道Leetcode，快乐数，虚拟链表，非常有意思。</p>
<p>16:00~17:00，下载本周大创项目相应的学习资料。</p>
<p>18:30~20:00，学STL。</p>
<p>20:00~21:00，JS项目5_flex pannels，这讲被css的flex听懵了。</p>
<p>22:20~24:00，继续看数据结构堆栈。</p>
<hr>
<h4 id="7-16"><a href="#7-16" class="headerlink" title="7.16"></a>7.16</h4><h5 id="时间线-11"><a href="#时间线-11" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~1:00，看固体物理的书。</p>
<p>1:00~2:00，两道Leetcode。存在重复元素I、II，其中II还没解出来，学完STL部分的知识再去回顾。</p>
<p>11:00~13:00，操作系统，进程调度部分的内容。</p>
<ul>
<li>调度原则，调度指标</li>
<li>先来先服务算法</li>
<li>短作业优先算法</li>
<li>最高响应比算法</li>
</ul>
<p>14:10~16:00，六级卷子。TOO HARD, FUCK IT。</p>
<p>17:30~19:00，学习STL中的<code>map</code>和<code>unordered_map</code>用法，完成了凌晨一点那题的解法。</p>
<p>19:30~21:00，利用刚学的<code>unordered_map</code>解Leetcode的存在重复元素III，实现了，但超时了。明天学了<code>set</code>之后，把这道题再磕了。</p>
<p>22:30~24:00，继续看固体物理的书。</p>
<hr>
<h4 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h4><h5 id="时间线-12"><a href="#时间线-12" class="headerlink" title="时间线"></a>时间线</h5><p>10:00~13:00，操作系统的进程调度学完。</p>
<ul>
<li>轮循算法</li>
<li>多级反馈队列<ul>
<li><a href="https://www.jianshu.com/p/1f5195dcc75b" target="_blank" rel="noopener">CPU密集型和I/O密集型的分别</a></li>
</ul>
</li>
<li>公平共享制度</li>
<li>实时调度（似懂非懂）</li>
<li>多处理器调度</li>
<li>优先级反转现象及解决方案</li>
</ul>
<p>14:30~16:00，看机试书。</p>
<p>19:00~22:00，刷Leetcode，学习<code>set</code>的用法。</p>
<hr>
<h4 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h4><h5 id="时间线-13"><a href="#时间线-13" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~13:40，昨天遗留的Leetcode每日一题，交错字符串。并总结滚动数组的相关用法。</p>
<p>14:30~18:30，四道Leetcode。</p>
<ul>
<li>移除链表元素</li>
<li>交错字符串</li>
<li>计数质数</li>
<li>我能赢吗（不会做）</li>
</ul>
<p>19:30~22:00，两道Leetcode（被简单题虐死了？？）</p>
<ul>
<li>反转链表</li>
<li>同构字符串</li>
</ul>
<p>23:00~24:00，两道Leetcode（是的，今天是Leetcode Saturday）</p>
<ul>
<li>好数对的数目</li>
<li>仅含1的字符串</li>
</ul>
<hr>
<h4 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h4><h5 id="时间线-14"><a href="#时间线-14" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~11:30，操作系统的同步内容介绍。</p>
<p>12:00~13:30，Leetcode每日一题总结。</p>
<p>16:00~19:00，树的相关知识，以及Leetcode上的简单树的题。<br><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">一个GitHub上非常牛的刷题导引</a><br><a href="https://lyl0724.github.io/2020/01/25/1/" target="_blank" rel="noopener">由此引出来的递归调用理解以及相关递归树题目导航的大佬blog传送门</a></p>
<p>19:00~20:35，几个树的题目。</p>
<ul>
<li>二叉树的最大深度</li>
<li>平衡二叉树判定<ul>
<li>自顶向下递归法</li>
<li>自底向上递归法</li>
</ul>
</li>
<li>翻转二叉树</li>
<li>两两交换链表中的结点（后面还要写出来迭代法等解法）</li>
</ul>
<p>21:00~23:00，递归专题练习。</p>
<ul>
<li>删除排序链表中的重复元素</li>
<li>对称二叉树</li>
<li>二叉树的最小深度</li>
</ul>
<p>23:15~23:40，看固体物理的视频。</p>
<h5 id="今日遗留-2"><a href="#今日遗留-2" class="headerlink" title="今日遗留"></a>今日遗留</h5><ul>
<li>合并二叉树</li>
<li>最大二叉树</li>
</ul>
<hr>
<h4 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h4><h5 id="时间线-15"><a href="#时间线-15" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~2:00，python爬虫scrapy模块，Linux入坑视频。</p>
<p>10:00~10:30，Leetcode每日一题。</p>
<p>10:30~11:40，操作系统看完同步内容。</p>
<ul>
<li>临界区的实现方法<ul>
<li>基于flag[i]和turn来设计</li>
<li>基于TestAndSet操作实现</li>
<li>基于Exchange操作实现</li>
</ul>
</li>
</ul>
<p>13:00~15:30，遗留的Leetcode。</p>
<ul>
<li>合并二叉树</li>
<li>最大二叉树</li>
</ul>
<p>16:30~18:00，固体物理原子链部分。</p>
<p>19:00~20:00，爬虫scrapy。</p>
<p>20:30~22:00，总结图结构，Leetcode课程表（未解决）。</p>
<h5 id="今日遗留-3"><a href="#今日遗留-3" class="headerlink" title="今日遗留"></a>今日遗留</h5><ul>
<li><code>nullptr</code>和<code>NULL</code>的区别</li>
<li>Linux安装</li>
<li>blog建立评论区</li>
<li>记得抽时间把那个blog的出处都弄一下</li>
</ul>
<hr>
<h4 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h4><h5 id="小笔记-3"><a href="#小笔记-3" class="headerlink" title="小笔记"></a>小笔记</h5><p><a href="https://blog.csdn.net/zzq060143/article/details/96278516" target="_blank" rel="noopener">参考文章</a></p>
<ul>
<li><code>nullptr</code>在C++里代指空指针</li>
<li><code>NULL</code><ul>
<li>C中是<code>(void*)0</code></li>
<li>C++中是<code>0</code></li>
</ul>
</li>
</ul>
<h5 id="时间线-16"><a href="#时间线-16" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~1:00，Leetcode每日一题，不同的二叉搜索树II。又是一道递归，没做出来。。不过看答案之后秒懂，还是好菜</p>
<p>10:30~12:30，操作系统的信号量内容。</p>
<ul>
<li>信号量的定义<ul>
<li>二进制信号量</li>
<li>计数信号量</li>
</ul>
</li>
<li>生产者消费者模型</li>
<li>P-V操作的实现</li>
</ul>
<p>14:00~15:00，安装Centos Linux。</p>
<p>16:00~20:30，拓扑排序，和相关习题，DFS和BFS的原理。</p>
<p>22:00~24:00，坎坷得配置Linux网络和与主机的通信。</p>
<h5 id="今日遗留-4"><a href="#今日遗留-4" class="headerlink" title="今日遗留"></a>今日遗留</h5><ul>
<li>爬虫-&gt;nba数据</li>
<li>二分图</li>
<li>今天的图论的Leetcode笔记</li>
</ul>
<hr>
<h4 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h4><h5 id="时间线-17"><a href="#时间线-17" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~1:00，继续配置，，终于成功</p>
<p>1:00~1:30，Leetcode每日一题。</p>
<p>8:00~9:00，找机场。</p>
<p>11:00~13:00，操作系统管程。</p>
<p>15:00~16:30，研究清华的操作系统实验资源。</p>
<p>17:00~18:00，Linux命令行。</p>
<p>19:00~2:30，写Leetcode周练。</p>
<ul>
<li>换酒问题(40min)</li>
<li>子树中标签相同的结点数(4h+)</li>
</ul>
<p>服了。。</p>
<hr>
<h4 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a>7.23</h4><h5 id="小笔记-4"><a href="#小笔记-4" class="headerlink" title="小笔记"></a>小笔记</h5><p>BFS VS DFS</p>
<ul>
<li>空间复杂度<ul>
<li>BFS：$O(n)$</li>
<li>DFS：$O(logn)$</li>
</ul>
</li>
<li>BFS适合找最小值问题，例如迷宫最短路径</li>
<li>由于DFS需要函数调用消耗栈空间，而栈空间当层数过大时容易爆栈，所以当层数过大时尽量用BFS</li>
</ul>
<p>总结：<br>BFS</p>
<ol>
<li>空间是指数级别的</li>
<li>不会有爆栈风险（给队列开全局变量，不会存在爆堆）</li>
</ol>
<p>DFS</p>
<ol>
<li>空间与深度成正比</li>
<li>有爆栈风险</li>
</ol>
<h5 id="时间线-18"><a href="#时间线-18" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~14:00，两道leetcode，最近脑子不够使啊，做啥都好难(；′⌒`)。</p>
<ul>
<li>最多的不重叠字符串</li>
<li>最小路径和</li>
</ul>
<p>15:00~19:00，混乱浏览。</p>
<ul>
<li>配置操作系统课实验环境</li>
<li>看计组课的前七节</li>
<li>汇编解释编程本质课</li>
</ul>
<p>19:30~20:15，Leetcode，二分图。</p>
<p>21:00~22:00，操作系统。</p>
<p>22:30~23:30，看DFS和BFS视频，敲完二分图。</p>
<h5 id="今日遗留-5"><a href="#今日遗留-5" class="headerlink" title="今日遗留"></a>今日遗留</h5><ul>
<li>二分查找解决前一个未打卡的题</li>
<li>操作系统看完这几节</li>
<li>看完BFS和DFS</li>
<li>flood fill</li>
</ul>
<hr>
<h4 id="7-24"><a href="#7-24" class="headerlink" title="7.24"></a>7.24</h4><h5 id="时间线-19"><a href="#时间线-19" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~1:20，Leetcode。</p>
<ul>
<li>完全平方数</li>
<li>除数博弈</li>
<li>二分图BFS</li>
</ul>
<p>11:00~14:00，BFS和DFS的几道题。</p>
<ul>
<li>flood fill</li>
<li>num of islands</li>
<li>surrounded regions</li>
</ul>
<p>17:00~20:00，做Leetcode右侧小于当前元素个数。</p>
<ul>
<li>小笔记：<code>lower_bound(first, last, value)</code>返回指向范围<code>[first, last)</code>中首个不小于（即大于或等于） <code>value</code> 的元素的迭代器，或若找不到这种元素则返回 <code>last</code> 。</li>
</ul>
<p>20:30~22:30，操作系统的读者写者问题。</p>
<hr>
<h4 id="7-25"><a href="#7-25" class="headerlink" title="7.25"></a>7.25</h4><h5 id="时间线-20"><a href="#时间线-20" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~1:30，Leetcode每日一题。</p>
<ul>
<li>分割数组的最大值</li>
</ul>
<p>10:30~12:30，操作系统哲学家就餐问题。</p>
<p>14:00~19:40，一道Leetcode，还是中等题呜呜呜5555呜呜呜</p>
<ul>
<li>检查网格中是否存在有效路径</li>
</ul>
<p>20:00~23:30，一道Leetcode，好像还是不难，哎哟。</p>
<ul>
<li>从先序遍历还原二叉树</li>
</ul>
<hr>
<h4 id="7-26"><a href="#7-26" class="headerlink" title="7.26"></a>7.26</h4><h5 id="时间线-21"><a href="#时间线-21" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~2:30，Leetcode一道题。</p>
<ul>
<li>封闭的岛屿数量</li>
<li>矩阵中最长递归路径(明天需要继续总结)</li>
</ul>
<p>9:30~10:30，每日一题的拓扑排序做法。</p>
<p>10:30~12:00，比赛。。就做出一道题，第二题太笨，第三题欠考虑了。</p>
<p>14:00~15:30，总结两道竞赛题。</p>
<ul>
<li>灯泡开关IV</li>
<li>好叶子节点对数量</li>
</ul>
<p>18:00~19:00，一道Leetcode的BFS题目。</p>
<p>19:30~20:50，死锁问题的开头。</p>
<ul>
<li>死锁问题</li>
<li>死锁模型</li>
<li>死锁特点</li>
<li>死锁四条件</li>
<li>死锁预防和死锁避免</li>
</ul>
<p>22:00~23:00，计组的硬件功能和简单指令实现。</p>
<ul>
<li>存储器</li>
<li>运算器</li>
<li>控制器</li>
<li>取数指令过程</li>
<li>存数指令过程</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>11-12月学习</title>
    <url>/2020/11/13/11-12%E6%9C%88%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>这两个月是学物理的时候了，哎真的烦</p>
<a id="more"></a>

<h1 id="本学期剩余ddl"><a href="#本学期剩余ddl" class="headerlink" title="本学期剩余ddl"></a>本学期剩余ddl</h1><ul>
<li><del>11.15 光电子考试</del> </li>
<li><del>11.20 通选大作业</del> </li>
<li><del>11.25 科研训练作业和论文</del> </li>
<li><del>12.12 六级刷分</del> </li>
<li><del>12.19 原子物理期末考试</del> </li>
<li><del>12.22 金工实习报告</del><ul>
<li><del>数车</del></li>
<li><del>数铣</del></li>
<li><del>钳工</del></li>
</ul>
</li>
<li><del>12.25 近代物理实验所有报告</del><ul>
<li><del>油滴</del> </li>
<li><del>光电</del></li>
<li><del>声光</del></li>
</ul>
</li>
<li><del>12.25 电子测试论文</del></li>
<li><del>12.25 电子测试课设报告</del></li>
<li><del>12.28 热力学与统计物理期末考试</del></li>
<li><del>12.29 计算机三级考试报名 数据库</del></li>
<li><del>12.31 电动力学期末考试</del></li>
<li><del>01.02 收光学作业</del></li>
<li><del>01.03 激光原理报告和作业</del></li>
<li><del>01.04 图像处理小程序验收</del></li>
<li><del>01.05 光学期末考试</del></li>
<li><del>01.07 人工智能验收</del></li>
<li><del>01.09 图像处理报告</del><ul>
<li><del>本专业的图像处理应用小论文</del></li>
<li><del>直方图处理</del></li>
<li><del>一个图像处理项目</del></li>
</ul>
</li>
<li><del>01.15 人工智能作业</del><ul>
<li><del>1 n皇后</del></li>
<li>2 怪兽世界</li>
<li><del>3 井字棋</del></li>
<li><del>4 粒子群求最小</del></li>
<li><del>5 遗传求最大</del> </li>
</ul>
</li>
</ul>
<hr>
<p>1、分别采用<strong>随机重启爬山法</strong>、<strong>最小冲突法</strong>和<strong>遗传算法</strong>求解n皇后问题。</p>
<p>2、使用<strong>联机搜索</strong>求解Wumpus怪兽世界问题</p>
<ul>
<li>Wumpus World PEAS 描述：<ul>
<li>性能度量：gold +1000, death -1000，-1 per step, -10 for using the arrow</li>
<li>环境描述：<ul>
<li>Squares adjacent to wumpus are smelly</li>
<li>Squares adjacent to pit are breezy</li>
<li>Glitter iff gold is in the same square</li>
<li>Shooting kills wumpus if you are facing it</li>
<li>Shooting uses up the only arrow</li>
<li>Grabbing picks up gold if in same square</li>
<li>Releasing drops the gold in same square</li>
</ul>
</li>
<li>传感器： Stench, Breeze, Glitter, Bump, Scream</li>
<li>执行器： Left turn, Right turn, Forward, Grab, Release, Shoot</li>
</ul>
</li>
</ul>
<p>3、采用<strong>α-β 剪枝算法</strong>实现井字棋游戏。（可以人-计算机或计算机-计算机）</p>
<ul>
<li><p>图形化界面。</p>
</li>
<li><p>随机选取先手后手。</p>
</li>
</ul>
<p>4、采用<strong>粒子群算法</strong>求解问题：求函数$y = f(x1, x2) = x_{12} - x_{22}$的最小值，其中$-10 \le x1, x2 \le 10$。</p>
<p>5、利用<strong>遗传算法</strong>求解问题</p>
<p>求函数$f(x) = 15x - x^2$在$x \in [0, 15]$的最大值，其中<strong>$x$为整数</strong>。</p>
<hr>
<h1 id="短期计划"><a href="#短期计划" class="headerlink" title="短期计划"></a>短期计划</h1><p><strong>12.17-12.31</strong> 挤空余时间做人工智能课设</p>
<p><strong>12.17-12.20晚上</strong> 完成油滴和光电的报告</p>
<p><strong>12.20-12.29白天</strong> 复习热统、电动力学、光学</p>
<ul>
<li>电动力学、热统采用goodnotes记笔记，光学采用typora</li>
</ul>
<p><strong>12.21上午</strong> 抄声光的预习报告</p>
<p><strong>12.21-12.26激光原理课</strong> 完成激光原理的作业和激光原理报告的定题</p>
<p><strong>12.21-12.26晚上</strong> 完成电子测试的课程报告和声光实验报告</p>
<p><strong>12.27-12.30晚上</strong> 完成电子测试的课设报告和激光原理的报告</p>
<p><strong>1.1-1.3晚上</strong> 完成图像处理的课设</p>
<h1 id="冲刺日记"><a href="#冲刺日记" class="headerlink" title="冲刺日记"></a>冲刺日记</h1><p><strong>12.16晚制定</strong></p>
<hr>
<h2 id="12-17周四"><a href="#12-17周四" class="headerlink" title="12.17周四"></a>12.17周四</h2><p>8:00-9:30，算法学习。💻</p>
<ul>
<li>随机重启爬山法</li>
<li>最小冲突法</li>
<li>完成用遗传算法解决n皇后问题</li>
</ul>
<p>10:00-11:30，体育课。🏀</p>
<p>12:30-13:30，人工智能课设。💻</p>
<p>14:00-18:00，图书馆。📕</p>
<ul>
<li>原子物理<ul>
<li>解决问题</li>
<li>第三章复习</li>
<li>背公式</li>
</ul>
</li>
<li>电动力学<ul>
<li>找问题并总结</li>
<li>看第四章</li>
</ul>
</li>
<li>乐跑</li>
</ul>
<p>19:00-22:00，图书馆。📕</p>
<ul>
<li>原子物理复习</li>
</ul>
<p>23:00-24:30，实验报告油滴实验。</p>
<h2 id="12-18周五"><a href="#12-18周五" class="headerlink" title="12.18周五"></a>12.18周五</h2><p>8:00-11:30，图书馆。📕</p>
<ul>
<li>原子物理<ul>
<li>看网课巩固知识点</li>
</ul>
</li>
</ul>
<p>12:30-13:30，人工智能1、4题。💻</p>
<p>15:00-17:00，电动力学/原子物理答疑，乐跑。👴</p>
<p>18:00-22:00，图书馆。📕</p>
<ul>
<li>原子物理<ul>
<li><strong>背公式、默公式</strong></li>
<li>讨论</li>
<li>看习题、笔记</li>
</ul>
</li>
</ul>
<p>23:00-24:30，完成油滴实验报告。💻</p>
<p>睡前，背公式。</p>
<h2 id="12-19周六"><a href="#12-19周六" class="headerlink" title="12.19周六"></a>12.19周六</h2><p><strong><em>上午，原子物理考试。</em></strong>📕</p>
<p>14:00-18:00，图书馆。📕</p>
<ul>
<li>热统<ul>
<li>画导图</li>
</ul>
</li>
<li>光学<ul>
<li>记笔记U2-U4</li>
</ul>
</li>
</ul>
<p>19:00-22:00，暂定去放松一下。🎤</p>
<p>23:00-24:30，完成光电的实验报告。💻</p>
<h2 id="12-20周日"><a href="#12-20周日" class="headerlink" title="12.20周日"></a>12.20周日</h2><p>8:00-11:30，图书馆。📕</p>
<ul>
<li>统计物理<ul>
<li>画导图</li>
<li>第六章和第七章重点</li>
</ul>
</li>
<li>光学<ul>
<li>记笔记U4-U6</li>
</ul>
</li>
</ul>
<p>12:30-18:30，图书馆。📕</p>
<ul>
<li>光学<ul>
<li>做作业</li>
</ul>
</li>
<li>电子测试课程报告</li>
<li>乐跑</li>
</ul>
<p>19:30-22:00，图书馆。📕</p>
<ul>
<li><p>统计物理</p>
<ul>
<li>第八章重点</li>
</ul>
</li>
<li><p>电子测试课程报告</p>
</li>
<li><p>金工实习报告</p>
</li>
</ul>
<p>23:00-24:30，继续电子测试报告。💻</p>
<p><strong>12.20晚制定</strong></p>
<hr>
<h2 id="12-20补"><a href="#12-20补" class="headerlink" title="12.20补"></a>12.20补</h2><p>19:00-22:00，图书馆。</p>
<ul>
<li>统计物理<ul>
<li>第六章</li>
</ul>
</li>
<li>光学<ul>
<li>第三章</li>
</ul>
</li>
</ul>
<p>23:00-1:00，宿舍。</p>
<ul>
<li>抄声光实验预习报告1</li>
<li>抄金工实习报告1</li>
</ul>
<h2 id="12-21周一"><a href="#12-21周一" class="headerlink" title="12.21周一"></a>12.21周一</h2><p>8:00-9:20，热统答疑。</p>
<p>10:05-11:30，抄声光实验预习报告2。</p>
<p>12:00-13:30，抄金工实习报告2。</p>
<p>14:00-17:00，做声光实验，直接记录数据到表格中。</p>
<p>19:00-22:00，图书馆。</p>
<ul>
<li>电动力学<ul>
<li>找问题</li>
</ul>
</li>
<li>统计物理<ul>
<li>第六章</li>
</ul>
</li>
<li>热力学<ul>
<li>第一章1</li>
</ul>
</li>
</ul>
<p>23:00-1:00，宿舍。</p>
<ul>
<li>电子测试技术报告</li>
</ul>
<h2 id="12-22周二"><a href="#12-22周二" class="headerlink" title="12.22周二"></a>12.22周二</h2><p>7:30-12:00，图书馆。</p>
<ul>
<li>热力学<ul>
<li>第一、二章习题</li>
</ul>
</li>
</ul>
<p>12:30-13:00，整理金工报告。</p>
<p>15:00-18:00，图书馆。</p>
<ul>
<li>光学<ul>
<li>第三章笔记3</li>
</ul>
</li>
<li>热力学第一章串讲</li>
</ul>
<p>18:00-22:00，图书馆。</p>
<ul>
<li>统计物理<ul>
<li>华科大热统串讲视频</li>
<li>第六章笔记</li>
</ul>
</li>
</ul>
<p>23:00-24:30，宿舍。</p>
<ul>
<li>光电实验报告</li>
</ul>
<h2 id="12-23周三"><a href="#12-23周三" class="headerlink" title="12.23周三"></a>12.23周三</h2><p>早上面包 中午外卖 晚上外卖</p>
<p>7:30-11:00，图书馆。</p>
<ul>
<li>电动力学<ul>
<li>第六章</li>
</ul>
</li>
<li>统计物理<ul>
<li>第六章笔记</li>
</ul>
</li>
</ul>
<p>12:00-13:30，图书馆，ipad充电。</p>
<ul>
<li>光学<ul>
<li>第三章</li>
</ul>
</li>
</ul>
<p>14:00-15:30，激光原理。</p>
<ul>
<li>热力学<ul>
<li>第三章习题、复习</li>
</ul>
</li>
</ul>
<p>16:00-18:00，图书馆。</p>
<ul>
<li>实验报告<ul>
<li>油滴实验思考题</li>
<li>完成光电效应</li>
<li>完成声光调制实验</li>
</ul>
</li>
</ul>
<p>19:00-21:30，图书馆。</p>
<ul>
<li>电子测试技术课设报告</li>
</ul>
<p>22:30-24:30，宿舍。</p>
<ul>
<li>统计物理<ul>
<li>第六、七章</li>
</ul>
</li>
</ul>
<h2 id="12-24周四"><a href="#12-24周四" class="headerlink" title="12.24周四"></a>12.24周四</h2><p>8:30-9:30，电动力学答疑。</p>
<p>10:00-11:30，篮球课。</p>
<p>13:00-18:00，宿舍。</p>
<ul>
<li>声光调制的报告</li>
<li>电子测试的论文</li>
</ul>
<p>19:00-22:00，图书馆。</p>
<ul>
<li>统计物理</li>
</ul>
<h2 id="12-25周五"><a href="#12-25周五" class="headerlink" title="12.25周五"></a>12.25周五</h2><p>8:00-11:30，图书馆。</p>
<ul>
<li><p>电子测试论文</p>
</li>
<li><p>电子测试课设1</p>
</li>
</ul>
<p>12:30-13:00，电子测试录像。</p>
<p>14:00-18:00，宿舍。</p>
<ul>
<li><p>电子测试课设2</p>
</li>
<li><p>统计物理</p>
<ul>
<li>第六章</li>
</ul>
</li>
</ul>
<p>19:00-21:00，光学答疑。</p>
<ul>
<li>问考点</li>
</ul>
<p>22:00-1:00，宿舍。</p>
<ul>
<li><p>热力学</p>
<ul>
<li>第三章收尾</li>
<li>第四章</li>
</ul>
</li>
<li><p>统计物理</p>
<ul>
<li>第七章</li>
</ul>
</li>
</ul>
<h2 id="12-26周六"><a href="#12-26周六" class="headerlink" title="12.26周六"></a>12.26周六</h2><p>全天肝统计物理和热力学！！</p>
<p>大目标：热力学复习完，统计物理到第九章，课设报告写完</p>
<p>8:00-11:30，图书馆。</p>
<ul>
<li>统计物理<ul>
<li>第六、七章</li>
</ul>
</li>
<li>热力学<ul>
<li>第三章收尾</li>
</ul>
</li>
</ul>
<p>12:30-17:30，图书馆。</p>
<ul>
<li>统计物理<ul>
<li>第七章</li>
</ul>
</li>
<li>热力学<ul>
<li>第四章</li>
</ul>
</li>
</ul>
<p>18:30-21:00，图书馆。</p>
<p>22:00-24:30，课设报告。</p>
<h2 id="12-27周日"><a href="#12-27周日" class="headerlink" title="12.27周日"></a>12.27周日</h2><p>大目标：热统所有课后题和知识点</p>
<p>8:00-11:30，图书馆。</p>
<p>12:30-17:30，图书馆。</p>
<p>18:30-22:00，图书馆。</p>
<h2 id="01-03周日"><a href="#01-03周日" class="headerlink" title="01.03周日"></a>01.03周日</h2><p>8:30-12:30，激光原理论文。</p>
<p>14:30-17:30，光学答疑+完成作业。</p>
<p>19:00-22:00，抄激光原理作业。</p>
<p>22:30-24:00，熟悉图像处理程序。</p>
<h2 id="01-04周一"><a href="#01-04周一" class="headerlink" title="01.04周一"></a>01.04周一</h2><p>12:30-22:00，图书馆。</p>
<h2 id="01-05周二"><a href="#01-05周二" class="headerlink" title="01.05周二"></a>01.05周二</h2><p>物理专业的学习一切都结束了……爽！</p>
<p><img src="C:%5CUsers%5CLenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210115235503859.png" alt="image-20210115235503859"></p>
<ol>
<li><p>先从(1,1)到(2,1)闻到臭味，判断怪兽在(3,1)或(2,2)</p>
</li>
<li><p>退回(1,1)</p>
</li>
<li><p>去(1,2)发现风，由于没有臭味所以(2,2)没怪兽</p>
</li>
<li><p>退回到(1,1)，到(1,2)，用箭杀死(3,1)的怪兽</p>
</li>
<li><p>来到(3,1)</p>
</li>
<li><p>右拐到(2,2)发现宝物原路返回</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>2021.3学习</title>
    <url>/2021/02/28/2021-3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>即将读研，加油~</p>
<a id="more"></a>

<h1 id="大目标"><a href="#大目标" class="headerlink" title="大目标"></a>大目标</h1><h2 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h2><p>3.13 PAT考试</p>
<p>3.24 三级数据库考试</p>
<p>4.xx 蓝桥杯考试</p>
<p>5.xx 夏令营投递</p>
<p>6.xx 期末考试准备，计算机四级，夏令营相关考试项目的准备（专业课，科研成果，编程能力，面试等）</p>
<p>7.xx 夏令营开始</p>
<h2 id="阶段目标"><a href="#阶段目标" class="headerlink" title="阶段目标"></a>阶段目标</h2><ul>
<li>3月<ul>
<li>3.1-3.13 PAT准备。</li>
<li>3.13-3.24<ul>
<li>三级数据库准备</li>
<li>定期训练文献阅读能力</li>
<li>尝试科研</li>
</ul>
</li>
</ul>
</li>
<li>4月<ul>
<li>4.1-4.10 编程比赛最后冲刺</li>
<li>4.10-4.30<ul>
<li>英语自我介绍准备…发挥优势</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="日计划"><a href="#日计划" class="headerlink" title="日计划"></a>日计划</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>7:30-8:00，吃饭。</p>
<p>8:00-11:30，图书馆。</p>
<ul>
<li>8:00-10:30，PAT刷题。</li>
<li>10:30-11:30，PAT总结。</li>
</ul>
<p>11:30-12:30，吃饭。</p>
<ul>
<li>鸡公煲外卖</li>
</ul>
<p>12:30-13:30，图书馆。</p>
<ul>
<li>数据库</li>
</ul>
<p>14:00-16:00，计网课。</p>
<p>16:00-17:30，图书馆。</p>
<ul>
<li>计算机组成原理网课</li>
</ul>
<p>17:30-18:00，吃饭。</p>
<ul>
<li>鸡胸肉+早餐奶</li>
</ul>
<p>18:00-22:00，图书馆。</p>
<ul>
<li>PAT刷题2h</li>
<li>蓝桥杯刷题2h</li>
</ul>
<p>23:00-24:00，宿舍。</p>
<ul>
<li>PAT总结</li>
</ul>
<h3 id="现实"><a href="#现实" class="headerlink" title="现实"></a>现实</h3><p>8:00-11:30，图书馆。</p>
<ul>
<li>PAT刷题<ul>
<li>1044 二分前缀和</li>
<li>1045 dp</li>
<li>1046</li>
<li>1047 C字符串</li>
<li>1048 双指针</li>
<li>1049</li>
</ul>
</li>
</ul>
<p>12:30-13:30，图书馆。</p>
<ul>
<li>1064 中序转层序</li>
</ul>
<p>14:00-16:30，听水课。</p>
<ul>
<li>决策树概念</li>
<li>熵、条件熵公式</li>
<li>信息增益</li>
</ul>
<p>17:30-18:30，计算机组成原理。</p>
<ul>
<li>存储器与CPU的连接习题课</li>
</ul>
<p>19:00-22:00，蓝桥杯2019真题。</p>
<p>123456题</p>
<h2 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h2><h3 id="计划-1"><a href="#计划-1" class="headerlink" title="计划"></a>计划</h3><p>7:40-8:00，看书预习。</p>
<p>8:00-9:35，好好听讲。</p>
<p>10:05-12:00，决策树算法，Leetcode每日一题。</p>
<p>12:00-13:00，图书馆找座+吃饭。</p>
<p>13:30-15:00，PAT刷题。</p>
<p>15:00-16:00，计算机组成原理。</p>
<p>16:00-17:30，蓝桥杯真题。</p>
<p>17:30-18:00，吃一块面包。</p>
<p>18:00-19:00，数据库。</p>
<p>19:00-21:00，PAT总结。</p>
<p>21:30-24:00，</p>
<ul>
<li>蓝桥杯真题</li>
<li>买东西</li>
<li>PAT总结</li>
</ul>
<h3 id="现实-1"><a href="#现实-1" class="headerlink" title="现实"></a>现实</h3><p>10:05-12:00，决策树算法，Leetcode每日一题。</p>
<ul>
<li>ID3</li>
<li>C4.5</li>
</ul>
<p>14:00-16:00，PAT刷题。</p>
<ul>
<li>1050 hash</li>
<li>1051 堆栈模拟</li>
<li>1052 链表</li>
</ul>
<p>16:00-18:00，蓝桥杯绕弯。</p>
<ul>
<li>迷宫 <ul>
<li>dfs要在每一个坐标维护一个当前到该坐标最短步数来剪枝</li>
<li>bfs要将四方向提前按照字母序排好</li>
</ul>
</li>
<li>外卖优先级 暴力模拟</li>
<li>修改数组<ul>
<li>顺序遍历 80%</li>
</ul>
</li>
<li>糖果<ul>
<li>DFS 10%</li>
<li>状压dp ×</li>
</ul>
</li>
</ul>
<p>18:30-20:00，计算机组成原理。</p>
<ul>
<li>存储器的校验—海明码</li>
</ul>
<h2 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h2><h3 id="计划-2"><a href="#计划-2" class="headerlink" title="计划"></a>计划</h3><p>7:40-8:00，看书。</p>
<p>8:00-9:35，量子力学。</p>
<p>10:00-12:00，图书馆。</p>
<ul>
<li>状压dp</li>
<li>树状数组</li>
</ul>
<p>12:00-13:00，黄焖鸡/鸡公煲。</p>
<p>13:00-17:00，图书馆。</p>
<ul>
<li>第9届蓝桥杯题目</li>
</ul>
<p>17:00-17:30，三明治。</p>
<p>18:00-19:30，PAT总结。</p>
<p>19:30-20:30，PAT刷题。</p>
<p>20:40-21:30，计算机组成原理。</p>
<p>21:30-22:00，PAT刷题。</p>
<p>22:30-23:10，数据库。</p>
<h3 id="现实-2"><a href="#现实-2" class="headerlink" title="现实"></a>现实</h3><p>10:00-12:00，图书馆。</p>
<ul>
<li>状压dp<ul>
<li>二进制整数刻画状态</li>
</ul>
</li>
<li>树状数组<ul>
<li>优化前缀和的更新和求解</li>
</ul>
</li>
</ul>
<p>14:00-17:00，蓝桥杯S9磨人。</p>
<p>18:00-19:00，计算机组成原理。</p>
<ul>
<li>提高访存速度的措施</li>
</ul>
<p>20:00-21:00，PAT刷题。</p>
<ul>
<li>1053 dfs模板题</li>
<li>1054</li>
<li>1055 排序模板题</li>
</ul>
<p>ps：模板题做够了，明天开始把没做过的一个一个扫题解，不亲自做了。</p>
<h2 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h2><h3 id="计划-3"><a href="#计划-3" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:30，听讲。</p>
<p>10:00-12:00，教一。</p>
<ul>
<li>PAT扫题</li>
</ul>
<p>12:00-13:00，吃馄饨。</p>
<p>13:00-17:00，图书馆。</p>
<ul>
<li>蓝桥杯S9</li>
<li>状压dp</li>
<li>计算机组成原理。</li>
</ul>
<p>22:00-24:00，宿舍。</p>
<ul>
<li>数据库</li>
<li>PAT扫题</li>
</ul>
<h3 id="现实-3"><a href="#现实-3" class="headerlink" title="现实"></a>现实</h3><p>10:00-12:00，宿舍。</p>
<ul>
<li>计网第一章网课</li>
</ul>
<p>14:30-19:00，自习室。</p>
<ul>
<li>蓝桥杯S11扫题<ul>
<li>12345</li>
<li>回文日期 年数加一 得到回文 判断是否合法</li>
<li>子串分值和 dp！维护下一个出现的该字符最近位置</li>
<li>荒岛探测 蒙特卡洛？</li>
</ul>
</li>
<li>PAT扫题<ul>
<li>1056 排序 后做</li>
<li>1057 树状数组 跳过</li>
<li>1058 新规则加法 跳过</li>
<li>1059 分解质因数</li>
<li>1060 浮点数转科学计数法 最恶心的一类题 我赌不考</li>
<li>1061 翻译密文 简单 跳过</li>
<li>1062 排序 规则一堆 先在读入时将等级分层再进行排序</li>
<li>1063 题意坑爹，让人难以理解！不表</li>
</ul>
</li>
</ul>
<p>20:30-23:30，</p>
<ul>
<li>PAT扫题。<ul>
<li>1065 判断A+B是否大于C，由于题目给的范围比较特殊，刚好在longlongint之内，不用担心溢出（ab为正相加为负，所以加和一定大于c）</li>
<li>1066 AVL树的模板题</li>
</ul>
</li>
<li>Leetcode每日一题<ul>
<li>最长递增子序列 dp</li>
</ul>
</li>
</ul>
<h2 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h2><h3 id="计划-4"><a href="#计划-4" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:00，计算机网络学习。</p>
<p>9:10-9:30，计算机组成原理。</p>
<p>9:30-10:00，理论力学复习。</p>
<p>10:00-11:40，听课。</p>
<p>11:40-12:30，吃小火锅。</p>
<p>12:30-13:30，决策树算法收尾。</p>
<p>14:00-15:30，C栋。</p>
<ul>
<li>刷leetcode</li>
<li>看蓝桥杯S8</li>
</ul>
<p>15:30-17:00，宿舍。</p>
<ul>
<li>PAT扫题</li>
</ul>
<p>17:00-18:00，吃饭。</p>
<p>18:00-22:00，图书馆。</p>
<ul>
<li>蓝桥杯S8</li>
<li>支持向量机算法</li>
</ul>
<p>22:30-24:00，宿舍。</p>
<ul>
<li>PAT扫题</li>
</ul>
<h3 id="现实-4"><a href="#现实-4" class="headerlink" title="现实"></a>现实</h3><p>8:20-9:30，计算机网络P2。</p>
<p>14:00-17:30，蓝桥杯S8填空题，太难了。</p>
<ul>
<li>第一题 dfs走迷宫</li>
<li>第二题  跳蚱蜢，bfs？不会</li>
<li>第三题 二阶魔方的所有情况，魔鬼模拟，不会</li>
<li>第四题 方格分割 dfs 沿着网格线进行对称dfs直到将网格分割成两部分</li>
</ul>
<p>18:30-20:00，PAT。</p>
<ul>
<li>1067 模拟交换，策略题。</li>
<li>1068 01背包/01dfs（会部分超时）</li>
</ul>
<p>23:00-24:00，和疯子吵架。</p>
<p>24:00-2:00，思考如何不被疯子杀死。</p>
<h2 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h2><h3 id="现实-5"><a href="#现实-5" class="headerlink" title="现实"></a>现实</h3><p>15:00-17:00，Leetcode。</p>
<ul>
<li>下一个更大元素I</li>
<li>下一个更大元素II 单调栈</li>
<li>第k个逆序对 dp</li>
</ul>
<p>19:00-21:00，PAT扫题。</p>
<ul>
<li>1069 黑洞数 重点在于字符串补零和读</li>
<li>1070 贪心吃月饼</li>
<li>1071 高频词检索 字符串编号 注意用<code>tolower</code>函数转换一下</li>
</ul>
<h2 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h2><h3 id="计划-5"><a href="#计划-5" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:30，计算机组成。</p>
<p>9:30-11:00，PAT扫题。</p>
<p>11:00-11:30，中商吃饭。</p>
<p>11:30-13:00，PAT扫题。</p>
<p>13:00-14:30，计算机网络。</p>
<p>21:00-23:00，背包问题。</p>
<h3 id="现实-6"><a href="#现实-6" class="headerlink" title="现实"></a>现实</h3><p>9:00-9:40，计算机组成。</p>
<p>9:40-13:00，教一。</p>
<ul>
<li>Leetcode dfs</li>
<li>PAT扫题<ul>
<li><a href="https://www.liuchuo.net/archives/2376" target="_blank" rel="noopener">1072 迪杰斯特拉</a></li>
<li><a href="https://blog.csdn.net/liuchuo/article/details/52121350" target="_blank" rel="noopener">1073 科学计数法</a></li>
<li>1074 反转链表</li>
<li>1075 排序模板题 以后写</li>
<li>1076 广搜 以后写</li>
<li>1077 最长相同后缀 翻转直接判断就行</li>
<li>1078 二次探测hash 之前写过一模一样的</li>
<li>1079 抽象树 dfs 以后做</li>
<li>1080 排序 题目较长 以后做</li>
</ul>
</li>
<li>14:00-14:50，蓝桥S8第五六题。</li>
</ul>
<h2 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h2><h3 id="计划-6"><a href="#计划-6" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:00，计算机网络。</p>
<p>9:00-11:00，练习迪杰斯特拉&amp;PAT相关题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		dist[j] = graph[v0][i]; <span class="comment">// 初始化dist数组为起点到各点的距离</span></span><br><span class="line">		ismin[i] = <span class="number">0</span>; <span class="comment">// vis数组为0</span></span><br><span class="line">		<span class="keyword">if</span> (i != v0 &amp;&amp; dist[i] &lt; maxWeight) path[i] = v0; <span class="comment">// 如果v0到i点有边，更新path[i]</span></span><br><span class="line">	&#125;</span><br><span class="line">	ismin[v0] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 在当前还未找到最短路径的顶点集中选取具有最短距离的顶点idx</span></span><br><span class="line">		minDis = maxWeight; <span class="comment">// 初始化最大权重</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ismin[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; minDis) &#123;</span><br><span class="line">				idx = j; <span class="comment">// 更新集合MST到外中最小距离的idx </span></span><br><span class="line">				minDis = dist[j]; <span class="comment">// 同时更新当前最小距离</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span> (minDis == maxWeight) <span class="keyword">return</span>; <span class="comment">// 如果没有路径，直接结束算法</span></span><br><span class="line">        ismin[idx] = <span class="number">1</span>; <span class="comment">// 将其纳入MST集合中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ismin[j] == <span class="number">0</span> &amp;&amp; graph[idx][j] &lt; maxWeight &amp;&amp; dist[u] + graph[idx][j] &lt; dist[j]) &#123;</span><br><span class="line">                <span class="comment">// 针对那些不在MST但与MST连通的点中，尝试更新其当前最短路径，并同时更新其上一个结点的位置</span></span><br><span class="line">                dist[j] = dist[idx] + graph[idx][j];</span><br><span class="line">                path[j] = idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11:00-12:00，PAT扫题。</p>
<p>12:00-12:30，吃外卖。</p>
<p>13:00-15:00，PAT扫题。</p>
<p>16:00-17:30，计算机组成。</p>
<p>17:30-18:00，吃外卖。</p>
<p>18:30-19:30，数据库。</p>
<p>19:30-22:00，背包问题。</p>
<h3 id="现实-7"><a href="#现实-7" class="headerlink" title="现实"></a>现实</h3><p>8:30-9:30，计算机组成。</p>
<ul>
<li>Cache基本..</li>
</ul>
<p>13:00-21:00，</p>
<ul>
<li>迪杰斯特拉<ul>
<li>1072</li>
<li>1011 1/2</li>
</ul>
</li>
<li>PAT扫题<ul>
<li>1081 分数加法（最大公约数和最小公倍数的求法）</li>
<li>1082 用中文读数字，字符串坑题</li>
<li>1083 排序基础题</li>
<li>1084 map水题</li>
<li>1085 简单滑窗，注意longlong防止溢出</li>
<li>1086 已知中序堆栈情况，还原后序</li>
</ul>
</li>
</ul>
<h2 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h2><h3 id="计划-7"><a href="#计划-7" class="headerlink" title="计划"></a>计划</h3><p>7:30-8:00，热干面，背概念。</p>
<p>8:00-9:35，听课。</p>
<p>9:50-12:30，教一。</p>
<ul>
<li><p>Leetcode每日</p>
</li>
<li><p>3.8PAT笔记</p>
</li>
<li><p>dijkstra扫题</p>
</li>
</ul>
<p>12:30-14:00，取快递，宿舍外卖。</p>
<p>14:00-15:00，数据库。</p>
<p>15:00-17:00，PAT扫题。</p>
<p>17:00-18:00，计组。</p>
<p>18:00-19:00，计网。</p>
<p>19:30-20:00，吃外卖。</p>
<p>20:00-22:00，图书馆。</p>
<ul>
<li>PAT总结笔记</li>
</ul>
<p>23:00-24:00，预习量子力学。</p>
<h3 id="现实-8"><a href="#现实-8" class="headerlink" title="现实"></a>现实</h3><p>9:50-11:40，PAT1111</p>
<p>14:30-17:30，PAT…dijkstra</p>
<ul>
<li>1111 dijkstra</li>
<li>1087 dijkstra + dfs</li>
</ul>
<p>17:30-19:00，计组，计网。</p>
<p>19:00-24:00，PAT扫题</p>
<ul>
<li><p>1088 分数加法</p>
</li>
<li><p>1089 分辨插入排序和归并排序，并预测下一步</p>
</li>
<li><p>1090 供应商 零售商问题 模拟树</p>
</li>
<li><p>1091 </p>
</li>
<li><p>1092</p>
</li>
<li><p>1093 数序列中的PAT，遍历三遍，每个‘A’依次记录前边的P数量和后面的T数量</p>
</li>
<li><p>1094 链表存储多叉树，BFS层序遍历得到最多人数的层</p>
</li>
<li><p>1095 </p>
</li>
</ul>
<h2 id="3-10"><a href="#3-10" class="headerlink" title="3.10"></a>3.10</h2><h3 id="计划-8"><a href="#计划-8" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:35，听课。</p>
<p>9:35-11:00，教一。</p>
<ul>
<li>Leetcode每日一题</li>
<li>PAT图部分总结，BFS题型</li>
</ul>
<p>12:00-12:30，取外卖，取快递，打印准考证和学分替代。</p>
<p>12:30-13:00，周六考试请假。</p>
<p>14:00-21:00，教一，咖啡和零食。</p>
<ul>
<li>14:00-15:35，计算机网络和计算机组成。</li>
<li>16:00-17:00，数据库。</li>
<li>17:00-19:00，扫荡之前遗留的排序题。</li>
<li>19:00-21:00，PAT总结。</li>
</ul>
<p>23:00-24:00，信息光学作业。</p>
<h3 id="现实-9"><a href="#现实-9" class="headerlink" title="现实"></a>现实</h3><p>9:35-11:00，教一。</p>
<ul>
<li>每日一题</li>
<li>部分总结</li>
</ul>
<p>14:20-19:00</p>
<ul>
<li>14:20-16:40，PAT总结。<ul>
<li>题型浏览1-36 135-155 101-107</li>
<li>总结类型</li>
</ul>
</li>
<li>17:00-18:30，<ul>
<li>计组：辅助存储器</li>
<li>计网：网络分类，性能指标</li>
</ul>
</li>
</ul>
<p>19:00-21:00，PAT扫题。</p>
<ul>
<li>1076 BFS</li>
<li>1079 树的遍历</li>
</ul>
<p>21:30-22:00，买吃的，买本</p>
<p>22:00-22:30，洗衣服。</p>
<p>23:30-24:30，信息光学。</p>
<h2 id="3-11"><a href="#3-11" class="headerlink" title="3.11"></a>3.11</h2><h3 id="计划-9"><a href="#计划-9" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:35，听课。</p>
<p>9:50-12:30，教一。</p>
<ul>
<li><p>Leetcode每日</p>
</li>
<li><p>PAT扫题</p>
</li>
<li><p>完善总结</p>
</li>
</ul>
<p>12:30-14:00，吃饭，午休。</p>
<p>14:30-21:30，教一，带键盘，编译器改用devcpp。</p>
<ul>
<li>14:30-16:30，PAT总结。</li>
<li>16:30-17:30，数据库。</li>
<li>17:30-19:00，计网计组。</li>
<li>19:30-21:30，PAT总结。</li>
</ul>
<p>21:30-22:30，洗衣服，洗裤子。</p>
<p>22:30-23:30，PAT。</p>
<p>23:30-24:30，记忆树的遍历题。</p>
<h3 id="现实-10"><a href="#现实-10" class="headerlink" title="现实"></a>现实</h3><p>10:00-13:00，信息光学笔记。</p>
<p>14:00-16:00，PAT扫题。</p>
<ul>
<li>BFS类型题目总结</li>
<li>1091 Acute Stroke 三维图<ul>
<li>DFS 超时</li>
<li>BFS AC</li>
</ul>
</li>
</ul>
<p>16:30-18:30，数据库。</p>
<ul>
<li>第一二章</li>
</ul>
<p>19:00-21:30，图书馆。</p>
<ul>
<li><p>PAT扫题</p>
<ul>
<li>hash 二次探测再散列</li>
<li>dijkstra的两种变形</li>
</ul>
</li>
<li><p>学堂在线–算法设计与分析</p>
</li>
<li><p>证明康普顿散射~失败</p>
</li>
</ul>
<p>24:00-24:30，计网。</p>
<h2 id="3-12"><a href="#3-12" class="headerlink" title="3.12"></a>3.12</h2><h3 id="计划-10"><a href="#计划-10" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:50，教一。</p>
<ul>
<li>康普顿散射的证明</li>
<li>复习波函数部分</li>
<li>Leetcode每日</li>
<li>剩余时间看PAT笔记</li>
</ul>
<p>10:00-11:40，听课，点外卖。</p>
<p>12:30-13:30，PAT扫题。</p>
<p>14:00-15:30，看笔记，ipad练练写写画画。</p>
<p>16:30-22:00，教一。</p>
<ul>
<li>PAT扫题</li>
</ul>
<p>23:00-24:00，PAT看笔记。</p>
<h3 id="现实-11"><a href="#现实-11" class="headerlink" title="现实"></a>现实</h3><p>复习PAT</p>
<h2 id="3-13"><a href="#3-13" class="headerlink" title="3.13"></a>3.13</h2><p>考PAT</p>
<p>第一题：最大值小于maxP的n个等差数列（要求差值尽量大，最大的数尽量大）</p>
<p>第二题：已知每个人预约进入实验室时间，且实验室最多同时有一个人，求最多能进来的人数</p>
<p>第三题：堆排序后针对对应问题给出相应的解（是根？兄弟姐妹？父节点？左孩子？右孩子）</p>
<p>第四题：迪杰斯特拉。。因为fill函数导致整个考试失败</p>
<h2 id="3-14"><a href="#3-14" class="headerlink" title="3.14"></a>3.14</h2><p>8:00-12:30，图书馆。</p>
<ul>
<li>8:00-9:30，数据库网课。</li>
<li>9:30-12:00，量子力学作业，光学笔记。</li>
</ul>
<p>12:30-13:00，洗澡。</p>
<p>13:00-15:00，给老师发邮件，计组计网。</p>
<p>22:00-24:00，光学作业。</p>
<h2 id="3-15"><a href="#3-15" class="headerlink" title="3.15"></a>3.15</h2><h3 id="计划-11"><a href="#计划-11" class="headerlink" title="计划"></a>计划</h3><p>8:00-11:30，图书馆。</p>
<ul>
<li>8:00-9:30，数据库网课看至少4P</li>
<li>9:30-10:30，Leetcode每日一题。</li>
<li>10:30-11:30，背包问题。</li>
</ul>
<p>11:30-12:00，小卖部吃饭。</p>
<p>12:00-16:00，图书馆。</p>
<ul>
<li>12:00-13:30，背包问题。</li>
<li>13:30-15:00，量子力学，光学笔记。</li>
<li>15:00-16:00，计组。</li>
</ul>
<p>16:00-17:00，吃外卖。</p>
<p>17:00-21:00，图书馆。</p>
<ul>
<li>17:00-18:00，计网</li>
<li>18:00-21:00，算法。<ul>
<li>18:00-20:00，统计学习算法，位运算，树状数组强化。</li>
<li>20:00-21:00，学堂在线，算法课。</li>
</ul>
</li>
</ul>
<p>21:00-22:00，夜宵。</p>
<p>22:00-24:00，光学笔记。</p>
<h3 id="现实-12"><a href="#现实-12" class="headerlink" title="现实"></a>现实</h3><p>10:00-12:00，数据库。</p>
<p>14:00-16:30，物理。</p>
<ul>
<li>量子力学</li>
<li>光学笔记</li>
</ul>
<p>20:00-21:30，计组。</p>
<h2 id="3-16"><a href="#3-16" class="headerlink" title="3.16"></a>3.16</h2><h3 id="理想"><a href="#理想" class="headerlink" title="理想"></a>理想</h3><p>8:00-9:30，听课。</p>
<p>10:00-11:30，抄实验报告。</p>
<p>11:40-12:00，回宿舍。</p>
<p>12:00-12:30，拿电脑，买面包，去自习室。</p>
<p>12:30-13:30，数据库视频，买套餐。</p>
<p>13:30-14:30，吃饭。</p>
<p>14:30-17:30，自习。</p>
<ul>
<li>实验报告</li>
<li>youtube算法视频</li>
<li>学堂在线第一章</li>
</ul>
<p>18:30-21:00，做实验。</p>
<ul>
<li>抽空刷Leetcode动规</li>
</ul>
<p>21:30-23:00，technology区up主刷视频。</p>
<p>23:00-24:00，哈密顿量了解，and= =该发邮件了。</p>
<p>24:00-25:30</p>
<ul>
<li>Leetcode每日一题。</li>
<li>计网一节课</li>
</ul>
<h3 id="现实-13"><a href="#现实-13" class="headerlink" title="现实"></a>现实</h3><p>12:30-13:30，看数据库。</p>
<p>14:00-15:00，抄实验报告。</p>
<p>15:00-17:00，了解动态相关。</p>
<p>22:00-23:00，硬件科普。</p>
<p>23:00-24:00，计算机网络一节课。</p>
<h2 id="3-17"><a href="#3-17" class="headerlink" title="3.17"></a>3.17</h2><h3 id="理想-1"><a href="#理想-1" class="headerlink" title="理想"></a>理想</h3><p>8:00-9:30，听课。</p>
<p>9:30-10:30，存钱，取笔，买饭。</p>
<p>11:00-12:00，硬件科普视频，发邮件。</p>
<p>12:00-18:00，教一。</p>
<ul>
<li>12:30-14:00，数据库。</li>
<li>14:00-16:00，完全背包，动规一道题，状压dp。</li>
<li>16:00-18:00，蓝桥杯刷题。</li>
</ul>
<p>18:00-18:30，吃饭。</p>
<p>18:30-20:00，奶茶店。</p>
<ul>
<li><p>统计方法阅读</p>
</li>
<li><p>操作系统实现</p>
</li>
</ul>
<p>20:00-22:00，图书馆。</p>
<ul>
<li>人工智能相关算法</li>
</ul>
<p>22:30-23:00，硬件科普视频。</p>
<p>23:00-24:30，光学，作业笔记。</p>
<h3 id="现实-14"><a href="#现实-14" class="headerlink" title="现实"></a>现实</h3><p>13:00-18:00，教一。</p>
<ul>
<li>Leetcode每日一题，dp</li>
<li>完全背包问题</li>
<li>youtuber动]规，没看完</li>
<li>发邮件，交涉失败</li>
</ul>
<p>18:30-22:00，七杯茶。</p>
<ul>
<li>计组 I/O</li>
<li>操作系统原理复习</li>
</ul>
<h2 id="3-18"><a href="#3-18" class="headerlink" title="3.18"></a>3.18</h2><h3 id="理想-2"><a href="#理想-2" class="headerlink" title="理想"></a>理想</h3><p>14:00-17:00，教一。</p>
<ul>
<li>14:00-15:30，数据库。</li>
<li>15:30-16:30，背包问题。</li>
<li>16:30-17:30，操作系统网课。</li>
<li>17:30-18:30，东教。<ul>
<li>看计网书</li>
<li>物理层</li>
</ul>
</li>
</ul>
<p>19:00-22:00，做实验，吃饭。</p>
<p>22:00-24:00，</p>
<ul>
<li><p>背包问题走一节</p>
</li>
<li><p>淘宝联系学习计划。</p>
</li>
</ul>
<p>24:00-25:30，</p>
<ul>
<li>Leetcode每日一题</li>
<li>计算机组成原理</li>
</ul>
<h3 id="现实-15"><a href="#现实-15" class="headerlink" title="现实"></a>现实</h3><p>14:00-17:00，七杯茶。</p>
<ul>
<li>数据库网课</li>
<li>操作系统网课一节</li>
<li>背包问题：多重背包问题I</li>
</ul>
<p>22:00-23:00，搬迁。</p>
<h2 id="3-19"><a href="#3-19" class="headerlink" title="3.19"></a>3.19</h2><p>10:05-11:30，没听课，看计网的书。</p>
<p>12:00-13:00，Leetcode不同的子序列II</p>
<p>14:00-15:30，看计网的书。</p>
<p>16:30-18:30，考蓝桥模拟。</p>
<p>19:00-21:00，计组I/O两节课</p>
<h2 id="3-22"><a href="#3-22" class="headerlink" title="3.22"></a>3.22</h2><h3 id="计划-12"><a href="#计划-12" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:30，机器学习项目。</p>
<p>9:30-10:30，数据库网课。</p>
<p>10:30-12:00，机器学习看书。</p>
<p>12:00-12:30，吃饭。</p>
<p>13:00-14:00，操作系统网课。</p>
<p>14:00-16:00，机器学习看书。</p>
<p>16:00-18:00，计组、计网。</p>
<p>18:00-18:30，吃饭。</p>
<p>18:30-20:00，背包问题。</p>
<p>20:00-22:00，机器学习。</p>
<p>23:00-24:00，信息光学。</p>
<p>24:00-25:30，Leetcode每日，实验报告数据处理。</p>
<h3 id="现实-16"><a href="#现实-16" class="headerlink" title="现实"></a>现实</h3><p>8:00-22:00，图书馆。</p>
<ul>
<li>数据库 运维部分</li>
<li>机器学习 对数几率回归项目</li>
<li>操作系统代码课 3/4</li>
<li>计网一节</li>
</ul>
<p>24:00-25:30，信息光学，Lc每日一题。</p>
<h2 id="3-24"><a href="#3-24" class="headerlink" title="3.24"></a>3.24</h2><h3 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h3><ul>
<li>数据库复习</li>
<li>numpy and pandas</li>
</ul>
<h3 id="计划-13"><a href="#计划-13" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:35，听课/抄实验报告。</p>
<p>9:50-12:30，逛图书馆，若无充电，暂时七杯茶</p>
<ul>
<li>按照taobao安排的计划进行学习</li>
</ul>
<p>12:30-13:00，吃外卖。</p>
<p>13:00-19:00，图书馆。</p>
<ul>
<li><p>13:00-14:00，数据库刷题。</p>
</li>
<li><p>14:00-16:00，计组，计网。</p>
</li>
<li><p>16:00-17:30，数据库刷题，ipad充电。</p>
</li>
<li><p>17:30-19:00，按taobao计划学习。</p>
</li>
</ul>
<p>19:00-19:30，吃寿司。</p>
<p>19:30-22:00，图书馆。</p>
<ul>
<li><p>19:30-20:00，3.24的Lc每日解法2、3，并总结</p>
</li>
<li><p>20:30-22:00，看算法准备蓝桥杯。</p>
</li>
</ul>
<p>22:30-24:30，完成机器学习的报告，Lc每日。</p>
<p>24:30-25:30，看汇编书。</p>
<h3 id="现实-17"><a href="#现实-17" class="headerlink" title="现实"></a>现实</h3><p>9:50-13:00，taobao计划。</p>
<ul>
<li>numpy</li>
</ul>
<p>13:30-14:00，taobao。</p>
<p>14:30-15:30，数据库。</p>
<ul>
<li>安全管理</li>
<li>故障管理备份与恢复</li>
</ul>
<p>15:30-16:50，计组。</p>
<ul>
<li>程序中断学完</li>
</ul>
<p>19:00-19:30，数据库。</p>
<ul>
<li>大型数据库系统架构</li>
</ul>
<p>19:30-19:40，昨日Lc每日。</p>
<p>20:00-21:00，taobao。</p>
<ul>
<li>pandas的数据结构</li>
</ul>
<p>22:30-24:00，几率回归报告。</p>
<ul>
<li>完成了大部分，键盘声有点大不敢打字了</li>
</ul>
<p>24:00-24:10，Lc每日。</p>
<p>24:30-25:30，看书。</p>
<h2 id="3-25"><a href="#3-25" class="headerlink" title="3.25"></a>3.25</h2><h3 id="主要-1"><a href="#主要-1" class="headerlink" title="主要"></a>主要</h3><ul>
<li>数据库非选择题</li>
</ul>
<h3 id="计划-14"><a href="#计划-14" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:35，听课。</p>
<p>9:50-12:00，图书馆。</p>
<ul>
<li>taobao学习</li>
</ul>
<p>12:00-12:30，外卖。</p>
<p>12:30-13:10，预习报告。</p>
<p>13:10-14:30，数据库。</p>
<p>14:30-15:30，计组。</p>
<p>15:30-16:30，完成几率回归报告并提交作业。</p>
<p>16:30-18:00，数据库。</p>
<p>18:00-18:30，吃饭团。</p>
<p>18:30-19:00，看计网。</p>
<p>19:00-22:00，实验+夜宵。</p>
<p>22:00-24:00，傅里叶光学第二章作业。</p>
<p>24:00-25:30，看汇编。</p>
<h3 id="现实-18"><a href="#现实-18" class="headerlink" title="现实"></a>现实</h3><p>10:00-12:00，taobao。</p>
<p>13:20-13:50，抄实验报告。</p>
<p>14:00-14:50，写完数据库选择题。</p>
<p>15:00-16:30，完成作业。</p>
<p>24:00-24:10，Lc每日。</p>
<h2 id="3-26"><a href="#3-26" class="headerlink" title="3.26"></a>3.26</h2><h3 id="主要-2"><a href="#主要-2" class="headerlink" title="主要"></a>主要</h3><p>数据库</p>
<h3 id="计划-15"><a href="#计划-15" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:40，图书馆。</p>
<ul>
<li>Taobao看完pandas</li>
</ul>
<p>10:00-11:40，听课/光学笔记</p>
<p>12:00-14:00，外卖午休，打印准考证，请假。</p>
<p>14:00-17:00，七杯茶。</p>
<ul>
<li>数据库</li>
</ul>
<p>17:00-18:00，吃饭。</p>
<p>18:00-22:00，图书馆。</p>
<ul>
<li>计算机组成</li>
<li>汇编</li>
</ul>
<h3 id="现实-19"><a href="#现实-19" class="headerlink" title="现实"></a>现实</h3><ul>
<li>汇编的寄存器</li>
<li>计网的TCPIP结构概览</li>
</ul>
<h2 id="3-27"><a href="#3-27" class="headerlink" title="3.27"></a>3.27</h2><h3 id="现实-20"><a href="#现实-20" class="headerlink" title="现实"></a>现实</h3><p>上午，看汇编，看完寄存器内容（堆栈，数据段，指令段），听决策树。</p>
<p>下午，学完pandas。</p>
<p>晚上，量子力学三道题，多个最小二乘法迭代图</p>
<h2 id="3-28"><a href="#3-28" class="headerlink" title="3.28"></a>3.28</h2><h3 id="计划-16"><a href="#计划-16" class="headerlink" title="计划"></a>计划</h3><p>7:30-8:00，一道dp。</p>
<p>8:00-9:30，pandas补充内容，开始可视化matplotlib。</p>
<p>9:30-11:00，量子力学作业。</p>
<p>11:00-12:00，学计算机网络。</p>
<p>12:00-12:30，吃外卖。</p>
<p>12:30-13:30，数据处理，主要是完成自动化程序处理，完成处理留在周日周一两天晚上完成。</p>
<p>13:30-14:00，冥想，休息。</p>
<p>14:00-18:00，决策树部分的代码。</p>
<p>18:00-18:30，吃饭。</p>
<p>18:30-19:30，计算机组成原理。</p>
<p>19:30-21:30</p>
<ul>
<li>选择1：前面部分完成的很好，那么继续专注完成决策树代码结合之前的可视化</li>
<li>选择2：前面部分有拖拉，那么此时暂时放弃决策树<ul>
<li>看汇编书</li>
<li>一节操作系统课/刷dp</li>
</ul>
</li>
</ul>
<p>21:30-22:30，运动，夜宵，洗澡。</p>
<p>22:30-24:00，实验报告处理，尽量一晚上完成。</p>
<h3 id="现实-21"><a href="#现实-21" class="headerlink" title="现实"></a>现实</h3><p>8:30-10:00，taobao。</p>
<p>10:00-11:00，量子力学。</p>
<p>11:00-11:30，TCP/IP的数据链路部分内容。</p>
<p>12:30-17:30，琢磨决策树那题。</p>
<p>19:00-20:00，计算机组成原理DMA。</p>
<p>20:00-21:00，操作系统网课。</p>
<h2 id="3-29"><a href="#3-29" class="headerlink" title="3.29"></a>3.29</h2><h3 id="主要-3"><a href="#主要-3" class="headerlink" title="主要"></a>主要</h3><ul>
<li>完成taobao第一阶段</li>
<li>完成光学作业，实验报告</li>
</ul>
<h3 id="计划-17"><a href="#计划-17" class="headerlink" title="计划"></a>计划</h3><p>8:00-8:30，一道dp。</p>
<p>8:30-11:30，taobao。</p>
<p>11:30-12:00，吃外卖，意面。</p>
<p>12:00-13:00，处理实验数据。</p>
<p>13:00-13:30，午休。</p>
<p>13:30-14:30，继续处理实验数据。</p>
<p>14:30-16:30，信息光学第二章作业。</p>
<p>16:30-18:00，操作系统一节课。</p>
<p>18:00-19:00，吃饭，饭团+和味道+水果。</p>
<p>19:00-21:00，计网计组。</p>
<p>21:00-22:00，处理实验数据。</p>
<h3 id="现实-22"><a href="#现实-22" class="headerlink" title="现实"></a>现实</h3><p>8:30-10:00，Taobao，因为网络中途放弃。</p>
<p>10:00-11:30，光学作业和第二章笔记。</p>
<p>13:00-16:00，艰难实验处理。</p>
<p>16:00-18:00，教一艰难实验处理。</p>
<p>19:30-21:30，计组结束第五章。</p>
<p>21:30-23:00，处理完实验数据。</p>
<h2 id="3-30"><a href="#3-30" class="headerlink" title="3.30"></a>3.30</h2><h3 id="计划-18"><a href="#计划-18" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:35，听讲。</p>
<p>9:50-11:40，电脑学Taobao。</p>
<p>11:40-12:30，iPad充半个小时电。</p>
<p>13:30-16:30，麦当劳，选择多多。</p>
<ul>
<li>看操作系统课</li>
<li>看TCP/IP</li>
<li>看汇编</li>
<li>刷dp</li>
</ul>
<p>19:00-21:00，做实验。</p>
<p>22:00-23:00，学Taobao。</p>
<p>23:00-24:00，量子力学最后一题。</p>
<h3 id="现实-23"><a href="#现实-23" class="headerlink" title="现实"></a>现实</h3><p>Taobao Seaborn</p>
<ul>
<li>箱线图</li>
<li>散点图</li>
<li>小提琴图</li>
</ul>
<p>汇编第四章</p>
<p>TCPIP一部分</p>
<p>信息光学部分题</p>
<h2 id="3-31"><a href="#3-31" class="headerlink" title="3.31"></a>3.31</h2><h3 id="主要-4"><a href="#主要-4" class="headerlink" title="主要"></a>主要</h3><ul>
<li>Seaborn学完，可视化部分全部敲完！</li>
<li>决策树代码50%</li>
<li>光学剩的作业写完</li>
</ul>
<h3 id="计划-19"><a href="#计划-19" class="headerlink" title="计划"></a>计划</h3><p>8:00-9:30，量子力学/抄实验报告。</p>
<p>9:50-12:00，Taobao（没雨教一，有雨宿舍）。</p>
<p>12:00-13:00，外卖。</p>
<p>13:00-18:00，决策树+Taobao完成。</p>
<p>18:00-19:00，铁板。</p>
<p>19:00-24:00，</p>
<ul>
<li>操作系统一节课</li>
<li>汇编继续看</li>
<li>计网继续看</li>
<li>光学作业</li>
</ul>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>2020暑假第二阶段学习</title>
    <url>/2020/07/26/2020%E6%9A%91%E5%81%87%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>新的一周马上开始了，暑假也过了一半，感觉前一阶段的学习还算中规中矩，没有达到自己想要达到的目标，下一阶段继续加油！</p>
<a id="more"></a>
<p>该阶段主要任务：</p>
<ol>
<li>六级真题*8(每周至少要做两套)</li>
<li>Leetcode 70道题(一天至少要提交两道)</li>
<li>Leetcode 至少三次周赛(只能有一次缺席)</li>
<li>操作系统课</li>
<li>计组课</li>
<li>汇编课</li>
<li>固体物理课（原子链、能带理论）</li>
<li>Matlab使用方法</li>
<li>操作系统实验(在4、6学习完毕之后开展)</li>
</ol>
<p>保留任务：一个小项目（如果暑假没有时间也可以开学了完成）</p>
<h3 id="7-27"><a href="#7-27" class="headerlink" title="7.27"></a>7.27</h3><h4 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~1:10，Leetcode两道题。</p>
<ul>
<li>路径之和</li>
<li>判断子序列</li>
</ul>
<p>10:30~11:30，小刷六级，痛苦一天，13个听力，555</p>
<p>12:00~13:00，Leetcode两道树的题目，虽然DFS仍然稀烂无比，但上手题目渐渐有了自己的想法。</p>
<ul>
<li>二叉树中的链表</li>
<li>二叉树迭代器</li>
</ul>
<p>14:00~15:00，小刷六级阅读，全是马虎错，需刷题弥补。</p>
<p>16:00~18:00，操作系统第九章。</p>
<ul>
<li>死锁检测</li>
<li>死锁恢复</li>
<li>IPC（进程间通信）</li>
</ul>
<p>20:00~21:30，Leetcode两道树题目。</p>
<ul>
<li>路径总和II</li>
<li>路径总和III</li>
</ul>
<h3 id="7-28"><a href="#7-28" class="headerlink" title="7.28"></a>7.28</h3><h4 id="时间线-1"><a href="#时间线-1" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~2:00，Leetcode两道树题目。</p>
<ul>
<li>从前序与中序遍历序列构造二叉树</li>
<li>先序遍历构造二叉树</li>
</ul>
<p>11:00~13:14，二叉树的三种遍历的迭代方法，四道Leetcode。</p>
<ul>
<li>二叉树前序遍历</li>
<li>二叉树中序遍历</li>
<li>二叉树后序遍历</li>
<li>N叉树的前序遍历</li>
</ul>
<p>14:00~16:00，操作系统文件系统。</p>
<ul>
<li>文件描述符</li>
<li>文件别名</li>
<li>文件系统分类</li>
</ul>
<p>19:40~20:20，一道Leetcode。</p>
<ul>
<li>层序遍历II</li>
</ul>
<p>20:30~21:30，计组的系统总线的基础知识。</p>
<ul>
<li>总线结构</li>
<li>总线种类</li>
</ul>
<p>22:00~23:00，两道Leetcode的链表，Leetcode今天终于破百啦，庆祝撒花！！。</p>
<ul>
<li>分隔链表I</li>
<li>分隔链表II</li>
</ul>
<h4 id="算法下阶段重点"><a href="#算法下阶段重点" class="headerlink" title="算法下阶段重点"></a>算法下阶段重点</h4><ol>
<li>stl里面内置方法的复杂度总结（第六章）</li>
<li>并查集（第九章）</li>
<li>hash（四.2、十二.1）</li>
<li>最短路径算法（第十章）</li>
<li>树状数组（第十三章）</li>
<li>动态规划（第十一章）</li>
</ol>
<h3 id="7-29"><a href="#7-29" class="headerlink" title="7.29"></a>7.29</h3><h4 id="时间线-2"><a href="#时间线-2" class="headerlink" title="时间线"></a>时间线</h4><p>0:30~2:00，Typora下载，汇编语言第一章部分内容。<a href="https://www.dazhuanlan.com/2019/12/13/5df30035bec19/" target="_blank" rel="noopener">如何用typora+hexo的风格在文档中添加图片</a></p>
<p>10:30~12:30，STL库用法以及时间复杂度整理。</p>
<ul>
<li>vector</li>
<li>set</li>
<li>string</li>
</ul>
<p>12:30~13:00，Leetcode一道dp题。</p>
<ul>
<li>不同路径I</li>
<li>不同路径II</li>
</ul>
<p>14:00~16:00，Leetcode一道。</p>
<ul>
<li>迷你语法解析器</li>
</ul>
<p>18:00~19:00，STL库总结。</p>
<ul>
<li>queue</li>
<li>map</li>
<li>stack</li>
<li>priority_queue</li>
<li>pair</li>
</ul>
<p>21:30~22:20，六级听力，进步了错两道。</p>
<p>22:40~23:10，操作系统文件。</p>
<ul>
<li>虚拟文件系统</li>
<li>数据缓存</li>
</ul>
<p>23:40~24:00，不同路径II的滚动数组优化。</p>
<h3 id="7-30"><a href="#7-30" class="headerlink" title="7.30"></a>7.30</h3><h4 id="时间线-3"><a href="#时间线-3" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~1:40，两道Leetcode。</p>
<ul>
<li>不同路径III</li>
<li>整数拆分</li>
</ul>
<p>10:00~13:00，Leetcode双指针专题。</p>
<ul>
<li>删除排序数组的重复项II</li>
<li>反转字符串</li>
<li>三数之和</li>
</ul>
<p>14:00~18:00，Leetcode双指针。这题是真的恶心，吐了。</p>
<ul>
<li>和相同的二元子数组</li>
</ul>
<p>19:00~21:00，继续淦！Leetcode双指针，又吐了，简单题做了好久。</p>
<ul>
<li>划分字母区间</li>
<li>移动零</li>
<li>反转字符串中的元音字母</li>
</ul>
<h3 id="7-31-8-1"><a href="#7-31-8-1" class="headerlink" title="7.31-8.1"></a>7.31-8.1</h3><h4 id="时间线-4"><a href="#时间线-4" class="headerlink" title="时间线"></a>时间线</h4><p>23:30~24:00，三道Leetcode。</p>
<ul>
<li>验证回文串</li>
<li>魔术索引</li>
</ul>
<p>10:30~14:00，两道Leetcode。</p>
<ul>
<li>验证二叉搜索树</li>
<li>通过删除字母匹配到字典里最长单词</li>
</ul>
<p>14:30~18:30，学习并查集，一道Leetcode不过好像没用上。</p>
<ul>
<li>最长连续序列</li>
</ul>
<p>22:00~22:30，一道Leetcode。</p>
<ul>
<li>朋友圈</li>
</ul>
<p>22:40~23:30，操作系统完结。</p>
<ul>
<li>文件分配</li>
<li>空闲空间列表</li>
</ul>
<h3 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h3><h4 id="时间线-5"><a href="#时间线-5" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~1:00，两道Leetcode。</p>
<ul>
<li>杨辉三角形</li>
<li>二叉树展开为链表（缺两种方法总结）</li>
</ul>
<p>10:30~12:00，Leetcode周赛，虽然这次题目好像比较简单，但是第一次做出来三道题感觉还不错！</p>
<p>13:00~14:00，每日一题的另外两种解法。</p>
<p>14:30~23:30，MatLab基础语法，两道Leetcode。</p>
<ul>
<li>环形链表II</li>
<li>最大得分</li>
</ul>
<h3 id="8-3"><a href="#8-3" class="headerlink" title="8.3"></a>8.3</h3><h4 id="时间线-6"><a href="#时间线-6" class="headerlink" title="时间线"></a>时间线</h4><p>0:20~0:40，Leetcode每日一题。</p>
<ul>
<li>字符串相加</li>
</ul>
<p>1:00~1:30，汇编第一章。</p>
<p>11:30~15:30，学完Matlab基础语法。</p>
<p>16:50~18:30，三道Leetcode。</p>
<ul>
<li>推多米诺</li>
<li>大样本统计</li>
<li>相同的树</li>
</ul>
<p>21:30~24:00，Leetcode四道题。</p>
<ul>
<li>有序链表转换二叉搜索树（递归分治）</li>
<li>买卖股票最佳时机I（简单遍历，维护i前的最小值）</li>
<li>买卖股票最佳时机II（贪心，二维动态）</li>
<li>买卖股票最佳时机III（三维动态）</li>
</ul>
<h3 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h3><h4 id="时间线-7"><a href="#时间线-7" class="headerlink" title="时间线"></a>时间线</h4><p>0:30~2:00，计算机组成原理。</p>
<ul>
<li>总线控制</li>
</ul>
<p>11:30~13:00，两道Leetcode。</p>
<ul>
<li>二叉树的最大路径和（困难，简单递归）</li>
<li>杨辉三角II（模拟）</li>
</ul>
<p>14:30~16:00，MatLab绘图基础。</p>
<p>22:00~23:00，两道Leetcode。</p>
<ul>
<li>只出现一次的数字I</li>
<li>只出现一次的数字II<br>（hashset，位运算）</li>
</ul>
<h3 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h3><h4 id="时间线-8"><a href="#时间线-8" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~2:00，Leetcode三道题。</p>
<ul>
<li>打家劫舍I（dp）</li>
<li>打家劫舍II（分类后简化成I）</li>
<li>打家劫舍III（记忆化DFS）</li>
</ul>
<p>11:00~14:00，刷bp的reaction，就当是英语听力吧555</p>
<p>15:30~18:00，两道Leetcode。</p>
<ul>
<li>求根到叶子节点数字之和（每层递归记录当前和）</li>
<li>买卖股票的最佳时机IV（根据II推导）</li>
</ul>
<p>18:30~19:30，Matlab画图的子图、标注等知识。</p>
<p>20:00~22:30，学习树状数组，利用树状数组解计算右侧小于当前元素个数。</p>
<h4 id="今日遗留"><a href="#今日遗留" class="headerlink" title="今日遗留"></a>今日遗留</h4><ol>
<li>每日一题，回文对。</li>
<li>字典树</li>
<li>红黑树</li>
<li>sort方法没有完全掌握（排序pair结构出现问题）</li>
<li>以maxn的方式开数组，是否空间复杂度极高。</li>
</ol>
<h3 id="8-6"><a href="#8-6" class="headerlink" title="8.6"></a>8.6</h3><h4 id="时间线-9"><a href="#时间线-9" class="headerlink" title="时间线"></a>时间线</h4><p>21:00~23:00，学字典树，弄懂了昨日的每日一题。</p>
<h4 id="今日遗留-1"><a href="#今日遗留-1" class="headerlink" title="今日遗留"></a>今日遗留</h4><ul>
<li>Leetcode实现trie这题</li>
<li>整理200次周赛的2、3题</li>
</ul>
<h3 id="8-7"><a href="#8-7" class="headerlink" title="8.7"></a>8.7</h3><h4 id="时间线-10"><a href="#时间线-10" class="headerlink" title="时间线"></a>时间线</h4><p>10:30~11:30，回文串暴力解法（不要拼接字符串），一道Leetcode。</p>
<ul>
<li>实现tried树</li>
</ul>
<p>12:00~13:40，一道Leetcode。</p>
<ul>
<li>单词搜索II(trie树+dfs)</li>
</ul>
<p>14:40~15:40，一道Leetcode。</p>
<ul>
<li>恢复空格(trie树+dp)</li>
</ul>
<p>15:40~16:00，周赛的2、3题总结，我的方法居然还都不错？</p>
<p>16:30~17:30，Matlab二维图学完。</p>
<p>18:00~19:00，三种方法做Leetcode。</p>
<ul>
<li>长度最小的子数组<ul>
<li>暴力</li>
<li>前缀和</li>
<li>双指针(滑动窗口)</li>
</ul>
</li>
</ul>
<p>20:00~21:00，两道Leetcode，总结滑动数组思想。</p>
<ul>
<li>二叉树中第k小的元素(迭代中序遍历)</li>
<li>单词搜索I（dfs）<br>Leetcode 150道里程碑！</li>
</ul>
<p>22:00~23:00，计组结束总线控制。</p>
<ul>
<li>同步通信</li>
<li>异步通信</li>
<li>半同步通信</li>
<li>分离式通信</li>
</ul>
<h4 id="小笔记"><a href="#小笔记" class="headerlink" title="小笔记"></a>小笔记</h4><p>回溯避免重复访问的两种方式：</p>
<ol>
<li>设置vis数组<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">dfs();</span><br><span class="line">vis[i][j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li>
<li>访问后，修改为其他标记<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> cur = board[i][j];</span><br><span class="line">board[i][j] = <span class="string">"#"</span>;</span><br><span class="line">dfs();</span><br><span class="line">board[i][j] = cur;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="今日遗留-2"><a href="#今日遗留-2" class="headerlink" title="今日遗留"></a>今日遗留</h4><ol>
<li>莫里斯遍历</li>
<li>三种遍历的优化（原来的ifelse有点啰嗦）</li>
<li>快排、堆排序</li>
</ol>
<h3 id="8-8"><a href="#8-8" class="headerlink" title="8.8"></a>8.8</h3><h4 id="时间线-11"><a href="#时间线-11" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~1:00，Leetcode每日一题。</p>
<ul>
<li>恢复二叉搜索树（中序+迭代）</li>
</ul>
<p>1:10~1:40，一套英语听力。</p>
<p>10:00~10:30，两道Leetcode。</p>
<ul>
<li>用栈实现队列</li>
<li>数组中第k个最大元素</li>
</ul>
<p>11:30~14:30，学习堆排序，重做数组中第k个最大元素。</p>
<p>14:45~16:00，Matlab的基本三维图绘制。</p>
<ul>
<li>曲线图</li>
<li>曲面图<ul>
<li>网格图</li>
<li>网面图</li>
<li>柱、球</li>
</ul>
</li>
</ul>
<p>17:00~18:00，一道Leetcode。</p>
<ul>
<li>完全二叉树的节点个数（递归）</li>
</ul>
<p>19:00~20:00，一道Leetcode。</p>
<ul>
<li>滑动窗口最大值（滑动窗口/双端队列）</li>
</ul>
<p>22:30~24:00，Leetcode双周赛。</p>
<ul>
<li>第k个缺失的正整数（模拟）</li>
<li>k次操作转变字符串（模拟）</li>
</ul>
<h3 id="8-9"><a href="#8-9" class="headerlink" title="8.9"></a>8.9</h3><h4 id="时间线-12"><a href="#时间线-12" class="headerlink" title="时间线"></a>时间线</h4><p>0:10~0:30，双周赛第三题</p>
<ul>
<li>平衡括号字符串的最小插入次数（字符串匹配，栈）</li>
</ul>
<p>9:30~10:30，Leetcode每日一题。</p>
<ul>
<li>复原IP地址(枚举递归)</li>
</ul>
<p>10:30~12:00，Leetcode周赛，3、4真的不会（最近做了很多前缀和题目，老实说3没有往这方面想挺不应该的），1题真的倒胃。</p>
<ul>
<li><p>整理字符串（模拟）</p>
</li>
<li><p>找出第N个二进制字符串的第K位（模拟）</p>
</li>
</ul>
<p><strong>ps：深感自己算法知识不足。下一阶段要追求广度，力求先将算法的方法概况先掌握个大概，先不要求深度。</strong></p>
<ul>
<li>前缀和思想√</li>
<li>状态压缩</li>
<li>位运算√</li>
<li>字符串匹配</li>
<li>莫里斯遍历</li>
</ul>
<p>13:30~15:30，两道前缀和的题。</p>
<ul>
<li>和为K的子数组</li>
<li>和为目标值的最大不重叠非空子数组数目</li>
</ul>
<p>15:45~17:00，位运算总结。</p>
<p>19:00~21:00，磕了一道dp（我太菜了），白天的周赛压轴题</p>
<ul>
<li>切棍子的最小成本</li>
</ul>
<h3 id="8-10"><a href="#8-10" class="headerlink" title="8.10"></a>8.10</h3><h4 id="时间线-13"><a href="#时间线-13" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~2:00，Leetcode两道题。</p>
<ul>
<li>找出最长的超赞子字符串（前缀和+位运算）</li>
<li>计数二进制子串</li>
</ul>
<p>11:00~14:00，Leetcode以前遗留的位运算的题目。</p>
<p>15:00~19:00，还是淦位运算的题，真的不好想，自己脑子也笨，题解还得吃半天，由于感觉学习成本有点高，打算先不继续向下拓展，要不有损信心。</p>
<ul>
<li>只出现一次的数字II</li>
<li>只出现一次的数字III</li>
<li>数字范围按位与</li>
</ul>
<p>20:00~23:00，看计组的课，不知道为啥，计组这也好难懂，最近学啥都不顺利qwq。</p>
<ul>
<li>存储器结构</li>
<li>半导体存储器简介</li>
<li>存储字长、存储单元、地址线、寻址空间……的联系</li>
</ul>
<h3 id="8-11"><a href="#8-11" class="headerlink" title="8.11"></a>8.11</h3><p>0:30~1:30，一道回文串的题目，这个递归思想看了半天才看懂。</p>
<p>1:30~2:30，三道Leetcode简单题。</p>
<ul>
<li>删除链表中的节点</li>
<li>2的幂（位运算）</li>
<li>回文链表（快慢指针+反转）</li>
</ul>
<p>10:30~15:00，四道Leetcode。</p>
<ul>
<li>3的幂</li>
<li>4的幂（位运算）</li>
<li>灯泡开关（脑筋急转弯）</li>
<li>零钱兑换（dfs/记忆化搜索/贪心）</li>
<li>零钱兑换II（dp）</li>
</ul>
<p>16:30~17:30，英语六级，听力错仨还可以。</p>
<p>18:00~19:00，写下一阶段文档。</p>
<p>21:30~23:30，汇编语言三节（相当于是计组的复习和扩展）。</p>
<ul>
<li>微机基本结构</li>
<li>寄存器</li>
<li>存储器</li>
</ul>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>30个JS小项目</title>
    <url>/2020/07/11/30%E4%B8%AAJS%E5%B0%8F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>一个对Javascript学习很有帮助的实操项目。</p>
<a id="more"></a>
<h2 id="打鼓点"><a href="#打鼓点" class="headerlink" title="打鼓点"></a>打鼓点</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li><code>querySelector()</code>方法返回文档中匹配指定CSS选择器的一个元素。<code>querySelectorAll()</code>返回全部元素。</li>
<li><code>&lt;kbd&gt;</code>标签用于指定该字符是从键盘输入的。</li>
<li><code>keyCode</code>65-90对应的是键盘上A-Z。</li>
<li><code>element.classList.add()</code>添加一个或多个类名。对应的<code>remove()</code>删除。</li>
<li>当发生<code>transitionend</code>事件时，<code>propertyName</code>属性返回<strong>与转换关联的CSS属性的名称</strong>。此属性是只读的。</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>加入对键盘按键的事件监听，每当按下一个按键时<ul>
<li>audio要play</li>
<li>加入playing类，从而使得样式改变。</li>
</ul>
</li>
<li>加入对每一个key的监听，若事件结束，则remove playing类从而返回初始状态。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTransition</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.propertyName !== <span class="string">'transform'</span>) <span class="keyword">return</span>; <span class="comment">// 只有监听到transition结束时，才remove playing</span></span><br><span class="line">  e.target.classList.remove(<span class="string">'playing'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playSound</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// audio和key承载了整个标签和标签里的内容</span></span><br><span class="line">  <span class="keyword">const</span> audio = <span class="built_in">document</span>.querySelector(<span class="string">`audio[data-key="<span class="subst">$&#123;e.keyCode&#125;</span>"]`</span>);</span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">document</span>.querySelector(<span class="string">`div[data-key="<span class="subst">$&#123;e.keyCode&#125;</span>"]`</span>);</span><br><span class="line">  <span class="keyword">if</span> (!audio) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  key.classList.add(<span class="string">'playing'</span>);</span><br><span class="line">  audio.currentTime = <span class="number">0</span>; <span class="comment">// 使时间归零，重新播放当前鼓点</span></span><br><span class="line">  audio.play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'.key'</span>));</span><br><span class="line">keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> key.addEventListener(<span class="string">'transitionend'</span>, removeTransition));</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'keydown'</span>, playSound);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="钟表"><a href="#钟表" class="headerlink" title="钟表"></a>钟表</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li><a href="https://www.runoob.com/jsref/prop-style-transform.html" target="_blank" rel="noopener">style的transform属性</a><code>object.style.transform</code></li>
<li><code>setinterval()</code>方法</li>
</ol>
<ul>
<li><code>setInterval()</code> 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式</li>
<li><code>setInterval()</code> 方法会不停地调用函数，直到 <code>clearInterval()</code> 被调用或窗口被关闭。</li>
</ul>
<h3 id="script代码"><a href="#script代码" class="headerlink" title="script代码"></a>script代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> secondHand = <span class="built_in">document</span>.querySelector(<span class="string">'.second-hand'</span>);</span><br><span class="line"><span class="keyword">const</span> minsHand = <span class="built_in">document</span>.querySelector(<span class="string">'.min-hand'</span>);</span><br><span class="line"><span class="keyword">const</span> hourHand = <span class="built_in">document</span>.querySelector(<span class="string">'.hour-hand'</span>);</span><br><span class="line"><span class="comment">// .XXX-hand都是类名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> seconds = now.getSeconds();</span><br><span class="line">  <span class="keyword">const</span> secondsDegrees = ((seconds / <span class="number">60</span>) * <span class="number">360</span>) + <span class="number">90</span>; <span class="comment">//初始角度为90°</span></span><br><span class="line">  secondHand.style.transform = <span class="string">`rotate(<span class="subst">$&#123;secondsDegrees&#125;</span>deg)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mins = now.getMinutes();</span><br><span class="line">  <span class="keyword">const</span> minsDegrees = ((mins / <span class="number">60</span>) * <span class="number">360</span>) + ((seconds/<span class="number">60</span>)*<span class="number">6</span>) + <span class="number">90</span>;</span><br><span class="line">  minsHand.style.transform = <span class="string">`rotate(<span class="subst">$&#123;minsDegrees&#125;</span>deg)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hour = now.getHours();</span><br><span class="line">  <span class="keyword">const</span> hourDegrees = ((hour / <span class="number">12</span>) * <span class="number">360</span>) + ((mins/<span class="number">60</span>)*<span class="number">30</span>) + <span class="number">90</span>;</span><br><span class="line">  hourHand.style.transform = <span class="string">`rotate(<span class="subst">$&#123;hourDegrees&#125;</span>deg)`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(setDate);</span><br><span class="line"></span><br><span class="line">setDate();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Update-CSS-Variable-With-JS"><a href="#Update-CSS-Variable-With-JS" class="headerlink" title="Update CSS Variable With JS"></a>Update CSS Variable With JS</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li><code>label</code>标签，<code>for</code>属性的值与后面的<code>input</code>的<code>id</code>相一致。 也可以直接把<code>input</code>内嵌到<code>label</code>中，此时不需要<code>for</code>属性。标签的作用就是关联。</li>
<li><code>:root</code>选择器用于匹配文档的根标签。</li>
<li>CSS variable<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="comment">/*变量用--表示*/</span></span><br><span class="line">  <span class="attribute">--base</span>: <span class="number">#ffc600</span>;</span><br><span class="line">  <span class="attribute">--spacing</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">--blur</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="comment">/*将变量赋值给属性*/</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="built_in">var</span>(--spacing);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--base);</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(var(--blur));</span><br><span class="line">  <span class="comment">/*blur用于设置高斯模糊*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>data-xxx</code>是input后面自定义的一个属性。用<code>this.dataset.sizing</code>获取<code>data-sizing</code>属性的值。</li>
</ol>
<h3 id="script代码-1"><a href="#script代码-1" class="headerlink" title="script代码"></a>script代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inputs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'input'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> suffix = <span class="keyword">this</span>.dataset.sizing || <span class="string">''</span>; </span><br><span class="line">  <span class="comment">// 设置后缀，like'px'，dataset对应了data-sizeing="px"，由于color项不含data-属性，故添加||''</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.setProperty(<span class="string">`--<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>, <span class="keyword">this</span>.value + suffix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inputs.forEach(<span class="function"><span class="params">input</span> =&gt;</span> input.addEventListener(<span class="string">'change'</span>, handleUpdate));</span><br><span class="line">inputs.forEach(<span class="function"><span class="params">input</span> =&gt;</span> input.addEventListener(<span class="string">'mousemove'</span>, handleUpdate));</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数组方法训练"><a href="#数组方法训练" class="headerlink" title="数组方法训练"></a>数组方法训练</h2><h3 id="知识点及应用"><a href="#知识点及应用" class="headerlink" title="知识点及应用"></a>知识点及应用</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>定义：<code>array.filter(function(currentValue,index,arr), thisValue)</code></p>
<ul>
<li><code>function</code>是必选参数，数组中每个元素都会执行这个函数，故其中<code>currentValue</code>是必选值，<code>index</code>和<code>arr</code>可以不指定。</li>
<li><code>thisValue</code>可选，<code>thisValue</code>赋给函数的<code>this</code>。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Filter the list of inventors for those who were born in the 1500's</span></span><br><span class="line"><span class="keyword">const</span> fifteen = inventors.filter(<span class="function"><span class="params">inventor</span> =&gt;</span> (inventor.year &gt;= <span class="number">1500</span> &amp;&amp; inventor.year &lt; <span class="number">1600</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>定义：<code>array.map(function(currentValue,index,arr), thisValue)</code></p>
<ul>
<li>与filter类似。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. Give us an array of the inventor first and last names</span></span><br><span class="line"><span class="keyword">const</span> fullNames = inventors.map(<span class="function"><span class="params">inventor</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;inventor.first&#125;</span> <span class="subst">$&#123;inventor.last&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fullNames);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>定义：<code>array.sort(sortFunction)</code>如无参数，默认按字母顺序。<br>原理：模拟前一个数<code>a</code>和后一个数<code>b</code>的比较，对数组所有元素进行sort。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. Sort the inventors by birthdate, oldest to youngest</span></span><br><span class="line"><span class="keyword">const</span> ordered = inventors.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.year &gt; b.year ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 若前大于后，则为1，交换顺序</span></span><br><span class="line"><span class="comment">// 若前小于后，则为-1，不交换</span></span><br><span class="line"><span class="comment">// 故为升序（从老到新--1400年的人老于1430年的人）</span></span><br><span class="line"><span class="built_in">console</span>.table(ordered);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. Sort the inventors by years lived</span></span><br><span class="line"><span class="keyword">const</span> oldest = inventors.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> lastInventor = a.passed - a.year;</span><br><span class="line">  <span class="keyword">const</span> nextInventor = b.passed - b.year;</span><br><span class="line">  <span class="keyword">return</span> lastInventor &gt; nextInventor ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.table(oldest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. sort Exercise</span></span><br><span class="line"><span class="comment">// Sort the people alphabetically by last name</span></span><br><span class="line"><span class="keyword">const</span> alpha = people.sort(<span class="function">(<span class="params">lastOne, nextOne</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [aLast, aFirst] = lastOne.split(<span class="string">', '</span>);</span><br><span class="line">  <span class="keyword">const</span> [bLast, bFirst] = nextOne.split(<span class="string">', '</span>);</span><br><span class="line">  <span class="keyword">return</span> aLast &gt; bLast ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(alpha);</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>定义：<code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></p>
<ul>
<li>按照function将数组从<code>initialValue</code>开始向后依次累计计算。</li>
<li><code>function</code>是必选参数，数组中每个元素都会执行这个函数。<code>currentValue</code>和<code>total</code>都是必选值，<code>total</code>相当于<code>m+=1</code>的<code>m</code>的效果</li>
<li><code>initalValue</code>是传递给函数的初始值，可选。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. How many years did all the inventors live?</span></span><br><span class="line"><span class="keyword">const</span> totalYears = inventors.reduce(<span class="function">(<span class="params">total, inventor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + (inventor.passed - inventor.year);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. Reduce Exercise</span></span><br><span class="line"><span class="comment">// Sum up the instances of each of these</span></span><br><span class="line"><span class="keyword">const</span> data = [<span class="string">'car'</span>, <span class="string">'car'</span>, <span class="string">'truck'</span>, <span class="string">'truck'</span>, <span class="string">'bike'</span>, <span class="string">'walk'</span>, <span class="string">'car'</span>, <span class="string">'van'</span>, <span class="string">'bike'</span>, <span class="string">'walk'</span>, <span class="string">'car'</span>, <span class="string">'van'</span>, <span class="string">'car'</span>, <span class="string">'truck'</span>, <span class="string">'pogostick'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transportation = data.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">obj, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj[item]) &#123;</span><br><span class="line">    obj[item] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  obj[item]++;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// 此处的obj和上边的total理解为初始化一个对象(数据)，然后开始逐一计算</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(transportation);</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="flex-panels"><a href="#flex-panels" class="headerlink" title="flex panels"></a>flex panels</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex" target="_blank" rel="noopener"><code>flex</code></a>属性</li>
<li><code>arr.includes(valueToFind[, fromIndex])</code>数组中是否包含某元素</li>
<li><code>str.includes(searchString[, position])</code>字符串中是否包含某子串</li>
<li><code>classList.toggle()</code>给某dom元素添加类</li>
</ul>
<h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> panels = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.panel'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击事件，修改为open</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleOpen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">this</span>.classList.toggle(<span class="string">'open'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件结束，修改为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleActive</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.propertyName);</span><br><span class="line">  <span class="keyword">if</span> (e.propertyName.includes(<span class="string">'flex'</span>)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.classList.toggle(<span class="string">'open-active'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">panels.forEach(<span class="function"><span class="params">panel</span> =&gt;</span> panel.addEventListener(<span class="string">'click'</span>, toggleOpen));</span><br><span class="line">panels.forEach(<span class="function"><span class="params">panel</span> =&gt;</span> panel.addEventListener(<span class="string">'transitionend'</span>, toggleActive));</span><br></pre></td></tr></table></figure>

<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p><code>.panel &gt; *{}</code>是啥意思？</p>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>4月学习</title>
    <url>/2021/04/02/4%E6%9C%88%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>4月的学习记录。</p>
<a id="more"></a>

<h2 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h2><p>8:30-10:00，教一</p>
<ul>
<li>Leetcode每日</li>
<li>看TCP/IPpdf，汇编pdf</li>
</ul>
<p>10:00-11:40，听课，点外卖。</p>
<p>12:30-13:30，看线性回归相关模型</p>
<p>14:00-16:00，</p>
<ul>
<li>看决策树知识（从实现项目的角度而言）</li>
<li>预习神经网络</li>
</ul>
<p>16:00-16:45，口语跟读？</p>
<h2 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h2><p>Lc每日</p>
<h2 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h2><ul>
<li>决策树ID3算法题目完成</li>
</ul>
<h2 id="4-5"><a href="#4-5" class="headerlink" title="4.5"></a>4.5</h2><ul>
<li>决策树ID3、C4.5、对数几率回归划分+报告(除可视化和结果分析)</li>
<li>计算机组成：机器指令</li>
<li>一道dp</li>
</ul>
<h2 id="4-6"><a href="#4-6" class="headerlink" title="4.6"></a>4.6</h2><ul>
<li>dp二维前缀和</li>
<li>计算机网络完成链路层</li>
<li>汇编的dw指令</li>
</ul>
<h2 id="4-7"><a href="#4-7" class="headerlink" title="4.7"></a>4.7</h2><ul>
<li>完成kaggle上线性回归提交</li>
<li>计组操作数及存放</li>
<li>汇编看完第六章</li>
</ul>
<h2 id="4-8"><a href="#4-8" class="headerlink" title="4.8"></a>4.8</h2><ul>
<li>预习报告</li>
<li>实验处理</li>
<li>汇编部分</li>
</ul>
<h2 id="4-9"><a href="#4-9" class="headerlink" title="4.9"></a>4.9</h2><ul>
<li>汇编七八章<ul>
<li>and or</li>
<li>[bx + idata]</li>
<li>SI和DI寄存器</li>
<li>[bx + si + idata]</li>
<li>二维数组的应用</li>
<li>寻址方式表格</li>
</ul>
</li>
<li>一道dp<ul>
<li>丑数II 三指针dp</li>
</ul>
</li>
<li>计组看完第七章<ul>
<li>寻址方式</li>
<li>RISC和CISC</li>
</ul>
</li>
</ul>
<h2 id="4-10"><a href="#4-10" class="headerlink" title="4.10"></a>4.10</h2><ul>
<li>机器学习：神经网络<ul>
<li>多层前馈神经网络</li>
<li>反向传播算法</li>
</ul>
</li>
<li>IP地址</li>
<li>光学第三章作业</li>
</ul>
<h2 id="4-11"><a href="#4-11" class="headerlink" title="4.11"></a>4.11</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>7:30-12:00，图书馆。</p>
<ul>
<li>7:30-10:30，逻辑回归。</li>
<li>10:30-12:00，刷题。</li>
</ul>
<p>14:00-18:00，肯德基。</p>
<ul>
<li>实验报告1h</li>
<li>TCP/IP 1h</li>
<li>逻辑回归理论 1h</li>
<li>信息光学笔记整理 1h</li>
</ul>
<p>22:00-24:00，神经网络模型。</p>
<h2 id="4-12"><a href="#4-12" class="headerlink" title="4.12"></a>4.12</h2><p>8:30-11:30，图书馆。</p>
<ul>
<li>Titannic项目</li>
</ul>
<p>12:00-18:00，图书馆。</p>
<ul>
<li>蓝桥杯刷题</li>
</ul>
<p>19:00-22:00，图书馆。</p>
<ul>
<li>神经网络题目</li>
</ul>
<h2 id="4-13"><a href="#4-13" class="headerlink" title="4.13"></a>4.13</h2><ul>
<li><p>一道dp</p>
</li>
<li><p>汇编jmp</p>
</li>
</ul>
<h2 id="4-14"><a href="#4-14" class="headerlink" title="4.14"></a>4.14</h2><p>8:00-9:30，重抄实验报告。</p>
<p>10:00-12:00，图书馆。</p>
<ul>
<li>神经网络</li>
</ul>
<p>13:00-17:00，蓝桥杯。</p>
<p>18:00-20:00，机器学习决策树。</p>
<p>20:00-21:00，计算机组成原理。</p>
<p>21:00-22:00，背包九讲dp。</p>
<p>23:00-24:00，抄实验报告，改荧光实验。</p>
<p>实际上：</p>
<ul>
<li>卡在神经网络实现上了</li>
<li>一道dp</li>
<li>抄实验报告，改荧光实验</li>
</ul>
<h2 id="4-15"><a href="#4-15" class="headerlink" title="4.15"></a>4.15</h2><p>8:00-9:30，听课。</p>
<p>10:00-12:00，决策树学习。</p>
<p>13:00-17:30，蓝桥杯真题。</p>
<p>17:30-18:30，吃火龙果，晚饭，打印。</p>
<p>19:00-20:30，交报告，做实验。</p>
<p>21:00-22:00，图书馆。</p>
<ul>
<li>计算机网络</li>
</ul>
<p>22:30-24:00，宿舍。</p>
<ul>
<li>刷算法</li>
</ul>
<p>24:00-25:30，Lc每日，看算法总结。</p>
<h2 id="4-21"><a href="#4-21" class="headerlink" title="4.21"></a>4.21</h2><p>计算机网络：InterNet和边缘网络</p>
<p>计算机组成原理：CPU结构</p>
<p>taobao辅导：集成学习概览，相应的偏差与方差</p>
<p>dp每日</p>
<p>概率论复习：期望，方差，协方差</p>
<h2 id="4-28"><a href="#4-28" class="headerlink" title="4.28"></a>4.28</h2><ol>
<li>计算机网络一节网课</li>
<li>计算机组成原理学完指令流水</li>
<li>看完lightGBM实战课，完成Titanic实战</li>
<li>完成添加新属性的任务，结束taobao第四章</li>
<li>参加保研会</li>
</ol>
<p>8:00-9:30，抄多普勒</p>
<p>9:50-12:30，完成taobao第四章</p>
<p>13:00-14:00，计组</p>
<p>14:00-15:30，贝叶斯实战，ipad充电</p>
<p>16:00-18:00，保研会，信息光学笔记</p>
<p>18:30-21:00，图书馆</p>
<ul>
<li>汇编整理 1h</li>
<li>贝叶斯实战 1.5h</li>
</ul>
<p>23:00-25:00，实验数据处理，Lc每日</p>
<p>25:00-26:00，计算机网络结束第一章学习</p>
<p>26:00-27:00，特征工程学习。</p>
<h2 id="4-29"><a href="#4-29" class="headerlink" title="4.29"></a>4.29</h2><p>8:00-9:30，抄多普勒</p>
<p>9:50-12:30，特征工程，速度学，能学多少是多少</p>
<p>13:00-14:00，计组中断系统 part1</p>
<p>14:00-16:00，使用git部署现有项目</p>
<ul>
<li><p>C语言管理系统</p>
</li>
<li><p>Cpp，MFC，任务调度系统</p>
</li>
<li><p>data-structure 堆栈迷宫求解</p>
</li>
<li><p>遗传算法可视化</p>
</li>
<li><p>罗马尼亚度假问题</p>
</li>
<li><p>部分AI期末题</p>
</li>
<li><p>西瓜书部分习题的实现</p>
</li>
</ul>
<p>16:00-17:00，计算机网络。</p>
<p>18:00-19:00，计算机网络。</p>
<p>19:00-21:00，实验数据处理。</p>
<p>23:00-24:00，英文自我介绍。</p>
<p>24:00-24:30，Lc每日。</p>
<p>24:30-26:30，学特征工程。</p>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>2021寒假学习</title>
    <url>/2021/01/06/2021%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>2021年的寒假从01.08-02.29，是非常重要的一个“假期”，希望自己能管住自己，准备三四级考试，提升专业实力，学习相应课程。</p>
<a id="more"></a>

<h1 id="寒假大目标"><a href="#寒假大目标" class="headerlink" title="寒假大目标"></a>寒假大目标</h1><ol>
<li>计算机三级数据库准备</li>
<li>操作系统、计算机组成、汇编系统三门课的融会贯通*</li>
<li>深度学习–NLP</li>
<li><strong>PAT甲级考试准备，日常刷题</strong></li>
<li><strong>蓝桥杯考试准备</strong></li>
<li>Leetcode日常刷题保持手感</li>
<li>Wumpus World的随机地图解法*</li>
<li>练英语口语</li>
</ol>
<h1 id="寒假日记"><a href="#寒假日记" class="headerlink" title="寒假日记"></a>寒假日记</h1><h2 id="01-17"><a href="#01-17" class="headerlink" title="01.17"></a>01.17</h2><p>今天晚上，我终于终结了人工智能的所有要求，所以上个学期的课程终于告一段落了，，</p>
<h2 id="01-18"><a href="#01-18" class="headerlink" title="01.18"></a>01.18</h2><p>了解了很多跨保的信息，发现项目还是挺重要的。接下来试着联系计算机学院的老师跟着做项目，也和表舅联系一下nlp的进展，以后要查一下华科的计算机学院都有哪些方向和导师。</p>
<h2 id="01-19"><a href="#01-19" class="headerlink" title="01.19"></a>01.19</h2><p>每日一句：每天算法，会回来的！</p>
<p>理想：</p>
<ul>
<li><p>9:00-10:00，Leetcode两道题。</p>
</li>
<li><p>10:20-11:30，计算机网络P1。</p>
</li>
<li><p>12:30-14:00，计算机网络P2。</p>
</li>
<li><p>14:30-16:00，PAT甲级两道。</p>
</li>
<li><p>17:00-20:00，深度学习。</p>
<ul>
<li>nlp论文研读</li>
<li>项目实操</li>
</ul>
</li>
<li><p>20:30-22:00，计算机组成原理。</p>
</li>
</ul>
<p>现实：</p>
<ul>
<li>五道Leetcode。</li>
</ul>
<p>补充：</p>
<p>初步计划戒掉手机，每天开机时间：</p>
<ol>
<li>9点前</li>
<li>18点后</li>
<li>19点开番茄</li>
</ol>
<h2 id="01-20"><a href="#01-20" class="headerlink" title="01.20"></a>01.20</h2><p>每日一句：不坐床！坐椅子。</p>
<p>理想：</p>
<ul>
<li>9:00-10:30，做Leetcode。</li>
<li>10:30-11:00，读口语。</li>
<li>11:00-12:00，nlp。<ul>
<li>论文研读</li>
<li>吴恩达课程复习</li>
</ul>
</li>
<li>13:00-14:30，计组。</li>
<li>14:30-15:00，读口语。</li>
<li>15:00-16:30，nlp。</li>
<li>16:30-18:00，华科导师了解。</li>
<li>19:00-22:00，PAT甲级刷题。</li>
<li>22:00-24:00，Leetcode题型总结。</li>
</ul>
<p>现实：</p>
<ul>
<li>10:30-13:00，Leetcode。<ul>
<li>省份数量</li>
<li>旋转数组</li>
<li>汇总区间</li>
</ul>
</li>
<li>15:00-18:00，计算机组成原理。<ul>
<li>第一章速览</li>
<li>第一章预习</li>
</ul>
</li>
<li>19:00-22:00，PAT甲级。<ul>
<li>counting leaves</li>
<li>sign in and sign out</li>
<li>spell it right</li>
</ul>
</li>
<li>22:00-24:00，华科导师信息了解P1-P4。</li>
</ul>
<p>比赛报名：</p>
<ul>
<li>PAT甲级<ul>
<li>报名截止3.3</li>
<li>考试时间3.13</li>
</ul>
</li>
<li>蓝桥杯C++<ul>
<li>报名时间截止到3-12</li>
<li>模拟赛报名截止1.23</li>
<li>考试时间，4月份</li>
</ul>
</li>
</ul>
<h2 id="01-21"><a href="#01-21" class="headerlink" title="01.21"></a>01.21</h2><p>每日一句：打球回来之后记得回归状态！</p>
<p>理想：</p>
<ul>
<li>12:00-14:00，计算机组成原理。<ul>
<li>第二章速览</li>
</ul>
</li>
<li>14:00-15:00，Leetcode。</li>
<li>15:00-16:30，nlp。</li>
<li>17:00-19:00，Leetcode题型总结。</li>
<li>19:00-22:00，PAT甲级，从1131-1155。</li>
<li>22:00-24:00，蓝桥杯真题。</li>
</ul>
<p>现实：</p>
<ul>
<li>14:00-16:00，计组第二章<ul>
<li>2.1-2.5</li>
</ul>
</li>
<li>17:00-19:00，nlp。<ul>
<li>读书</li>
</ul>
</li>
<li>19:30-24:00，PAT两道题。<ul>
<li>Is it a redblack tree</li>
<li>a delayed palindrome</li>
</ul>
</li>
</ul>
<h2 id="01-22"><a href="#01-22" class="headerlink" title="01.22"></a>01.22</h2><p>每日一句：不如人家本专业的不要泄气，还有机会！</p>
<p>理想：</p>
<ul>
<li><p>8:30-10:00，计组第二章。</p>
</li>
<li><p>10:00-11:00</p>
<ul>
<li>读口语</li>
<li>花29元买资料</li>
</ul>
</li>
<li><p>11:00-12:00，nlp。</p>
<ul>
<li>看书</li>
</ul>
</li>
<li><p>12:00-13:00，由买好的资料定下午的学习计划。</p>
</li>
<li><p>18:00-22:00</p>
<ul>
<li>PAT刷题</li>
<li>Leetcode整理</li>
</ul>
</li>
</ul>
<p>现实：</p>
<p>由于PAT坑太多，我真的是服了，我今天真的不适合写代码。</p>
<ul>
<li>10:00-23:00，PAT甲级。<ul>
<li>final grading</li>
<li>postorder traversal</li>
<li>first contact</li>
</ul>
</li>
</ul>
<h2 id="01-23"><a href="#01-23" class="headerlink" title="01.23"></a>01.23</h2><p>每日一句：别纠结一道题了，四处碰壁就换换心情！今天试试分开做题的效果如何。</p>
<p>理想：</p>
<ul>
<li>8:30-10:00，PAT甲级一道题。</li>
<li>10:00-11:00，NLP，feel it。</li>
<li>11:30-13:30，计算机组成原理。</li>
<li>14:00-15:00，PAT甲级一道题。</li>
<li>15:30-17:30，最短路径算法整理。</li>
<li>19:00-20:30，PAT甲级一道题。</li>
<li>20:30-22:00，买数据库的题。</li>
<li>23:00-24:00，找蓝桥杯真题。</li>
</ul>
<p>现实：</p>
<p>三道PAT。</p>
<h2 id="01-24"><a href="#01-24" class="headerlink" title="01.24"></a>01.24</h2><p>每日一句：已经回家16天了！我都学了个啥！今天我绝不离开座位半步！</p>
<p>理想：</p>
<ul>
<li>8:30-10:30，PAT甲级两道题。</li>
<li>10:30-11:30，统计方法。</li>
<li>11:30-13:30，计组。</li>
<li>14:00-16:30，最短路径算法。</li>
<li>17:00-19:00，数据库题库and复习计划。</li>
<li>19:00-21:00，PAT甲级两道题。</li>
<li>22:30-24:00，NLP。</li>
</ul>
<p>现实：</p>
<p>四道PAT。</p>
<h2 id="01-25"><a href="#01-25" class="headerlink" title="01.25"></a>01.25</h2><p>每日一句：stayfocused插件用起来！锁住b站。</p>
<p>理想：</p>
<ul>
<li>8:30-10:00，PAT甲级两道题。</li>
<li>10:00-11:30，统计方法。<ul>
<li>范数</li>
<li>感知机</li>
</ul>
</li>
<li>11:30-13:30，计组。</li>
<li>14:00-16:30，最短路径算法。</li>
<li>17:00-19:00，数据库题库and复习计划。</li>
<li>19:00-21:00，PAT甲级两道题。</li>
<li>22:30-24:00，NLP。</li>
</ul>
<p>现实：</p>
<p>两道PAT难题，devcpp配置。</p>
<h2 id="01-26"><a href="#01-26" class="headerlink" title="01.26"></a>01.26</h2><p>理想：</p>
<ul>
<li><p>8:30-10:00</p>
<ul>
<li>锻炼</li>
<li>更新情侣网站</li>
<li>购买数据库资料</li>
</ul>
</li>
<li><p>10:00-11:30，统计学习方法。</p>
<ul>
<li>范数</li>
<li>感知机</li>
</ul>
</li>
<li><p>11:30-13:30，计组。</p>
</li>
<li><p>14:00-16:30，蓝桥杯初赛3道题。</p>
</li>
<li><p>17:00-19:00，最短路径算法。</p>
</li>
<li><p>19:00-21:30，PAT甲级三道题。</p>
</li>
<li><p>22:30-24:00，NLP。</p>
</li>
</ul>
<h2 id="01-27-01-29"><a href="#01-27-01-29" class="headerlink" title="01.27-01.29"></a>01.27-01.29</h2><p>现实：</p>
<ul>
<li>PAT11道</li>
<li>感知机模型学习</li>
<li>朴素贝叶斯模型学习</li>
<li>计组第二章</li>
</ul>
<h2 id="01-30"><a href="#01-30" class="headerlink" title="01.30"></a>01.30</h2><p>每日一句：今天！复活！</p>
<p>理想：</p>
<ul>
<li>9:30-10:30，蓝桥杯OJ两道题。</li>
<li>10:30-11:30，数据库题库。</li>
<li>13:00-14:30，最短路径算法。</li>
<li>15:30-17:00，决策树模型阅读。<ul>
<li>C4.5算法</li>
<li>CART算法</li>
</ul>
</li>
<li>17:30-20:30，PAT甲级三道题。</li>
<li>21:00-24:00，Leetcode总结。</li>
</ul>
<h2 id="02-01"><a href="#02-01" class="headerlink" title="02.01"></a>02.01</h2><ul>
<li>数据库刷题</li>
<li>PAT一道题</li>
<li>Leetcode每日一题</li>
<li>计算机组成原理<ul>
<li>静态RAM</li>
<li>动态RAM</li>
</ul>
</li>
</ul>
<h2 id="02-02"><a href="#02-02" class="headerlink" title="02.02"></a>02.02</h2><ul>
<li>Leetcode每日一题<ul>
<li>滑动窗口</li>
</ul>
</li>
<li>PAT三道题</li>
<li>图论算法复习<ul>
<li>Prim</li>
<li>Kruskal</li>
<li>Dijikastra</li>
</ul>
</li>
</ul>
<h2 id="02-03"><a href="#02-03" class="headerlink" title="02.03"></a>02.03</h2><p>理想：</p>
<ul>
<li>9:00-10:00，PAT两道题。</li>
<li>10:00-10:30，数据库练习。</li>
<li>11:00-12:00，决策树算法。</li>
<li>13:00-15:00，PAT两道题。</li>
<li>16:30-18:00，计算机组成原理3P。</li>
<li>19:00-21:00，Leetcode题型总结。</li>
<li>21:00-22:30，观看蓝桥杯试讲课决定是否买。</li>
</ul>
<p>现实：</p>
<p>PAT四道题。</p>
<h2 id="02-04"><a href="#02-04" class="headerlink" title="02.04"></a>02.04</h2><p>理想：</p>
<ul>
<li>8:30-9:30，计算机组成原理3P。</li>
<li>9:30-10:30，数据库练习。</li>
</ul>
<p>现实：</p>
<ul>
<li>四道PAT</li>
<li>计算机组成原理2P</li>
</ul>
<h2 id="02-05"><a href="#02-05" class="headerlink" title="02.05"></a>02.05</h2><p>理想：</p>
<ul>
<li>8:30-9:30，计算机原理3P。</li>
<li>9:30-10:30，数据库。</li>
<li>11:00-13:30，AVL树的基本操作，独立解决1123。</li>
<li>14:30-15:30，决策树原理。</li>
<li>16:00-18:00，购买蓝桥杯课程。</li>
<li>19:00-21:00，三道PAT。</li>
<li>21:30-22:30，Leetcode总结。</li>
</ul>
<h2 id="02-05-02-14"><a href="#02-05-02-14" class="headerlink" title="02.05-02.14"></a>02.05-02.14</h2><p>事儿干是干了，但干的不好，干的也不多，就没记，让这个记录断在这里好鞭策自己。</p>
<h2 id="02-15"><a href="#02-15" class="headerlink" title="02.15"></a>02.15</h2><p>理想：</p>
<ul>
<li>PAT五道题</li>
<li>数据库刷题</li>
</ul>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>9月散记</title>
    <url>/2020/09/06/9%E6%9C%88%E6%95%A3%E8%AE%B0/</url>
    <content><![CDATA[<p>开学了，学习计算机的时间不多了。</p>
<a id="more"></a>

<h1 id="9-6"><a href="#9-6" class="headerlink" title="9.6"></a>9.6</h1><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>10:30~11:00，计组–字符。</p>
<ul>
<li>字符</li>
<li>字符串</li>
<li>汉字编码</li>
</ul>
<p>11:00~12:00，开源项目Simple-Nes。</p>
<p>16:00~22:00，开源项目。</p>
<ul>
<li>安CMake和SFML，安装成功可是开源项目运行失败。</li>
<li>c/c++开源项目<ul>
<li>cJSON</li>
<li>MyTinySTL</li>
<li>Tinyhttpd</li>
<li>Linux0.11</li>
<li>Redis</li>
</ul>
</li>
</ul>
<h1 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h1><h2 id="时间线-1"><a href="#时间线-1" class="headerlink" title="时间线"></a>时间线</h2><p>0:00~0:30，Leetcode每日一题，完成本周计划。</p>
<ul>
<li>前K个高频元素（哈希+二元组排序）</li>
</ul>
<p>8:30~9:30，六级听力+两篇阅读。</p>
<p>13:10~13:30，Leetcode一题。</p>
<ul>
<li>二叉树的所有路径（简单遍历）</li>
</ul>
<p>19:00~22:00，CJSON学习。第一次读开源项目，由于c知识的匮乏，确实有些晦涩难懂，不过随着时间的推移，应当能越来越熟练。</p>
<h1 id="9-8"><a href="#9-8" class="headerlink" title="9.8"></a>9.8</h1><h2 id="时间线-2"><a href="#时间线-2" class="headerlink" title="时间线"></a>时间线</h2><p>0:00~0:10，Leetcode每日一题。</p>
<ul>
<li>组合（回溯）</li>
</ul>
<p>下午： Leetcode两道题，都是回溯。</p>
<ul>
<li>组合总和（自底向上）</li>
<li>组合总和II（自顶向下）</li>
</ul>
<p>19:30~21:30，计算机组成原理。</p>
<ul>
<li>奇偶校验</li>
<li>海明码校验<ul>
<li><a href="https://www.cnblogs.com/godoforange/p/12003676.html#1515052129" target="_blank" rel="noopener">参考资料</a></li>
</ul>
</li>
</ul>
<p>22:00~24:00，cJSON项目阅读完头文件。</p>
<h1 id="9-9"><a href="#9-9" class="headerlink" title="9.9"></a>9.9</h1><h2 id="时间线-3"><a href="#时间线-3" class="headerlink" title="时间线"></a>时间线</h2><p>白天，两道Leetcode。</p>
<ul>
<li>01矩阵（bfs/dp）</li>
<li>翻转二叉树以匹配先序序列（dfs）</li>
</ul>
<p>19:00~23:00，cJSON.c进行到127行。</p>
<h1 id="9-10"><a href="#9-10" class="headerlink" title="9.10"></a>9.10</h1><h2 id="时间线-4"><a href="#时间线-4" class="headerlink" title="时间线"></a>时间线</h2><p>18:30~22:00，cJSON。</p>
<hr>
<p>疑惑：</p>
<ul>
<li><p><code>print_number</code>函数</p>
<ul>
<li>if语句的前两种情况不明白为什么要开2和21的空间大小。</li>
</ul>
</li>
<li><p>类型的宏定义应该定义的是右移的位数？</p>
</li>
<li><p><code>pow2gt()</code>求比needed大的最小2次幂数有什么用</p>
</li>
<li><p><code>print_string</code>函数</p>
<ul>
<li>转义字符那段没看懂，为什么将<code>\b</code>-&gt;<code>b</code>？</li>
</ul>
</li>
<li><p><code>depth</code>和<code>fmt</code>这两个参数没有搞懂</p>
</li>
<li><p><code>update()</code>中，为什么不直接在原地<code>p-&gt;buffer+p-&gt;offset</code>位置之后申请<code>newsize - length</code>的空间</p>
</li>
<li><p>606行那个<code>i</code>好像有点问题（<code>fmt==1</code>时被锁定为<code>i = depth</code>）</p>
<ul>
<li>感觉上面的for循环的循环变量不应该是i</li>
</ul>
</li>
</ul>
<hr>
<h1 id="9-12"><a href="#9-12" class="headerlink" title="9.12"></a>9.12</h1><p>上午，图像处理水课。</p>
<p>下午 &amp;&amp; 晚上。</p>
<ul>
<li>cJSON开源项目，看完<code>print()</code>部分</li>
<li>linux的基本命令</li>
</ul>
<h1 id="9-13"><a href="#9-13" class="headerlink" title="9.13"></a>9.13</h1><ul>
<li>cJSON，parse部分两个函数</li>
<li>六级一套</li>
<li>原子物理作业</li>
</ul>
<h1 id="9-14"><a href="#9-14" class="headerlink" title="9.14"></a>9.14</h1><p>8:00~9:20，计组。</p>
<ul>
<li>定点数原码补码等</li>
</ul>
<p>晚上：发现了stl一处奇怪的地方。unordered_map m，当使用m[i]来访问了m[i]本来为空的情况，m[i]会被分配一个空间，而这使得hash表的size自增1。</p>
<h1 id="9-15-9-22"><a href="#9-15-9-22" class="headerlink" title="9.15-9.22"></a>9.15-9.22</h1><ul>
<li><p>网课学习</p>
<ul>
<li>计组：学完移位</li>
</ul>
</li>
<li><p>课外学习</p>
<ul>
<li>完成git的学习</li>
<li>完成Linux基本命令以及vim编辑器的使用</li>
</ul>
</li>
<li><p>Leetcode</p>
<ul>
<li>回溯（着重练习了回溯）</li>
<li>dfs</li>
</ul>
</li>
</ul>
<p><strong>由于之前事后总结的方法实施效率不高，决定改进为每天既有计划又有完成情况</strong></p>
<h1 id="9-23-周三"><a href="#9-23-周三" class="headerlink" title="9.23 周三"></a>9.23 周三</h1><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>上午<ul>
<li>原子物理课：听课，写作业前5题</li>
<li>热学课：听课，记笔记</li>
</ul>
</li>
<li>中午<ul>
<li>买本子，写实验报告（思考题）</li>
</ul>
</li>
<li>下午<ul>
<li>光电子课：光电子笔记，电动力学的笔记等</li>
<li>自习课：吃完饭直接去图书馆，先整理组会以及学习相应的固体物理知识</li>
</ul>
</li>
<li>晚上<ul>
<li>复习c++面向对象相关知识</li>
</ul>
</li>
</ul>
<h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><p>除了固体物理没学其他全部完成~</p>
<h1 id="9-24-周四"><a href="#9-24-周四" class="headerlink" title="9.24 周四"></a>9.24 周四</h1><h2 id="计划-1"><a href="#计划-1" class="headerlink" title="计划"></a>计划</h2><ul>
<li>上午<ul>
<li>电动力学课：前排，听课记笔记</li>
</ul>
</li>
<li>下午（图书馆）<ul>
<li>01背包问题</li>
<li>汇编一节课</li>
<li>计组两节课</li>
</ul>
</li>
<li>晚上（图书馆）<ul>
<li>计算机二级模考</li>
<li>组会内容总结，固体物理相关知识，文献搜索</li>
</ul>
</li>
</ul>
<h2 id="完成情况-1"><a href="#完成情况-1" class="headerlink" title="完成情况"></a>完成情况</h2><ul>
<li><p>上午 完成</p>
</li>
<li><p>下午 </p>
<ul>
<li>01背包问题√</li>
<li>计组两节课√</li>
</ul>
</li>
<li><p>晚上</p>
<ul>
<li>计算机二级模考（42分，判分系统服气）</li>
<li>人工智能课笔记总结</li>
</ul>
</li>
</ul>
<p>还是没有开展有关项目的学习，明天重点放在专业课上。</p>
<h1 id="9-25-周五"><a href="#9-25-周五" class="headerlink" title="9.25 周五"></a>9.25 周五</h1><h2 id="计划-2"><a href="#计划-2" class="headerlink" title="计划"></a>计划</h2><ul>
<li>上午 听课记笔记</li>
<li>中午（11:50-12:20） 实验数据处理完+</li>
<li>下午<ul>
<li>56节：人工智能作业，预习电动力学，Leetcode每日一题</li>
<li>78节：找固体物理的文献</li>
</ul>
</li>
<li>晚上<ul>
<li>7-9点：在老师办公室学光学，问项目问题</li>
<li>继续攻克背包问题</li>
</ul>
</li>
</ul>
<h2 id="完成情况-2"><a href="#完成情况-2" class="headerlink" title="完成情况"></a>完成情况</h2><p>$100%$</p>
<h1 id="9-26-周六"><a href="#9-26-周六" class="headerlink" title="9.26 周六"></a>9.26 周六</h1><h2 id="计划-3"><a href="#计划-3" class="headerlink" title="计划"></a>计划</h2><ul>
<li>上午 带着python人脸识别的书，记笔记</li>
<li>下午（13:00-17:00）<ul>
<li>背包问题搞完</li>
<li>mooc-os当成开源项目做</li>
</ul>
</li>
<li>晚上（18:00-22:00）<ul>
<li>电动力学预习</li>
<li>看文献</li>
<li>原子物理作业</li>
<li>光学作业</li>
<li>英才工程申报</li>
</ul>
</li>
</ul>
<h2 id="完成情况-3"><a href="#完成情况-3" class="headerlink" title="完成情况"></a>完成情况</h2><ul>
<li>背包问题只搞了三个</li>
<li>Linux安装python环境安装了半天</li>
<li>其他的尚可，论文没看完</li>
</ul>
<h1 id="9-27-周日"><a href="#9-27-周日" class="headerlink" title="9.27 周日"></a>9.27 周日</h1><h2 id="计划-4"><a href="#计划-4" class="headerlink" title="计划"></a>计划</h2><ul>
<li><p>上午（8:00-11:30）</p>
<ul>
<li><p>二级一套</p>
</li>
<li><p>光学作业</p>
</li>
<li><p>Linux下安装pycharm</p>
</li>
<li><p>多重背包III</p>
</li>
</ul>
</li>
<li><p>中午（12:30-14:00）</p>
<ul>
<li>看二级笔记</li>
</ul>
</li>
<li><p>晚上</p>
<ul>
<li>看文献</li>
<li>做报告ppt</li>
</ul>
</li>
<li><p>mooc-os</p>
</li>
</ul>
<h2 id="完成情况-4"><a href="#完成情况-4" class="headerlink" title="完成情况"></a>完成情况</h2><p>只完成了pycharm安装，二级一套以及看文献（还没看完）</p>
<ul>
<li>机器学习计划<ol>
<li>新建虚拟机，搞到全屏<ul>
<li>3MB内存+20MB空间存储</li>
</ul>
</li>
<li>删除原来的虚拟机</li>
<li>安装python和conda/pycharm</li>
<li>结合neatReader那本教材开始逐一学习</li>
</ol>
</li>
</ul>
<h1 id="9-28-周一"><a href="#9-28-周一" class="headerlink" title="9.28 周一"></a>9.28 周一</h1><h2 id="计划-5"><a href="#计划-5" class="headerlink" title="计划"></a>计划</h2><ul>
<li>上午12节（8:00-9:20）<ul>
<li>看计算物理网课 定题</li>
<li>看论文</li>
</ul>
</li>
<li>上午34节<ul>
<li>Leetcode116</li>
<li>光学作业<ul>
<li>习题1.5，1.6</li>
<li>习题2.1，2.2</li>
<li>牛顿环习题</li>
</ul>
</li>
</ul>
</li>
<li>中午 Leetcode117</li>
<li>下午实验课<ul>
<li>塞曼效应的数据处理</li>
<li>整理报告内容</li>
</ul>
</li>
<li>晚上图书馆（18:00-22:00）<ul>
<li>多重背包III</li>
<li>新虚拟机配置</li>
</ul>
</li>
<li>晚上<ul>
<li>电动力学预习</li>
<li>科研训练 定题</li>
</ul>
</li>
</ul>
<h2 id="完成情况-5"><a href="#完成情况-5" class="headerlink" title="完成情况"></a>完成情况</h2><p>由于论文太过晦涩，我从34节课到晚上的时间都用来看论文了。。</p>
<h1 id="9-29-周二"><a href="#9-29-周二" class="headerlink" title="9.29 周二"></a>9.29 周二</h1><h2 id="计划-6"><a href="#计划-6" class="headerlink" title="计划"></a>计划</h2><ul>
<li>上午12节 听课</li>
<li>上午34节 电子测试<ul>
<li>准备晚上报告</li>
<li>光学作业</li>
</ul>
</li>
<li>中午 多重背包III</li>
<li>下午58节 科研训练<ul>
<li>光学作业</li>
<li>电动力学作业</li>
</ul>
</li>
<li>晚上<ul>
<li>19:00-21:00，作报告</li>
<li>22:00- <ul>
<li>虚拟机Python环境配置</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>ES6学习笔记</title>
    <url>/2020/07/01/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/es6/" target="_blank" rel="noopener">这是ES 6的FCC链接</a><br><a href="https://www.runoob.com/w3cnote/es6-concise-tutorial.html" target="_blank" rel="noopener">ES 6</a>是Javascript语言的新一代标准，加入了很多新的功能和语法。</p>
<a id="more"></a>
<h2 id="ES-6"><a href="#ES-6" class="headerlink" title="ES 6"></a>ES 6</h2><h3 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h3><ul>
<li><strong>let关键字只在let命令所在的代码块里有效</strong><br>为了帮助理解这个<code>代码块</code>的概念，下面介绍一个实例：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'function scope'</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="string">'block scope'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Block scope i is: '</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Function scope i is: '</span>, i);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码最后会返回结果<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Block scope i is block scope</span><br><span class="line">Function scope is fuction scope</span><br></pre></td></tr></table></figure>
也就是i的赋值只在对应声明的function大模块和if模块里才会生效，let关键字可以连续声明两次变量而不报错，原因也是<strong>这两次let在不同的模块里</strong>。</li>
</ul>
<hr>
<h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>const声明的常量类似于一个指针，指向一个引用，而且const关键字也是在<strong>块区域内有效</strong>。另外我之前以为能够完全锁定一个变量，实则不然：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// 不合法</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">8</span>;  <span class="comment">// 合法，s被改为[5, 6, 8]</span></span><br></pre></td></tr></table></figure>
<p>也就是类似于这种对象，const只能保证无法直接更改原对象，但是像这种逐一修改的方式仍能改变原对象。<br>那么有没有更保险的方法，能够“锁住”对象呢？Javascript提供了一种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.freeze(obj);  </span><br><span class="line"><span class="comment">// Object.freeze()函数能够使得针对obj的修改全部被忽视</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在JavaScript中，通常不需要为函数命名，特别是在将一个函数作为参数传递给另一个函数时。取而代之的是，我们创建内联函数。从而不需要命名这些函数，因为我们不会在其他地方重用它们。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="string">"default name"</span>;</span><br><span class="line">    <span class="keyword">return</span> myVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段简单的函数可以被替换成下面的类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="string">"default name"</span>;</span><br><span class="line">    <span class="keyword">return</span> myVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而当函数只有返回值语句是，以上写法仍能够被简化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"default name"</span>;</span><br></pre></td></tr></table></figure>
<p>这三段代码都是等效的，显然第三种是最高效的写法。</p>
<p>若这个内联函数有参数，则应该被写成如下的样子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = <span class="function">(<span class="params">name = <span class="string">"default"</span></span>) =&gt;</span> name + <span class="string">"name"</span>;</span><br></pre></td></tr></table></figure>
<p>和其他语言一样，若传递了一个有意义的实参，参数值以传递值为准。</p>
<hr>
<h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>为了帮助我们创建更灵活的函数，ES6为函数参数引入了rest参数。使用rest参数，您可以创建具有可变数量参数的函数。这些参数存储在一个<strong>数组</strong>中，<strong>以后可以从函数内部访问该数组</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">howMany</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"You have passed "</span> + args.length + <span class="string">" arguments."</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(howMany(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)); </span><br><span class="line"><span class="comment">// You have passed 3 arguments.</span></span><br><span class="line"><span class="built_in">console</span>.log(howMany(<span class="string">"string"</span>, <span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123; &#125;)); </span><br><span class="line"><span class="comment">// You have passed 4 arguments.</span></span><br></pre></td></tr></table></figure>
<p>从这个FCC的实例中，可以看出来…args的length是与传入参数的数量有关的，而传入的参数共同构成了一个数组，数组名为<code>args</code>。</p>
<hr>
<h3 id="spread操作符"><a href="#spread操作符" class="headerlink" title="spread操作符"></a>spread操作符</h3><p>ES6引入了spread操作符，它允许我们在需要多个参数或元素的地方展开数组和其他表达式，这增强了代码的可读性和高效性。<code>···arr</code>返回一个未打包的数组。换句话说，它分散了数组。但是，spread操作符只能就地工作，比如在函数的参数或数组文字中。下面来看两个实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">6</span>, <span class="number">89</span>, <span class="number">3</span>, <span class="number">45</span>];</span><br><span class="line"><span class="keyword">const</span> maximus = <span class="built_in">Math</span>.max(...arr); <span class="comment">// returns 89</span></span><br><span class="line"><span class="keyword">const</span> spreaded = ...arr; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="析构赋值-destructing-assignment"><a href="#析构赋值-destructing-assignment" class="headerlink" title="析构赋值(destructing assignment)"></a>析构赋值(destructing assignment)</h3><p>析构赋值这部分涉及到的知识点比较多，我直接上实例：</p>
<h4 id="针对对象的赋值方式"><a href="#针对对象的赋值方式" class="headerlink" title="针对对象的赋值方式"></a>针对对象的赋值方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">name</span>:<span class="string">'John Doe'</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统的赋值方式</span></span><br><span class="line"><span class="keyword">const</span> userName = user.name;</span><br><span class="line"><span class="keyword">const</span> userAge = user.age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值方式一</span></span><br><span class="line"><span class="keyword">const</span> &#123;userName1, userAge1&#125; = user;</span><br><span class="line"><span class="comment">//赋值方式二</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>:userName2, <span class="attr">age</span>:userAge2&#125; = user;</span><br></pre></td></tr></table></figure>
<p>同理，这样的方式对嵌套的对象仍适用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  johnDoe: &#123; </span><br><span class="line">    age: <span class="number">34</span>,</span><br><span class="line">    email: <span class="string">'johnDoe@freeCodeCamp.com'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">johnDoe</span>: &#123; age, email &#125;&#125; = user;</span><br><span class="line"><span class="comment">//赋值方式一</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">johnDoe</span>: &#123; <span class="attr">age</span>: userAge, <span class="attr">email</span>: userEmail &#125;&#125; = user;</span><br><span class="line"><span class="comment">//赋值方式二</span></span><br></pre></td></tr></table></figure>

<h4 id="针对数组的赋值方式"><a href="#针对数组的赋值方式" class="headerlink" title="针对数组的赋值方式"></a>针对数组的赋值方式</h4><p>我们可以把这种方式看成是”省略”，这在python的编程思想中也比较常见（个人认为）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b,,, c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1,2,5</span></span><br></pre></td></tr></table></figure>
<p>除此以外rest参数在数组中也是适用的，如果将中间的三个逗号替换成rest：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>[a, b, ...arr] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [3,4,5,6,7]</span></span><br></pre></td></tr></table></figure>

<h4 id="针对函数参数的赋值方式"><a href="#针对函数参数的赋值方式" class="headerlink" title="针对函数参数的赋值方式"></a>针对函数参数的赋值方式</h4><p>修改前的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">profileData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age, nationality, location &#125; = profileData;</span><br><span class="line">  <span class="comment">// do something with these variables</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">&#123; name, age, nationality, location &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* do something with these fields */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这删除了一些额外的行，使我们的代码看起来整洁。这样做的另一个好处是<strong>不必在函数中操作整个对象，只需要在函数中复制所需的字段</strong>。<br>利用第二个好处我们再来修改一个实例，已知<code>stats</code>是一个<code>max</code>和<code>min</code>属性的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">stats</span>) =&gt;</span> (stats.max + stats.min) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">&#123;max, min&#125;</span>) =&gt;</span> (max + min) / <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，此处<code>max</code>和<code>min</code>并不一定是<code>stats</code>的全部属性，只要其属性名在<code>stats</code>中有同名的就可以。</p>
<hr>
<h3 id="模板语法和分隔符"><a href="#模板语法和分隔符" class="headerlink" title="模板语法和分隔符"></a>模板语法和分隔符</h3><p>这涉及到<code>$</code>和<code>`</code>两个符号，在<code>`</code>包围下的<code>$</code>符号才会生效：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Zodiac Hasbro"</span>,</span><br><span class="line">  age: <span class="number">56</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template literal with multi-line and string interpolation</span></span><br><span class="line"><span class="keyword">const</span> greeting = <span class="string">`Hello, my name is <span class="subst">$&#123;person.name&#125;</span>!</span></span><br><span class="line"><span class="string">I am <span class="subst">$&#123;person.age&#125;</span> years old.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting); <span class="comment">// prints</span></span><br><span class="line"><span class="comment">// Hello, my name is Zodiac Hasbro!</span></span><br><span class="line"><span class="comment">// I am 56 years old.</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="对象词法扩展"><a href="#对象词法扩展" class="headerlink" title="对象词法扩展"></a>对象词法扩展</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCar</span>(<span class="params">make, model, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 简写变量</span></span><br><span class="line">    make,  <span class="comment">// 等同于 make: make</span></span><br><span class="line">    model, <span class="comment">// 等同于 model: model</span></span><br><span class="line">    value, <span class="comment">// 等同于 value: value</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 属性可以使用表达式计算值</span></span><br><span class="line">    [<span class="string">'make'</span> + make]: <span class="literal">true</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 忽略 `function` 关键词简写对象函数</span></span><br><span class="line">    depreciate() &#123;</span><br><span class="line">      <span class="keyword">this</span>.value -= <span class="number">2500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car = getCar(<span class="string">'Barret'</span>, <span class="string">'Lee'</span>, <span class="number">40000</span>);</span><br><span class="line"><span class="comment">// output: &#123;</span></span><br><span class="line"><span class="comment">//     make: 'Barret',</span></span><br><span class="line"><span class="comment">//     model:'Lee',</span></span><br><span class="line"><span class="comment">//     value: 40000,</span></span><br><span class="line"><span class="comment">//     makeBarret: true,</span></span><br><span class="line"><span class="comment">//     depreciate: [Function: depreciate]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>可以达到的目的：</p>
<ol>
<li><strong>简写变量</strong></li>
<li>属性可以使用表达式计算值</li>
<li>忽略<code>function</code>关键词简写对象函数</li>
</ol>
<p>针对第三点可以参照下面的实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES 5写法</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Taylor"</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//ES 6写法</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Taylor"</span>,</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是ES 6提供的创建一个新对象的关键字。需要注意的是，类语法只是语法，而不是面向对象范式的成熟的基于类的实现，这与Java、Python、Ruby等语言不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShuttle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(targetPlanet) &#123;</span><br><span class="line">    <span class="keyword">this</span>.targetPlanet = targetPlanet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zeus = <span class="keyword">new</span> SpaceShuttle(<span class="string">'Jupiter'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>实例中的<code>constructor</code>相当于一个构造函数</li>
<li>类的命名一般采用UpperCamelCase的方式命名</li>
</ul>
<p>我们还可以从对象中获取值并设置对象中的属性值。这些通常称为getter和setter。Getter函数只是将对象私有变量的值返回(获取)给用户，而不需要用户直接访问私有变量。Setter函数用于根据传入Setter函数的值修改(设置)对象私有变量的值。这种更改可能涉及计算，甚至完全覆盖以前的值。这两种计算只要稍微熟悉C++和python的应该都不陌生。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(author) &#123;</span><br><span class="line">    <span class="keyword">this</span>._author = author;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> writer() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._author;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> writer(updatedAuthor) &#123;</span><br><span class="line">    <span class="keyword">this</span>._author = updatedAuthor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lol = <span class="keyword">new</span> Book(<span class="string">'anonymous'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lol.writer);  <span class="comment">// anonymous</span></span><br><span class="line">lol.writer = <span class="string">'wut'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(lol.writer);  <span class="comment">// wut</span></span><br></pre></td></tr></table></figure>
<p>这样就能实现对象的writer属性既可以被访问也可以被更改了。<br>下面是利用这个原理，写出的摄氏度单位转换实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thermostat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fahrenheit) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fahrenheit = fahrenheit;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> temperature() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">5</span> / <span class="number">9</span>) * (<span class="keyword">this</span>.fahrenheit - <span class="number">32</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> temperature(celsius) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fahrenheit = (celsius * <span class="number">9.0</span>) / <span class="number">5</span> + <span class="number">32</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="export-amp-import"><a href="#export-amp-import" class="headerlink" title="export&amp;import"></a><code>export</code>&amp;<code>import</code></h3><p>直接上实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math_function.js</span></span><br><span class="line"><span class="keyword">export</span>&#123;add, subtract&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;add,subtract&#125; <span class="keyword">from</span> <span class="string">'./math_functions'</span> ;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myMathModule <span class="keyword">from</span> <span class="string">'./math_functions'</span> ; <span class="comment">// import everything</span></span><br></pre></td></tr></table></figure>
<p>而当只用到该文件的一个函数时，我们有一种简单的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math_function.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">multiple</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125; <span class="comment">// 当只用从该文件中导出一个函数时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> multiple <span class="keyword">from</span> <span class="string">'./math_functions'</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Promise构造"><a href="#Promise构造" class="headerlink" title="Promise构造"></a>Promise构造</h3><p>一个promise有三种状态：<code>pending</code>,<code>fulfilled</code>和<code>rejected</code>。您在上一个挑战中创建的承诺将永远处于挂起状态，因为您没有添加完成该承诺的方法。提供给promise参数的<code>resolve</code>和<code>reject</code>参数用于执行此操作。当你希望你的承诺成功时，就用<code>resolve</code>，而当你希望它失败时，就用<code>reject</code>。<br>以下是promise的使用模板：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(condition here) &#123;</span><br><span class="line">    resolve(<span class="string">"Promise was fulfilled"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">"Promise was rejected"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>承诺在当你有一个进程在你的代码中花费了未知的时间(例如一些异步的事情，通常是一个服务器请求)是管用的。当您发出一个服务器请求时，它会花费一定的时间，在请求完成后，您通常需要对服务器的响应进行处理。这可以通过使用<code>then</code>方法来实现。<code>then</code>方法会在您的承诺被坚定地实现之后立即执行。这是它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myPromise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something with the result.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>与<code>then</code>相对应的有<code>catch</code>，<code>catch</code>是当你的承诺被拒绝时使用的方法。它在调用承诺的<code>reject</code>方法后立即执行。下面是它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myPromise.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something with the error.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>所以一个promise的完整架构为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> makeServerRequest = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// responseFromServer is set to false to represent an unsuccessful response from a server</span></span><br><span class="line">  <span class="keyword">let</span> responseFromServer = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(responseFromServer) &#123;</span><br><span class="line">    resolve(<span class="string">"We got the data"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    reject(<span class="string">"Data not received"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">makeServerRequest.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br><span class="line">makeServerRequest.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<p>到这里就是ES6课程的全部内容了，完结撒花~</p>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Basic Javascript学习笔记</title>
    <url>/2020/06/30/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>　　昨天刚刚搭建了自己的博客，这也算是自己写的第一个blog吧.</p>
<p>　　最近刚刚学习到前端的相关知识，在<a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="noopener">FreeCodeCamp</a>上练习<a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/basic-javascript/" target="_blank" rel="noopener">Basic Javascript</a>的基础知识，知识体系有点混乱，这篇笔记也是帮助自己理清一下思路。</p>
<a id="more"></a>

<h2 id="Basic-javascript"><a href="#Basic-javascript" class="headerlink" title="Basic javascript"></a>Basic javascript</h2><p><em>注：不按系统知识记，只记录自己不熟的知识点</em></p>
<hr>
<h3 id="字符串不变性"><a href="#字符串不变性" class="headerlink" title="字符串不变性"></a>字符串不变性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> usedString = <span class="string">"Bob"</span>;</span><br><span class="line">usedString[<span class="number">0</span>] = <span class="string">'J'</span>;</span><br></pre></td></tr></table></figure>
<p>以上这段代码并不能修改<code>usedString</code> 为<code>&quot;Job&quot;</code>的输出，这就是字符串的不变性。要想实现替换的话，只能将字符串重新赋值。</p>
<hr>
<h3 id="push-pop-shift-unshift方法"><a href="#push-pop-shift-unshift方法" class="headerlink" title="push, pop, shift, unshift方法"></a>push, pop, shift, unshift方法</h3><ul>
<li>push()将括号中的数据追加到数组的末尾</li>
<li>pop()用来抛出数组的末尾数据，同时还可以将该数据赋给一个变量</li>
<li>shift()抛出第一个数据，其他和pop()一样</li>
<li>unshift()将该数据移到数组的开头</li>
</ul>
<p><strong>用这些方法能够很容易的实现经典的数据结构–堆栈</strong></p>
<hr>
<h3 id="对象（python的字典）"><a href="#对象（python的字典）" class="headerlink" title="对象（python的字典）"></a>对象（python的字典）</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="new详解"><a href="#new详解" class="headerlink" title="new详解"></a>new详解</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">constructor</span>[([arguments])]; //new的声明</span><br></pre></td></tr></table></figure>
<p>对两个参数的解释为</p>
<ul>
<li><code>constructor</code>一个指定对象实例的类型的<strong>类或函数</strong>。</li>
<li><code>arguments</code>一个用于被 constructor 调用的参数列表。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">&#125; <span class="comment">// 这个function其实就是个(构造)函数，ES6中改进成了类中的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car(<span class="string">'Eagle'</span>, <span class="string">'Talon TSi'</span>, <span class="number">1993</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car1.make);</span><br><span class="line"><span class="comment">// expected output: "Eagle"</span></span><br></pre></td></tr></table></figure>
<p><code>new</code>操作符做了什么？</p>
<ol>
<li>创建obj{}对象</li>
<li>将函数的作用域赋给新对象</li>
<li>执行函数（为对象初始化，添加..）</li>
<li>考察第3步返回的返回值，无返回值或者返回一个非对象值时，则将创建的新对象返回，否则会将返回值作为新对象返回。</li>
</ol>
<p>如果代码层面看的更深，当<code>new Foo(..)</code>执行时：</p>
<ol>
<li>一个继承自<code>Foo.prototype</code>的新对象被创建。（<code>prototype</code>-&gt;原型对象）</li>
<li>使用指定参数调用构造函数<code>Foo</code>，并<strong>将<code>this</code>绑定到新创建的对象，也就是没有指定参数列表，<code>Foo</code>不带任何参数调用的情况</strong>（然后开始执行函数）。</li>
<li>由构造函数返回的对象就是<code>new</code>表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li>
</ol>
<h4 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h4><h5 id="中括号访问"><a href="#中括号访问" class="headerlink" title="中括号访问"></a>中括号访问</h5><p>中括号访问可以进行多层寻找，而且中间的属性名称可以是来自于某个变量的值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> johnsonOneOfTheSportHobby;</span><br><span class="line"><span class="keyword">var</span> myInfo=&#123;</span><br><span class="line">    name: <span class="string">"Johnson"</span>,</span><br><span class="line">    sex: <span class="string">"male"</span>,</span><br><span class="line">    hobby_sport: &#123;<span class="string">"basketball"</span>, <span class="string">"swimming"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">johnsonOneOfTheSportHobby = myInfo[hobby_sport][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h5 id="点操作符访问"><a href="#点操作符访问" class="headerlink" title="点操作符访问"></a>点操作符访问</h5><p>点操作符的使用场景比较局限。只有属性名称已知的话，才可以使用点操作符，<strong>变量名+点操作符访问变量的操作不合法</strong>，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> johnsonOneOfTheSportHobby;</span><br><span class="line"><span class="keyword">var</span> property = sex;</span><br><span class="line"><span class="keyword">var</span> myInfo=&#123;</span><br><span class="line">    name: <span class="string">"Johnson"</span>,</span><br><span class="line">    sex: <span class="string">"male"</span>,</span><br><span class="line">    hobby_sport: &#123;<span class="string">"basketball"</span>, <span class="string">"swimming"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">johnsonSex = myInfo.property; <span class="comment">// 不正确</span></span><br><span class="line">johnsonSex = myInfo.sex; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="更新方式"><a href="#更新方式" class="headerlink" title="更新方式"></a>更新方式</h4><p><em>以下中括号方式修改也可</em></p>
<h5 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> myInfo.sex; <span class="comment">// 删除myInfo的sex属性</span></span><br></pre></td></tr></table></figure>
<h5 id="更改数据"><a href="#更改数据" class="headerlink" title="更改数据"></a>更改数据</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myInfo.sex = <span class="string">"female"</span>; <span class="comment">// 更改Info中的属性</span></span><br></pre></td></tr></table></figure>
<h5 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myInfo.job = <span class="string">"coder"</span>;  <span class="comment">// 添加job属性，并将数据初始化为coder</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="判断方式"><a href="#判断方式" class="headerlink" title="判断方式"></a>判断方式</h4><h5 id="判断属性是否存在"><a href="#判断属性是否存在" class="headerlink" title="判断属性是否存在"></a>判断属性是否存在</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(myInfo.hasOwnProperty(job) == <span class="literal">false</span>)&#123;</span><br><span class="line">    myInfo.job = <span class="string">"coder"</span>;  </span><br><span class="line">    <span class="comment">// 如果没有job属性，则添加该属性并初始化为coder</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="JavaScript-Object-Notation-JSON"><a href="#JavaScript-Object-Notation-JSON" class="headerlink" title="JavaScript Object Notation(JSON)"></a>JavaScript Object Notation(JSON)</h4><p><strong>JSON使用Javascript对象的格式来存储数据</strong>，JSON是灵活的，因为它允许多种数据结构的任意组合，下面来看一个JSON的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyFriend=[</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">"Iris"</span>,</span><br><span class="line">        sex: <span class="string">"female"</span>,</span><br><span class="line">        hobby_sport: [<span class="string">"basketball"</span>, <span class="string">"movie"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">"Kevin Durant"</span>,</span><br><span class="line">        sex: <span class="string">"male"</span>,</span><br><span class="line">        hobby_sport: [<span class="string">"basketball"</span>, <span class="string">"chatting"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>JSON可以按一种类似串联的方式，来访问格式中的某个数据，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">girlfriendHobby = MyFriend[<span class="number">0</span>].hobby_sport[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex备忘录</title>
    <url>/2020/09/24/Latex%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<p>latex太难记了……</p>
<a id="more"></a>

<p><a href="https://www.jianshu.com/p/3f7f984d0d66" target="_blank" rel="noopener">希腊字母</a></p>
<p><a href="https://www.jianshu.com/p/8aa646fad1c5" target="_blank" rel="noopener">导数</a></p>
<p><a href="https://blog.csdn.net/luohuiwu/article/details/80722026" target="_blank" rel="noopener">矩阵</a></p>
<h1 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\quad</span><br></pre></td></tr></table></figure>

<h1 id="epsilon"><a href="#epsilon" class="headerlink" title="$\epsilon$"></a>$\epsilon$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\epsilon</span><br></pre></td></tr></table></figure>

<h1 id="cdot"><a href="#cdot" class="headerlink" title="$\cdot$"></a>$\cdot$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\cdot</span><br></pre></td></tr></table></figure>

<h1 id="times"><a href="#times" class="headerlink" title="$\times$"></a>$\times$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\times</span><br></pre></td></tr></table></figure>

<h1 id="approx"><a href="#approx" class="headerlink" title="$\approx$"></a>$\approx$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\approx</span><br></pre></td></tr></table></figure>

<h1 id="nabla"><a href="#nabla" class="headerlink" title="$\nabla$"></a>$\nabla$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\nabla</span><br></pre></td></tr></table></figure>

<h1 id="phi"><a href="#phi" class="headerlink" title="$\phi$"></a>$\phi$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\phi</span><br></pre></td></tr></table></figure>

<h1 id="lambda"><a href="#lambda" class="headerlink" title="$\lambda$"></a>$\lambda$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\lambda</span><br></pre></td></tr></table></figure>

<h1 id="Sigma"><a href="#Sigma" class="headerlink" title="$\Sigma$"></a>$\Sigma$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\Sigma</span><br></pre></td></tr></table></figure>

<h1 id="sum-k-1-n"><a href="#sum-k-1-n" class="headerlink" title="$\sum_{k = 1}^n$"></a>$\sum_{k = 1}^n$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\sum_&#123;k &#x3D; 1&#125;^n</span><br></pre></td></tr></table></figure>

<h1 id="propto"><a href="#propto" class="headerlink" title="$\propto$"></a>$\propto$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\propto</span><br></pre></td></tr></table></figure>

<h1 id="nu"><a href="#nu" class="headerlink" title="$\nu$"></a>$\nu$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\nu</span><br></pre></td></tr></table></figure>

<h1 id="rho"><a href="#rho" class="headerlink" title="$\rho$"></a>$\rho$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\rho</span><br></pre></td></tr></table></figure>

<h1 id="pm"><a href="#pm" class="headerlink" title="$\pm$"></a>$\pm$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\pm</span><br></pre></td></tr></table></figure>

<h1 id="int"><a href="#int" class="headerlink" title="$\int$"></a>$\int$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\int</span><br></pre></td></tr></table></figure>

<h1 id="iint"><a href="#iint" class="headerlink" title="$\iint$"></a>$\iint$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\iint</span><br></pre></td></tr></table></figure>

<h1 id="bar-x"><a href="#bar-x" class="headerlink" title="$\bar x$"></a>$\bar x$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\bar x</span><br></pre></td></tr></table></figure>

<h1 id="hbar"><a href="#hbar" class="headerlink" title="$\hbar$"></a>$\hbar$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\hbar</span><br></pre></td></tr></table></figure>

<h1 id="prod"><a href="#prod" class="headerlink" title="$\prod$"></a>$\prod$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\prod</span><br></pre></td></tr></table></figure>

<h1 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x) &#x3D; </span><br><span class="line">\left\&#123;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">x &#x3D; 1 \\</span><br><span class="line">y &#x3D; 2 \\</span><br><span class="line">z &#x3D; 3 \\</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\right.</span><br></pre></td></tr></table></figure>

<p>$$<br>f(x) =<br>\left{<br>\begin{aligned}<br>x = 1 \<br>y = 2 \<br>z = 3 \<br>\end{aligned}<br>\right.<br>$$</p>
<h1 id="wedge"><a href="#wedge" class="headerlink" title="$\wedge$"></a>$\wedge$</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\wedge</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Leetcode_202101</title>
    <url>/2021/01/20/Leetcode-202101/</url>
    <content><![CDATA[<p>从去年十二月到今天整整1个月没有刷题，先进入恢复阶段，依旧按照题型分类，过两天把所有做过的汇总一下。</p>
<a id="more"></a>

<h1 id="脑筋急转弯"><a href="#脑筋急转弯" class="headerlink" title="脑筋急转弯"></a>脑筋急转弯</h1><h2 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605 种花问题"></a>605 种花问题</h2><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>, num = <span class="number">0</span>; <span class="comment">// assume to append 0 first</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// every 3 space can plant one flower</span></span><br><span class="line">                num++;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">2</span>) num++;</span><br><span class="line">        <span class="keyword">return</span> n &lt;= num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>key point:</p>
<ul>
<li>整数数组顺序遍历边界补零法</li>
<li>从信息中挖掘出连续三个空花坛能种一盆花</li>
<li>这三个花坛组成的是滑动窗口</li>
</ul>
<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189 旋转数组"></a>189 旋转数组</h2><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[l];</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            nums[r] = tmp;</span><br><span class="line">            l++; r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reverese for 3 times</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k %= n; <span class="comment">// key point!!!</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>经典的平移问题转换成三次翻转，注意k一定要取余。</p>
<h2 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228 汇总区间"></a>228 汇总区间</h2><p><a href="https://leetcode-cn.com/problems/summary-ranges/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">summaryRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            ans.push_back(to_string(nums[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[r] - r == nums[l] - l) &#123; <span class="comment">// avoid overflow</span></span><br><span class="line">                    r++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                        ans.push_back(to_string(nums[l]));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ans.push_back(to_string(nums[l]) + <span class="string">"-&gt;"</span> + to_string(nums[r - <span class="number">1</span>]));</span><br><span class="line">                    &#125;</span><br><span class="line">                    l = r;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) ans.push_back(to_string(nums[l]));</span><br><span class="line">        <span class="keyword">else</span> ans.push_back(to_string(nums[l]) + <span class="string">"-&gt;"</span> + to_string(nums[r - <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>key point:</p>
<ul>
<li>这题数据范围是$-2^{31} &lt;= nums[i] &lt;= 2^{31}-1$，不能直接相加减</li>
</ul>
<h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">summaryRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">string</span> temp = to_string(nums[low]);</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                temp.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">                temp.append(to_string(nums[high]));</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(<span class="built_in">move</span>(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665 非递减数列"></a>665 非递减数列</h2><p>给你一个长度为 <code>n</code> 的整数数组，请你判断在 <strong>最多</strong> 改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p>
<p>存在以下两种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当nums[i] &gt;&#x3D; nums[i - 2]</span><br><span class="line">                x               </span><br><span class="line">                    x     -&gt;      x   x    更正：nums[i - 1] &#x3D; nums[i] # 无药可救</span><br><span class="line">             x                 x</span><br><span class="line">             </span><br><span class="line">当nums[i] &lt; nums[i - 2]</span><br><span class="line"></span><br><span class="line">                x                x   x     更正：nums[i] &#x3D; nums[i - 1] # 尚有希望</span><br><span class="line">             x            -&gt;  x</span><br><span class="line">                   x</span><br></pre></td></tr></table></figure>

<p>我们对下面这种情况采取“医治”，对上面这种情况采取”弃疗“（因为大小为2的窗口始终在向后移动，对于第一种情况的修改nums[i-1]已经是一种无用功了），只要再次出现这种情况，就被认定为false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; nums[i] &lt; nums[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                    nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395 至少有 K 个重复字符的最长子串"></a>395 至少有 K 个重复字符的最长子串</h2><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p>
<p>分治法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            cnt[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &lt; k &amp;&amp; cnt[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r - l + <span class="number">1</span>; <span class="comment">// if no char appear less than k, ans is len</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = l, length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s[i] - <span class="string">'a'</span>) == idx) &#123;</span><br><span class="line">                length = <span class="built_in">max</span>(length, dfs(s, left, i - <span class="number">1</span>, k));</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(length, dfs(s, left, r, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>注意：并查集是一边查询一边压缩的！</p>
<h2 id="990-等式方程的可满足性"><a href="#990-等式方程的可满足性" class="headerlink" title="990 等式方程的可满足性"></a>990 等式方程的可满足性</h2><p>这题其实和并查集的第一个例题–好朋友那道题特像。</p>
<p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> father[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != father[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> org = father[x];</span><br><span class="line">            father[x] = <span class="built_in">find</span>(father[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fA = <span class="built_in">find</span>(a);</span><br><span class="line">        <span class="keyword">int</span> fB = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (fA != fB) &#123;</span><br><span class="line">            father[fA] = fB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) father[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (equations[i][<span class="number">1</span>] == <span class="string">'='</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = equations[i][<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> b = equations[i][<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">                Union(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (equations[i][<span class="number">1</span>] == <span class="string">'!'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = equations[i][<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> b = equations[i][<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> fA = <span class="built_in">find</span>(a);</span><br><span class="line">                <span class="keyword">int</span> fB = <span class="built_in">find</span>(b);</span><br><span class="line">                <span class="keyword">if</span> (fA == fB) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>key point:</p>
<ul>
<li>最后一个for循环时，一定要用find函数获取父亲，而不是用father[a]获取！这是由并查集<strong>边查边改</strong>的特色决定的。</li>
</ul>
<h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547 省份数量"></a>547 省份数量</h2><p><a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener">题目链接</a></p>
<p>同样用并查集解决，然后结尾要求输出省份数量（数组中总共有多少个不同的值），用一个<code>isRoot[]</code>的辅助数组解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (father[x] != x) &#123;</span><br><span class="line">            father[x] = findFather(father[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fA = findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fB = findFather(y);</span><br><span class="line">        <span class="keyword">if</span> (fA != fB) &#123;</span><br><span class="line">            father[fA] = fB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> isRoot[n];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(isRoot, <span class="number">0</span>, <span class="keyword">sizeof</span> isRoot);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            isRoot[findFather(i)] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cnt += isRoot[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        n = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        father.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    Union(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// traverse to find the nums of different value</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numOfSet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399 除法求值"></a>399 除法求值</h2><p><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">题目链接</a></p>
<p>这道题的将900的并查集扩展到了<strong>有权状态下的并查集</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sToId;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (father[x] != x) &#123;</span><br><span class="line">            <span class="keyword">int</span> curOrigin = father[x];</span><br><span class="line">            father[x] = findFather(father[x]); <span class="comment">// find "father's father.."</span></span><br><span class="line">            weight[x] *= weight[curOrigin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fA = findFather(a);</span><br><span class="line">        <span class="keyword">int</span> fB = findFather(b);</span><br><span class="line">        <span class="keyword">if</span> (fA != fB) &#123;</span><br><span class="line">            <span class="comment">// if the two unions haven't been combined</span></span><br><span class="line">            father[fA] = fB;</span><br><span class="line">            weight[fA] = value * weight[b] / weight[a];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">searchForRes</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fA = findFather(a);</span><br><span class="line">        <span class="keyword">int</span> fB = findFather(b);</span><br><span class="line">        <span class="keyword">if</span> (fA == fB) &#123;</span><br><span class="line">            <span class="keyword">return</span> weight[a] / weight[b];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// initialize, point at itself</span></span><br><span class="line">        n = equations.<span class="built_in">size</span>();</span><br><span class="line">        father.resize(<span class="number">2</span> * n);</span><br><span class="line">        weight.resize(<span class="number">2</span> * n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">            weight[i] = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// string -&gt; id -&gt; disjoint set</span></span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> s1 = equations[i][<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">string</span> s2 = equations[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sToId.<span class="built_in">find</span>(s1) == sToId.<span class="built_in">end</span>()) sToId[s1] = id++;</span><br><span class="line">            <span class="keyword">if</span> (sToId.<span class="built_in">find</span>(s2) == sToId.<span class="built_in">end</span>()) sToId[s2] = id++;</span><br><span class="line"></span><br><span class="line">            Union(sToId[s1], sToId[s2], values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// finish the query</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> s1 = queries[i][<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">string</span> s2 = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> id1 = <span class="number">-1</span>, id2 = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (sToId.<span class="built_in">find</span>(s1) != sToId.<span class="built_in">end</span>()) id1 = sToId[s1];</span><br><span class="line">            <span class="keyword">if</span> (sToId.<span class="built_in">find</span>(s2) != sToId.<span class="built_in">end</span>()) id2 = sToId[s2];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (id1 == <span class="number">-1</span> || id2 == <span class="number">-1</span>) &#123;</span><br><span class="line">                ans.emplace_back(<span class="number">-1.0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.emplace_back(searchForRes(id1, id2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><ol>
<li><p>窗口大小可变</p>
<ul>
<li>424</li>
<li>1208</li>
<li>1438</li>
</ul>
</li>
<li><p>窗口大小不变</p>
<ul>
<li>995</li>
</ul>
</li>
</ol>
<h2 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424 替换后的最长重复字符"></a>424 替换后的最长重复字符</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">size</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, len = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            cnt[s[r] - <span class="string">'A'</span>]++;</span><br><span class="line">            len = <span class="built_in">max</span>(len, cnt[s[r] - <span class="string">'A'</span>]); <span class="comment">// get the historical maxapp</span></span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> - len &gt; k) &#123;</span><br><span class="line">                cnt[s[l++] - <span class="string">'A'</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1208-尽可能使字符串相等"><a href="#1208-尽可能使字符串相等" class="headerlink" title="1208 尽可能使字符串相等"></a>1208 尽可能使字符串相等</h2><p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p>
<p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p>
<p>用于变更字符串的最大预算是 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p>
<p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p>
<p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p>
<p><strong>解法：滑动窗口，相当于将原问题转换成在一个cost数组($cost[i] = abs(s[i] - t[i])$)中求连续最长长度使得加和sum不大于maxCost。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sliding window</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, sum = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            sum += <span class="built_in">abs</span>(s[r] - t[r]);</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; maxCost) &#123;</span><br><span class="line">                sum -= <span class="built_in">abs</span>(s[l] - t[l++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="995-K连续位的最小翻转次数"><a href="#995-K连续位的最小翻转次数" class="headerlink" title="995 K连续位的最小翻转次数"></a>995 K连续位的最小翻转次数</h2><p>在仅包含 <code>0</code> 和 <code>1</code> 的数组 <code>A</code> 中，一次 <em><code>K</code> 位翻转</em>包括选择一个长度为 <code>K</code> 的（连续）子数组，同时将子数组中的每个 <code>0</code> 更改为 <code>1</code>，而每个 <code>1</code> 更改为 <code>0</code>。</p>
<p>返回所需的 <code>K</code> 位翻转的最小次数，以便数组没有值为 <code>0</code> 的元素。如果不可能，返回 <code>-1</code>。</p>
<h3 id="法1：差分数组diff"><a href="#法1：差分数组diff" class="headerlink" title="法1：差分数组diff"></a>法1：差分数组diff</h3><ul>
<li><p><code>diff[i]</code>表示当前第<code>i</code>个元素和第<code>i - 1</code>个元素的翻转次数差。<code>diff</code>更新只与窗口的首元素和末元素有关（<code>diff[l]</code>和<code>diff[r + 1]</code>）。</p>
</li>
<li><p>用<code>revCnt</code>表示当前被遍历位的反转次数。<code>revCnt</code>的更新是根据<code>diff[]</code>的前缀和</p>
</li>
<li><p>判断当前元素是否需要翻转的依据是<code>(A[i] + revCnt)</code>是否为偶数。若为偶数则需要翻转，否则不需要进行任何操作。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, revCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            revCnt += diff[i];</span><br><span class="line">            <span class="keyword">if</span> ((A[i] + revCnt) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + K &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++ans;</span><br><span class="line">                ++revCnt;</span><br><span class="line">                --diff[i + K];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模2意义下的加减法与异或等价：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, revCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            revCnt ^= diff[i];</span><br><span class="line">            <span class="keyword">if</span> (A[i] == revCnt) &#123; <span class="comment">// A[i] ^ revCnt == 0</span></span><br><span class="line">                <span class="keyword">if</span> (i + K &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++ans;</span><br><span class="line">                revCnt ^= <span class="number">1</span>;</span><br><span class="line">                diff[i + K] ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="法2：滑动窗口"><a href="#法2：滑动窗口" class="headerlink" title="法2：滑动窗口"></a>法2：滑动窗口</h3><p>将空间优化成$O(1)$。不需要diff数组，改为将原数组元素替换成输入空间$[0, 1]$以外范围的数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, revCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= K &amp;&amp; A[i - K] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                revCnt ^= <span class="number">1</span>;</span><br><span class="line">                A[i - K] -= <span class="number">2</span>; <span class="comment">// 复原数组元素，若允许修改数组 A，则可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == revCnt) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + K &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++ans;</span><br><span class="line">                revCnt ^= <span class="number">1</span>;</span><br><span class="line">                A[i] += <span class="number">2</span>; <span class="comment">// 相当于修改diff</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438 绝对差不超过限制的最长连续子数组"></a>1438 绝对差不超过限制的最长连续子数组</h2><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code>。</p>
<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>
<h3 id="法1：滑窗-有序集合-multiset"><a href="#法1：滑窗-有序集合-multiset" class="headerlink" title="法1：滑窗+有序集合(multiset)"></a>法1：滑窗+有序集合(multiset)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            s.insert(nums[r]);</span><br><span class="line">            <span class="keyword">while</span> (*s.rbegin() - *s.<span class="built_in">begin</span>() &gt; limit) &#123;</span><br><span class="line">                <span class="comment">// 当最大值最小值差太多，尝试缩小窗口</span></span><br><span class="line">                s.erase(s.<span class="built_in">find</span>(nums[l++]));</span><br><span class="line">            &#125;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, r - l + <span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="法2：滑窗-双端队列-deque"><a href="#法2：滑窗-双端队列-deque" class="headerlink" title="法2：滑窗+双端队列(deque)"></a>法2：滑窗+双端队列(deque)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; qMax, qMin;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="comment">// part A</span></span><br><span class="line">            <span class="keyword">while</span> (!qMax.empty() &amp;&amp; qMax.back() &lt; nums[r]) &#123;</span><br><span class="line">                <span class="comment">// 维护qMax，将nums[r]加入集合，使得后端小于nums[r]的数据全部出队</span></span><br><span class="line">                qMax.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!qMin.empty() &amp;&amp; qMin.back() &gt; nums[r]) &#123;</span><br><span class="line">                <span class="comment">// 维护qMin，将nums[r]加入集合，使得后端大于nums[r]的数据全部出队</span></span><br><span class="line">                qMin.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            qMax.push_back(nums[r]);</span><br><span class="line">            qMin.push_back(nums[r]);</span><br><span class="line">            <span class="keyword">while</span> (!qMax.empty() &amp;&amp; !qMin.empty() &amp;&amp; qMax.front() - qMin.front() &gt; limit) &#123;</span><br><span class="line">                <span class="comment">// 尝试缩小窗口</span></span><br><span class="line">                <span class="keyword">if</span> (nums[l] == qMin.front()) &#123;</span><br><span class="line">                    <span class="comment">// 只需要关注队列首端?这个最优性不会证</span></span><br><span class="line">                    qMin.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] == qMax.front()) &#123;</span><br><span class="line">                    qMax.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><del>目前不太懂最后一个注释那部分，在调整双端队列时，只删除与即将压缩窗口的左端元素<code>num[l]</code>相等的首端元素？</del></p>
<p><del>例如序列<code>qMax = {8 4 2}</code>，<code>nums[l] = 4</code>，此时序列中间的4无法被删除，然后<code>l++</code>，<code>nums[l] = 8</code>此时删掉了8之后，序列就变为<code>4 2</code>，这样在下一轮r自增时，<code>qMax</code>就有可能认为当前窗口最大值为4，然而实际上4应该已经被排除在窗口外了。</del></p>
<p>已经想通了，在partA更新的过程中，我所说的这种位于非首端非尾端的元素，在前面的更新中一定会因为来了一个更大的元素在<code>qMax</code>将其剪枝，一个更小的元素在<code>qMin</code>将其剪枝。<code>nums[l]</code>体现在两个双端队列中，一定是一个队首队尾元素或者一个已经在队列中被剔除的元素。</p>
]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记II</title>
    <url>/2020/07/19/Leetcode%E6%97%A5%E8%AE%B0II/</url>
    <content><![CDATA[<p>最近Leetcode的刷题量大大增加，我一定会学有所成的！<br>本篇将按专题分类整理，主要包括树和图论两类题目。</p>
<a id="more"></a>
<h3 id="树-递归专题"><a href="#树-递归专题" class="headerlink" title="树-递归专题"></a>树-递归专题</h3><h4 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (root == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">max</span>(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><strong><em>平衡二叉树的定义：根节点的左子树是平衡二叉树，右子树是平衡二叉树，且它的左右子树的高度差不大于1。</em></strong></p>
<h5 id="自顶向下递归法"><a href="#自顶向下递归法" class="headerlink" title="自顶向下递归法"></a>自顶向下递归法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(Depth(root-&gt;left), Depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(Depth(root-&gt;left) - Depth(root-&gt;right)) &gt; <span class="number">1</span>) &#123; <span class="comment">// 查看当前根节点的左右子树是否满足，不满足直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 否则，继续递归看左右子树是否满足</span></span><br><span class="line">                <span class="keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="自底向上递归法"><a href="#自底向上递归法" class="headerlink" title="自底向上递归法"></a>自底向上递归法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 返回根节点是否平衡，并且保存树高度为一个引用变量</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalancedTreeHelper</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空树是平衡的，高度为-1</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">height</span> = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查子树是否平衡，如果平衡则通过递归调用返回的高度来判断当前结点是否平衡</span></span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="keyword">if</span> (isBalancedTreeHelper(root-&gt;left, left)  &amp;&amp;</span><br><span class="line">            isBalancedTreeHelper(root-&gt;right, right) &amp;&amp;</span><br><span class="line">            <span class="built_in">abs</span>(left - right) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 保存当前结点的高度</span></span><br><span class="line">            <span class="built_in">height</span> = <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalancedTreeHelper(root, <span class="built_in">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span> || rightHeight == <span class="number">-1</span> || <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h4><p>将一个二叉树对称翻转。</p>
<h5 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自顶向下递归</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;right = invertTree(root-&gt;right);       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="多种遍历方法求解"><a href="#多种遍历方法求解" class="headerlink" title="多种遍历方法求解"></a>多种遍历方法求解</h5><p>出自sunchunlei</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用前序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="comment">// 先序遍历--从顶向下交换</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">            <span class="comment">// 保存右子树</span></span><br><span class="line">            TreeNode rightTree = root.right;</span><br><span class="line">            <span class="comment">// 交换左右子树的位置</span></span><br><span class="line">            root.right = invertTree(root.left);</span><br><span class="line">            root.left = invertTree(rightTree);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">            invertTree(root.left); <span class="comment">// 递归找到左节点</span></span><br><span class="line">            TreeNode rightNode= root.right; <span class="comment">// 保存右节点</span></span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            <span class="comment">// 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left</span></span><br><span class="line">            invertTree(root.left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用后序遍历</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 后序遍历-- 从下向上交换</span></span><br><span class="line">            <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">            TreeNode leftNode = invertTree(root.left);</span><br><span class="line">            TreeNode rightNode = invertTree(root.right);</span><br><span class="line">            root.right = leftNode;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用层次遍历</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 层次遍历--直接左右交换即可</span></span><br><span class="line">            <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">            Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="built_in">queue</span>.offer(root);</span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span>.poll();</span><br><span class="line">                TreeNode rightTree = node.right;</span><br><span class="line">                node.right = node.left;</span><br><span class="line">                node.left = rightTree;</span><br><span class="line">                <span class="keyword">if</span> (node.left != null)&#123;</span><br><span class="line">                    <span class="built_in">queue</span>.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != null)&#123;</span><br><span class="line">                    <span class="built_in">queue</span>.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><p>设计辅助函数，将左子树和右子树作为辅助函数的参数。逐一判断：<strong>左子树的左孩子是否等于右子树的有孩子 以及 左子树的右孩子是否等于右子树的左孩子</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetricHelper</span><span class="params">(TreeNode* rootLeft, TreeNode* rootRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rootLeft == <span class="literal">NULL</span> &amp;&amp; rootRight == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootLeft != <span class="literal">NULL</span> &amp;&amp; rootRight != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rootLeft-&gt;val != rootRight-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSymmetricHelper(rootLeft-&gt;right, rootRight-&gt;left) &amp;&amp; isSymmetricHelper(rootLeft-&gt;left, rootRight-&gt;right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSymmetricHelper(root-&gt;left, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><p>这题的坑在于，最小深度在此题的定义为：<strong>从根节点到最近叶子节点的最短路径上的<em>节点数量</em></strong>。细品发现如果直接按照上题最大深度改变的话，无叶子节点的分支会被算作是更小的分支来计数，而实际上没有节点是不能计数的，这就要求我们返回的时候要分类讨论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return (root == NULL) ? 0 : max(1, min(minDepth(root-&gt;left), minDepth(root-&gt;right))) + 1;</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = minDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) &#123; <span class="comment">// 如果左右子树都不为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!left &amp;&amp; !right) &#123; <span class="comment">// 如果都为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果有一个为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h4><p>这题做了很久，最后改进的时候非常不满意，因为对NULL指针的引用这个小问题，导致必须牺牲时间在每次循环下多加两个判断语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        ans-&gt;val = ((t1 == <span class="literal">NULL</span>) ? <span class="number">0</span> : t1-&gt;val) + ((t2 == <span class="literal">NULL</span>) ? <span class="number">0</span> : t2-&gt;val); <span class="comment">// 完成当前根结点值的合并</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ans-&gt;left = mergeTrees(<span class="literal">NULL</span>, t2-&gt;left);</span><br><span class="line">            ans-&gt;right = mergeTrees(<span class="literal">NULL</span>, t2-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ans-&gt;left = mergeTrees(t1-&gt;left, <span class="literal">NULL</span>);</span><br><span class="line">            ans-&gt;right = mergeTrees(t1-&gt;right, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            ans-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看完了答案，爷悟了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        ans-&gt;val = t1-&gt;val + t2-&gt;val; <span class="comment">// 完成当前根结点值的合并</span></span><br><span class="line">        </span><br><span class="line">        ans-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        ans-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码量简直锐减。</p>
<h4 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h4><p>起初是这么做的，超时了。应该是构造子数组这步是多此一举。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOfMaxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>], maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">                <span class="built_in">max</span> = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = indexOfMaxValue(nums, n);  <span class="comment">// 获取最大元素的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建左右的子数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numsLeft</span><span class="params">(maxIndex, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numsRight</span><span class="params">(n - maxIndex, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxIndex; ++i) &#123;</span><br><span class="line">            numsLeft.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = maxIndex + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            numsRight.push_back(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        ans-&gt;val = nums[maxIndex];  <span class="comment">// 当前根结点的值</span></span><br><span class="line"></span><br><span class="line">        ans-&gt;left = constructMaximumBinaryTree(numsLeft);</span><br><span class="line">        ans-&gt;right = constructMaximumBinaryTree(numsRight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>决定构造一个新的函数，传的参数可以只是数组的下标范围。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOfMaxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = nums[start], maxIndex = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">                <span class="built_in">max</span> = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTreeHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = indexOfMaxValue(nums, start, <span class="built_in">end</span>);  <span class="comment">// 获取最大元素的索引</span></span><br><span class="line"></span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        ans-&gt;val = nums[maxIndex];  <span class="comment">// 当前根结点的值</span></span><br><span class="line"></span><br><span class="line">        ans-&gt;left = constructMaximumBinaryTreeHelper(nums, start, maxIndex - <span class="number">1</span>);</span><br><span class="line">        ans-&gt;right = constructMaximumBinaryTreeHelper(nums, maxIndex + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        ans = constructMaximumBinaryTreeHelper(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(n^2)$，辅助函数一共被调用n次。每次递归寻找根节点时，需要遍历当前索引范围内所有元素找出最大值。一般情况下，每次遍历的复杂度为 $O(logn)$，总复杂度为$O(nlogn)$。最坏的情况下，数组 <code>nums</code>有序，此时为$O(n^2)$。</p>
<p>空间复杂度：$O(n)$，递归深度为n。</p>
<h4 id="不同的二叉搜索树II"><a href="#不同的二叉搜索树II" class="headerlink" title="不同的二叉搜索树II"></a>不同的二叉搜索树II</h4><p>输入整型数n，输出由[1:n]不同的数构成的所有二叉搜索树构成的集合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateHelper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="built_in">end</span>) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 获取[start,end]范围内满足条件的左右子树集合</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees = generateHelper(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees = generateHelper(i + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分别从左子树和右子树集合中选取树合并为一个可行解，并加入到解集里</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> leftTree:leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> rightTree:rightTrees) &#123;</span><br><span class="line">                    TreeNode* curr = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    curr-&gt;left = leftTree;</span><br><span class="line">                    curr-&gt;right = rightTree;</span><br><span class="line">                    ans.push_back(curr); <span class="comment">// 这句要注意，每一层递归返回的这个ans很多层都没用，我们只是关注最后一次返回的ans即可</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> generateHelper(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkVisit</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">string</span>&amp; labels, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查看该结点label是否等于target，并查看下边是否还有后续结点，如果有check是否有相同label，并返回对应主函数中的ans[i]数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (labels[node] == labels[target]) count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postNode:graph[node]) &#123; <span class="comment">// 遍历给定node所连结点的序列</span></span><br><span class="line">            <span class="keyword">if</span> (tag[target][postNode] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"辅函数 "</span>&lt;&lt;target&lt;&lt;<span class="string">"与"</span>&lt;&lt;postNode&lt;&lt;<span class="string">"比较"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                tag[node][postNode] = <span class="number">1</span>;</span><br><span class="line">                tag[postNode][node] = <span class="number">1</span>;</span><br><span class="line">                count += checkVisit(postNode, target, graph, labels, tag);</span><br><span class="line">                tag[postNode][target] = <span class="number">1</span>; <span class="comment">// 更新tag</span></span><br><span class="line">                tag[target][postNode] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSubTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(n, v)</span></span>; <span class="comment">// 邻接表形式的图</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">tag</span><span class="params">(n, row)</span></span>; <span class="comment">// 结点访问标志，当0-1访问后，1-0也应该被置为1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构造无向图邻接表 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 其他结点对0的标志位设为1 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            tag[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从0-n逐行遍历图 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;node:graph[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tag[i][node] == <span class="number">0</span>) &#123; <span class="comment">// 当该结点未被访问过时</span></span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"主函数 "</span>&lt;&lt;i&lt;&lt;<span class="string">"与"</span>&lt;&lt;node&lt;&lt;<span class="string">"比较"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    ans[i] += checkVisit(node, i, graph, labels, tag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="从先序遍历还原二叉树"><a href="#从先序遍历还原二叉树" class="headerlink" title="从先序遍历还原二叉树"></a>从先序遍历还原二叉树</h4><p>注意：<code>dep</code>需设为全局变量，因为每一次调用到底时需要回溯，而如果把<code>dep</code>设置为局部变量，它仅在该层dfs函数内有效，并不能指向回溯后的数据。<br>以$1-2–3–4-5–6–7$为例，当<code>pos</code>指向4时，触发<code>dep != currDepth</code>（2!=3），返回了一个空指针。这样3的左右节点由于dfs参数相同，均为空，此时3结点会返回给2结点的<code>left</code>，2结点便开始进行<code>node-&gt;right</code>操作，此时的dep仍为2，这保证了在执行dfs的时候能够跳过前侧的<code>dep != currDepth</code>判断，直接将右节点的值设置为4。便实现了回溯。</p>
<p>综上来看，这个思路关键是在dep处理上要设置成全局。tql，源自于dijks大佬。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, dep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> currDepth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s[pos] == <span class="string">'-'</span> &amp;&amp; pos &lt; n) &#123; <span class="comment">// 如果遍历到'-'，记录深度信息到dep上</span></span><br><span class="line">            pos++;</span><br><span class="line">            dep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dep != currDepth) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 如果深度信息与当前树深度不一致，返回空</span></span><br><span class="line">        dep = <span class="number">0</span>; <span class="comment">// 此处dep必须赋值为0，为了下一次调用时更新获取的'-'数。</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[pos] != <span class="string">'-'</span> &amp;&amp; pos &lt; n) val = val * <span class="number">10</span> + (s[pos++] - <span class="string">'0'</span>); <span class="comment">// 获取结点值</span></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">        node-&gt;left = dfs(currDepth + <span class="number">1</span>);</span><br><span class="line">        node-&gt;right = dfs(currDepth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        s = S;</span><br><span class="line">        n = S.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="图-专题"><a href="#图-专题" class="headerlink" title="图-专题"></a>图-专题</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>==主要思路==（以邻接表的结构为基础）<br>遍历<code>nums</code>，对<code>nums[i]</code>向dfs()传参传入该节点关键字和邻接表<br>dfs()：</p>
<ul>
<li>写递归出口</li>
<li>逐个遍历传入<code>node</code>的所有邻接<code>neibor</code><ul>
<li>递归调用df</li>
</ul>
</li>
</ul>
<h5 id="子树中标签相同的节点数"><a href="#子树中标签相同的节点数" class="headerlink" title="子树中标签相同的节点数"></a>子树中标签相同的节点数</h5><p>要求：一个<strong>根节点为0</strong>的<strong>无向图</strong>，每一个序号对应着<code>string labels</code>中的该序号的字母，判断第i个结点的子树（包括自身）中与<code>labels[i]</code>相同的个数，并返回<code>ans</code>数组。<br>输入：边的集合，labels，总数n<br>输出：<code>ans</code></p>
<h6 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h6><p>这是最初的解法，并没有意识到<strong>根节点为0</strong>以及<strong>边的给定顺序可能不是由edge[0]指向edge[1]</strong>，最终失败。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkVisit</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">string</span>&amp; labels)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查看该结点label是否等于target，并查看下边是否还有后续结点，如果有check是否有相同label，并返回对应主函数中的ans[i]数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (labels[node] == labels[target]) count += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (graph[node].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[node].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                count += checkVisit(graph[node][i], target, graph, labels);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSubTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(n, v)</span></span>; <span class="comment">// 邻接表形式的图</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构造图 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> node:graph[i]) &#123;</span><br><span class="line">                ans[i] += checkVisit(node, i, graph, labels);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h6><ol>
<li>先由给定的集合<strong>递归求得树每层结点的相对ranking</strong>，例如给定边集$[(0,1),(1,2),(0,3)]$，ranking为<code>[4,3,2,3]</code>。</li>
<li>再根据ranking的相对大小，进行坑1类似的操作，即根据邻接表来依次自顶向下访问各结点信息并进行比较。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkVisit</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">string</span>&amp; labels, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查看该结点label是否等于target，并查看下边是否还有后续结点，如果有check是否ranking要更低级，并返回对应主函数中的ans[i]数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (labels[node] == labels[target]) count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postNode:graph[node]) &#123; <span class="comment">// 遍历给定node所连结点的序列</span></span><br><span class="line">            <span class="keyword">if</span> (tag[postNode] &lt; tag[node]) &#123;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;"辅函数 "&lt;&lt;target&lt;&lt;"与"&lt;&lt;postNode&lt;&lt;"比较"&lt;&lt;endl;</span></span><br><span class="line">                count += checkVisit(postNode, target, graph, labels, tag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getRanking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tag, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> currRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 从0开始向下遍历以得到结点的相对ranking */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; next:graph[currRoot]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag[next] &lt; tag[currRoot]) &#123;</span><br><span class="line">                tag[next] = tag[currRoot] - <span class="number">1</span>;</span><br><span class="line">                getRanking(tag, graph, next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSubTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(n, v)</span></span>; <span class="comment">// 邻接表形式的图</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构造无向图邻接表 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tag</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 结点ranking数组</span></span><br><span class="line">        tag[<span class="number">0</span>] = n;</span><br><span class="line">        getRanking(tag, graph, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从0-n逐行遍历图 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;node:graph[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tag[node] &lt; tag[i]) &#123; <span class="comment">// 当该结点ranking较小</span></span><br><span class="line">                    <span class="comment">//cout&lt;&lt;"主函数 "&lt;&lt;i&lt;&lt;"与"&lt;&lt;node&lt;&lt;"比较"&lt;&lt;endl;</span></span><br><span class="line">                    ans[i] += checkVisit(node, i, graph, labels, tag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
结果：超时！！！<br>计算ranking复杂度为$O(n)$，遍历图的复杂度为$O(nlogn)$，而每次还都需要进行一次checkVisit的递归，递归的开销也有$(logn)^2$左右吧。那乘起来就是$O(n*(logn)^3)$再加上$O(n)$。</li>
</ol>
<h6 id="官方答案"><a href="#官方答案" class="headerlink" title="官方答案"></a>官方答案</h6><p>直接设置了一个数组$f[n][26]$用于标记<strong>o子树中各结点代表的字母出现的次数</strong>，例如：$f[0][2]=2$代表0序号的子树中$b$出现的次数为2。</p>
<p><strong>最关键的思路：</strong><br>$o$相当于当前结点的一个层级，$pre$则是因为这次递推，已经确定的前驱结点。如果$nex==pre$那就是遍历时又向前访问了前一层。<br>更新语句：<code>o = nex</code>和<code>pre = o</code></p>
<p><strong>以$1(d)⬅2(b)⬅0(a)➡3(b)$为例的每部详细过程：</strong><br>递归前  o=0  nex=2  pre=-1<br>不递归  o=2  nex=0  pre=0<br>递归前  o=2  nex=1  pre=0<br>不递归  o=1  nex=2  pre=2<br>递归后  o=2  nex=1  pre=0<br>递归后  o=0  nex=2  pre=-1<br>递归前  o=0  nex=3  pre=-1<br>不递归  o=3  nex=0  pre=0<br>递归后  o=0  nex=3  pre=-1</p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">o</th>
<th align="center">pre</th>
<th align="center">赋值 or for加和</th>
<th align="center">nex</th>
<th align="center">continue or return or recursive</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">f[0][0]=1</td>
<td align="center">2</td>
<td align="center">recursive</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">f[2][1]=1</td>
<td align="center">0</td>
<td align="center">continue</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">无</td>
<td align="center">1</td>
<td align="center">recursive</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">f[1][3]=1</td>
<td align="center">2</td>
<td align="center">return</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">加和</td>
<td align="center">1</td>
<td align="center">return</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">加和</td>
<td align="center">2</td>
<td align="center">return</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">..</td>
<td align="center">..</td>
<td align="center">..</td>
<td align="center">..</td>
<td align="center">..</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> pre, <span class="keyword">const</span> <span class="built_in">string</span> &amp;labels)</span> </span>&#123;</span><br><span class="line">        f[o][labels[o] - <span class="string">'a'</span>] = <span class="number">1</span>; <span class="comment">// 自身预先出现一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;nex: g[o]) &#123; <span class="comment">// 遍历自己的连接结点</span></span><br><span class="line">            <span class="keyword">if</span> (nex == pre) &#123;</span><br><span class="line">                <span class="comment">// 避免了回溯</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            dfs(nex, o, labels);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                f[o][i] += f[nex][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSubTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels)</span> </span>&#123;</span><br><span class="line">        g.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;edge: edges) &#123;</span><br><span class="line">            g[edge[<span class="number">0</span>]].push_back(edge[<span class="number">1</span>]);</span><br><span class="line">            g[edge[<span class="number">1</span>]].push_back(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        f.assign(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">-1</span>, labels);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans.push_back(f[i][labels[i] - <span class="string">'a'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(nc)$，其中 n 是树中的节点数，c 是字符集大小，此处 c = 26。深度优先搜索需要对树中的每个节点访问一次，对每个节点都需要更新所有可能的标签出现的次数，由于标签都是小写字母，需要对 26 个字母都进行一次讨论。</p>
<p>空间复杂度：$O(nc)$，其中 n 是树中的节点数。空间复杂度主要取决于递归栈的调用深度，递归栈的调用深度不会超过 n。</p>
<h5 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h5><p>返回该给定邻接表的图，是否为二分图。</p>
<h6 id="DFS方法"><a href="#DFS方法" class="headerlink" title="DFS方法"></a>DFS方法</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tag; <span class="comment">// 设置标签位，未标签为-1，标签有1、0两种</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> currTag, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        tag[node] = currTag;</span><br><span class="line">        <span class="keyword">int</span> revCurrTag = (currTag == <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">// 将标签取反</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neibor:graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag[neibor] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dfs(neibor, revCurrTag, graph);</span><br><span class="line">                <span class="keyword">if</span> (valid == <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag[neibor] != revCurrTag) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// graph就是邻接表的形式</span></span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        valid = <span class="literal">true</span>;</span><br><span class="line">        tag.assign(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> currTag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dfs(i, currTag, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路：设置一个标志位，标志有三种状态：未标记，1标记，0标记。dfs遍历图：</p>
<ul>
<li>若相邻结点未被标记，标记相反标记后，继续向下遍历</li>
<li>若相邻节点已被标记，查看标记位，若不相反，则返回false</li>
</ul>
<h5 id="flood-fill"><a href="#flood-fill" class="headerlink" title="flood fill"></a>flood fill</h5><p>将给定的二维数组中的某坐标元素的颜色记为oldColor，将它的四邻方块（包括自己）中为oldColor的依次更新为newColor，并对四邻方块递归执行如上操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">image</span>, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldColor = <span class="built_in">image</span>[sr][sc];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">image</span>.empty() || newColor == oldColor) <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> rowLen = <span class="built_in">image</span>[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> colLen = <span class="built_in">image</span>.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">image</span>[sr][sc] = newColor;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = sr + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = sc + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; colLen &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; rowLen &amp;&amp; <span class="built_in">image</span>[x][y] == oldColor)</span><br><span class="line">                floodFill(<span class="built_in">image</span>, x, y, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h5><p>统计给定二维数组的连通块数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == <span class="string">'1'</span>)</span><br><span class="line">                dfs(grid, x, y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="封闭岛屿数量"><a href="#封闭岛屿数量" class="headerlink" title="封闭岛屿数量"></a>封闭岛屿数量</h5><p>和上一题基本一样，只是边界情况不算（和数组外联通不算）</p>
<p>处理方法：当将0修改为1的过程中，碰到了边界的0，此时这次count增加不算。</p>
<h6 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count, row, col;</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;; <span class="comment">//下右上左</span></span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= row - <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt;= col - <span class="number">1</span> &amp;&amp; grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">0</span> || x == row - <span class="number">1</span> || y == <span class="number">0</span> || y == col - <span class="number">1</span>) &#123; <span class="comment">// 如果联通到边缘的石块，则valid置为false</span></span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    grid[r][c] = <span class="number">0</span>; <span class="comment">// 这步骤是为了防止前一步错误更改的1，导致下一次遍历的时候封闭使得count偏大</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(grid, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row &lt;= <span class="number">2</span> || col &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="comment">//bool isEdge = i &gt; 0 &amp;&amp; i &lt; row - 1 &amp;&amp; j &gt; 0 &amp;&amp; j &lt; col - 1; </span></span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">                    dfs (grid, i, j);</span><br><span class="line">                    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    valid = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h6><p>变化主要在dfs函数上，思想是：如果按上下左右方向遍历，遍历到0的话，继续遍历直到遇到1，此时就会返回true，如果四个方向都是true那么就是正确的，否则错误。方法简单明了，值得学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(grid,i,j))&#123;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> up = dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        <span class="keyword">boolean</span> down = dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        <span class="keyword">boolean</span> left = dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> right = dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(up &amp;&amp; down &amp;&amp; left &amp;&amp; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/number-of-closed-islands/solution/dfsjie-jue-by-liuchuan1992/" target="_blank" rel="noopener">Liuchuan1992</a></p>
<h5 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h5><p>将被<code>&#39;X&#39;</code>围绕的<code>&#39;O&#39;</code>更新为<code>&#39;X&#39;</code>（二维数组的边界被<code>&#39;O&#39;</code>包围）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= row  || j &gt;= col || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'#'</span>)</span><br><span class="line">            <span class="comment">// 如果越界或者是数组被标记或者该处为X</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">'#'</span>; <span class="comment">// 将该O标记为#</span></span><br><span class="line"></span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        row = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!row) <span class="keyword">return</span>;</span><br><span class="line">        col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从边界向内深搜（在深搜内限制不能从边界向外搜索，但可以向内）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span> &amp;&amp; (i == <span class="number">0</span> || j == <span class="number">0</span> || i == row - <span class="number">1</span> || j == col - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="检查网格中是否有有效路径"><a href="#检查网格中是否有有效路径" class="headerlink" title="检查网格中是否有有效路径"></a>检查网格中是否有有效路径</h5><p><a href="https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/" target="_blank" rel="noopener">题目一览</a></p>
<h6 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h6><p>首先用<code>validNextDirection</code>和<code>validComeDirection</code>来表示该方块的合法来方向和合法去方向。然后每次dfs到一个网格时，要四方向遍历，这导致我的时间复杂度达到了$O(mn * 4)$，且占用了很多不必要的空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> blk = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> down = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> left = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> right = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下左右</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> validNextDirection[<span class="number">7</span>][<span class="number">4</span>] = </span><br><span class="line">    &#123;   &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;blk,blk,left,right&#125;,</span><br><span class="line">        &#123;up,down,blk,blk&#125;,</span><br><span class="line">        &#123;blk,down,left,blk&#125;,</span><br><span class="line">        &#123;blk,down,blk,right&#125;,</span><br><span class="line">        &#123;up,blk,left,blk&#125;,</span><br><span class="line">        &#123;up,blk,blk,right&#125;  &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> validComeDirection[<span class="number">7</span>][<span class="number">4</span>] = </span><br><span class="line">    &#123;   &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;blk,blk,left,right&#125;,</span><br><span class="line">        &#123;up,down,blk,blk&#125;,</span><br><span class="line">        &#123;up,blk,blk,right&#125;,</span><br><span class="line">        &#123;up,blk,left,blk&#125;,</span><br><span class="line">        &#123;blk,down,blk,right&#125;,</span><br><span class="line">        &#123;blk,down,left,blk&#125;  &#125;;</span><br><span class="line">    <span class="keyword">int</span> visited[<span class="number">302</span>][<span class="number">302</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (validComeDirection[grid[r][c]][dir] == blk) &#123; <span class="comment">// 如果来的方向不对，返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> edgeValid = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">            <span class="keyword">if</span> (edgeValid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (validNextDirection[grid[r][c]][i] != blk &amp;&amp; visited[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dfs(grid, x, y, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValidPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>();</span><br><span class="line">        n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line"></span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; <span class="comment">// 尝试四个方向走</span></span><br><span class="line">            <span class="keyword">bool</span> edgeValid = dx[i] &gt;= <span class="number">0</span> &amp;&amp; dx[i] &lt; m &amp;&amp; dy[i] &gt;= <span class="number">0</span> &amp;&amp; dy[i] &lt; n;</span><br><span class="line">            <span class="keyword">if</span> (validNextDirection[grid[<span class="number">0</span>][<span class="number">0</span>]][i] != blk &amp;&amp; edgeValid) &#123; <span class="comment">// 如果这个方向合法，就dfs</span></span><br><span class="line">                dfs(grid, dx[i], dy[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>插曲：我最后又check了一下，发现超时是因为我的调试语句<code>cout</code>没有删掉，我去去去去去！！！！</p>
<h6 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h6><p>参考“五行缺你”朋友改进。<br>以<code>validDirection[7][4]</code>同时显示来的方向和去的方向两层信息。</p>
<ul>
<li>index 提示来的方向</li>
<li>value 提示去的方向</li>
</ul>
<p>这样可以顺次遍历，复杂度提升到$O(mn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> blk = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> down = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> left = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> right = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下左右</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> validDirection[<span class="number">7</span>][<span class="number">4</span>] = </span><br><span class="line">    &#123;   &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;blk,blk,left,right&#125;,</span><br><span class="line">        &#123;up,down,blk,blk&#125;,</span><br><span class="line">        &#123;left,blk,blk,down&#125;,</span><br><span class="line">        &#123;right,blk,down,blk&#125;,</span><br><span class="line">        &#123;blk,left,blk,up&#125;,</span><br><span class="line">        &#123;blk,right,up,blk&#125;  &#125;;</span><br><span class="line">    <span class="keyword">int</span> visited[<span class="number">302</span>][<span class="number">302</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> dir)</span> </span>&#123;</span><br><span class="line">        visited[r][c] = <span class="number">1</span>;  <span class="comment">// 标记为已访问</span></span><br><span class="line">        <span class="keyword">int</span> nextDir = validDirection[grid[r][c]][dir];  <span class="comment">// 该方块的下一个方向是[当前块种类][下一个方向]</span></span><br><span class="line">        <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span> &amp;&amp; nextDir != blk) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nextDir != blk) &#123;  <span class="comment">// 如果下一个方向不是blk</span></span><br><span class="line">            <span class="keyword">int</span> x = r + dx[nextDir];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[nextDir];</span><br><span class="line">            <span class="keyword">bool</span> edgeValid = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">            <span class="keyword">if</span> (edgeValid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dfs(grid, x, y, nextDir);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValidPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>();</span><br><span class="line">        n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line"></span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; <span class="comment">// 尝试四个方向走 0 上 1 下 2 左 3 右</span></span><br><span class="line">            <span class="keyword">if</span> (validDirection[grid[<span class="number">0</span>][<span class="number">0</span>]][i] != blk) &#123; <span class="comment">// 如果这个方向合法，就dfs</span></span><br><span class="line">                dfs(grid, <span class="number">0</span>, <span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩阵中最长递归路径"><a href="#矩阵中最长递归路径" class="headerlink" title="矩阵中最长递归路径"></a>矩阵中最长递归路径</h5><p>给定一个整数矩阵，找出最长递增路径的长度。</p>
<p>个人解法应该是超时了，原思路是按照dfs走的，然后用一个res来存储每次的</p>
<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h6><p>记忆化深度优先搜索，当访问到一个单元格 (i,j) 时，如果${memo}[i][j] \neq 0$，说明该单元格的结果已经计算过，则直接从缓存中读取结果，如果${memo}[i][j]=0$，说明该单元格的结果尚未被计算过，则进行搜索，并将计算得到的结果存入缓存中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[r][c] != <span class="number">0</span>) <span class="keyword">return</span> memo[r][c];</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        memo[r][c]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col;</span><br><span class="line">            <span class="keyword">if</span> (notEdge &amp;&amp; matrix[x][y] &gt; matrix[r][c]) &#123;</span><br><span class="line">                memo[r][c] = <span class="built_in">max</span>(memo[r][c], dfs(matrix, x, y, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> memo = <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; (row, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; (col));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dfs(matrix, i, j, memo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="不同路径III"><a href="#不同路径III" class="headerlink" title="不同路径III"></a>不同路径III</h5><p>方格中有四种状态.</p>
<ul>
<li>1表示起点，只有1个</li>
<li>2表示终点，只有1个</li>
<li>0表示可走</li>
<li>-1表示不可走<br>要求从起点走到终点，且经过所有的可走点，并返回路径的可能总数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; start;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fixedStep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> <span class="built_in">step</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">step</span> &gt; fixedStep) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">step</span> == fixedStep) ++ans;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span> || grid[x][y] == <span class="number">0</span>)</span><br><span class="line">                    dfs(grid, x, y, <span class="built_in">step</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先找1，并返回从1到2应该走的正确步数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) start = &#123;i, j&#125;;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] != <span class="number">-1</span>) fixedStep++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再从起点开始DFS</span></span><br><span class="line">        dfs(grid, start.first, start.second, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用了所有节点都需走一遍的这个性质，提前计算出了固定的步数，如果没达到预期，则此次路径无效。</li>
<li>用修改0状态为3，来实现记忆化搜索。但需要注意的是，在四个方向遍历结束后，要将当前的状态修改回0，已更新新的方法。</li>
</ul>
<hr>
<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>==要素==：队列</p>
<h5 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h5><p>输入一个正整数n，返回其通过平方数（1，4，9，16..）等加和得到的需要最小平方数。</p>
<p>BFS解法：相当于将原问题转换为，求根节点到某叶子节点（结点的关键字值为n）的最短距离（最小深度）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>; <span class="comment">// dist代表的是当前元素所在的深度</span></span><br><span class="line">        q.push(<span class="number">0</span>);</span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 根节点深度为0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123; <span class="comment">// 当队列不为空时</span></span><br><span class="line">            <span class="keyword">int</span> temp = q.front(); <span class="comment">// 取出顶元素</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp == n) <span class="keyword">return</span> dist[temp]; <span class="comment">// 如果此时到达n，直接输出此时的层数即可</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * i + temp &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i * i + temp; <span class="comment">// 更新j为此时的平方加和数</span></span><br><span class="line">                <span class="keyword">if</span> (dist[j] &gt; dist[temp] + <span class="number">1</span>) &#123; <span class="comment">// 如果此时j的dist要大于temp的层数+1</span></span><br><span class="line">                    dist[j] = dist[temp] + <span class="number">1</span>; <span class="comment">// 更新它为temp的下一层</span></span><br><span class="line">                    q.push(j); <span class="comment">// 并将其加入队列尾部</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>附：dp解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 抽象成一个平方数加上一个数（上一步得来的数）</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h5><p>给出一个二叉树，返回一个二维数组，数组的第i行对应的是二叉树的第i深度从左到右的顺序。</p>
<p>不贴个人的BFS了，官方的这个解法没有额外的求各层的深度，而是利用了<strong>每次进入循环时队列的长度为各层的长度</strong>这个性质，在每次循环中直接处理完这层的遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/" target="_blank" rel="noopener">出自nettee大佬的BFS精华总结</a></p>
<hr>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="课程表II"><a href="#课程表II" class="headerlink" title="课程表II"></a>课程表II</h5><p>给定课程表的$[后续课，先行课]$集合，以及课程总数。输出符合先行课规则的上课顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(numCourses, v)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据边信息构造邻接表graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            indegree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">            graph[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i); <span class="comment">// 将入度为0的边入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123; <span class="comment">// 当队列非空时，循环操作</span></span><br><span class="line">            <span class="keyword">int</span> temp = q.front();  <span class="comment">// 将队列头部的元素出队</span></span><br><span class="line">            q.pop();</span><br><span class="line">            count++;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改入度表indegree，当发现有入度为0时，将其入队</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[temp].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                indegree[graph[temp][i]]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[graph[temp][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(graph[temp][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a>矩阵中的最长递增路径</h5><p>和上面的dfs一道题的题目相同，用拓扑排序的方法求解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!row) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(col, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(row, v)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算出度</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k];</span><br><span class="line">                    <span class="keyword">int</span> y = j + dy[k];</span><br><span class="line">                    <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col;</span><br><span class="line">                    <span class="keyword">if</span> (notEdge &amp;&amp; matrix[x][y] &gt; matrix[i][j]) &#123;</span><br><span class="line">                        memo[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!memo[i][j]) q.push(&#123;i, j&#125;); <span class="comment">// 如果出度为0(四周没人比他大)，入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 记录每次出队的层数</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="comment">// 如果队列非空，对队列里的所有元素依次处理</span></span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>(); <span class="comment">// 保存当前队中的数据个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> r = temp.first;</span><br><span class="line">                <span class="keyword">int</span> c = temp.second;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = r + dx[j];</span><br><span class="line">                    <span class="keyword">int</span> y = c + dy[j];</span><br><span class="line">                    <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col;</span><br><span class="line">                    <span class="keyword">if</span> (notEdge &amp;&amp; matrix[x][y] &lt; matrix[r][c]) &#123;</span><br><span class="line">                        --memo[x][y]; </span><br><span class="line">                        <span class="comment">// 四周的所有点中，较小的的出度应该减1，下一次就有希望被纳入到队列中</span></span><br><span class="line">                        <span class="keyword">if</span> (memo[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                            q.push(&#123;x, y&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode日记</title>
    <url>/2020/07/02/LeetCode%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>偶尔在力扣上刷刷题碰到些有价值的题目随手都记录到这里了。</p>
<a id="more"></a>
<p><strong><em>题目分类：</em></strong></p>
<p><strong>动态规划：</strong></p>
<ul>
<li>爬楼梯</li>
<li>恢复空格</li>
<li>地下城与勇士</li>
<li>三角形最小路径和</li>
<li>不同的二叉搜索树</li>
</ul>
<p><strong>双指针：</strong></p>
<ul>
<li>删除链表的倒数第n个结点</li>
<li>删除排序链表里的重复元素II</li>
<li>相交链表</li>
<li>环形链表</li>
<li>重排链表</li>
<li>数组交集</li>
<li>两数之和II</li>
<li>快乐数</li>
<li>戳气球</li>
</ul>
<p>贪心法：</p>
<ul>
<li>跳跃游戏</li>
</ul>
<p><strong>hash表：</strong></p>
<ul>
<li>删除排序链表里的重复元素II</li>
<li>恢复空格</li>
<li>数组交集</li>
<li>存在重复元素II</li>
<li>存在重复元素III</li>
</ul>
<p>递归：</p>
<ul>
<li>删除排序链表里的重复元素II</li>
<li>反转链表</li>
</ul>
<p>二分法</p>
<ul>
<li>排列硬币</li>
<li>旋转数组的最小值</li>
</ul>
<p>排除法</p>
<ul>
<li>计数质数</li>
</ul>
<hr>
<h4 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h4><h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><p>输入：两个二进制字符串<br>输出：加法后得到的二进制字符串</p>
<h5 id="个人解答-Python"><a href="#个人解答-Python" class="headerlink" title="个人解答(Python)"></a>个人解答(Python)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        carry = <span class="number">0</span>  <span class="comment"># 进位初始化为0</span></span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        n = max(len(a),len(b))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(i &gt; len(a)<span class="number">-1</span>):  <span class="comment"># 当b未遍历完，a遍历完</span></span><br><span class="line">                result += str((int(b[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">                carry = (int(b[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; len(b)<span class="number">-1</span>):  <span class="comment"># 当a未遍历完，b遍历完</span></span><br><span class="line">                result += str((int(a[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">                carry = (int(a[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            result += str((int(a[-i<span class="number">-1</span>])+int(b[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">            carry = (int(a[-i<span class="number">-1</span>])+int(b[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>):  <span class="comment"># 如果最后进位是1，补位</span></span><br><span class="line">            result += str(carry)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h5 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h5><p>两个数字位数较小的一个，直接用0补齐，使得两个字符串的位数相同，可以节省代码空间，减少判断次数，降低运行时间。</p>
<h5 id="法2：位运算"><a href="#法2：位运算" class="headerlink" title="法2：位运算"></a>法2：位运算</h5><p><a href="https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/" target="_blank" rel="noopener">戳我看解法</a></p>
<hr>
<h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><h5 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h5><p>人一次只能爬1个或2个楼梯<br>输入：楼梯个数<br>输出：爬楼梯共有多少种爬法</p>
<h5 id="个人解答-Python-1"><a href="#个人解答-Python-1" class="headerlink" title="个人解答(Python)"></a>个人解答(Python)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * f(n<span class="number">-1</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = (n//<span class="number">2</span>)+<span class="number">1</span>  <span class="comment"># 共有多少种不重复的已经确定的1，2个数分布</span></span><br><span class="line">        j = n  <span class="comment"># 排列组合公式的底数</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">            result += f(j)/(f(i)*f(j-i))</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h5 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结"></a>我的总结</h5><p>我的思路是先找到1，2个数的所有组合，举个例子：<br>比如n=6，那么楼梯的1，2组合只能是以下四种：</p>
<ul>
<li>111111</li>
<li>11112</li>
<li>1122</li>
<li>222</li>
</ul>
<p>那么只需要找到2的排列组合数就行：</p>
<ul>
<li>0/6 111111</li>
<li>1/5 11112</li>
<li>2/4 1122</li>
<li>3/3 222</li>
</ul>
<p>虽然找到了公式，但不得不说，我这个不论空间还是时间都垃圾的很……直接看标答吧…<br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">戳我看完整答案</a></p>
<h5 id="方法1：动态规划！"><a href="#方法1：动态规划！" class="headerlink" title="方法1：动态规划！"></a>方法1：动态规划！</h5><p>我们用 <code>f(x)</code> 表示爬到第 <code>x</code> 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：<br>$$f(x) = f(x-1) + f(x-2)$$</p>
<p>这个公式的意思是，爬到第n级台阶只能是爬到n-1级（爬到第n级用了一步）或是爬到n-2级（爬到n级用了两步）的方案的集合。看到这里就一目了然，这不就是传说中的<code>斐波那契数列</code>吗？（后话）<br>利用滚动数组的方法求解代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    q = <span class="number">0</span></span><br><span class="line">    r = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        p = q  <span class="comment"># q前移一位</span></span><br><span class="line">        q = r  <span class="comment"># r前移一位</span></span><br><span class="line">        r = p + q  <span class="comment"># 更新r</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>
<h5 id="方法2：斐波那契公式"><a href="#方法2：斐波那契公式" class="headerlink" title="方法2：斐波那契公式"></a>方法2：斐波那契公式</h5><p>$$f ( n ) = \frac { 1 } { \sqrt { 5 } } [ ( \frac { 1 + \sqrt { 5 } } { 2 } ) ^ { n } - ( \frac { 1 - \sqrt { 5 } } { 2 } ) ^ { n } ]<br>$$</p>
<hr>
<h4 id="删除链表的倒数第n个节点"><a href="#删除链表的倒数第n个节点" class="headerlink" title="删除链表的倒数第n个节点"></a>删除链表的倒数第n个节点</h4><h5 id="个人解答-C-两次遍历"><a href="#个人解答-C-两次遍历" class="headerlink" title="个人解答(C,两次遍历)"></a>个人解答(C,两次遍历)</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cur = cur -&gt; next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==n)&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 如果删除头结点，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count-n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125; <span class="comment">// 如果不删除头结点，按照结点删除法删除对应节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="我的总结-1"><a href="#我的总结-1" class="headerlink" title="我的总结"></a>我的总结</h5><p>遍历2L-n次，时间复杂度 $O(L)$<br>空间复杂度$O(1)$</p>
<h5 id="优化：一次遍历法（双指针）"><a href="#优化：一次遍历法（双指针）" class="headerlink" title="优化：一次遍历法（双指针）"></a>优化：一次遍历法（双指针）</h5><p>哎呀，想了十分钟没想出来，一说双指针一下子明白了。双指针保持间隔为n，依次向前递推，直到快指针指向空，慢指针定位成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 定位快指针到第n+1个结点</span></span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 如果第n+1个结点为空，直接返回head-&gt;next</span></span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>free语句是必不可少的，这里为了省空间就没用q承载再删除</strong>。正解如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>


<hr>
<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><h5 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h5><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p>
<h5 id="个人解答-C"><a href="#个人解答-C" class="headerlink" title="个人解答(C)"></a>个人解答(C)</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = numsSize<span class="number">-2</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= numsSize-i<span class="number">-1</span>)&#123; </span><br><span class="line">            <span class="comment">// 如果这个在尾元素之前的元素可以到达末尾，则以该元素为末尾</span></span><br><span class="line">            numsSize -= (numsSize-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numsSize==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<h5 id="标答-贪心法"><a href="#标答-贪心法" class="headerlink" title="标答(贪心法)"></a>标答(贪心法)</h5><p><strong>更新能跳到的最远位置</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n, rightmost = len(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &lt;= rightmost:</span><br><span class="line">                rightmost = max(rightmost, i + nums[i])</span><br><span class="line">                <span class="keyword">if</span> rightmost &gt;= n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两链表之和"><a href="#两链表之和" class="headerlink" title="两链表之和"></a>两链表之和</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>例如：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><p>本来想省一点空间，直接在L1上操作，现在导致前后两难：</p>
<ol>
<li>逻辑不清晰，可读性很差</li>
<li>时间复杂度提高的鸭子！！</li>
<li>代码冗长</li>
</ol>
<p>浪费了我俩小时，先睡了。/(ㄒoㄒ)/~~</p>
<p>2020.7.8..今天早上用c语言做出来了，直接贴代码。之前的思路（改变L1），造成了我遍历完其中一个链表，就会分类讨论出三种情况，无疑复杂化了原问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>; <span class="comment">// 进位位初始化</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>; <span class="comment">// 每位的加和</span></span><br><span class="line">    <span class="keyword">int</span> x,y; <span class="comment">// 每位的真实加法数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">L1</span>=<span class="title">l1</span>,*<span class="title">L2</span>=<span class="title">l2</span>,*<span class="title">result</span>,*<span class="title">cur</span>,*<span class="title">high</span>,*<span class="title">nextNode</span>;</span></span><br><span class="line">    result = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    cur = result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(L1!=<span class="literal">NULL</span> || L2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        x = L1!=<span class="literal">NULL</span> ? L1-&gt;val : <span class="number">0</span>;</span><br><span class="line">        y = L2!=<span class="literal">NULL</span> ? L2-&gt;val : <span class="number">0</span>;</span><br><span class="line">        nextNode = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        sum = x + y + temp;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            nextNode -&gt; val = sum%<span class="number">10</span>;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nextNode -&gt; val = sum;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            L1=L1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            L2=L2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = nextNode;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后排除多位问题</span></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">1</span>)&#123;</span><br><span class="line">        high = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        high -&gt; val = <span class="number">1</span>;</span><br><span class="line">        cur -&gt; next = high;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以以后再碰到类似的题目，要先想好自己要不要优化空间（时间），到底是先试着把题目做出来，还是就着一个优化空间的角度钻牛角尖，还是要衡量一下的。</strong>后面还看到了一个时间上比我快很多的算法，其实和我之前的思路有一点类似(当某一个链表遍历完，剩余的链接到后面，但是由于我一心只想改变L1，造成了很多不必要的麻烦，而且后面的关于进位位的处理也没人家想的好)大体讲一下思路，开阔一下视野。</p>
<ol>
<li>新建一个链表l3，用以存放l1+l2的和</li>
<li>分3种情况，在l1，l2都没到尾的前提下<ul>
<li>l1先结束，l2多出来的部分直接加入到l3</li>
<li>l2先结束，l1多出来的部分直接加到l3</li>
<li>两个一起结束，直接相加，不管结果是否大于10</li>
</ul>
</li>
<li>遍历l3，先不考虑链表最后一个数，<ul>
<li>如果l3.val&gt;10，减去10，并在下一个节点上加1</li>
<li>如果链表最后一个数大于10，则减去10，并新建一个节点存1</li>
</ul>
</li>
</ol>
<p>这个思路的<strong>对进位位的处理</strong>是很值得借鉴的，就是先不管进位位的情况下统一加完，再遍历链表实现进位位的加法，这种方法看似消耗了时间（相当于两次遍历），实际上居然比我那个要快很多，显然是因为我那个的条件判断语句有点过多了。</p>
<hr>
<h4 id="跳水板"><a href="#跳水板" class="headerlink" title="跳水板"></a>跳水板</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。<br>返回的长度需要<strong>从小到大排列</strong>。</p>
<h5 id="个人解答-1"><a href="#个人解答-1" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">divingBoard</span><span class="params">(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *newNode;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(longer==shorter)&#123;</span><br><span class="line">        newNode = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line">        *newNode = longer*k;</span><br><span class="line">        *returnSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(k+<span class="number">1</span>));</span><br><span class="line">    *returnSize = k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        newNode[k-i] = i*shorter + (k-i)*longer; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="删除排序链表里的重复元素II"><a href="#删除排序链表里的重复元素II" class="headerlink" title="删除排序链表里的重复元素II"></a>删除排序链表里的重复元素II</h4><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中<strong>没有重复出现</strong>的数字。</p>
<h5 id="个人原解答"><a href="#个人原解答" class="headerlink" title="个人原解答"></a>个人原解答</h5><p>思路：</p>
<ol>
<li>如果链表只有0/1个元素，返回head。 </li>
<li>将链表化为<strong>前两个元素一定不一样</strong>的模型。</li>
<li>设置快指针q，慢指针p。</li>
<li>p-&gt;next-&gt;val == q-&gt;val时是删除条件<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// p是慢指针，q是快指针</span></span><br><span class="line">    <span class="comment">// 如果是开头重复：label=1</span></span><br><span class="line">    <span class="comment">// 如果是中间重复：label=0</span></span><br><span class="line">    <span class="comment">// 由于头结点和后面都不一样，我觉得先摘除头结点重复的前半部分，将链表化为“前两个一定不相同的模型”</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>=<span class="title">head</span>, *<span class="title">q</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> label = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next-&gt;val == head-&gt;val)&#123;</span><br><span class="line">        label = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next-&gt;val == head-&gt;val)&#123;</span><br><span class="line">            label = <span class="number">1</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(label)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;val == q-&gt;val)&#123; <span class="comment">// 若相等</span></span><br><span class="line">            <span class="keyword">if</span>(q-&gt;next==<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123; <span class="comment">// 到达链表尾，则删除</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 否则快指针后移</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 若不等</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;next == q)&#123; <span class="comment">// 不能删，要后移p</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 否则应该删掉中间结点</span></span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我感觉我想法挺好的啊！但真的做崩了，被各种细节卡了下来，提交了5次都没成功，我是真的垃圾。都说能用递归，那我用递归试试，半小时不行就劝退吧，现在是0：49，我很困。<br>1：01，爷想不出来，气死了，睡觉。</li>
</ol>
<h5 id="标准解法"><a href="#标准解法" class="headerlink" title="标准解法"></a>标准解法</h5><h6 id="方法1：递归"><a href="#方法1：递归" class="headerlink" title="方法1：递归"></a>方法1：递归</h6><ul>
<li><code>head</code>后面有值而且和<code>head</code>的值相等，那么就找到不相等为止，然后对后面一个结点去递归，这样就把前面重复的给删除了。</li>
<li><code>head</code>后面有值但和<code>head</code>的值不等，那么就递归后面一个结点，接在<code>head</code>的后面。</li>
<li>最后返回<code>head</code>。</li>
</ul>
<p>想法和我是一样的，但是我就……没能力实现出来？？其实中间很多循环条件判断条件也是完全一样的，，这个<code>return deleteDuplicates(head-&gt;next)</code>我服了，我当时怎么都没想出来解决(1,1,2,2)这种情况，人家一句就解决了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="方法2：hash表"><a href="#方法2：hash表" class="headerlink" title="方法2：hash表"></a>方法2：hash表</h6><p>hash_map 统计出现次数，如果出现次数等于1，那么就放在新链表后面。</p>
<h6 id="方法3：双指针"><a href="#方法3：双指针" class="headerlink" title="方法3：双指针"></a>方法3：双指针</h6><p><strong>先建一个哑结点真的省事儿</strong>，当建完哑结点后，删除就会和<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表里的重复元素I</a>这道题的方法基本一样–<strong>顺序遍历，若同则删</strong>，不同的是，<code>cur-&gt;next</code>是否为空要加以判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哑结点指向head</span></span><br><span class="line">    ListNode* dummy = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode* pre = dummy;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">NULL</span> &amp;&amp; cur-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next!=<span class="literal">NULL</span> &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;                </span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h5><p>当这种情况下，可能有很多种情况，首先想能不能把这几个情况想个方法合并。比如法1的递归和法3的双指针的哑结点，都是<strong>为了排除特殊情情况而设计的</strong>。</p>
<hr>
<h4 id="恢复空格"><a href="#恢复空格" class="headerlink" title="恢复空格"></a>恢复空格</h4><h5 id="别人解答C"><a href="#别人解答C" class="headerlink" title="别人解答C"></a>别人解答C</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CMP</span><span class="params">(<span class="keyword">void</span> * a,<span class="keyword">void</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * S1 = *(<span class="keyword">char</span> **)a;</span><br><span class="line">    <span class="keyword">char</span> * S2 = *(<span class="keyword">char</span> **)b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(S1,S2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Binary</span><span class="params">(<span class="keyword">char</span> **dictionary,<span class="keyword">int</span> dictionarySize,<span class="keyword">char</span> * <span class="built_in">string</span>,<span class="keyword">int</span> lenth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = dictionarySize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>,ret2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;        <span class="comment">//mid是一个区间</span></span><br><span class="line">        ret = <span class="built_in">strncmp</span>(dictionary[mid],<span class="built_in">string</span>,lenth);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret2 = <span class="built_in">strlen</span>(dictionary[mid]);</span><br><span class="line">            <span class="keyword">if</span>(ret2 == lenth)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret2 &gt; lenth)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="keyword">char</span>** dictionary, <span class="keyword">int</span> dictionarySize, <span class="keyword">char</span>* sentence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    qsort(dictionary,dictionarySize,<span class="keyword">sizeof</span>(<span class="keyword">char</span> *),CMP);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(sentence);</span><br><span class="line">    <span class="keyword">int</span> * dp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    * dp = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *(dp + i) = *(dp + i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt;= i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Binary(dictionary,dictionarySize,sentence + j,i - j + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    *(dp + i) = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    *(dp + i) = MIN(dp[i],dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> answer = dp[len] - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(dp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我改进后的，用C语言基于动态规划的答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">substr</span><span class="params">(<span class="keyword">char</span>* sentence, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *substring = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        substring[i] = sentence[start+i];</span><br><span class="line">    &#125;</span><br><span class="line">    substring[len] = <span class="string">'\0'</span>; <span class="comment">// 这个结尾一定要赋'\0'要不比较不了</span></span><br><span class="line">    <span class="keyword">return</span> substring;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="keyword">char</span>** dictionary, <span class="keyword">int</span> dictionarySize, <span class="keyword">char</span>* sentence)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回的是字符数，不是单词数……</span></span><br><span class="line">    <span class="comment">// 这题应该能用动态规划解</span></span><br><span class="line">    <span class="comment">// 转移方程：f[i]=min&#123;f[i-word.length],f[i]&#125;</span></span><br><span class="line">    <span class="comment">// 之所以会有min函数是因为 </span></span><br><span class="line">    <span class="comment">// sentence:"looked" dictionary:["looked","oked"]这种情况，最后就会采取最小匹配</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(sentence); <span class="comment">// sentence长度</span></span><br><span class="line">    <span class="keyword">int</span> dp[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">// 单词长度</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        dp[i+<span class="number">1</span>] = dp[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; dictionarySize;j++)&#123;</span><br><span class="line">            <span class="built_in">size</span> = <span class="built_in">strlen</span>(dictionary[j]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">size</span>&lt;=i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dictionary[j], substr(sentence, i+<span class="number">1</span>-<span class="built_in">size</span>, <span class="built_in">size</span>))==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>] = dp[i+<span class="number">1</span>]&lt;dp[i+<span class="number">1</span>-<span class="built_in">size</span>] ? dp[i+<span class="number">1</span>] : dp[i+<span class="number">1</span>-<span class="built_in">size</span>];</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看别人家的题解，了解到了<strong>字典树</strong>（Trie树）这个概念，同时还有<strong>字符串hash</strong>的解法。<br><a href="https://leetcode-cn.com/problems/re-space-lcci/solution/jian-dan-dp-trieshu-bi-xu-miao-dong-by-sweetiee/" target="_blank" rel="noopener">甜姐的trie解法</a></p>
<hr>
<h4 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h4><p>编写一个程序，找到两个单链表相交的起始节点。<br>利用<strong>两个链表的总长是一样的</strong>这一看似弱智的现象，有点类似于那个前移n位的算法，就是将[0:m]的前[0:n]和后[n+1:m]分别反转，整体再反转，就能实现前移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pA</span> = <span class="title">headA</span>, *<span class="title">pB</span> = <span class="title">headB</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(pA==<span class="literal">NULL</span> || pB==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">        pA = pA == <span class="literal">NULL</span> ? headB : pA-&gt;next;</span><br><span class="line">        pB = pB == <span class="literal">NULL</span> ? headA : pB-&gt;next; </span><br><span class="line">    &#125; <span class="comment">// 当无相交现象时，最后都为NULL时会直接跳出</span></span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p>判断给定链表是否有环。<br>设置快慢指针，快指针一次两步，慢指针一次一步。设置哑结点以优雅的处理边界(后来发现设置没有什么卵用)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummyhead</span>, *<span class="title">fast</span>, *<span class="title">slow</span>;</span> </span><br><span class="line">    dummyhead = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line"></span><br><span class="line">    dummyhead-&gt;next = head;</span><br><span class="line">    slow = dummyhead;</span><br><span class="line">    fast = dummyhead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">NULL</span> || fast-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="地下城与勇士"><a href="#地下城与勇士" class="headerlink" title="地下城与勇士"></a>地下城与勇士</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<ul>
<li>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</li>
<li>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</li>
<li>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</li>
</ul>
<h5 id="初代解法（失败）"><a href="#初代解法（失败）" class="headerlink" title="初代解法（失败）"></a>初代解法（失败）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>** dungeon, <span class="keyword">int</span> dungeonSize, <span class="keyword">int</span>* dungeonColSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[dungeonSize][*dungeonColSize]; <span class="comment">// 申请一个和原二维数组相同大小的二维空间</span></span><br><span class="line">    f[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>] = <span class="number">1</span> - dungeon[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>]; <span class="comment">// 初始化f</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = dungeonSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = *dungeonColSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==dungeonSize<span class="number">-1</span> &amp;&amp; j==*dungeonColSize<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == dungeonSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = f[i][j+<span class="number">1</span>] - dungeon[i][j]; <span class="comment">// 下边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(j == *dungeonColSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = f[i+<span class="number">1</span>][j] - dungeon[i][j]; <span class="comment">// 左边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            f[i][j] = fmin(f[i+<span class="number">1</span>][j], f[i][j+<span class="number">1</span>]) - dungeon[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二代解法（成功）"><a href="#二代解法（成功）" class="headerlink" title="二代解法（成功）"></a>二代解法（成功）</h5><p>这次只修改了代码中的一个逻辑，就是在每一次赋值的时候均将该值与1（生命最小值）相比较。<br>分析原来的算法可以知道，原来的算法对于某些情况的路径是适用的，即在递推过程中，没有一条路径中出现的f值会为负数，所以我用<code>[[-2,-3,-3],[-5,-10,-1],[-10,-30,-5]]</code>这个全负测试用例来测试一代解法是百试不爽的。但错就错在，我们的主角是有生命值限制的，中间一旦生命值&lt;1就会立即死亡。<br>因此，为了改进原算法，只需修改原来的赋值等号右侧，<strong>一旦值小于0，就将该值修改为1</strong>，即我们加入了一个限制条件，我们可以这么理解：按一代解法的主角开挂路径（就如同一个主角开了生命值掉为0都死不了的挂），主角走到该点单看生命值其实已经挂了，我们现在手里没有挂，那么我们为了求出满足条件的最低开局生命值，只能不断手动尽量让这个点的主角残血。那么一直向前推，开局的主角就将是满足当前条件的血量最小值（不断地残血逼近开头，最终达到目的），有点类似于递归思想。<br>这么看的话，一代解法似乎是一种极端，那么如果所有的房间都是治愈房间（值为非负数），那么开局必为残血，<code>f[0][0]=1</code>。感觉这竟然很像高中的数学极限法……不知道这个思路会不会有点用以后。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>** dungeon, <span class="keyword">int</span> dungeonSize, <span class="keyword">int</span>* dungeonColSize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[dungeonSize][*dungeonColSize]; <span class="comment">// 申请一个和原二维数组相同大小的二维空间</span></span><br><span class="line">    f[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>] = fmax(<span class="number">1</span>, <span class="number">1</span> - dungeon[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>]); <span class="comment">// 初始化f</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = dungeonSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = *dungeonColSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==dungeonSize<span class="number">-1</span> &amp;&amp; j==*dungeonColSize<span class="number">-1</span>) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == dungeonSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = fmax(<span class="number">1</span>, f[i][j+<span class="number">1</span>] - dungeon[i][j]); <span class="comment">// 下边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(j == *dungeonColSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = fmax(<span class="number">1</span>, f[i+<span class="number">1</span>][j] - dungeon[i][j]); <span class="comment">// 左边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            f[i][j] = fmax(<span class="number">1</span>, fmin(f[i+<span class="number">1</span>][j], f[i][j+<span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<h5 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h5><p>一开始一直超时还纳闷，我这不就是个双层循环吗，至于这么被针对？？最后发现是倒数第二个节点应该在每次循环的时候都指向空，否则链表就有环了，<code>p = p-&gt;next</code>那里肯定要超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span> || head-&gt;next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">head</span>, * <span class="title">cur</span> = <span class="title">head</span>, * <span class="title">q</span>, *<span class="title">lastTwo</span>;</span> <span class="comment">// p指向这一轮被移到前方的尾结点，cur指向当前的头结点</span></span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTwo = p; <span class="comment">// 找到倒数第二个结点</span></span><br><span class="line">        p = p-&gt;next; <span class="comment">// p现在是最后一个结点</span></span><br><span class="line">        q = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = p; <span class="comment">// 形成了这一轮的L0和Ln连接</span></span><br><span class="line">        p-&gt;next = q; <span class="comment">// 形成了L0，Ln，L1的连接</span></span><br><span class="line"></span><br><span class="line">        cur = cur-&gt;next-&gt;next; <span class="comment">// 更新cur</span></span><br><span class="line">        p = cur; <span class="comment">// 更新p</span></span><br><span class="line">        lastTwo-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 更新lastTwo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实做的时候就知道自己这个$O(n^2)$绝对性能贼差。</p>
<h5 id="别人解法"><a href="#别人解法" class="headerlink" title="别人解法"></a>别人解法</h5><ul>
<li>快慢指针定中点(慢一步，快两步，快到尾，慢到中)</li>
<li>后半部分链表反转</li>
<li>插空站队</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == null || head.next == null) <span class="keyword">return</span>;</span><br><span class="line">        ListNode s = head, f = head.next;</span><br><span class="line">        <span class="keyword">while</span> (f != null &amp;&amp; f.next != null) &#123;</span><br><span class="line">            s = s.next;</span><br><span class="line">            f = f.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出后，s指向链表中间节点</span></span><br><span class="line">        ListNode r = s.next; <span class="comment">// r保存s后面的队列</span></span><br><span class="line">        s.next = null;</span><br><span class="line">        ListNode prev = null, curr = r;</span><br><span class="line">        <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">            ListNode t = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时的prev就是反转后的头结点</span></span><br><span class="line">        ListNode c1 = head, c2 = prev, c3 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> le = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (c1 != null &amp;&amp; c2 != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (le % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                c3.next = c1;</span><br><span class="line">                c1 = c1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c3.next = c2;</span><br><span class="line">                c2 = c2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            le ++;</span><br><span class="line">            c3 = c3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c1 != null) c3.next = c1;</span><br><span class="line">        <span class="keyword">if</span> (c2 != null) c3.next = c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表反转通式(头结点为哑结点)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">r</span> = <span class="title">dummyhead</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// 保存头结点以后信息</span></span><br><span class="line">dummyhead-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头结点独立</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">curr</span> = <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">t</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// 保存当前结点后所有信息</span></span><br><span class="line">    curr-&gt;next = prev; <span class="comment">// curr结点的下一个为prev</span></span><br><span class="line">    prev = curr; <span class="comment">// prev更新为curr（前移一位）</span></span><br><span class="line">    curr = t; <span class="comment">// 当前结点更新为当前结点原来的后面信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = prev; <span class="comment">// 此时prev为头结点</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h4><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。</li>
<li>不必考虑输出顺序。</li>
</ul>
<h5 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h5><ul>
<li><code>breakLable</code>解决了p指向是空的情况。</li>
<li>遭遇死亡<code>stack-buffer-overflow</code>和<code>heap-buffer-overflow</code>，初始化<code>returnSize</code>得到结论（Leetcode这个对C的设定真的不好，非要弄<code>returnSize</code>）</li>
<li>提交发现空表出问题，修改了初始返回空数组。</li>
<li>发现一个奇怪的案例不行，本机调试发现对nums1的计数器有问题，问题出在<code>break</code>后，没有考虑中途<code>break</code>和最后<code>break</code>的差别，修改后终于成功。</li>
</ul>
<h5 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h5><p>hash表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 出现次数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span> *<span class="title">next</span>;</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">intersect</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为涉及到出现次数，用hash表</span></span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums1Size == <span class="number">0</span> || nums2Size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">0</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span> *<span class="title">head</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * fmin(nums1Size, nums2Size));</span><br><span class="line">    head = (struct hashNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct hashNode));</span><br><span class="line"></span><br><span class="line">    head-&gt;index = nums1[<span class="number">0</span>];</span><br><span class="line">    head-&gt;value = <span class="number">1</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums1Size; i++) &#123; <span class="comment">// 遍历nums1，得到hash表</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">int</span> breakLabel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] == p-&gt;index)&#123;</span><br><span class="line">                p-&gt;value++;</span><br><span class="line">                breakLabel = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] == p-&gt;index)&#123;</span><br><span class="line">                p-&gt;value++;</span><br><span class="line">                breakLabel = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(breakLabel == <span class="number">0</span>)&#123; <span class="comment">// 若hash表中没有该值，则新建</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span> *<span class="title">newNode</span> = (<span class="title">struct</span> <span class="title">hashNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">hashNode</span>));</span></span><br><span class="line">            newNode-&gt;index = nums1[i];</span><br><span class="line">            newNode-&gt;value = <span class="number">1</span>;</span><br><span class="line">            p-&gt;next = newNode;</span><br><span class="line">            newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2Size; j++) &#123; <span class="comment">// 检查第二个数组里面与hash表的对应情况</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2[j] == p-&gt;index &amp;&amp; p-&gt;value &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                p-&gt;value--;</span><br><span class="line">                res[(*returnSize)++] = nums2[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="双指针思路"><a href="#双指针思路" class="headerlink" title="双指针思路"></a>双指针思路</h5><ul>
<li>如果两个数组是有序的，则可以便捷地计算两个数组的交集。</li>
<li>首先对两个数组进行排序，然后使用两个指针遍历两个数组。</li>
<li>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* _a, <span class="keyword">const</span> <span class="keyword">void</span>* _b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = _a, *b = (<span class="keyword">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a == *b ? <span class="number">0</span> : *a &gt; *b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">intersect</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    qsort(nums1, nums1Size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line">    qsort(nums2, nums2Size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* intersection = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * fmin(nums1Size, nums2Size));</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index1 &lt; nums1Size &amp;&amp; index2 &lt; nums2Size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">            index1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intersection[(*returnSize)++] = nums1[index1];</span><br><span class="line">            index1++;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个思路真的很简单漂亮啊，不过老实说就算提示我排序后更简单，这个方法我也可能会想不到……</li>
</ul>
<hr>
<h4 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h4><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<h5 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>** triangle, <span class="keyword">int</span> triangleSize, <span class="keyword">int</span>* triangleColSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 相当于每行数组左对齐后，只能向右下走或向下走</span></span><br><span class="line">    <span class="comment">// f[i][j] = min&#123;f[i-1][j], f[i-1][j-1]&#125; + f[i][j]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangleSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangleColSize[i]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) &#123;</span><br><span class="line">                triangle[i][j] += triangle[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == triangleColSize[i] - <span class="number">1</span>) &#123;</span><br><span class="line">                triangle[i][j] += triangle[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                triangle[i][j] += fmin(triangle[i<span class="number">-1</span>][j], triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = triangle[triangleSize - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; triangleSize; k++) &#123; <span class="comment">// 逐一遍历最后一行输出最小值</span></span><br><span class="line">        res = triangle[triangleSize - <span class="number">1</span>][k] &lt; res ? triangle[triangleSize - <span class="number">1</span>][k] : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实答案给的一种从三角形下侧遍历到上侧的思路挺好的，因为不用考虑边界情况了（下侧结点多于上侧）。<br>转移方程：<br>$$f[i][j]=min{f[i+1][j], f[i+1][j+1]}$$</p>
<hr>
<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><p>给出n，输出[1:n]的序列能构成的不同的二叉搜索树的数量。</p>
<h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p>dp求解：<br>大体思路：将[1:n]的序列，选定其中一个数为<code>i</code>，以它为根节点，由于根节点不同，所以建出来的树具有唯一性。再具体考虑这个以<code>i</code>为根节点建造的树，左右子树分别是[1:i-1]和[i+1:n]，显然[i+1:n]可以直接转换为[1:n-i]，那么以<code>i</code>为根节点所建造的树就是[1:i-1]和[1:n-i]所建造的树的<strong>笛卡尔乘积</strong>。</p>
<p>具体分析：</p>
<ol>
<li>状态<ul>
<li>$G(n)$：长度为<code>n</code>的序列能构成的不同二叉搜索树的个数</li>
</ul>
</li>
<li>初始条件<br>$$G(0) = G(1) = 1$$</li>
<li>转移方程<br>$$G(n) = \sum_{i=1}^nG(i-1)*G(n-i)$$</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> G[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">    G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两数之和II-输入有序数组"><a href="#两数之和II-输入有序数组" class="headerlink" title="两数之和II-输入有序数组"></a>两数之和II-输入有序数组</h4><p>给定一个升序排列的数组，找到两个数的加和使它们的和为目标数。返回两个数的索引+1。</p>
<h5 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> numbersSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 双指针思路</span></span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> breakLabel = <span class="number">0</span>; <span class="comment">// 寻找到目标数的标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index2 &lt; numbersSize) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index1] + numbers[index2] &lt; target) &#123; <span class="comment">// 如果相邻加起来小于目标数，指针前移</span></span><br><span class="line">            index1++;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index1] + numbers[index2] == target) &#123; <span class="comment">// 如果等于，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果大于目标数</span></span><br><span class="line">            <span class="keyword">while</span>(index1 &gt; <span class="number">0</span>) &#123; <span class="comment">// 先试着逐步后移慢指针</span></span><br><span class="line">                index1--;</span><br><span class="line">                <span class="keyword">if</span>(numbers[index1] + numbers[index2] == target) &#123;</span><br><span class="line">                    breakLabel = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(breakLabel == <span class="number">0</span>) &#123; <span class="comment">// 如果慢指针到头了未找到，更新两个索引为此次循环开始时的位置再各前移一个位置</span></span><br><span class="line">                index2++;</span><br><span class="line">                index1 = index2<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(breakLabel == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳出循环意味着已找到答案</span></span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    res[<span class="number">0</span>] = index1 + <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">1</span>] = index2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题解解法"><a href="#题解解法" class="headerlink" title="题解解法"></a>题解解法</h5><p>双指针分别从两侧向内逼近遍历：</p>
<ul>
<li>如果加和小于<code>target</code>，慢指针前移。</li>
<li>如果加和大于<code>target</code>，慢指针后移。</li>
<li>如果相等，直接返回。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[low] + numbers[high];</span><br><span class="line">            <span class="keyword">if</span> (sum == target)</span><br><span class="line">                <span class="keyword">return</span> &#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                ++low;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</li>
</ul>
<hr>
<h4 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h4><p>给定一个整数，循环计算各位的平方和，直到和为0，输出true。若陷入死循环，输出false。</p>
<h5 id="解法（参照官方题解）"><a href="#解法（参照官方题解）" class="headerlink" title="解法（参照官方题解）"></a>解法（参照官方题解）</h5><p>思路：双指针，建造<strong>虚拟链表</strong><br>原理：当陷入死循环时，相当于之前所有的记录构成了一个含环的链表。快指针前进速率永远是慢指针的两倍，当最后行进相交时，可以证明该链表含环。并没有真的建造一个链表，而是通过累次计算的次数不一样，来逐步构建这个链表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        res += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = n, fast = getNext(n);</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="number">1</span> &amp;&amp; slow != fast) &#123;</span><br><span class="line">        slow = getNext(slow);</span><br><span class="line">        fast = getNext(getNext(fast));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="存在重复元素II"><a href="#存在重复元素II" class="headerlink" title="存在重复元素II"></a>存在重复元素II</h4><p>给定一个整数数组和一个整数 <code>k</code>，判断数组中是否存在两个不同的索引 <code>i</code> 和 <code>j</code>，使得 <code>nums [i] = nums [j]</code>，并且 <code>i</code> 和 <code>j</code>的差的绝对值至多为 <code>k</code>。</p>
<h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><p>这个解法出自于官方题解，思路很简单，但主要是它的边界处理给了我一些启发。如果是以一个搜索框进行遍历操作的时候，越界的时候，以后可以用<code>max</code>或<code>min</code>这些函数来优雅地解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.max(i - k, <span class="number">0</span>); j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Time Limit Exceeded.</span></span><br></pre></td></tr></table></figure>

<h5 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h5><h6 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h6><p>通过散列表，即创造一个长度为k的表。<br>遍历数组，对于每个元素：</p>
<ul>
<li>在散列表中进行搜索，若存在，返回<code>true</code></li>
<li>在散列表中插入当前元素</li>
<li>如果当前大小超过了k，则将所待最久的元素移除</li>
</ul>
<p>相当于一个<strong>能遍历的队列</strong>。</p>
<h6 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h6><p>通过<code>hash</code>，<code>key</code>为<code>num</code>，<code>value</code>为其<code>index</code>。<br>遍历数组，对于每个元素：</p>
<ul>
<li>若元素在表中，判断<code>i-m[nums[i]] &lt;= k</code><ul>
<li>若<code>true</code>，返回<code>true</code></li>
<li>若<code>false</code>，更新其<code>m[nums[i]]</code>为<code>i</code></li>
</ul>
</li>
<li>若元素不在表中，更新其<code>m[nums[i]]</code>为<code>i</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter != m.<span class="built_in">end</span>() &amp;&amp; i - m[nums[i]] &lt;= k) &#123;</span><br><span class="line">                <span class="comment">// 若存在表中，且下标差符合要求</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="存在重复元素III"><a href="#存在重复元素III" class="headerlink" title="存在重复元素III"></a>存在重复元素III</h4><h5 id="个人解法（超时）"><a href="#个人解法（超时）" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// key:nums[i] value:i</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(nums[j]);</span><br><span class="line">            <span class="keyword">if</span>(iter != m.<span class="built_in">end</span>() &amp;&amp; j - iter-&gt;second &lt;= k)&#123; <span class="comment">// 如果新纳入的值已经存在表中 且 index差小于等于k 则返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">// 否则更新表</span></span><br><span class="line">                m[nums[j]] = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = nums[j]; <span class="comment">// temp表示当前的纳入表的数值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = temp-t; i &lt;= temp+t; ++i) &#123; </span><br><span class="line">                <span class="comment">// 然后在哈希表的[temp-t,temp+t]范围搜索是否这样的key为i</span></span><br><span class="line">                <span class="comment">// 使得 value存在(当前表中存在满足绝对值差&lt;=t条件的数) 且 m[nums[j]]-m[i] &lt;= k(存在的数也满足下标差&lt;=k)</span></span><br><span class="line">                <span class="keyword">if</span>(m.count(i) == <span class="number">1</span> &amp;&amp; m[temp] - m[i] &lt;= k &amp;&amp; i!=temp) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要是在<code>[temp-t,temp+t]</code>范围内查找的时候，如果t过大，会很慢很慢。</p>
<h5 id="他人解法"><a href="#他人解法" class="headerlink" title="他人解法"></a>他人解法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; <span class="built_in">set</span>;  <span class="comment">// 新建集合set</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;  <span class="comment">// 遍历nums</span></span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">set</span>.lower_bound((<span class="keyword">long</span>) nums[i] - t);  <span class="comment">// 将不小于nums[i] - t的迭代器返回给it</span></span><br><span class="line">            <span class="keyword">if</span>(it != <span class="built_in">set</span>.<span class="built_in">end</span>() &amp;&amp; *it &lt;= (<span class="keyword">long</span>) nums[i] + t)</span><br><span class="line">            <span class="comment">// 如果这个数存在，且不大于nums[i] + t</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">set</span>.insert(nums[i]);  <span class="comment">// 将nums[i]加入set集合</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">size</span>() == k + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">set</span>.erase(nums[i - k]); <span class="comment">//保证滑动窗口大小为k</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h4><p>给定字符串<code>s</code>和<code>t</code>，判断<code>s</code>是否为<code>t</code>的子序列。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<h5 id="个人解答-2"><a href="#个人解答-2" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n_s = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_s ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">n_t</span> = t.length();  <span class="comment">// 更新t的长度</span></span><br><span class="line">            <span class="keyword">auto</span> pos = t.<span class="built_in">find</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(pos != t.npos) &#123; <span class="comment">// 如果找到了，将t替换成其后的子串</span></span><br><span class="line">                t = t.substr(pos + <span class="number">1</span>, <span class="keyword">n_t</span> - pos - <span class="number">1</span>); <span class="comment">// 更新t</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="排列硬币"><a href="#排列硬币" class="headerlink" title="排列硬币"></a>排列硬币</h4><p>你总共有<code>n</code>枚硬币，你需要将它们摆成一个阶梯形状，第<code>k</code>行就必须正好有<code>k</code>枚硬币。</p>
<p>给定一个数字<code>n</code>，找出可形成完整阶梯行的总行数。</p>
<p><code>n</code>是一个非负整数，并且在32位有符号整型的范围内。</p>
<h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p>时间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt;= i) &#123;</span><br><span class="line">            n -= i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h5><p>时间复杂度：$O(log_2(n/2+1))$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找[1:n/2 + 1]中的一个中间数mid，使得(mid+1)*mid/2==n</span></span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">0</span>, <span class="built_in">end</span> = (<span class="keyword">long</span>)n / <span class="number">2</span> + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span> - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid * (mid + <span class="number">1</span>) == (<span class="keyword">long</span>)n * <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">int</span>(mid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid * (mid + <span class="number">1</span>) &lt; (<span class="keyword">long</span>)n * <span class="number">2</span>) &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">end</span> = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">end</span> * (<span class="built_in">end</span> + <span class="number">1</span>) == (<span class="keyword">long</span>)n * <span class="number">2</span>) ? (<span class="keyword">int</span>)<span class="built_in">end</span> : (<span class="keyword">int</span>)start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a>计数质数</h4><p>统计所有小于非负整数<code>n</code>的质数的数量。</p>
<h5 id="个人解法（超时）-1"><a href="#个人解法（超时）-1" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= (n<span class="number">-1</span>)/<span class="number">2</span>; ++i) &#123; </span><br><span class="line">            <span class="keyword">if</span>((n<span class="number">-1</span>) % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> countPrimes(n<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countPrimes(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="题解解法-1"><a href="#题解解法-1" class="headerlink" title="题解解法"></a>题解解法</h5><p>是排除法，排除从1到n-1范围内的所有质数（将其标志位置为0）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//n = 15</span></span><br><span class="line">        <span class="keyword">int</span> a[n+<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            a[i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i)</span><br><span class="line">                    a[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>没有想到有朝一日，这题居然也成了问题，但真没写对，555</p>
<h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><p>假设列表为：<br>$$n1\rightarrow…\rightarrow n_{k-1}\rightarrow n_k\rightarrow…\rightarrow n_m \rightarrow \varnothing$$<br>若$n_{k+1}$到$n_m$已经被反转，而我们已经处于$n_k$。<br>$$n1\rightarrow…\rightarrow n_{k-1}\rightarrow n_k\leftarrow…\leftarrow n_m$$<br>则只需将$n_{k+1}$的下一个结点指向$n_k$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="仅含1的字符串"><a href="#仅含1的字符串" class="headerlink" title="仅含1的字符串"></a>仅含1的字符串</h4><p>给你一个二进制字符串<code>s</code>（仅由<code>&#39;0&#39;</code>和<code>&#39;1&#39;</code>组成的字符串）。</p>
<p>返回所有字符都为<code>1</code>的子字符串的数目。</p>
<p>由于答案可能很大，请你将它对<code>10^9 + 7</code>取模后返回。</p>
<h5 id="个人解法-2"><a href="#个人解法-2" class="headerlink" title="个人解法"></a>个人解法</h5><p>hash表记录每段连续的1出现次数以及频次。<br>例如：<code>&quot;01101110111110011&quot;</code><br>对应的hash表为<br><code>m[2] = 2;
m[3] = 1;
m[5] = 1;</code><br>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSub</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oneCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// key:连续1出现的次数 value:这个次数出现的频次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                oneCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'0'</span> &amp;&amp; oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(m.count(oneCount) == <span class="number">0</span>) <span class="comment">// hash表中没有对应的键</span></span><br><span class="line">                    m[oneCount] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    m[oneCount]++;</span><br><span class="line">            &#125; </span><br><span class="line">            oneCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m.count(oneCount) == <span class="number">0</span>) <span class="comment">// hash表中没有对应的键</span></span><br><span class="line">                    m[oneCount] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m[oneCount]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;int,int&gt;&gt; v_map(m.begin(),m.end());</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, tn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tmp:v_map)&#123;</span><br><span class="line">            tn = ((<span class="keyword">long</span>)tmp.first + <span class="number">1</span>)*(<span class="keyword">long</span>)tmp.first / <span class="number">2</span>; <span class="comment">// 计算1+2+3+...+n</span></span><br><span class="line">            sum += ((<span class="keyword">long</span>)tmp.second*tn); <span class="comment">// 加等于 tn乘对应频次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(sum%MAXN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h5 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h5><p>不需要hash表，直接就地+=运算（瞬间感觉我用hash表，简直是脱裤子放p）<br>速度快了一倍多，，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">calValue</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * (n+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSub</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oneCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> MAXN = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                oneCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'0'</span> &amp;&amp; oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += calValue(oneCount);</span><br><span class="line">            &#125; </span><br><span class="line">            oneCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += calValue(oneCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(sum%MAXN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h4><p>有<code>n</code>个气球，编号为<code>0</code>到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p>
<p>现在要求你戳破所有的气球。如果你戳破气球<code>i</code>，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的<code>left</code>和<code>right</code>代表和<code>i</code>相邻的两个气球的序号。注意当你戳破了气球<code>i</code>后，气球<code>left</code>和气球<code>right</code>就变成了相邻的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>说明:</p>
<ul>
<li>你可以假设<code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li>
<li><code>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</code></li>
</ul>
<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>看了好几个大佬的题解，都是从回溯法到记忆递归向下一步步优化到动态规划的。<br><a href="https://qoogle.top/leetcode-312-burst-balloons/" target="_blank" rel="noopener">大佬1传送门</a><br><a href="https://www.cnblogs.com/niuyourou/p/11964842.html" target="_blank" rel="noopener">大佬2传送门</a></p>
<h5 id="动态规划代码"><a href="#动态规划代码" class="headerlink" title="动态规划代码"></a>动态规划代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>)); <span class="comment">// 新建一个dp二维数组</span></span><br><span class="line">        nums.push_back(<span class="number">1</span>);</span><br><span class="line">        nums.insert(nums.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k<span class="number">-1</span>] + dp[k+<span class="number">1</span>][j] + nums[k] * nums[i - <span class="number">1</span>] * nums[j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="旋转数组的最小值"><a href="#旋转数组的最小值" class="headerlink" title="旋转数组的最小值"></a>旋转数组的最小值</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 $[3,4,5,1,2]$ 为 $[1,2,3,4,5]$ 的一个旋转，该数组的最小值为1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分查找:找到该元素的左侧大于它，右侧大于等于它</span></span><br><span class="line">        <span class="keyword">int</span> n = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">end</span> &gt; start) &#123;</span><br><span class="line">            <span class="comment">//int mid = (start + end) / 2;</span></span><br><span class="line">            <span class="keyword">int</span> mid = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &lt; numbers[<span class="built_in">max</span>(<span class="number">0</span>, mid - <span class="number">1</span>)] <span class="comment">/*&amp;&amp; numbers[mid] &lt;= numbers[min(n - 1, mid + 1)]*/</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[mid];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[<span class="built_in">end</span>]) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[<span class="built_in">end</span>]) &#123;</span><br><span class="line">                <span class="built_in">end</span> = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">end</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="built_in">end</span>];       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个解法的边界处理非常值得总结一下，尤其是<code>start = mid + 1</code>和<code>end--</code>这两个地方非常容易出错。</p>
<ul>
<li><code>start = mid + 1</code>避免了形同$[3,1]$这种类型</li>
<li><code>end--</code>避免了$[1,1,1]$这样的结尾出现重复数的情形</li>
</ul>
<hr>
<p>Leetcode日记I就到这里啦，LeetcodeII日记再见~</p>
]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记III</title>
    <url>/2020/07/24/Leetcode%E6%97%A5%E8%AE%B0III/</url>
    <content><![CDATA[<p>延续II的风格，进行题型分类。</p>
<a id="more"></a>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="计算右侧小于当前元素的个数"></a>计算右侧小于当前元素的个数</h4><h5 id="第一次提交"><a href="#第一次提交" class="headerlink" title="第一次提交"></a>第一次提交</h5><p>从头向尾遍历数组，将第i个之后的数组拷贝一份并排序，并对排序后的数组应用二分查找找到后续的小于当前元素个数，超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sortedNums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sortedNums[m] &gt;= target) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedNums</span><span class="params">(n)</span></span>;</span><br><span class="line">            copy(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), sortedNums.<span class="built_in">begin</span>()); <span class="comment">// 拷贝一份nums</span></span><br><span class="line">            sort(sortedNums.<span class="built_in">begin</span>(), sortedNums.<span class="built_in">end</span>()); <span class="comment">// 对sortedNums进行排序</span></span><br><span class="line">            <span class="keyword">int</span> temp = binarySearch(num, sortedNums, n);</span><br><span class="line">            n -= <span class="number">1</span>;</span><br><span class="line">            nums.erase(nums.<span class="built_in">begin</span>());</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="第二次提交"><a href="#第二次提交" class="headerlink" title="第二次提交"></a>第二次提交</h5><p>从后向前遍历数组，将i后续的数组直接在原数组上进行排序，并将得到的<code>temp</code>头插入到<code>ans</code>数组中，依然超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sortedNums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sortedNums[m] &gt;= target) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">end</span>()); <span class="comment">// 对sortedNums进行排序</span></span><br><span class="line">            <span class="keyword">int</span> temp = binarySearch(num, nums, i, n - <span class="number">1</span>);</span><br><span class="line">            ans.insert(ans.<span class="built_in">begin</span>(), temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="第三次提交"><a href="#第三次提交" class="headerlink" title="第三次提交"></a>第三次提交</h5><p>使用了该作者的<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/315-ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-9/" target="_blank" rel="noopener">优化解法</a>。<br>他的解法妙就妙在并不用对后续的数组进行<code>sort</code>排序，而是利用返回的这个<code>r</code>向当前的排序数组进行插入。从而避免了每次都要重排的这部分开销，完美的利用了上一步的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ordered_arr存储排序后的有序数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ordered_arr, res(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = ordered_arr.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; ordered_arr[mid])</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// r即插入ordered_arr的位置，也是在其右侧比其小的元素个数</span></span><br><span class="line">            res[i] = r; </span><br><span class="line">            <span class="comment">// 倒序逐个插入元素</span></span><br><span class="line">            ordered_arr.insert(ordered_arr.<span class="built_in">begin</span>() + r, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(nlogn)$（但是insert函数开销较大，有接近$O(n)$的复杂度）</p>
<h4 id="分割数组的最大和"><a href="#分割数组的最大和" class="headerlink" title="分割数组的最大和"></a>分割数组的最大和</h4><p>给定一个数组，和一个要求的分割数<code>m</code>。求出所有分割法中，各分成m份中的最大值中最小的那个和。</p>
<h5 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h5><p>听官方的话说”求最大值中的最小值”这种问法常用二分法来解决。<br>思路：</p>
<ul>
<li>该目标值显然位于<code>maxVal</code>和<code>sumArray</code>之间，那么我们寻求一个中间的<code>mid</code>值，然后以这个<code>mid</code>值为标准对数组依次划分。</li>
<li>将数组从头到尾进行遍历，使之分成多个不大于<code>mid</code>的部分，然后判断这个得到的分割部分<code>count</code>是否满足不大于<code>m</code>这一条件？<ul>
<li>如果满足，则可能当前的<code>mid</code>选取的有点大了，将区间划到左侧继续尝试搜索有没有更小点的<code>mid</code>。</li>
<li>如果不满足，显然当前<code>mid</code>选取小了，需要在右侧区间进行继续搜索。</li>
</ul>
</li>
<li>最终不断地逼近正确结果，也就是最后<strong>不大不小刚刚好把题目的nums分成m份，且每一部分的和都比较接近</strong>（定性描述），此时的搜到的结果显然是所求解。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkMid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> mid, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 初始化计数器</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>; <span class="comment">// 初始化加和，目标是m - 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + sum &gt; mid) &#123; <span class="comment">// 当当前元素组的加和大于目标加和，截断，计数</span></span><br><span class="line">                count++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，继续向后累加</span></span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count &lt;= m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//if (!n) return 0;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> maxVal = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxVal)</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = maxVal, right = sum, mid; <span class="comment">// 在maxVal到sum的范围内进行二分搜索</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (checkMid(nums, mid, m)) &#123; <span class="comment">// 检查当前m的值是偏大还是偏小</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
不过我却还是觉得很神奇的就是，假设<code>nums[i] + sum &lt; mid</code>在所有分割数组都发生了，而没有出现过一个分割集的数恰好等于<code>mid</code>，那么最后输出的解就不是最优解了？</li>
<li>还是说当出现这种情况的时候，会触发最后的<code>checkMid</code>的<code>false</code>导致<code>left</code>更新然后修正了？</li>
<li>还是说根本不会达到我的假设？</li>
</ul>
<hr>
<h3 id="树和图"><a href="#树和图" class="headerlink" title="树和图"></a>树和图</h3><h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><p>给定一个树，给定一个sum。返回是否有从根节点到子节点的路径val总和==sum。</p>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt; pair&lt; <span class="keyword">int</span>, TreeNode* &gt; &gt; q; <span class="comment">// 保存&lt;当前和，节点&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        q.push(&#123;root-&gt;val, root&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> node = temp.second;</span><br><span class="line">            <span class="keyword">auto</span> curSum = temp.first;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) q.push(&#123;curSum + node-&gt;left-&gt;val, node-&gt;left&#125;);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) q.push(&#123;curSum + node-&gt;right-&gt;val, node-&gt;right&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum == curSum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树中的链表"><a href="#二叉树中的链表" class="headerlink" title="二叉树中的链表"></a>二叉树中的链表</h4><p>查找二叉树中从上到下的某条路径中是否含有与链表元素排列相同的子路径。</p>
<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><p>注意<code>isSubPath</code>函数中的返回值，如果针对<code>root</code>进行DFS失败后，就要试试左子树和右子树进行<code>isSubPath</code>是否成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != head-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(head-&gt;next, root-&gt;left) || dfs(head-&gt;next, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubPath</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自顶向下dfs</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(head, root) || isSubPath(head, root-&gt;left) || isSubPath(head, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><p>只关注到每一个非叶子节点的左节点和右节点是否满足，没有关注叶子节点的左子树和右子树是否满足。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left-&gt;val &lt; root-&gt;val) &#123;</span><br><span class="line">                ans &amp;= dfs(root-&gt;left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">                ans &amp;= dfs(root-&gt;right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root) &amp;&amp; isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="递归修正"><a href="#递归修正" class="headerlink" title="递归修正"></a>递归修正</h5><p>上限值和下限值的递归</p>
<ul>
<li>遍历到左子树，更新<code>higher</code>为<code>root-&gt;val</code></li>
<li>遍历到右子树，更新<code>lower</code>为<code>root-&gt;right</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> lower, <span class="keyword">long</span> <span class="keyword">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            inorder(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (ans.empty()) ans.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[ans.<span class="built_in">size</span>() - <span class="number">1</span>] &gt;= root-&gt;val) &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.push_back(root-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h4><p>找出路径和等于给定数值的路径总数。</p>
<h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span> currSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (currSum + root-&gt;val == sum) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, sum, currSum + root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right, sum, currSum + root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, sum, <span class="number">0</span>);</span><br><span class="line">        pathSum(root-&gt;left, sum);</span><br><span class="line">        pathSum(root-&gt;right, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h4><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径，返回一个二维数组。</p>
<h5 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h5><p>这个性能比较差，传参必须要传成非引用格式的<code>row</code>，否则后续返回其他结果的时候会与前面的路径产生交集。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        row.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                ans.push_back(row);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, target, row, sum);</span><br><span class="line">        dfs(root-&gt;right, target, row, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row;</span><br><span class="line">        dfs(root, sum, row, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="DFS优化"><a href="#DFS优化" class="headerlink" title="DFS优化"></a>DFS优化</h5><ul>
<li>优化掉了一个参数：每次向下递减就不用再额外保存sum参数了</li>
<li>每次结束后弹出，就能使用地址传参了，空间优化很多<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        row.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == target &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ans.push_back(row);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, target - root-&gt;val, row);</span><br><span class="line">        dfs(root-&gt;right, target - root-&gt;val, row);</span><br><span class="line">        row.pop_back(); </span><br><span class="line">        <span class="comment">/* 弹出最后一个添加的元素，每执行完一次dfs意味着</span></span><br><span class="line"><span class="comment">        该root的左右子节点均已返回，此时应该将该路径的数弹出，</span></span><br><span class="line"><span class="comment">        以防共用一个地址空间，后面的row数组会产生重复*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row;</span><br><span class="line">        dfs(root, sum, row);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h4><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, getMax(root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, getMax(root-&gt;right));</span><br><span class="line">        res = <span class="built_in">max</span>(res, root-&gt;val + left + right); <span class="comment">// 如果当前根节点的路径最大，则更新res</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root-&gt;val; <span class="comment">// 在每个子节点中选择左右子树中路径较大的加上根节点值才能构成合法路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        getMax(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h4><p>给定一个二叉树，<strong>原地</strong>将它展开为一个单链表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br><span class="line">转换为</span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; inf;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            inf.push_back(root);</span><br><span class="line">            dfs(root-&gt;left);</span><br><span class="line">            dfs(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       dfs(root);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; inf.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">           TreeNode* curr = inf[i], *prev = inf[i - <span class="number">1</span>];</span><br><span class="line">           prev-&gt;right = curr;</span><br><span class="line">           prev-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="边前序边展开"><a href="#边前序边展开" class="headerlink" title="边前序边展开"></a>边前序边展开</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            TreeNode* curr = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                prev-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                prev-&gt;right = curr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode *left = curr-&gt;left, *right = curr-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运算流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1进栈 </span><br><span class="line">1出栈 </span><br><span class="line">5进栈 </span><br><span class="line">2进栈</span><br><span class="line">2出栈</span><br><span class="line">prev是1</span><br><span class="line">prev右是2</span><br><span class="line">4进栈</span><br><span class="line">3进栈</span><br><span class="line">3出栈</span><br><span class="line">prev是2</span><br><span class="line">prev右是3</span><br><span class="line">4出栈</span><br><span class="line">prev是3</span><br><span class="line">prev右是4</span><br><span class="line">5出栈</span><br><span class="line">prev是4</span><br><span class="line">prev右是5</span><br><span class="line">6进栈</span><br><span class="line">6出栈</span><br><span class="line">prev是5</span><br><span class="line">prev右是6</span><br></pre></td></tr></table></figure>

<h5 id="前序递归"><a href="#前序递归" class="headerlink" title="前序递归"></a>前序递归</h5><p>参考王道烩大神的题解。<br>先把左右子树分别展开，然后将左子树插入到右子树上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            TreeNode* cur = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;right) &#123; </span><br><span class="line">                <span class="comment">// 找到当前节点的左子树的右侧尾结点</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;right = root-&gt;right; <span class="comment">// 将根节点的右子树挂到当前节点右侧</span></span><br><span class="line">            root-&gt;right = root-&gt;left; <span class="comment">// 左子树替换右子树</span></span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>; <span class="comment">// 左子树置为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><h4 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h4><p>对于一个迷宫<code>obstacleGrid</code>，里面只有0、1两种，1不允许通过，求从左上角到达右下角的路径个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[m];</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>) dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) temp = <span class="number">0</span>;</span><br><span class="line">            dp[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                        temp = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[<span class="number">0</span>] = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = (obstacleGrid[i][j] == <span class="number">1</span>) ? <span class="number">0</span> : (dp[j] + dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h4><p>将整数n化为多个数的乘积，使得乘积最大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i; ++j) &#123; <span class="comment">// 最后一份为j</span></span><br><span class="line">                <span class="comment">// 当i-j部分不继续分时，为后者</span></span><br><span class="line">                <span class="comment">// 当i-j部分需要继续分，为前者</span></span><br><span class="line">                <span class="keyword">int</span> max1 = <span class="built_in">max</span>(dp[i - j] * j, (i - j) * j);</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], max1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="和相同的二元子数组"><a href="#和相同的二元子数组" class="headerlink" title="和相同的二元子数组"></a>和相同的二元子数组</h4><p>在由若干<code>0</code>和<code>1</code> 组成的数组<code>A</code>中，有多少个和为<code>S</code>的非空子数组。</p>
<h5 id="个人解法（空间太大）"><a href="#个人解法（空间太大）" class="headerlink" title="个人解法（空间太大）"></a>个人解法（空间太大）</h5><p>数组开的过大，栈溢出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n][n];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// f[i][j] 表示从i到j构成的加和</span></span><br><span class="line">        <span class="comment">// f[i][j] = f[i][j - 1] + A[j] = f[i - 1][j] - A[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            dp[k][k] = A[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + A[j];</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == S) ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[k] == S) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="优化dp（超时）"><a href="#优化dp（超时）" class="headerlink" title="优化dp（超时）"></a>优化dp（超时）</h5><p>优化成滚动数组，超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// f[i][j] 表示从i到j构成的加和</span></span><br><span class="line">        <span class="comment">// f[i][j] = f[i][j - 1] + A[j] = f[i - 1][j] - A[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[k] == S) ++ans;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = A[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] + A[j];</span><br><span class="line">                <span class="keyword">if</span> (dp[j] == S) ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先求得前缀和<code>s[i]表示前i-1项和</code>，问题转换成：<br>遍历到第s[j]，求得有多少个S满足<code>S = s[j] - s[i]</code> </p>
<ol>
<li>如果前缀和大于等于S，则前侧存在满足条件的子数组</li>
<li>S = s[i] - s[j] (i &gt; j) –&gt; <strong>存在多少个s[j]使得，<code>s[j] = s[i] - S</code></strong></li>
<li>s[j]个数 = (s[i] - S)的个数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;int&gt; s(n + 1, 0), f(n + 1, 0);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="number">1</span>] + A[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = s[i]; <span class="comment">// 第i位置的前缀和</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= S) ans += f[sum - S]; </span><br><span class="line">            f[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="删除排序链表的重复项II"><a href="#删除排序链表的重复项II" class="headerlink" title="删除排序链表的重复项II"></a>删除排序链表的重复项II</h4><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[idx - <span class="number">2</span>]) &#123; <span class="comment">// 新序列的倒数第二个元素不等于当前遍历的元素</span></span><br><span class="line">                <span class="comment">// 则将新序列的下一个元素变为当前遍历的元素，并后移新序列的尾指针</span></span><br><span class="line">                nums[idx++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则i指针继续向前遍历</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 $a + b + c = 0$ ? 请你找出所有满足条件且不重复的三元组。</p>
<p>注意：<strong>答案中不可以包含重复的三元组</strong>。</p>
<h5 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h5><p>固定前一个元素，后续元素双指针优化，失败。（没有处理好重复元素限定）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 固定一个数，另外两个数为双指针寻值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> i = k + <span class="number">1</span>, j = n - <span class="number">1</span>; <span class="comment">// 快慢指针</span></span><br><span class="line">            <span class="keyword">int</span> target = -nums[k];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">                    v.push_back(nums[k]);</span><br><span class="line">                    v.push_back(nums[i]);</span><br><span class="line">                    v.push_back(nums[j]);</span><br><span class="line">                    ans.push_back(v);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] &gt; target) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考starfly的题解之后，修改细节如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 固定一个数，另外两个数为双指针寻值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果第一个值大于零，后续将不存在解，直接跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 排除固定元素造成的重复</span></span><br><span class="line">            <span class="keyword">int</span> i = k + <span class="number">1</span>, j = n - <span class="number">1</span>; <span class="comment">// 快慢指针</span></span><br><span class="line">            <span class="keyword">int</span> target = -nums[k];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">                    v.push_back(nums[k]);</span><br><span class="line">                    v.push_back(nums[i]);</span><br><span class="line">                    v.push_back(nums[j]);</span><br><span class="line">                    ans.push_back(v);</span><br><span class="line"></span><br><span class="line">                    ++i; --j;</span><br><span class="line">                    <span class="comment">// 排除快慢指针指向的元素造成的重复</span></span><br><span class="line">                    <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) --j;</span><br><span class="line">                    <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) ++i;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &gt; target) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<h5 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h5><p>固定前两个元素+双指针+set去重</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans; <span class="comment">// set去重</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">4</span>; ++i) &#123; <span class="comment">// 固定首元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n - <span class="number">3</span>; ++j) &#123; <span class="comment">// 固定次元素</span></span><br><span class="line">                <span class="keyword">int</span> k = j + <span class="number">1</span>, l = n - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "下标 " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; k &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "数值 " &lt;&lt; nums[i] &lt;&lt; " " &lt;&lt; nums[j] &lt;&lt; " " &lt;&lt; nums[k] &lt;&lt; " " &lt;&lt; nums[l] &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">while</span> (k &lt; l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[l];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        ans.insert(&#123;nums[i] ,nums[j] ,nums[k] ,nums[l]&#125;);</span><br><span class="line">                        ++k; --l;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        ++k;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        --l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h5><p>固定元素+双指针+边界条件去重</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">4</span>; ++i) &#123; <span class="comment">// 固定首元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n - <span class="number">3</span>; ++j) &#123; <span class="comment">// 固定次元素</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> k = j + <span class="number">1</span>, l = n - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "下标 " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; k &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "数值 " &lt;&lt; nums[i] &lt;&lt; " " &lt;&lt; nums[j] &lt;&lt; " " &lt;&lt; nums[k] &lt;&lt; " " &lt;&lt; nums[l] &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">while</span> (k &lt; l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[l];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        ans.push_back(&#123;nums[i] ,nums[j] ,nums[k] ,nums[l]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; l &amp;&amp; nums[k + <span class="number">1</span>] == nums[k])</span><br><span class="line">                            ++k; </span><br><span class="line">                        <span class="keyword">while</span> (k &lt; l &amp;&amp; nums[l - <span class="number">1</span>] == nums[l])</span><br><span class="line">                            --l;</span><br><span class="line">                        ++k; --l;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        ++k;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        --l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h4><p>字符串<code>S</code>由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
<p>看完这题完全没有思路。</p>
<p>hash表+双指针思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每个片段蕴含的字母尽量少，含有的字母种类尽量少</span></span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ends</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span></span>; <span class="comment">// 建立26个字母的hash表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ends[S[i] - <span class="string">'a'</span>] = i; <span class="comment">// 更新ends[c]为每一个字符c出现的最后一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = ends[S[i] - <span class="string">'a'</span>]; <span class="comment">// 获取当前分段的开头元素在数组中最后一次出现的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= r; ++j) &#123;</span><br><span class="line">                <span class="comment">// 更新r为区间(i,r]内的字符出现位置的最大值</span></span><br><span class="line">                r = <span class="built_in">max</span>(r, ends[S[j] - <span class="string">'a'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(r - i + <span class="number">1</span>);</span><br><span class="line">            i = r + <span class="number">1</span>; <span class="comment">// 更新i</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h4><ul>
<li><code>tolower()</code></li>
<li><code>isalsum(char c)</code>返回c是否为大写字母或小写字母或数字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="通过删除字母匹配到字典里最长单词"><a href="#通过删除字母匹配到字典里最长单词" class="headerlink" title="通过删除字母匹配到字典里最长单词"></a>通过删除字母匹配到字典里最长单词</h4><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p>
<p>思路：</p>
<ul>
<li>先将d容器按照优先长度升序，再按字典序倒序排列。</li>
<li>遍历时倒序遍历d检查即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a.length() == b.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> a &gt; b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.length() &lt; b.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; cmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span> || d.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        sort(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = d.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; <span class="comment">// i是s的指针，k是d[j]的指针</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.length()) &#123; <span class="comment">// 如果没遍历完s继续遍历</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == d[j][k]) ++k; <span class="comment">// 如果对应元素相同，子串的指针后移</span></span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span> (k == d[j].<span class="built_in">size</span>()) <span class="keyword">return</span> d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h4><p>根据给定的链表返回环形的入口节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设前半部分节点为x，后半部分节点为y</span></span><br><span class="line">        <span class="comment">// f = s + ny = 2s</span></span><br><span class="line">        <span class="comment">// s = ny (相遇时)</span></span><br><span class="line">        <span class="comment">// s' = x + ny (到入口时)</span></span><br><span class="line">        <span class="comment">// t = x</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">bool</span> tag = <span class="literal">false</span>; <span class="comment">// 判断是否有环</span></span><br><span class="line">        ListNode *f, *s, *dummyHead;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        f = dummyHead; s = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (f != <span class="literal">NULL</span> &amp;&amp; f-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            f = f-&gt;next-&gt;next;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (s == f) &#123;</span><br><span class="line">                tag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tag) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* t = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (t != s) &#123;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="迷你语法解析器"><a href="#迷你语法解析器" class="headerlink" title="迷你语法解析器"></a>迷你语法解析器</h4><p><a href="https://leetcode-cn.com/problems/mini-parser/" target="_blank" rel="noopener">题目链接</a></p>
<h5 id="个人解法-失败"><a href="#个人解法-失败" class="headerlink" title="个人解法(失败)"></a>个人解法(失败)</h5><p>失败原因：没理解题意，以为每个列表内只能是一个列表和一个整数，没想到还可以是两个整数，或者两个列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// key：级数 val：数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 代表当前遍历到的数值的级数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">NestedInteger <span class="title">helper</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        NestedInteger ans;</span><br><span class="line">        ans.add(m[k]);</span><br><span class="line">        <span class="keyword">if</span> (k == m.<span class="built_in">size</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        ans.add(helper(k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retValue</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123; <span class="comment">// 根据当前字符串获取值</span></span><br><span class="line">        <span class="keyword">int</span> negLabel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            negLabel = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            value = value * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        m[cnt] = (!negLabel) ? value : (-value); <span class="comment">// 向map对应级数添加元素</span></span><br><span class="line">        <span class="keyword">return</span> m[cnt];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">NestedInteger <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] != <span class="string">'['</span>) <span class="keyword">return</span> NestedInteger(retValue(s));</span><br><span class="line">        <span class="keyword">if</span> (!n || s == <span class="string">"[]"</span>) <span class="keyword">return</span> NestedInteger();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">','</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                --cnt;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'-'</span> || <span class="built_in">isdigit</span>(s[i])) </span><br><span class="line">                retValue(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            NestedInteger ans;</span><br><span class="line">            ans.add(NestedInteger());</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="答案解法"><a href="#答案解法" class="headerlink" title="答案解法"></a>答案解法</h5><p>将解析的过程以<code>&#39;[&#39;</code>的出现为标志，分为两类：解析数字或者解析列表。解析数字时直接返回新建的对象给上一级，而解析列表则是一一将该列表里的List或Num传入<code>parse()</code>中识别出它为列表还是数字，再掉用对应函数添加到结果里面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">NestedInteger <span class="title">parse</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前位置是个"["则已更改返回list</span></span><br><span class="line">        <span class="keyword">if</span> (s[pos] == <span class="string">'['</span>) <span class="keyword">return</span> parseList(s);</span><br><span class="line">        <span class="comment">// 否则解析一个数</span></span><br><span class="line">        <span class="keyword">return</span> parseNum(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析一个数字</span></span><br><span class="line">    <span class="function">NestedInteger <span class="title">parseNum</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断正负</span></span><br><span class="line">        <span class="keyword">int</span> sign = s[pos] == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[pos] == <span class="string">'-'</span> || s[pos] == <span class="string">'+'</span>) pos++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; pos &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[pos]); pos++)</span><br><span class="line">            num = num * <span class="number">10</span> + s[pos] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="comment">// 返回该数字</span></span><br><span class="line">        <span class="keyword">return</span> NestedInteger(sign * num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析一个List</span></span><br><span class="line">    <span class="function">NestedInteger <span class="title">parseList</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        NestedInteger ni;</span><br><span class="line">        <span class="keyword">while</span> (s[pos] != <span class="string">']'</span>) &#123;</span><br><span class="line">            pos++;                    <span class="comment">// 跳过[和,</span></span><br><span class="line">            <span class="keyword">if</span> (s[pos] == <span class="string">']'</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 对List中的每个元素进行解析，可能存在数字或者嵌套的List</span></span><br><span class="line">            ni.add(parse(s));</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;                        <span class="comment">// 跳过]</span></span><br><span class="line">        <span class="comment">// 返回解析的List</span></span><br><span class="line">        <span class="keyword">return</span> ni;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">NestedInteger <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parse(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="最小区间"><a href="#最小区间" class="headerlink" title="最小区间"></a>最小区间</h4><p>你有<code>k</code>个升序排列的整数数组。找到一个最小区间，使得<code>k</code>个列表中的每个列表至少有一个数包含在其中。</p>
<p>我们定义如果 <code>b-a &lt; d-c</code> 或者在 <code>b-a == d-c</code> 时 <code>a &lt; c</code>，则区间 <code>[a,b]</code> 比 <code>[c,d]</code> 小。</p>
<p>示例 1:</p>
<p>输入:<code>[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</code><br>输出: <code>[20,24]</code><br>解释:<br>列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。<br>列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。<br>列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。<br>注意:</p>
<p>给定的列表可能包含重复元素，所以在这里升序表示 &gt;= 。<br>1 &lt;= k &lt;= 3500<br>-105 &lt;= 元素的值 &lt;= 105</p>
<p>解法：hash表+滑动窗口<br><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/solution/pai-xu-hua-chuang-by-netcan/" target="_blank" rel="noopener">参考Netcan加的注释</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallestRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; ordered;</span><br><span class="line">        <span class="comment">// 将&#123;数值, 列表索引&#125;信息保存到ordered，并依照数值排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> item: nums[i]) &#123;</span><br><span class="line">                ordered.push_back(&#123;item, i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ordered.<span class="built_in">begin</span>(), ordered.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ordered.<span class="built_in">size</span>(); ++j) &#123; <span class="comment">// 遍历ordered</span></span><br><span class="line">            <span class="comment">// 以nums.size()为3举例</span></span><br><span class="line">            <span class="comment">// 如果遍历到的索引出现过，次数+1</span></span><br><span class="line">            <span class="comment">// 如果遍历到的索引没出现过，次数+1，指针后移（后移三次意味着0，1，2均出现过）</span></span><br><span class="line">            <span class="keyword">if</span> (!count[ordered[j].second]++) ++k;</span><br><span class="line">            <span class="keyword">if</span> (k == nums.<span class="built_in">size</span>()) &#123; <span class="comment">// 直到遍历三个长度的索引均出现过 </span></span><br><span class="line">                <span class="comment">// 当出现类似于滑动窗口为(2,21), (2,22), (2,23), (1,24), (0,25)这种情况</span></span><br><span class="line">                <span class="comment">// 不能单纯的取(2,21)而是要将i更新到(2,23)为真正的首窗口</span></span><br><span class="line">                <span class="keyword">while</span> (count[ordered[i].second] &gt; <span class="number">1</span>) --count[ordered[i++].second];</span><br><span class="line">                <span class="keyword">if</span> (ans.empty() || ans[<span class="number">1</span>] - ans[<span class="number">0</span>] &gt; ordered[j].first - ordered[i].first) &#123;</span><br><span class="line">                    <span class="comment">// 如果ans为空（第一次修正ans）</span></span><br><span class="line">                    <span class="comment">// 或者滑动窗口首尾值差小于之前ans中的存储的首尾差</span></span><br><span class="line">                    <span class="comment">// 则更新ans为新的首尾区间</span></span><br><span class="line">                    ans = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;ordered[i].first, ordered[j].first&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode周赛</title>
    <url>/2020/07/26/Leetcode%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<p>暑假的Leetcode周赛上的题目集合。</p>
<a id="more"></a>
<h2 id="第199次周赛"><a href="#第199次周赛" class="headerlink" title="第199次周赛"></a>第199次周赛</h2><h3 id="灯泡开关IV"><a href="#灯泡开关IV" class="headerlink" title="灯泡开关IV"></a>灯泡开关IV</h3><p><a href="https://leetcode-cn.com/problems/bulb-switcher-iv/" target="_blank" rel="noopener">题目链接</a></p>
<h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>从左到右遇到不同的数加一，再加上第一个数的值即可。<br>（？？什么原理）</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>参考vitamin用户。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = target.length();</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[n][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[n][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][0] 表示从第i个到末尾转换成target的次数</span></span><br><span class="line">        <span class="comment">// dp[i][1] 表示从第i个到末尾转换成target反的次数</span></span><br><span class="line">        <span class="comment">// 当target[i] = 0</span></span><br><span class="line">        <span class="comment">// dp[i][0] = dp[i + 1][0]  dp[i][1] = dp[i + 1][0] + 1</span></span><br><span class="line">        <span class="comment">// 当target[i] = 1</span></span><br><span class="line">        <span class="comment">// dp[i][0] = dp[i + 1][1] + 1  dp[i][1] = dp[i + 1][1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i + <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i + <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i + <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="好叶子节点对的数量"><a href="#好叶子节点对的数量" class="headerlink" title="好叶子节点对的数量"></a>好叶子节点对的数量</h4><p><a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/" target="_blank" rel="noopener">题目链接</a></p>
<h5 id="BFS-记录深度信息（失败）"><a href="#BFS-记录深度信息（失败）" class="headerlink" title="BFS+记录深度信息（失败）"></a>BFS+记录深度信息（失败）</h5><p>考虑欠妥，光关注了例子里的案例，单纯的想同一株子树的路径长度等于层数相减再+2，然而这只适用于源自于同一个祖宗节点的两个叶子节点。最后解答错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; leafNode;  <span class="comment">// 深度，左右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">queue</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt;&amp; q, <span class="keyword">int</span> tag)</span> </span>&#123; <span class="comment">// 0 左子树 1 右子树</span></span><br><span class="line">        <span class="keyword">if</span> (q.front().first == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//int dep = 1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="comment">//dep++;</span></span><br><span class="line">            <span class="keyword">auto</span> temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp.first-&gt;left || temp.first-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp.first-&gt;left != <span class="literal">NULL</span>) q.push(&#123;temp.first-&gt;left, temp.second + <span class="number">1</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span> (temp.first-&gt;right != <span class="literal">NULL</span>) q.push(&#123;temp.first-&gt;right, temp.second + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leafNode.push_back(&#123;temp.second, tag&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最短路径长度是（一侧的话，深度相减 + 2。异侧的话，深度相加）</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; qLeft; <span class="comment">// 结点，深度信息</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; qRight;</span><br><span class="line">        qLeft.push(&#123;root-&gt;left, <span class="number">1</span>&#125;); <span class="comment">// 纳入左根节点</span></span><br><span class="line">        qRight.push(&#123;root-&gt;right, <span class="number">1</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        helper(qLeft, <span class="number">0</span>);</span><br><span class="line">        helper(qRight, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (auto temp:leafNode) &#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; temp.first &lt;&lt; " " &lt;&lt; temp.second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leafNode.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; leafNode.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leafNode[i].second == leafNode[j].second &amp;&amp; <span class="built_in">abs</span>(leafNode[i].first - leafNode[j].first) + <span class="number">2</span> &lt;= distance)</span><br><span class="line">                    ++ans;</span><br><span class="line">                <span class="keyword">if</span> (leafNode[i].second != leafNode[j].second &amp;&amp; leafNode[i].first + leafNode[j].first &lt;= distance)</span><br><span class="line">                    ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root, distance, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 后序遍历dfs</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;; <span class="comment">// 是叶子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">auto</span> left = dfs(root-&gt;left, distance, ans);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dis:left) &#123; <span class="comment">// dis代表子节点到祖宗节点的相对路径</span></span><br><span class="line">            <span class="keyword">if</span> (++dis &gt; distance) <span class="keyword">continue</span>; <span class="comment">// 如果单侧路径已经超过distance，直接跳过</span></span><br><span class="line">            ret.push_back(dis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> right = dfs(root-&gt;right, distance, ans);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dis:right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++dis &gt; distance) <span class="keyword">continue</span>;</span><br><span class="line">            ret.push_back(dis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当完成一个完整的左子树、右子树、根节点遍历过程后，对left和right进行配对相加计算，相加后如果符合则ans++</span></span><br><span class="line">        <span class="comment">// 这样保证每一个祖宗节点的所有叶子节点都能被考虑到</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l:left) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r:right) &#123;</span><br><span class="line">                ans += (l + r &lt;= distance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第200场周赛"><a href="#第200场周赛" class="headerlink" title="第200场周赛"></a>第200场周赛</h2><h3 id="最大得分"><a href="#最大得分" class="headerlink" title="最大得分"></a>最大得分</h3><p><a href="https://leetcode-cn.com/problems/get-the-maximum-score/" target="_blank" rel="noopener">题目链接</a></p>
<p>参照LenoDeng的解法，以每个相同的通路为断点，求出每段的最大和，最后加和即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.<span class="built_in">size</span>() &amp;&amp; j &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                res += (<span class="built_in">max</span>(sum1, sum2) + nums1[i]);</span><br><span class="line">                sum1 = <span class="number">0</span>; sum2 = <span class="number">0</span>;</span><br><span class="line">                ++i; ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                sum2 += nums2[j];</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum1 += nums1[i];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sum1 += nums1[i]; </span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sum2 += nums2[j];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">max</span>(sum1, sum2);</span><br><span class="line">        <span class="keyword">return</span> res % (<span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第32场双周赛"><a href="#第32场双周赛" class="headerlink" title="第32场双周赛"></a>第32场双周赛</h2><h3 id="平衡括号字符串的最小插入次数"><a href="#平衡括号字符串的最小插入次数" class="headerlink" title="平衡括号字符串的最小插入次数"></a>平衡括号字符串的最小插入次数</h3><p><a href="https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string/" target="_blank" rel="noopener">题目链接</a></p>
<p>栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) stk.push(<span class="string">'('</span>); <span class="comment">// 左括号直接压栈</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 右括号分类讨论</span></span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123; <span class="comment">// 如果右括号在最后一位</span></span><br><span class="line">                    <span class="keyword">if</span> (stk.empty()) ans += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        ans += <span class="number">1</span>;</span><br><span class="line">                        stk.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i + <span class="number">1</span>] == <span class="string">'('</span>) &#123; <span class="comment">// 如果下一个是左括号</span></span><br><span class="line">                        <span class="keyword">if</span> (stk.empty()) &#123;</span><br><span class="line">                            ans += <span class="number">2</span>;</span><br><span class="line">                            stk.push(<span class="string">'('</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不需要出栈，因为下一次要再入栈</span></span><br><span class="line">                            ans += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果下一个是右括号</span></span><br><span class="line">                        <span class="keyword">if</span> (stk.empty()) ans += <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> stk.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    i += <span class="number">2</span>; <span class="comment">// 由于判断了后一位，所以i要后移两位</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!stk.empty()) ans += (<span class="number">2</span> * (stk.<span class="built_in">size</span>()));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="找出最长的超赞子字符串"><a href="#找出最长的超赞子字符串" class="headerlink" title="找出最长的超赞子字符串"></a>找出最长的超赞子字符串</h3><p><a href="https://leetcode-cn.com/problems/find-longest-awesome-substring/" target="_blank" rel="noopener">题目链接</a></p>
<h4 id="状态压缩-位运算"><a href="#状态压缩-位运算" class="headerlink" title="状态压缩+位运算"></a>状态压缩+位运算</h4><ul>
<li><code>1 &lt;&lt; i (0 &lt;= i &lt;= 9)</code> 表示 $2^i$</li>
</ul>
<p>状态说明：例如当出现数字$i = 2$，将其状态$status$通过$1 &lt;&lt; i$转换为$000000100$，这样<strong>从右向左数第2位</strong>就置为了1，这表示i出现了1次（奇数次）。</p>
<p>递推过程：向下递推的时候进行异或运算，即<br>$$status \land = (1 &lt;&lt; i)$$<br>就能获取截止到现在的，<strong>前i个字符的奇偶出现情况</strong>，其实也属于前缀和的思想。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestAwesome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*hash表存储了状态status（且全偶）出现的最新一次下标*/</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// status：idx</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, ans = <span class="number">1</span>;</span><br><span class="line">        m[cur] = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 00110 6</span></span><br><span class="line">        <span class="comment">// 00010 2</span></span><br><span class="line">        <span class="comment">// 00100 4</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; s.length(); ++c) &#123;</span><br><span class="line">            <span class="keyword">int</span> ch = s[c] - <span class="string">'0'</span>;</span><br><span class="line">            cur ^= (<span class="number">1</span> &lt;&lt; ch); <span class="comment">// 计算当前位的status</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = cur ^ (<span class="number">1</span> &lt;&lt; i); <span class="comment">// 试探有没有单个数出现奇数个(cur里面只有一个0)</span></span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">find</span>(next) != m.<span class="built_in">end</span>()) &#123; <span class="comment">// 如果试探出了全偶数的情况，证明这个是单奇数</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, c - m[next]); <span class="comment">// 返回该区域长度与ans相比的较大值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(cur) == m.<span class="built_in">end</span>()) &#123; <span class="comment">// 如果前面没有保存全偶状态</span></span><br><span class="line">                m[cur] = c;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则将ans更新为该区域长度与ans相比的最大值</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, c - m[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="第201场周赛"><a href="#第201场周赛" class="headerlink" title="第201场周赛"></a>第201场周赛</h2><h3 id="和为目标值的最大不重叠非空子数组数目"><a href="#和为目标值的最大不重叠非空子数组数目" class="headerlink" title="和为目标值的最大不重叠非空子数组数目"></a>和为目标值的最大不重叠非空子数组数目</h3><p>前缀和+哈希表+dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pre_idx; <span class="comment">// pre:idx</span></span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>]; <span class="comment">// dp[i]表示前i个非空不重叠子数组的最大数目</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            pre += nums[i - <span class="number">1</span>]; <span class="comment">// 求得前缀和</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>]; <span class="comment">// dp初始化</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 寻找[j, i]区间内和满足要求的最近的j(pre[i] - pre[j] = target)</span></span><br><span class="line">            <span class="keyword">int</span> j = pre_idx[pre - target];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j) &#123; <span class="comment">// 如果存在这样的j</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 注意:j==0有两种可能 1.当前前缀和就是target 2.不存在这样的元素</span></span><br><span class="line">                <span class="keyword">if</span> (pre == target) &#123; <span class="comment">// </span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(<span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre_idx[pre] = i; <span class="comment">// 更新前缀和出现的下标 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前缀和+哈希表+贪心</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">-1</span>; <span class="comment">// pre表示前缀和，end表示已经保存的子数组中的最大下标</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pre_idx; <span class="comment">// pre:idx</span></span><br><span class="line">        pre_idx[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 访问到pre刚好为target时，此时的pre_idx==0为错误值，应为下标-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            pre += nums[i - <span class="number">1</span>]; <span class="comment">// 求得前缀和</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 寻找[j, i]区间内和满足要求的最近的j(pre[i] - pre[j] = target)</span></span><br><span class="line">            <span class="keyword">if</span> (pre_idx.<span class="built_in">find</span>(pre - target) != pre_idx.<span class="built_in">end</span>()) &#123; <span class="comment">/// 如果这样的前缀存在</span></span><br><span class="line">                <span class="keyword">int</span> j = pre_idx[pre - target]; <span class="comment">// 获取区间上界j</span></span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &gt; <span class="built_in">end</span>) &#123; <span class="comment">// 如果j在end之后</span></span><br><span class="line">                    ++ans;</span><br><span class="line">                    <span class="built_in">end</span> = i - <span class="number">1</span>; <span class="comment">// 将当前已纳入结果中的子数组的最大下标更新为end</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre_idx[pre] = i - <span class="number">1</span>; <span class="comment">// 更新前缀和出现的下标 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="切棍子的最小成本"><a href="#切棍子的最小成本" class="headerlink" title="切棍子的最小成本"></a>切棍子的最小成本</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/" target="_blank" rel="noopener">题目链接</a></p>
<p><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/solution/c-dong-tai-gui-hua-si-lu-zhuan-hua-by-ming-tian-ge/" target="_blank" rel="noopener">参考题解</a><br>这题我看完题解觉得下次出现类似的题还是不会，可能这就是dp吧，太难入门了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;</span><br><span class="line">        sort(cuts.<span class="built_in">begin</span>(), cuts.<span class="built_in">end</span>());</span><br><span class="line">        cuts.insert(cuts.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        cuts.push_back(n);</span><br><span class="line">        <span class="comment">// 初始化dp各元素为极大值</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(cuts.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cuts.<span class="built_in">size</span>(),<span class="number">100000000</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cuts.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, cuts.<span class="built_in">size</span>() - <span class="number">1</span>, dp, cuts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &lt; <span class="number">100000000</span>)  <span class="keyword">return</span> dp[i][j]; <span class="comment">// 进行计算的直接返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; ++k) &#123; <span class="comment">// 对没有进行dp计算的区间[i, j]进行计算</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span> (dp[i][j], dfs(i, k, dp, cuts) + dfs(k , j, dp, cuts) + cuts[j] - cuts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>略去dfs过程，优化dp，参考随意凯的题解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = cuts.<span class="built_in">size</span>();</span><br><span class="line">        cuts.push_back(<span class="number">0</span>);</span><br><span class="line">        cuts.push_back(n);</span><br><span class="line">        sort(cuts.<span class="built_in">begin</span>(),cuts.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> dp[m + <span class="number">2</span>][m + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][i + <span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*dp思路过程----（）代表可计算的dp*/</span></span><br><span class="line">        <span class="comment">/*以 m = 6 为例*/</span></span><br><span class="line">        <span class="comment">/*每一步的dp均依靠上层计算好的dp值递推*/</span></span><br><span class="line">        <span class="comment">// 0  1  2  3  4  5  6  7  |</span></span><br><span class="line">        <span class="comment">// () () () () () () () () |k = 1 dp均赋值为0(不可分，无成本)</span></span><br><span class="line">        <span class="comment">// (   ) (   ) (   ) (   ) |k = 2</span></span><br><span class="line">        <span class="comment">//    (   ) (   ) (   )    |k = 2</span></span><br><span class="line">        <span class="comment">// (      ) (      )       |k = 3</span></span><br><span class="line">        <span class="comment">//    (      ) (      )    |k = 3</span></span><br><span class="line">        <span class="comment">//       (       ) (     ) |k = 3</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// (                     ) |k = m + 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= m + <span class="number">1</span>; k++) &#123; <span class="comment">// 每一个k代表当前循环枚举到的截断点个数为k个</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;"k"&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt;= m + <span class="number">1</span>; i++) &#123; <span class="comment">// i为木头的开头处，k</span></span><br><span class="line">                <span class="keyword">int</span> j = i + k; <span class="comment">// j为木头的最右端，与i中间相差k个截断点</span></span><br><span class="line">                <span class="keyword">int</span> t = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = i + <span class="number">1</span>; p &lt; j; p++) &#123; <span class="comment">// p为(i, j)间选定的截断点</span></span><br><span class="line">                    t = <span class="built_in">min</span>(t, dp[i][p] + dp[p][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;i+k&lt;&lt;endl;</span></span><br><span class="line">                dp[i][j] = t + cuts[j] - cuts[i];</span><br><span class="line">                <span class="comment">//cout&lt;&lt;dp[i][j]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/a2459956664/article/details/51106461" target="_blank" rel="noopener">一道类似题目的链接</a>，两道题一模一样，一模一样，一模一样。</p>
<h2 id="第202场周赛"><a href="#第202场周赛" class="headerlink" title="第202场周赛"></a>第202场周赛</h2><h3 id="两球之间的磁力"><a href="#两球之间的磁力" class="headerlink" title="两球之间的磁力"></a>两球之间的磁力</h3><p><a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/" target="_blank" rel="noopener">题目链接</a></p>
<p>这题和<a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">分割数组的最大和</a>一毛一样，题解写在Leetcode日记III里了。另外就是二分法的边界真的是个问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">position</span>, <span class="keyword">int</span> mid, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, pre = <span class="built_in">position</span>[<span class="number">0</span>]; <span class="comment">// 前一个放球点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">position</span>.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">position</span>[i] - pre &gt;= mid) &#123; <span class="comment">// 如果当前大于等于mid了，记为一个区间</span></span><br><span class="line">                ++cnt;</span><br><span class="line">                pre = <span class="built_in">position</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt; m - <span class="number">1</span>; <span class="comment">// 若这样的区间大于等于m-1个，则mid偏小了。反之区间不够m-1，则mid偏大了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">position</span>, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">position</span>.<span class="built_in">size</span>();</span><br><span class="line">        sort(<span class="built_in">position</span>.<span class="built_in">begin</span>(), <span class="built_in">position</span>.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="built_in">position</span>[n - <span class="number">1</span>] - <span class="built_in">position</span>[<span class="number">0</span>], minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = <span class="built_in">position</span>[i] - <span class="built_in">position</span>[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (sub &lt; minLen) minLen = sub;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = minLen, r = maxLen / (m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(<span class="built_in">position</span>, mid, m)) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：最大值最小和最小值最大这两种问题中，check函数的判断条件也需要进行相应的改动！！其返回为true至少要让原问题的最大这个原始条件满足！！！</strong></p>
<h3 id="吃掉-N-个橘子的最少天数"><a href="#吃掉-N-个橘子的最少天数" class="headerlink" title="吃掉 N 个橘子的最少天数"></a>吃掉 N 个橘子的最少天数</h3><p>厨房里总共有 <code>n</code> 个橘子，你决定每一天选择如下方式之一吃这些橘子：</p>
<ul>
<li>吃掉一个橘子。</li>
<li>如果剩余橘子数 <code>n</code> 能被 2 整除，那么你可以吃掉 <code>n/2</code> 个橘子。</li>
<li>如果剩余橘子数 <code>n</code> 能被 3 整除，那么你可以吃掉 <code>2*(n/3)</code> 个橘子。</li>
</ul>
<p>每天你只能从以上 3 种方案中选择一种方案。</p>
<p>请你返回吃掉所有 <code>n</code> 个橘子的最少天数。</p>
<h4 id="dfs（超时）"><a href="#dfs（超时）" class="headerlink" title="dfs（超时）"></a>dfs（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = (cur &lt; ans) ? cur : ans;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        helper(n - <span class="number">1</span>, cur + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) helper(n - n / <span class="number">2</span>, cur + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) helper(n - <span class="number">2</span> * (n / <span class="number">3</span>), cur + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        helper(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="dp（溢出）"><a href="#dp（溢出）" class="headerlink" title="dp（溢出）"></a>dp（溢出）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) dp[i] = <span class="built_in">min</span>(dp[i], dp[i - i / <span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) dp[i] = <span class="built_in">min</span>(dp[i], dp[i - <span class="number">2</span> * (i / <span class="number">3</span>)] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="bfs（超时）"><a href="#bfs（超时）" class="headerlink" title="bfs（超时）"></a>bfs（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q; <span class="comment">// left : day</span></span><br><span class="line">        q.push(&#123;n, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> left = tmp.first;</span><br><span class="line">                <span class="keyword">int</span> td = tmp.second;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> td;</span><br><span class="line">                <span class="keyword">if</span> (left % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(&#123;left /<span class="number">3</span>, td + <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="comment">//continue;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (left % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(&#123;left / <span class="number">2</span>, td + <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="comment">//continue;</span></span><br><span class="line">                &#125;</span><br><span class="line">                q.push(&#123;left - <span class="number">1</span>, td + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="贪心-hash"><a href="#贪心-hash" class="headerlink" title="贪心+hash"></a>贪心+hash</h4><p>参考ASAPIN的解答。</p>
<p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges/solution/tan-xin-dpde-shu-xue-zheng-ming-by-catnipan/" target="_blank" rel="noopener">贪心正确性证明</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp.count(n)) <span class="keyword">return</span> dp[n]; <span class="comment">// 用hash来记忆化</span></span><br><span class="line">        <span class="comment">/*每次减1为了能够将总数削减为原来的1/2或1/3，太妙了我的天*/</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">min</span>(minDays(n / <span class="number">2</span>) + n % <span class="number">2</span> + <span class="number">1</span>, minDays(n / <span class="number">3</span>) + n % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        dp[n] = res; <span class="comment">// 当前n向下递归完毕后，n的dp值唯一确定</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="bfs-hash"><a href="#bfs-hash" class="headerlink" title="bfs+hash"></a>bfs+hash</h4><p>由于没有优化对吃一个橘子的优化，速度要慢很多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> dis, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp.count(left)) <span class="keyword">return</span>;</span><br><span class="line">        dp[left] = dis + <span class="number">1</span>;</span><br><span class="line">        q.push(left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[n] = <span class="number">1</span>;</span><br><span class="line">        q.push(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="keyword">return</span> dp[t];</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (t % <span class="number">3</span> == <span class="number">0</span>) helper(dp[t], t / <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>) helper(dp[t], t / <span class="number">2</span>); </span><br><span class="line">            helper(dp[t], t - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="第33场双周赛"><a href="#第33场双周赛" class="headerlink" title="第33场双周赛"></a>第33场双周赛</h2><h3 id="得到目标数组的最少函数调用次数"><a href="#得到目标数组的最少函数调用次数" class="headerlink" title="得到目标数组的最少函数调用次数"></a>得到目标数组的最少函数调用次数</h3><p><a href="https://leetcode-cn.com/problems/minimum-numbers-of-function-calls-to-make-target-array/" target="_blank" rel="noopener">题目链接</a></p>
<p>模拟 参考Heltion的解答</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 操作1 给某数+1</span></span><br><span class="line">        <span class="comment">// 操作2 全部×2</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, m = <span class="number">0</span>; <span class="comment">// m记录了数组里的最大2的倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = num, n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    x -= <span class="number">1</span>;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x /= <span class="number">2</span>;</span><br><span class="line">                    n += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                m = <span class="built_in">max</span>(n, m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; m &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + m; <span class="comment">// 2的最大的倍数+奇数个数+n       </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二维网格图中探测环"><a href="#二维网格图中探测环" class="headerlink" title="二维网格图中探测环"></a>二维网格图中探测环</h3><p><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/" target="_blank" rel="noopener">题目链接</a></p>
<h4 id="个人解法（超时）"><a href="#个人解法（超时）" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; graph;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; start;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">char</span> target, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; r &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; grid[r][c] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "fuck   " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; grid[x][y] &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (graph[x][y] == target) &#123; <span class="comment">// 如果目标值要标记#</span></span><br><span class="line">                    graph[x][y] = <span class="string">'#'</span>;</span><br><span class="line">                    dfs(x, y, target, flag + <span class="number">1</span>);</span><br><span class="line">                    graph[x][y] = target;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graph[x][y] == <span class="string">'#'</span> &amp;&amp; x == start.first &amp;&amp; y == start.second &amp;&amp; flag &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    valid = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        graph = grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = graph[i][j];</span><br><span class="line">                <span class="keyword">if</span> (tmp == <span class="string">'#'</span>) <span class="keyword">continue</span>; </span><br><span class="line">                graph[i][j] = <span class="string">'#'</span>; <span class="comment">// 标记起点</span></span><br><span class="line">                start = &#123;i, j&#125;;</span><br><span class="line">                dfs(i, j, tmp, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (valid == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dir[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 精髓在于起点不是关键，只要在路上碰到了满足回路的解即可返回true，不一定要回溯到起点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">vis</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(i, j, <span class="number">-1</span>, <span class="number">-1</span>, g, vis))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> px, <span class="keyword">int</span> py, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;g, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dir[i], ty = y + dir[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || (tx == px &amp;&amp; ty == py) || g[tx][ty] != g[x][y])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[tx][ty]) <span class="comment">// 只要访问过并且不是一步回溯访问到的就可以</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(tx, ty, x, y, g, vis))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第203场周赛"><a href="#第203场周赛" class="headerlink" title="第203场周赛"></a>第203场周赛</h2><h3 id="查找大小为M的最新分组"><a href="#查找大小为M的最新分组" class="headerlink" title="查找大小为M的最新分组"></a>查找大小为M的最新分组</h3><p><a href="https://leetcode-cn.com/problems/find-latest-group-of-size-m/" target="_blank" rel="noopener">题目链接</a></p>
<h4 id="法1-倒序"><a href="#法1-倒序" class="headerlink" title="法1 倒序"></a>法1 倒序</h4><p>map倒序维护每一个可以分的区间，参考zerotrac2的解答。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s = &#123;&#123;<span class="number">1</span>, n&#125;&#125;; <span class="comment">// [1, n]区间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 倒序遍历arr</span></span><br><span class="line">            <span class="keyword">auto</span> it = prev(s.upper_bound(arr[i])); <span class="comment">// 获取该分割点所在的区间</span></span><br><span class="line">            <span class="keyword">auto</span> [l, r] = *it;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] - l == m || r - arr[i] == m) &#123; <span class="comment">// 如果分割后两个子长度满足，输出步骤</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            s.erase(it); <span class="comment">// 抹去重叠的原区间</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt;= arr[i] - <span class="number">1</span>) s.emplace(l, arr[i] - <span class="number">1</span>); <span class="comment">// 添加分割后的子区间</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] + <span class="number">1</span> &lt;= r) s.emplace(arr[i] + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="法2-正序"><a href="#法2-正序" class="headerlink" title="法2 正序"></a>法2 正序</h4><p>类似链表的结构，用指针来操作。</p>
<p>一段区间的定义：</p>
<ul>
<li>左端点的右指针指向右端点</li>
<li>右端点的左指针指向左端点</li>
</ul>
<p>分四种情况讨论（标记的0将变为1）</p>
<ol>
<li><p>1111<strong><em>0</em></strong>111  （左右均有全1区间）</p>
</li>
<li><p>1111<strong><em>0</em></strong>001  （左侧有全1区间）</p>
</li>
<li><p>1000<strong><em>0</em></strong>111  （右侧有全1区间）</p>
</li>
<li><p>1100<strong><em>0</em></strong>001  （两侧均无全1区间）</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l, r; <span class="comment">// left pointer || right pointer</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 求以x为左顶点的区间长度</span></span><br><span class="line">        <span class="keyword">return</span> r[x] - x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        l.resize(n + <span class="number">2</span>); r.resize(n + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = arr[i]; <span class="comment">// 获取当前change的位序号</span></span><br><span class="line">            <span class="keyword">if</span> (l[x - <span class="number">1</span>] &amp;&amp; r[x + <span class="number">1</span>]) &#123; <span class="comment">// 如果他的左区间和右区间都是全1</span></span><br><span class="line">                <span class="comment">// 左端点右指针指向右端点</span></span><br><span class="line">                <span class="comment">// 右端点左指针指向左端点</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(l[x - <span class="number">1</span>]) == m) --cnt;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(x + <span class="number">1</span>) == m) --cnt;</span><br><span class="line">                r[l[x - <span class="number">1</span>]] = r[x + <span class="number">1</span>];</span><br><span class="line">                l[r[x + <span class="number">1</span>]] = l[x - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(l[x - <span class="number">1</span>]) == m) ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l[x - <span class="number">1</span>]) &#123;<span class="comment">// 如果左区间存在全1，右区间还是0</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(l[x - <span class="number">1</span>]) == m) --cnt;</span><br><span class="line">                r[l[x - <span class="number">1</span>]] = x; <span class="comment">// 左端点的右指针指向右端点x</span></span><br><span class="line">                l[x] = l[x - <span class="number">1</span>]; <span class="comment">// 该x作为右端点，其左端点为l[x - 1]</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(l[x - <span class="number">1</span>]) == m) ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r[x + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(x + <span class="number">1</span>) == m) --cnt;</span><br><span class="line">                r[x] = r[x + <span class="number">1</span>];</span><br><span class="line">                l[r[x + <span class="number">1</span>]] = x;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(x) == m) ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l[x] = x; r[x] = x;</span><br><span class="line">                <span class="keyword">if</span> (m == <span class="number">1</span>) ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) res = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="石子游戏"><a href="#石子游戏" class="headerlink" title="石子游戏"></a>石子游戏</h4><p><a href="https://leetcode-cn.com/problems/stone-game-v/" target="_blank" rel="noopener">题目链接</a></p>
<p>区间dp，没有优化就过了，暂时这几天比较忙先不优化了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> pre[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] = stoneValue[i - <span class="number">1</span>] + pre[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> left = pre[k] - pre[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> right = pre[j] - pre[k];</span><br><span class="line">                    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], left + dp[i][k]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], right + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], left + <span class="built_in">max</span>(dp[i][k], dp[k + <span class="number">1</span>][j]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.bilibili.com/video/BV1wA411n7jz" target="_blank" rel="noopener">参考讲解</a></p>
<h2 id="第204场周赛"><a href="#第204场周赛" class="headerlink" title="第204场周赛"></a>第204场周赛</h2><h3 id="将子数组重新排序得到同一个二叉查找树的方案数"><a href="#将子数组重新排序得到同一个二叉查找树的方案数" class="headerlink" title="将子数组重新排序得到同一个二叉查找树的方案数"></a>将子数组重新排序得到同一个二叉查找树的方案数</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/" target="_blank" rel="noopener">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; C;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        C = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化组合数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % MOD;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排除题中给出的一种</span></span><br><span class="line">        <span class="keyword">return</span> (f(nums) + MOD - <span class="number">1</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> k = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left, right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; k) left.push_back(x);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; k) right.push_back(x - k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (LL)C[n<span class="number">-1</span>][left.<span class="built_in">size</span>()] * f(left) % MOD * f(right) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/solution/c-di-gui-jing-jian-by-dawncy/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造排列组合数组的模板</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % MOD;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记IV</title>
    <url>/2020/08/03/Leetcode%E6%97%A5%E8%AE%B0IV/</url>
    <content><![CDATA[<p>Leetcode日记IV，淦！</p>
<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="推多米诺"><a href="#推多米诺" class="headerlink" title="推多米诺"></a>推多米诺</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = dominoes.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> dominoes; </span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (f &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[f] == <span class="string">'L'</span> &amp;&amp; s == <span class="number">0</span> &amp;&amp; dominoes[s] == <span class="string">'.'</span>) &#123; <span class="comment">// &lt;-</span></span><br><span class="line">                <span class="keyword">while</span> (s &lt; f) &#123;</span><br><span class="line">                    dominoes[s++] = <span class="string">'L'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[f] == <span class="string">'R'</span> &amp;&amp; dominoes[s] == <span class="string">'L'</span>) &#123; <span class="comment">// &lt;- -&gt;</span></span><br><span class="line">                s = f;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[f] == <span class="string">'L'</span> &amp;&amp; dominoes[s] == <span class="string">'R'</span>) &#123; <span class="comment">// -&gt; &lt;-</span></span><br><span class="line">                <span class="comment">// 左右指针向右挤压</span></span><br><span class="line">                <span class="keyword">int</span> l = s, r = f;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    dominoes[r--] = <span class="string">'L'</span>;</span><br><span class="line">                    dominoes[l++] = <span class="string">'R'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l == r) dominoes[l] = <span class="string">'.'</span>;</span><br><span class="line">                s = f;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == n - <span class="number">1</span> &amp;&amp; dominoes[s] == <span class="string">'R'</span> &amp;&amp; dominoes[f] == <span class="string">'.'</span>) &#123; <span class="comment">// -&gt;</span></span><br><span class="line">                <span class="keyword">while</span> (s &lt;= f) &#123;</span><br><span class="line">                    dominoes[s++] = <span class="string">'R'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[f] == <span class="string">'L'</span> &amp;&amp; dominoes[s] == <span class="string">'L'</span>) &#123; <span class="comment">// &lt;- &lt;-</span></span><br><span class="line">                <span class="keyword">while</span> (s &lt; f) &#123;</span><br><span class="line">                    dominoes[s++] = <span class="string">'L'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[f] == <span class="string">'R'</span> &amp;&amp; dominoes[s] == <span class="string">'R'</span>) &#123; <span class="comment">// -&gt; -&gt;</span></span><br><span class="line">                <span class="keyword">while</span> (s &lt; f) &#123;</span><br><span class="line">                    dominoes[s++] = <span class="string">'R'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[s] == <span class="string">'.'</span> &amp;&amp; dominoes[f] != <span class="string">'.'</span>) &#123; <span class="comment">// . .</span></span><br><span class="line">                s = f;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dominoes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<h4 id="暴力法-滑动窗口优化"><a href="#暴力法-滑动窗口优化" class="headerlink" title="暴力法+滑动窗口优化"></a>暴力法+滑动窗口优化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="前缀和-二分查找"><a href="#前缀和-二分查找" class="headerlink" title="前缀和+二分查找"></a>前缀和+二分查找</h4><p>只适用于元素全正的情况下！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 2 3 1 2 4 3</span></span><br><span class="line">        <span class="comment">// 2 5 6 8 12 15</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = s + sum[i - <span class="number">1</span>]; <span class="comment">// 获取当前在sum数组中的目标数</span></span><br><span class="line">            <span class="keyword">auto</span> bound = lower_bound(sum.<span class="built_in">begin</span>(), sum.<span class="built_in">end</span>(), target);</span><br><span class="line">            <span class="keyword">if</span> (bound != sum.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, ((<span class="keyword">int</span>)(bound - sum.<span class="built_in">begin</span>()) - i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == (n + <span class="number">1</span>) ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="双指针（滑动窗口）"><a href="#双指针（滑动窗口）" class="headerlink" title="双指针（滑动窗口）"></a>双指针（滑动窗口）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">end</span> &lt; n) &#123;</span><br><span class="line">            sum += nums[<span class="built_in">end</span>];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">end</span> - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">end</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><p>判断链表是否回文。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *f = head, *s = head, *pre = <span class="literal">nullptr</span>, *p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 完成前序反转和寻找中间结点</span></span><br><span class="line">        <span class="keyword">while</span> (f != <span class="literal">nullptr</span> &amp;&amp; f-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = s;</span><br><span class="line">            f = f-&gt;next-&gt;next;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line"></span><br><span class="line">            p-&gt;next = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 证明有奇数个节点</span></span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != s-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// dp[i]表示amount=i时的硬币组合数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; ++i) &#123;</span><br><span class="line">                dp[i] += dp[i - coin]; <span class="comment">// 每一步i的组合数等于其最后一步之前的dp值加上当前值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外还有记忆化搜索的方法，就不再多说。</p>
<h3 id="猜数字大小II"><a href="#猜数字大小II" class="headerlink" title="猜数字大小II"></a>猜数字大小II</h3><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/" target="_blank" rel="noopener">题目链接</a></p>
<p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/dong-tai-gui-hua-c-you-tu-jie-by-zhang-xiao-tong-2/" target="_blank" rel="noopener">参考题解</a>写的是真的好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j] = min(k + max(dp[i][k - 1] + dp[k + 1][j]), dp[i][j])</span></span><br><span class="line">        <span class="comment">// 计算顺序：由于每一个(i, j)需要矩阵中偏左和偏下的元素值，所以按固定列（从左向右）行按从下向上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= j - <span class="number">1</span>; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(k + <span class="built_in">max</span>(dp[i][k - <span class="number">1</span>], dp[k + <span class="number">1</span>][j]), dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], i + dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], j + dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最长公共子序列LCS"><a href="#最长公共子序列LCS" class="headerlink" title="最长公共子序列LCS"></a>最长公共子序列LCS</h3><p>对于给定的text1和text2，返回其最长公共子序列的长度。</p>
<h4 id="递归（超时）"><a href="#递归（超时）" class="headerlink" title="递归（超时）"></a>递归（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// recursive</span></span><br><span class="line">        <span class="keyword">int</span> n1 = text1.<span class="built_in">size</span>(), n2 = text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n1 || !n2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (text1[n1 - <span class="number">1</span>] == text2[n2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> longestCommonSubsequence(text1.substr(<span class="number">0</span>, n1 - <span class="number">1</span>), text2.substr(<span class="number">0</span>, n2 - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s1 = longestCommonSubsequence(text1.substr(<span class="number">0</span>, n1 - <span class="number">1</span>), text2);</span><br><span class="line">        <span class="keyword">int</span> s2 = longestCommonSubsequence(text1, text2.substr(<span class="number">0</span>, n2 - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="dp-1"><a href="#dp-1" class="headerlink" title="dp"></a>dp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">int</span> n1 = text1.<span class="built_in">size</span>(), n2 = text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n1 || !n2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n2 + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="comment">/*dp[i][j]表示text1[0,i]和text2[0,j]范围内的最小公公序列个数*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">o o o o -&gt; 1 o o o -&gt; 1 8 9 √</span><br><span class="line">o o o o -&gt; o 2 o o -&gt; o 2 6 7</span><br><span class="line">o o o o -&gt; o o 3 o -&gt; o o 3 5</span><br><span class="line">o o o o -&gt; o o o 4 -&gt; o o o 4</span><br></pre></td></tr></table></figure>

<p>计算顺序图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n][n]; <span class="comment">// i ~ j范围内的最长子序列</span></span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == s[i]) dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><h3 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h3><p><a href="https://leetcode-cn.com/problems/house-robber-iii/comments/" target="_blank" rel="noopener">题目链接</a></p>
<p>起初以为简单的层序遍历+dp（打家劫舍I）就能做出来，最后发现有特例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; valSet; <span class="comment">// 每层的金额总和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123; <span class="comment">// BFS获取每层的金额总和</span></span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123; <span class="comment">// 将本层的全部出队</span></span><br><span class="line">                <span class="keyword">auto</span> temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                res += temp-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left) q.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right) q.push(temp-&gt;right); </span><br><span class="line">            &#125;</span><br><span class="line">            valSet.push_back(res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 问题转换为在数组中寻找一群不相邻的节点使得和最大，同打家劫舍I</span></span><br><span class="line">        <span class="keyword">int</span> n = valSet.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> valSet[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> first = valSet[<span class="number">0</span>], second = <span class="built_in">max</span>(valSet[<span class="number">0</span>], valSet[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = <span class="built_in">max</span>(first + valSet[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改为dfs递归求解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 情况1：偷根节点</span></span><br><span class="line">        <span class="keyword">int</span> res1 = r-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;left) res1 += (dfs(r-&gt;left-&gt;left) + dfs(r-&gt;left-&gt;right));</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;right) res1 += (dfs(r-&gt;right-&gt;left) + dfs(r-&gt;right-&gt;right));</span><br><span class="line">        <span class="comment">// 情况2：不偷根节点</span></span><br><span class="line">        <span class="keyword">int</span> res2 = dfs(r-&gt;left) + dfs(r-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1, res2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>超时。<br>参考coderYQ在评论区的解法后，改成记忆化dfs，过了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 情况1：偷根节点</span></span><br><span class="line">        <span class="keyword">if</span> (m.count(r) != <span class="number">0</span>) <span class="keyword">return</span> m[r];</span><br><span class="line">        <span class="keyword">int</span> res1 = r-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;left) res1 += (dfs(r-&gt;left-&gt;left) + dfs(r-&gt;left-&gt;right));</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;right) res1 += (dfs(r-&gt;right-&gt;left) + dfs(r-&gt;right-&gt;right));</span><br><span class="line">        <span class="comment">// 情况2：不偷根节点</span></span><br><span class="line">        <span class="keyword">int</span> res2 = dfs(r-&gt;left) + dfs(r-&gt;right);</span><br><span class="line">        m[r] = <span class="built_in">max</span>(res1, res2);</span><br><span class="line">        <span class="keyword">return</span> m[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="求根到叶子节点数字之和"><a href="#求根到叶子节点数字之和" class="headerlink" title="求根到叶子节点数字之和"></a>求根到叶子节点数字之和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">输出：495 + 491 + 40 &#x3D; 1026</span><br></pre></td></tr></table></figure>

<p>法1<br>每次dfs自带该层value</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* r, <span class="keyword">int</span> value)</span> </span>&#123; <span class="comment">// value储存了当前节点的和</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            value = value * <span class="number">10</span> + r-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (r-&gt;left) dfs(r-&gt;left, value);</span><br><span class="line">            <span class="keyword">if</span> (r-&gt;right) dfs(r-&gt;right, value);</span><br><span class="line">            <span class="keyword">if</span> (!r-&gt;left &amp;&amp; !r-&gt;right) &#123; <span class="comment">// 如果当前节点为叶子节点，纳入结果</span></span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法2<br>每次dfs的value共享一个变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        value = value * <span class="number">10</span> + r-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!r-&gt;left &amp;&amp; !r-&gt;right) &#123;</span><br><span class="line">            ans += value;</span><br><span class="line">            value /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;left) dfs(r-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;right) dfs(r-&gt;right);</span><br><span class="line">        value /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h3><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n, m, <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; B, <span class="keyword">const</span> <span class="built_in">string</span>&amp; WORD)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="built_in">size</span>) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (B[x][y] == WORD[k] &amp;&amp; B[x][y] != <span class="string">'#'</span>) &#123;</span><br><span class="line">                    <span class="keyword">char</span> cur = B[x][y];</span><br><span class="line">                    B[x][y] = <span class="string">'#'</span>;</span><br><span class="line">                    dfs(x, y, k + <span class="number">1</span>, B, WORD);</span><br><span class="line">                    B[x][y] = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">size</span> = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="keyword">word</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">                    dfs(i, j, <span class="number">1</span>, board, <span class="keyword">word</span>);</span><br><span class="line">                    board[i][j] = <span class="keyword">word</span>[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (valid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="单词搜索II"><a href="#单词搜索II" class="headerlink" title="单词搜索II"></a>单词搜索II</h3><p>给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<h4 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h4><p><strong>trie树 + dfs</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    Trie* son[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span>(son));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;son[x]) node-&gt;son[x] = <span class="keyword">new</span> Trie();</span><br><span class="line">            node = node-&gt;son[x];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;flag++;</span><br><span class="line">        node-&gt;<span class="keyword">word</span> = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">// 网格的长宽</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">// words大小</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    Trie* tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vis; <span class="comment">// vis数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, Trie* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;flag) &#123;</span><br><span class="line">            ans.push_back(cur-&gt;<span class="keyword">word</span>);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; cur-&gt;word &lt;&lt; endl;</span></span><br><span class="line">            cur-&gt;flag--; <span class="comment">// 避免重复</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">            <span class="keyword">if</span> (notEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;son[data[x][y] - <span class="string">'a'</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "dfs " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">                dfs(x, y, cur-&gt;son[data[x][y] - <span class="string">'a'</span>]);</span><br><span class="line">                vis[x][y] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        len = words.<span class="built_in">size</span>();</span><br><span class="line">        data = board;</span><br><span class="line">        m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!len || !m) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 构建trie树</span></span><br><span class="line"></span><br><span class="line">        tree = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            tree-&gt;insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vis.assign(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dfs过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                Trie* cur = tree; <span class="comment">// 指向根节点</span></span><br><span class="line">                <span class="keyword">int</span> x = board[i][j] - <span class="string">'a'</span>; <span class="comment">// 获取字母</span></span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;son[x]) <span class="keyword">continue</span>; <span class="comment">// 如果字典树中不存在以该字母开头的路径，跳过</span></span><br><span class="line">                vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "dfs " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl &lt;&lt; endl;</span></span><br><span class="line">                dfs(i, j, cur-&gt;son[x]); <span class="comment">// 进行dfs过程</span></span><br><span class="line">                vis[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h4><p><strong>回溯剪枝 + trie树</strong><br>出自bond用户的评论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;     <span class="comment">//记录该node是否为某个单词的结尾字符</span></span><br><span class="line">    <span class="keyword">int</span> cnt;    <span class="comment">//记录有几个单词经过该node</span></span><br><span class="line">    node* children[<span class="number">26</span>];</span><br><span class="line">    node()&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        id = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="keyword">sizeof</span>(children));</span><br><span class="line">    &#125;</span><br><span class="line">    ~node()&#123;</span><br><span class="line">        <span class="keyword">for</span>(node* child : children)</span><br><span class="line">            <span class="keyword">delete</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, node* cur, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    node* child = cur-&gt;children[board[i][j]-<span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">if</span>(!child) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;    <span class="comment">//计算经过该node匹配到的单词数量</span></span><br><span class="line">    <span class="keyword">if</span>(child-&gt;id != <span class="number">-1</span>)&#123;</span><br><span class="line">        res.push_back(words[child-&gt;id]);</span><br><span class="line">        child-&gt;id = <span class="number">-1</span>;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">    board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = i + dirs[k][<span class="number">0</span>], y = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; board[x][y] != <span class="string">'#'</span>)&#123;</span><br><span class="line">            ans += backtrace(board, words, child, x, y, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    board[i][j] = c;</span><br><span class="line">    child-&gt;cnt -= ans;</span><br><span class="line">    <span class="keyword">if</span>(child-&gt;cnt == <span class="number">0</span>)&#123;  <span class="comment">//经过该节点的所有单词都匹配到了，回溯回来的路上将其删除</span></span><br><span class="line">        <span class="keyword">delete</span> child;</span><br><span class="line">        cur-&gt;children[board[i][j]-<span class="string">'a'</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    node* root = <span class="keyword">new</span> node();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        node* cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : words[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;children[c - <span class="string">'a'</span>]) cur-&gt;children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> node();</span><br><span class="line">            cur = cur-&gt;children[c - <span class="string">'a'</span>];</span><br><span class="line">            cur-&gt;cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            backtrace(board, words, root, i, j, res); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h3><p>二叉搜索树中的两个节点值被交换了，要求你在不改变原树的前提下恢复树木。</p>
<h4 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h4><p>中序遍历+前后指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个出现后边的小于前边的的前边的那个节点一定有问题</span></span><br><span class="line">        <span class="comment">// 第二个出现后边的小于前边的的后边的那个节点一定有问题 或者 s1的后续节点有问题</span></span><br><span class="line">        <span class="comment">// 小 大(3) 2 (1) 4 5</span></span><br><span class="line">        <span class="comment">// (5) 2 3 4 (1)</span></span><br><span class="line">        <span class="comment">// 大 小1 2 (4) 3 5</span></span><br><span class="line">        <span class="comment">// 小 小1 2 (5) 4 (3)</span></span><br><span class="line">        <span class="comment">// 1 (3) (2) 4 5 6</span></span><br><span class="line">        <span class="comment">// 1 2 (4) (3) 5 6</span></span><br><span class="line">        <span class="comment">// 1 2 (5) 4 (3) 6</span></span><br><span class="line">        <span class="comment">// 1 (5) 3 4 (2) 6</span></span><br><span class="line">        <span class="comment">// 1 (6) 3 4 5 (2)</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *s1, *s2, *temp;</span><br><span class="line">        <span class="keyword">int</span> past = INT_MIN, curr; <span class="comment">// 分别指向当前中序的前一个元素和后一个元素</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                curr = root-&gt;val; <span class="comment">// 获取当前元素的值</span></span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">0</span> &amp;&amp; curr &gt;= past) s1 = root; <span class="comment">// s1总是指向中序遍历中前驱元素</span></span><br><span class="line">                <span class="keyword">if</span> (curr &lt; past &amp;&amp; cnt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123; <span class="comment">// 如果是第一次出现这种情况</span></span><br><span class="line">                        <span class="comment">// s1指向前驱节点</span></span><br><span class="line">                        temp = root; <span class="comment">// temp保存当前的后驱备用</span></span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">                        s2 = root; <span class="comment">// s2指向后驱节点</span></span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">1</span> &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="comment">// 遍历完，且只找到s1</span></span><br><span class="line">                    s2 = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                past = curr; <span class="comment">// 滚动</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(s1-&gt;val, s2-&gt;val);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="官方题解优化"><a href="#官方题解优化" class="headerlink" title="官方题解优化"></a>官方题解优化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* x = <span class="literal">nullptr</span>; <span class="comment">// 第一个出错节点</span></span><br><span class="line">        TreeNode* y = <span class="literal">nullptr</span>; <span class="comment">// 第二个出错节点</span></span><br><span class="line">        TreeNode* pred = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pred-&gt;val) &#123;</span><br><span class="line">                <span class="comment">// 如果再出现前驱 &lt; 后驱，只需更新y即可</span></span><br><span class="line">                y = root; <span class="comment">// y指向当前节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果x还没赋值，则它为前驱且固定</span></span><br><span class="line">                    x = pred;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = root; <span class="comment">// pred永远指向当前中序序列节点的前驱</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(x-&gt;val, y-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<h4 id="贪心（思路出错）"><a href="#贪心（思路出错）" class="headerlink" title="贪心（思路出错）"></a>贪心（思路出错）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        sort(coins.<span class="built_in">begin</span>(), coins.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">int</span> n = coins.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;coin : coins) &#123;</span><br><span class="line">            <span class="keyword">while</span> (amount &gt;= coin) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                amount -= coin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (amount != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="递归（超时）-1"><a href="#递归（超时）-1" class="headerlink" title="递归（超时）"></a>递归（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            ans = <span class="built_in">min</span>(cur, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt;= coin)</span><br><span class="line">                helper(coins, amount - coin, cur + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        helper(coins, amount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (valid) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="记忆化搜索（自顶向下）"><a href="#记忆化搜索（自顶向下）" class="headerlink" title="记忆化搜索（自顶向下）"></a>记忆化搜索（自顶向下）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> amount)</span> </span>&#123; <span class="comment">// 返回amount对应的最小步数</span></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[amount] != <span class="number">0</span>) <span class="keyword">return</span> memo[amount];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;coin : coins) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; coin &lt;&lt; " " &lt;&lt; amount &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> res = helper(coins, amount - coin);</span><br><span class="line">            <span class="keyword">if</span> (amount &gt;= coin &amp;&amp; res != <span class="number">-1</span>) &#123;</span><br><span class="line">             </span><br><span class="line">                ans = <span class="built_in">min</span>(res + <span class="number">1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[amount] = (ans == INT_MAX) ? <span class="number">-1</span> : ans;</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        memo.resize(amount + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="dp（自底向上）"><a href="#dp（自底向上）" class="headerlink" title="dp（自底向上）"></a>dp（自底向上）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;coin : coins)</span><br><span class="line">                <span class="keyword">if</span> (i - coin &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i - coin] + <span class="number">1</span>, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="贪心思想-dfs"><a href="#贪心思想-dfs" class="headerlink" title="贪心思想+dfs"></a>贪心思想+dfs</h4><p><a href="https://leetcode-cn.com/problems/coin-change/solution/322-by-ikaruga/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> c_idx, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c_idx == coins.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = amount / coins[c_idx]; k &gt;= <span class="number">0</span> &amp;&amp; k + cnt &lt; ans; k--) &#123; <span class="comment">// k为贪心扔最大，最多能扔多少个</span></span><br><span class="line">            helper(coins, amount - k * coins[c_idx], c_idx + <span class="number">1</span>, cnt + k);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(coins.rbegin(), coins.rend()); <span class="comment">// 从大到小进行排列</span></span><br><span class="line">        helper(coins, amount, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (ans == INT_MAX) ? <span class="number">-1</span> : ans;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="只出现一次的数字II"><a href="#只出现一次的数字II" class="headerlink" title="只出现一次的数字II"></a>只出现一次的数字II</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了<strong>三次</strong>。找出那个只出现了一次的元素。</p>
<p><a href="https://leetcode-cn.com/problems/single-number-ii/solution/luo-ji-dian-lu-jiao-du-xiang-xi-fen-xi-gai-ti-si-l/" target="_blank" rel="noopener">参考题解1</a></p>
<p><a href="https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/" target="_blank" rel="noopener">参考题解2</a></p>
<h4 id="状态分析"><a href="#状态分析" class="headerlink" title="状态分析"></a>状态分析</h4><ul>
<li>根据题意，我们需要记录三种状态：0次，1次，2次。<strong>之后次数都是这三种状态的循环</strong>。</li>
<li>记录三个状态需要两位二进制，我们选定<strong>00，01，10分别代表0次1次2次</strong>。</li>
<li>新输入数字（每一位的二进制数）导致状态发生改变的映射方程为：<ul>
<li><code>i = 0</code>(即00)，状态不变</li>
<li><code>i = 1</code>(即01)，$00 \rarr 01, 01 \rarr 10,10 \rarr 00$</li>
</ul>
</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/0a7ea5bca055b095673620d8bb4c98ef6c610a22f999294ed11ae35d43621e93-Picture3.png" alt="Picture3.png"></p>
<p>u1s1，对于只有一位的二进制数我是看懂了，但是数组中的数基本都是多位二进制数，怎么证明每位二进制数分别进行这波位运算操作，最后组合得到的Y就是所求解呢。我写了一个例子，发现确实是这么回事。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例：[33,33,33,8,5,5,5]</span><br><span class="line">显然输出应当为8。</span><br><span class="line">将这些数按二进制数顺序排开，纵向来看，每一位的运算结果都是通过&quot;数数&quot;得来的，即每一位的我们也能看到最后答案就是每一位按照逻辑运算的简单叠加，获取的就是一个唯一的数。</span><br><span class="line">10010 -&gt;33</span><br><span class="line">10010 -&gt;33</span><br><span class="line">10010 -&gt;33</span><br><span class="line">01000 -&gt;8</span><br><span class="line">00110 -&gt;5</span><br><span class="line">00110 -&gt;5</span><br><span class="line">00110 -&gt;5</span><br><span class="line">每位出现0个数:</span><br><span class="line">46417</span><br><span class="line">每位出现1个数:</span><br><span class="line">31360</span><br><span class="line">保留非3的倍数的位:</span><br><span class="line">01000 ---&gt; 8</span><br></pre></td></tr></table></figure>

<h3 id="只出现一次的数字III"><a href="#只出现一次的数字III" class="headerlink" title="只出现一次的数字III"></a>只出现一次的数字III</h3><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitmask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            bitmask ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bitmask = i ^ j</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> diff = bitmask &amp; (-bitmask); <span class="comment">// diff保存最右边的1的权值（这个1只可能来自i或j）</span></span><br><span class="line">        <span class="comment">// i : 011 -&gt; 3</span></span><br><span class="line">        <span class="comment">// j : 101 -&gt; 5</span></span><br><span class="line">        <span class="comment">// b : 110 -&gt; 6</span></span><br><span class="line">        <span class="comment">// d : 010 -&gt; 2</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; diff) != <span class="number">0</span>) &#123; <span class="comment">// 只要num在diff位为0（那么它要么是i、j其中一个要么是剩余的数中的几个）</span></span><br><span class="line">                x ^= num; <span class="comment">// x经过异或运算筛选出i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;x, bitmask ^ x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="逻辑表达式推导"><a href="#逻辑表达式推导" class="headerlink" title="逻辑表达式推导"></a>逻辑表达式推导</h4><p>法1：卡诺图</p>
<p>法2：根据真值表列表达式后化简</p>
<p><img src="https://pic.leetcode-cn.com/f75d89219ad93c69757b187c64784b4c7a57dce7911884fe82f14073d654d32f-Picture4.png" alt="Picture4.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> X = <span class="number">0</span>, Y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> Z : nums) &#123;</span><br><span class="line">            Y = Y ^ Z &amp; ~X;</span><br><span class="line">            X = X ^ Z &amp; ~Y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数字范围按位与"><a href="#数字范围按位与" class="headerlink" title="数字范围按位与"></a>数字范围按位与</h3><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 某一位上的m~n全部相同则该位为1，否则0</span></span><br><span class="line">        <span class="comment">// 由于是一段区间的二进制数，只要有一个位全为1，那么它以后的位一定不全为1</span></span><br><span class="line">        <span class="comment">// 这体现在该位为其最靠左的位置</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// m和n同为1的最靠左位置</span></span><br><span class="line">        <span class="keyword">while</span> (m != n) &#123; <span class="comment">// </span></span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            cnt++; <span class="comment">// 右移操作的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="两整数之和"><a href="#两整数之和" class="headerlink" title="两整数之和"></a>两整数之和</h3><p>不能够使用<code>+</code>或<code>-</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> lower, carrier;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lower = a ^ b;</span><br><span class="line">            carrier = a &amp; b;</span><br><span class="line">            <span class="keyword">if</span> (carrier == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            a = lower;</span><br><span class="line">            <span class="comment">// 当测试用例含-1时，其左移会发生溢出(符号位截断)，所以要先转换成无符号数再左移</span></span><br><span class="line">            b = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(carrier) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lower;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_35661481/article/details/78991712" target="_blank" rel="noopener">溢出说明</a></p>
<h3 id="数字转换为16进制"><a href="#数字转换为16进制" class="headerlink" title="数字转换为16进制"></a>数字转换为16进制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> hex = <span class="string">"0123456789abcdef"</span>, ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &amp;&amp; ans.<span class="built_in">size</span>() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="comment">/*0xf = 00...01111*/</span></span><br><span class="line">            ans = hex[num &amp; <span class="number">0xf</span>] + ans; <span class="comment">// 获取其低4位并转换为16进制</span></span><br><span class="line">            num &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="计数二进制子串"><a href="#计数二进制子串" class="headerlink" title="计数二进制子串"></a>计数二进制子串</h3><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p>
<p>重复出现的子串要计算它们出现的次数。</p>
<h4 id="个人解法-2"><a href="#个人解法-2" class="headerlink" title="个人解法"></a>个人解法</h4><p>将0、1按连续分组。<br>比如”00111001”-&gt;[2,3,2,1]再进行计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curCnt, pasCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            curCnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; s[i] == s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                curCnt++; i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">min</span>(pasCnt, curCnt);</span><br><span class="line">            i++;</span><br><span class="line">            pasCnt = curCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h4><p>官方这种在遍历过程中不涉及<code>i - 1</code>和<code>i</code>的比对，而是用c保存<code>i - 1</code>的结果挺好的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>, n = s.<span class="built_in">size</span>(), last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[ptr];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (ptr &lt; n &amp;&amp; s[ptr] == c) &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">min</span>(count, last);</span><br><span class="line">            last = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最短回文串"><a href="#最短回文串" class="headerlink" title="最短回文串"></a>最短回文串</h3><p>给定一个字符串 <strong><em>s</em></strong>，你可以通过在字符串<strong>前面</strong>添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<p><a href="https://leetcode-cn.com/problems/shortest-palindrome/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--44/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// if (n &lt;= 1) return s;</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// a b c d e c b e a</span></span><br><span class="line">        <span class="comment">// a e b c e (a b c d) e c b e a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> rev = s.substr(i, n);</span><br><span class="line">        reverse(rev.<span class="built_in">begin</span>(), rev.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// [0, i)之间的字符串保证里面存在最长回文串</span></span><br><span class="line">        <span class="keyword">return</span> rev + shortestPalindrome(s.substr(<span class="number">0</span>, i)) + s.substr(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h3><p>返回两个字符串相乘得到的字符串。</p>
<h4 id="个人解法-3"><a href="#个人解法-3" class="headerlink" title="个人解法"></a>个人解法</h4><p>模拟竖式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mulHelper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*返回一位数乘多位数字符串结果*/</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "在计算" &lt;&lt; s &lt;&lt; "*" &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = s[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "cur " &lt;&lt; cur &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> res = cur * c + carry; <span class="comment">// 当前位的计算结果加上carry</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "res " &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">string</span> lower = to_string(res % <span class="number">10</span>); <span class="comment">// 当前位应记下的值</span></span><br><span class="line">            ret.insert(<span class="number">0</span>, lower);</span><br><span class="line">            carry = res / <span class="number">10</span>; <span class="comment">// 当前的carry</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">            ret.insert(<span class="number">0</span>, to_string(carry)); <span class="comment">// 将carry补到前侧</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addHelper</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*返回两个字符串相加的字符串*/</span></span><br><span class="line">        <span class="keyword">int</span> n1 = s1.<span class="built_in">size</span>(), n2 = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "在计算" &lt;&lt; s1 &lt;&lt; "+" &lt;&lt; s2 &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">0</span>) <span class="keyword">return</span> s2;</span><br><span class="line">        <span class="keyword">if</span> (n2 == <span class="number">0</span>) <span class="keyword">return</span> s1;</span><br><span class="line">        <span class="keyword">int</span> i = n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = (s1[i] - <span class="string">'0'</span>) + (s2[j] - <span class="string">'0'</span>) + carry;</span><br><span class="line">            ret.insert(<span class="number">0</span>, to_string(cur % <span class="number">10</span>));</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            --i; --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "ret= " &lt;&lt; ret &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = (s1[i] - <span class="string">'0'</span>) + carry;</span><br><span class="line">            ret.insert(<span class="number">0</span>, to_string(cur % <span class="number">10</span>));</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = (s2[j] - <span class="string">'0'</span>) + carry;</span><br><span class="line">            ret.insert(<span class="number">0</span>, to_string(cur % <span class="number">10</span>));</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) ret.insert(<span class="number">0</span>, to_string(carry));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = num1.<span class="built_in">size</span>(), n2 = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span> (n1 &lt; n2) &#123;</span><br><span class="line">            swap(num1, num2);</span><br><span class="line">            swap(n2, n1);</span><br><span class="line">            <span class="comment">// 使位数偏多的数留在竖式的上侧简化乘法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*字符串一阶乘法*/</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = (num2[i] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="built_in">string</span> temp = mulHelper(num1, cur);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; ++j) &#123;</span><br><span class="line">                temp += <span class="string">"0"</span>; <span class="comment">// 后侧补0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "此次temp " &lt;&lt; temp;</span></span><br><span class="line">            res = addHelper(res, temp);</span><br><span class="line">            cnt++; <span class="comment">// cnt为当前后侧补0数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="官方优化"><a href="#官方优化" class="headerlink" title="官方优化"></a>官方优化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.<span class="built_in">size</span>(), n = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">            swap(m, n); swap(num1, num2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                curr.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> y = num2.at(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = num1.at(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> product = x * y + add;</span><br><span class="line">                curr.push_back(product % <span class="number">10</span>);</span><br><span class="line">                add = product / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (add != <span class="number">0</span>) &#123;</span><br><span class="line">                curr.push_back(add % <span class="number">10</span>);</span><br><span class="line">                add /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(curr.<span class="built_in">begin</span>(), curr.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : curr) &#123;</span><br><span class="line">                c += <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = addStrings(ans, curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> &amp;num1, <span class="built_in">string</span> &amp;num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>, j = num2.<span class="built_in">size</span>() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.at(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.at(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.push_back(result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c: ans) &#123;</span><br><span class="line">            c += <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="重复叠加字符串匹配"><a href="#重复叠加字符串匹配" class="headerlink" title="重复叠加字符串匹配"></a>重复叠加字符串匹配</h3><p>给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。</p>
<p>举个例子，A = “abcd”，B = “cdabcdab”。</p>
<p>答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”，此时 B 是其子串；A 重复叠加两遍后为”abcdabcd”，B 并不是其子串。</p>
<h4 id="个人解法-kmp"><a href="#个人解法-kmp" class="headerlink" title="个人解法(kmp)"></a>个人解法(kmp)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buildNext</span><span class="params">(<span class="built_in">string</span> &amp;T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> n = T.length(), j = <span class="number">0</span>; <span class="comment">// "主"串指针</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>; <span class="comment">// 模式串指针</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">0</span> || T[j] == T[t]) &#123;</span><br><span class="line">                <span class="comment">/*如果碰到了哨兵或是正确匹配*/</span></span><br><span class="line">                ++t; ++j;</span><br><span class="line">                next[j] = (T[j] == T[t]) ? next[t] : t; <span class="comment">// 防止以卵击石的"幼稚"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = next[t]; <span class="comment">// 赋值为next(相当于移动模式串)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;   	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> &amp;S, <span class="built_in">string</span> &amp;T, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 2 3 | 1 2 3</span></span><br><span class="line">        <span class="comment">// 0 1 2 | 0 1 2            </span></span><br><span class="line">        <span class="comment">// 0 1 2   3 4 5</span></span><br><span class="line">        <span class="comment">// 3 1 2 3</span></span><br><span class="line">        <span class="comment">// 2 - 3 &lt;= 9 - 4</span></span><br><span class="line">        <span class="comment">// -1 &lt;= 5</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; S &lt;&lt; " " &lt;&lt; T &lt;&lt; " " &lt;&lt; lim &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> n1 = S.length(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = T.length(), j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = lim;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span> || S[i] == T[j]) &#123;</span><br><span class="line">                ++i; ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == n1 &amp;&amp; lim &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                --lim;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + (<span class="built_in">size</span> - lim) * n1; <span class="comment">// 计算i的真实下标</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i - j &lt;= <span class="built_in">size</span> * n1 - n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n2 = B.<span class="built_in">size</span>(), j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = A.<span class="built_in">size</span>(), i = <span class="number">0</span>;</span><br><span class="line">        next = buildNext(B);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n1 * cnt &lt; n2) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="comment">// 算出&gt;=B.length()的最小长度A</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lim = n2 / n1 + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (!kmp(A, B, cnt)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; lim) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h4><p><a href="https://blog.csdn.net/qq_41855420/article/details/89459140" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> tempA = A;</span><br><span class="line">        <span class="comment">//cnt代表的A重复的次数,midRepCnt代表的B串中间A重复的次数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>, Asize = A.<span class="built_in">size</span>(), Bsize = B.<span class="built_in">size</span>(), midRepCnt = Bsize / Asize;</span><br><span class="line">        <span class="comment">//midRepCnt代表的B串中间A重复的次数,2是首位各添加一个A串</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= midRepCnt + <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tempA.<span class="built_in">find</span>(B) != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            tempA += A;<span class="comment">//重复次数自增</span></span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="数组中第k个最大元素"><a href="#数组中第k个最大元素" class="headerlink" title="数组中第k个最大元素"></a>数组中第k个最大元素</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>建堆 + 删除取栈顶</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low, j = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap[j] &gt; heap[i]) &#123;</span><br><span class="line">                swap(heap[i], heap[j]);</span><br><span class="line">                i = j;</span><br><span class="line">                j = i * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            downAdjust(i, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">        downAdjust(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据原序列建立堆，删除k - 1次的堆顶元素即为所求</span></span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.insert(nums.<span class="built_in">begin</span>(), <span class="number">-1</span>); <span class="comment">// 顶部插入占位元素</span></span><br><span class="line">        heap = nums;</span><br><span class="line">        createHeap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            deleteTop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<h4 id="个人解法-4"><a href="#个人解法-4" class="headerlink" title="个人解法"></a>个人解法</h4><p>滑动窗口维护最大值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;int, int&gt; getMax(vector&lt;int&gt;&amp; nums, int l, int r) &#123; // idx, val</span><br><span class="line">        <span class="keyword">int</span> mmax = INT_MIN, idx = l;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &gt; mmax) &#123;</span><br><span class="line">                idx = l;</span><br><span class="line">                mmax = nums[l];</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;idx, mmax&#125;;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最大值如果在滑动窗口之间，只需比较当前最大值和下一个进窗口的值</span></span><br><span class="line">        <span class="comment">// 如果最大值在最左侧，要记录其次大值，与下一个进窗口的值进行比较（直接调用最大值函数得了）</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums; <span class="comment">// 如果以1为区间，直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先获取第一个窗口的最大值</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> res = getMax(nums, l, r);</span><br><span class="line">        <span class="keyword">int</span> maxVal = res.second;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = res.first;</span><br><span class="line">        ans.push_back(maxVal);</span><br><span class="line">        <span class="keyword">if</span> (maxIdx == <span class="number">0</span> &amp;&amp; k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res = getMax(nums, l + <span class="number">1</span>, r);</span><br><span class="line">            maxIdx = res.first;</span><br><span class="line">            maxVal = res.second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - k; ++i) &#123;</span><br><span class="line">            <span class="comment">// i ~ k + i - 1</span></span><br><span class="line">            l = i, r = k + i - <span class="number">1</span>; <span class="comment">// 滑动窗口的左右边界</span></span><br><span class="line">            <span class="keyword">if</span> (nums[r] &gt; maxVal) &#123; <span class="comment">// 如果当前新纳入窗口的元素大于当前窗口的最大元素，更新最大值</span></span><br><span class="line">                maxIdx = r;</span><br><span class="line">                maxVal = nums[r];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(maxVal); <span class="comment">// 纳入结果数组</span></span><br><span class="line">            <span class="keyword">if</span> (maxIdx == l &amp;&amp; k &gt; <span class="number">1</span>) &#123; <span class="comment">// 如果当前最大元素位于最左边</span></span><br><span class="line">                res = getMax(nums, l + <span class="number">1</span>, r); <span class="comment">// 获取当前窗口除了左边界元素的最大值，并更新idx和val</span></span><br><span class="line">                maxVal = res.second;</span><br><span class="line">                maxIdx = res.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="其他解法-1"><a href="#其他解法-1" class="headerlink" title="其他解法"></a>其他解法</h4><p>双端队列<br>出自用户icloud</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; window;   <span class="comment">//双端队列，从队头到队尾 依次存 窗口内最大元素的index ~ 最小元素的index</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;   <span class="comment">//后续，窗口每右移一次，都会产生一个最大值[队列头位置的元素]</span></span><br><span class="line">            <span class="keyword">if</span>(!window.empty() &amp;&amp; window.front() &lt;= right - k)&#123;   <span class="comment">//队头不在窗口范围内</span></span><br><span class="line">                window.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!window.empty() &amp;&amp; nums[right] &gt; nums[window.back()])&#123;   <span class="comment">//待入队元素比队尾元素大</span></span><br><span class="line">                window.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            window.push_back(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(right &gt;= k) res.push_back(nums[window.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二进制矩阵中的最短路径"><a href="#二进制矩阵中的最短路径" class="headerlink" title="二进制矩阵中的最短路径"></a>二进制矩阵中的最短路径</h3><p><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">题目链接</a></p>
<p>图论BFS模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span> || grid[n - <span class="number">1</span>][n - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> r = tmp.first;</span><br><span class="line">                <span class="keyword">int</span> c = tmp.second;</span><br><span class="line">                <span class="keyword">if</span> (r == n - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">                    <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">                    <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">                    <span class="keyword">if</span> (notEdge) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                            q.push(&#123;x, y&#125;);</span><br><span class="line">                            grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">step</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记VIII</title>
    <url>/2020/11/17/Leetcode%E6%97%A5%E8%AE%B0VIII/</url>
    <content><![CDATA[<p>8</p>
<a id="more"></a>

<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="132模式"><a href="#132模式" class="headerlink" title="132模式"></a>132模式</h2><p>给定一个整数序列：a1, a2, …, an，一个132模式的子序列 a<strong>i</strong>, a<strong>j</strong>, a<strong>k</strong> 被定义为：当 <strong>i</strong> &lt; <strong>j</strong> &lt; <strong>k</strong> 时，a<strong>i</strong> &lt; a<strong>k</strong> &lt; a<strong>j</strong>。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。</p>
<h3 id="优先级队列-维护最小值"><a href="#优先级队列-维护最小值" class="headerlink" title="优先级队列+维护最小值"></a>优先级队列+维护最小值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minLeft = nums[<span class="number">0</span>]; <span class="comment">// 维护当前左侧所有数中的最小值</span></span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; right_all_items; <span class="comment">// 维护当前右侧所有数所构成的有序集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; n; ++k) right_all_items.insert(nums[k]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">// 枚举所有可能的j</span></span><br><span class="line">            <span class="keyword">if</span> (minLeft &lt; nums[j]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = right_all_items.upper_bound(minLeft); <span class="comment">// 试图找刚好比左侧元素大一点的元素</span></span><br><span class="line">                <span class="keyword">if</span> (it != right_all_items.<span class="built_in">end</span>() &amp;&amp; *it &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新维护minLeft 和 right_all_items</span></span><br><span class="line">            minLeft = <span class="built_in">min</span>(minLeft, nums[j]);</span><br><span class="line">            right_all_items.erase(right_all_items.<span class="built_in">find</span>(nums[j + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> last = INT_MIN; <span class="comment">// 维护一个栈中当前的倒数第二大值，last永远指向当前栈顶下一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; last) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 前面的操作已经保证j, k的正确性，只要当前枚举的新元素是三个数据中最小的那个就满足条件</span></span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt; nums[i]) &#123;</span><br><span class="line">                last = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="移掉K位数字"><a href="#移掉K位数字" class="headerlink" title="移掉K位数字"></a>移掉K位数字</h2><p>给定一个以字符串表示的非负整数 <em>num*，移除这个数中的 *k</em> 位数字，使得剩下的数字最小。</p>
<p>思路：从数字高位开始向低位遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; stk; <span class="comment">// 定义单调非降双端队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; digit : num) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; stk.back() &gt; digit &amp;&amp; k) &#123;</span><br><span class="line">                <span class="comment">// 保持队列非降，如果当前数字小于栈顶，弹出较大值，更新k</span></span><br><span class="line">                stk.pop_back();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push_back(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">            stk.pop_back(); <span class="comment">// 从尾部向头部删除</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>; <span class="comment">// 将stk转入到ans</span></span><br><span class="line">        <span class="keyword">bool</span> isLeadingZero = <span class="literal">true</span>; <span class="comment">// 前导零的标志位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; digit : stk) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeadingZero &amp;&amp; digit == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            isLeadingZero = <span class="literal">false</span>;</span><br><span class="line">            ans += digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == <span class="string">""</span> ? <span class="string">"0"</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="下一个更大元素I"><a href="#下一个更大元素I" class="headerlink" title="下一个更大元素I"></a>下一个更大元素I</h2><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">10005</span>, <span class="number">-1</span>)</span></span>; <span class="comment">// arr[i]表示数字i的下一个比它大元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; nums2[i] &gt; nums2[stk.top()]) &#123;</span><br><span class="line">                arr[nums2[stk.top()]] = nums2[i];</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums1.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i) ans[i] = arr[nums1[i]];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="下一个更大元素II"><a href="#下一个更大元素II" class="headerlink" title="下一个更大元素II"></a>下一个更大元素II</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p>思路：</p>
<ul>
<li><p>单调栈的从栈底到栈顶的序列是非降的</p>
</li>
<li><p>模拟循环数组让i对n取余即可</p>
</li>
<li><p>循环遍历两遍数组，每次不断将小于当前元素的栈顶下标出栈，并修改<code>ans[stk.top()]</code>为当前元素（<strong>如果有更靠前的更大元素，那么这些位置将被提前弹出栈</strong>）。最后将当前元素压栈</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; nums[stk.top()] &lt; nums[i % n]) &#123;</span><br><span class="line">                ret[stk.top()] = nums[i % n];</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i % n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><h3 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h3><p>自底向上逐层模拟。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (true) &#123;</span><br><span class="line">            int curSum = accumulate(height.begin(), height.end(), <span class="number">0</span>);</span><br><span class="line">            int maxVal = *max_element(height.begin(), height.end());</span><br><span class="line">            <span class="keyword">if</span> (maxVal == <span class="number">0</span> || maxVal == curSum) <span class="keyword">break</span>;</span><br><span class="line">            bool appeared_Block = false, lastIsBlock = false;</span><br><span class="line">            int tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; height.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (height[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    appeared_Block = true;</span><br><span class="line">                    <span class="keyword">if</span> (appeared_Block &amp;&amp; !lastIsBlock) &#123;</span><br><span class="line">                        ans += tmp;</span><br><span class="line">                        tmp = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lastIsBlock = true;</span><br><span class="line">                &#125; <span class="keyword">else</span> lastIsBlock = false;</span><br><span class="line">                <span class="keyword">if</span> (appeared_Block &amp;&amp; height[i] == <span class="number">0</span>) tmp++;</span><br><span class="line">                <span class="keyword">if</span> (height[i] &gt; <span class="number">0</span>) height[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">leftMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        leftMax[<span class="number">0</span>] = <span class="built_in">height</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            leftMax[i] = <span class="built_in">max</span>(leftMax[i - <span class="number">1</span>], <span class="built_in">height</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = <span class="built_in">height</span>[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            rightMax[i] = <span class="built_in">max</span>(rightMax[i + <span class="number">1</span>], <span class="built_in">height</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += <span class="built_in">min</span>(leftMax[i], rightMax[i]) - <span class="built_in">height</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1011. 在 D 天内送达包裹的能力</a></h2><p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p>
<p>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 等效问题：分D段，从而最小化最长的子数组总和(最小化最大问题，用二分查找)</span></span><br><span class="line">        <span class="keyword">int</span> maxNum = *max_element(weights.<span class="built_in">begin</span>(), weights.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> sumNum = accumulate(weights.<span class="built_in">begin</span>(), weights.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> l = maxNum, r = sumNum;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 判断当前的m是否满足</span></span><br><span class="line">            <span class="keyword">int</span> tmpSum = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; weight : weights) &#123;</span><br><span class="line">                tmpSum += weight;</span><br><span class="line">                <span class="keyword">if</span> (tmpSum &gt; m) &#123;</span><br><span class="line">                    tmpSum = weight;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; D) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p><strong>说明：</strong></p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/gas-station/solution/jia-you-zhan-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, <span class="built_in">run</span> = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="comment">// 从头遍历一遍</span></span><br><span class="line">            cur += (gas[i] - cost[i]); <span class="comment">// cur记录了全程的油量-路程</span></span><br><span class="line">            <span class="built_in">run</span> += (gas[i] - cost[i]); <span class="comment">// run记录了每次重生后的路程</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">run</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">// 更新start为出生地</span></span><br><span class="line">                <span class="built_in">run</span> = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur &gt;= <span class="number">0</span> ? start : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/" target="_blank" rel="noopener">官方题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;); <span class="comment">// 按y的大小升序排列</span></span><br><span class="line">        <span class="keyword">int</span> pos = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; pos) &#123;</span><br><span class="line">                pos = points[i][<span class="number">1</span>]; <span class="comment">// 更新pos为下一个索引的y</span></span><br><span class="line">                ans++; <span class="comment">// 箭的数量加一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记VI</title>
    <url>/2020/09/08/Leetcode%E6%97%A5%E8%AE%B0VI/</url>
    <content><![CDATA[<p>Leetcode日记VI。</p>
<a id="more"></a>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以<strong>无限制重复被选取</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="comment">// 从每层的第二个结点开始都不能再使用该层前边几个元素使用过的元素了</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= candidates[i]) &#123;</span><br><span class="line">                v.push_back(candidates[i]);</span><br><span class="line">                helper(candidates, cur - candidates[i], v, i);</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*以target为初始值，向下依次试探candidates的所有元素，并递归向下，直到得到0输出*/</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        len = candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        helper(candidates, target, v, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curV, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == target) &#123;</span><br><span class="line">            ans.push_back(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; target || pos == len - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; pos + <span class="number">1</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur + candidates[i] &lt;= target) &#123;</span><br><span class="line">                curV.push_back(candidates[i]);</span><br><span class="line">                helper(candidates, target, cur + candidates[i], curV, i);</span><br><span class="line">                curV.pop_back(); <span class="comment">// backtracking</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        len = candidates.<span class="built_in">size</span>();</span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;candidates[i]&#125;;</span><br><span class="line">            helper(candidates, target, candidates[i], v, i);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><p>找出所有相加之和为 <strong><em>n</em></strong> 的 <strong>k</strong> 个数的组合<strong>。</strong>组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.<span class="built_in">size</span>() == k) ans.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur + i &lt;= target) &#123;</span><br><span class="line">                v.push_back(i);</span><br><span class="line">                helper(cur + i, k, i + <span class="number">1</span>, target, v);</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        helper(<span class="number">0</span>, k, <span class="number">1</span>, n, v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == len) &#123;</span><br><span class="line">            ans.emplace_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cur.emplace_back(nums[i]);</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            backTracing(nums, cur);</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">            cur.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line">        vis.assign(len, <span class="number">0</span>);</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        backTracing(nums, v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == len) &#123;</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &amp;&amp; !vis[i - <span class="number">1</span>] || vis[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cur.push_back(nums[i]);</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            helper(nums, cur, vis);</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">            cur.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(nums.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line">        helper(nums, v, vis);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> cnt, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == cnt) &#123;</span><br><span class="line">            ans.emplace_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; ++i) &#123;</span><br><span class="line">            cur.emplace_back(nums[i]);</span><br><span class="line">            backTracing(nums, cnt, cur, i + <span class="number">1</span>);</span><br><span class="line">            cur.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            backTracing(nums, i, v, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><p>给定一组<strong>可能包含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == <span class="built_in">size</span>) &#123;</span><br><span class="line">            ans.emplace_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 与上题唯一的不同是在这里去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.emplace_back(nums[i]);</span><br><span class="line">            backTracing(nums, i + <span class="number">1</span>, cur, <span class="built_in">size</span>);</span><br><span class="line">            cur.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            backTracing(nums, <span class="number">0</span>, v, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 <em>s</em> 所有可能的分割方案。</p>
<h3 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h3><p>dfs+双指针判断回文串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[l++] != str[r--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;tmp, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt;= str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 最后一个回文子串构建成功</span></span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isPal(start, cur)) &#123;</span><br><span class="line">            tmp.push_back(str.substr(start, cur - start + <span class="number">1</span>));</span><br><span class="line">            dfs(cur + <span class="number">1</span>, cur + <span class="number">1</span>, tmp, <span class="number">1</span>);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(start, cur + <span class="number">1</span>, tmp, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">partition</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        str = s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, tmp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><p>法1：回溯+<strong>动态规划预处理</strong></p>
<p>提前利用如下状态转移方程，用dp数组<code>dp[i][j]</code>表示ij之间是否为回文串，注意计算顺序。<br>$$<br>f(i, j) =<br>\left {<br>\begin{aligned}<br>true, i &lt;= j \<br>f(i + 1, j - 1) \wedge (s[i] == s[j]), otherwise<br>\end{aligned}<br>\right.<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ret;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ret.push_back(ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j]) &#123;</span><br><span class="line">                ans.push_back(s.substr(i, j - i + <span class="number">1</span>));</span><br><span class="line">                dfs(s, j + <span class="number">1</span>);</span><br><span class="line">                ans.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">partition</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        n = s.<span class="built_in">size</span>();</span><br><span class="line">        f.assign(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/palindrome-partitioning/solution/fen-ge-hui-wen-chuan-by-leetcode-solutio-6jkv/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>法2：回溯+记忆化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ret;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ret.push_back(ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, i, j) == <span class="number">1</span>) &#123;</span><br><span class="line">                ans.push_back(s.substr(i, j - i + <span class="number">1</span>));</span><br><span class="line">                dfs(s, j + <span class="number">1</span>);</span><br><span class="line">                ans.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索中，f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">return</span> f[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[i][j] = (s[i] == s[j] ? isPalindrome(s, i + <span class="number">1</span>, j - <span class="number">1</span>) : <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">partition</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        n = s.<span class="built_in">size</span>();</span><br><span class="line">        f.assign(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/palindrome-partitioning/solution/fen-ge-hui-wen-chuan-by-leetcode-solutio-6jkv/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>





<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="01矩阵"><a href="#01矩阵" class="headerlink" title="01矩阵"></a>01矩阵</h2><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。</p>
<h3 id="个人解法（BFS）"><a href="#个人解法（BFS）" class="headerlink" title="个人解法（BFS）"></a>个人解法（BFS）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">updateMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// bfs</span></span><br><span class="line">                    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; tmp;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                    <span class="keyword">bool</span> breakLabel = <span class="literal">false</span>; <span class="comment">// bfs在该层找到目标0的话，需要break</span></span><br><span class="line">                    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                        <span class="built_in">size</span>++;</span><br><span class="line">                        <span class="keyword">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">0</span>; time &lt; len; ++time) &#123;</span><br><span class="line">                            tmp.push(q.front());</span><br><span class="line">                            <span class="keyword">int</span> r = q.front().first, c = q.front().second;</span><br><span class="line">                            q.pop();</span><br><span class="line">                            matrix[r][c] = <span class="number">-1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                                <span class="keyword">int</span> x = r + dx[k];</span><br><span class="line">                                <span class="keyword">int</span> y = c + dy[k];</span><br><span class="line">                                <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">                                <span class="keyword">if</span> (notEdge &amp;&amp; matrix[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                                    ans[i][j] = <span class="built_in">size</span>;</span><br><span class="line">                                    breakLabel = <span class="literal">true</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (notEdge &amp;&amp; matrix[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                                    q.push(&#123;x, y&#125;); </span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (breakLabel) <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (breakLabel) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (!tmp.empty()) &#123;</span><br><span class="line">                        <span class="comment">// 将之前标记成-1的元素回退成1</span></span><br><span class="line">                        matrix[tmp.front().first][tmp.front().second] = <span class="number">1</span>;</span><br><span class="line">                        tmp.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><a href="https://leetcode-cn.com/problems/01-matrix/solution/01ju-zhen-by-leetcode-solution/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">updateMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dist</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">seen</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 将所有的 0 添加进初始队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.emplace(i, j);</span><br><span class="line">                    seen[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, j] = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; ++d) &#123;</span><br><span class="line">                <span class="keyword">int</span> ni = i + dirs[d][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nj = j + dirs[d][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; n &amp;&amp; !seen[ni][nj]) &#123;</span><br><span class="line">                    dist[ni][nj] = dist[i][j] + <span class="number">1</span>;</span><br><span class="line">                    q.emplace(ni, nj);</span><br><span class="line">                    seen[ni][nj] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">updateMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dist</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, INT_MAX / <span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 如果 (i, j) 的元素为 0，那么距离为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                    dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="统计不开心的朋友"><a href="#统计不开心的朋友" class="headerlink" title="统计不开心的朋友"></a>统计不开心的朋友</h2><p><a href="https://leetcode-cn.com/problems/count-unhappy-friends/" target="_blank" rel="noopener">题目链接</a></p>
<p>这题看似简单，其实踩到坑了，下边的双层for循环中的<code>if (m.count(x) != 0 &amp;&amp; m[x].count(t.first) != 0)</code>这一句，如果不加<code>m.count(x) != 0</code>这句的话会导致<strong>当以x下标访问hash表，而该x处又没有元素的时候，hash表会自动给m[x]开辟一个空间，也就是m[x]非空了，m.size()自增1！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unhappyFriends</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; preferences, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// preferences自成一个邻接表</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; m; <span class="comment">// m存储了i非朋友中比其朋友亲密度更高的群体（即有可能是令i不开心的人）</span></span><br><span class="line">        <span class="comment">// 只有存在比它朋友更亲密的非朋友，才有可能不开心</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : pairs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pf : preferences[pair[<span class="number">0</span>]]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pf == pair[<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">                m[pair[<span class="number">0</span>]].insert(pf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pf : preferences[pair[<span class="number">1</span>]]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pf == pair[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">                m[pair[<span class="number">1</span>]].insert(pf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;t : m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;x : t.second) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.count(x) != <span class="number">0</span> &amp;&amp; m[x].count(t.first) != <span class="number">0</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="冗余连接II"><a href="#冗余连接II" class="headerlink" title="冗余连接II"></a>冗余连接II</h2><p><a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ancestor;</span><br><span class="line"></span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        ancestor.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ancestor[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index == ancestor[index] ? index : ancestor[index] = <span class="built_in">find</span>(ancestor[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ancestor[<span class="built_in">find</span>(u)] = <span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nodesCount = edges.<span class="built_in">size</span>();</span><br><span class="line">        UnionFind uf = UnionFind(nodesCount + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nodesCount + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodesCount; ++i) &#123;</span><br><span class="line">            <span class="comment">// 初始化并查集</span></span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> conflict = <span class="number">-1</span>; <span class="comment">// 代表冲突的边</span></span><br><span class="line">        <span class="keyword">int</span> cycle = <span class="number">-1</span>; <span class="comment">// 代表环路的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodesCount; ++i) &#123;</span><br><span class="line">            <span class="comment">// 遍历边，构造并查集，同时记录最后一个冲突边和环路边</span></span><br><span class="line">            <span class="keyword">auto</span> edge = edges[i];</span><br><span class="line">            <span class="keyword">int</span> node1 = edge[<span class="number">0</span>], node2 = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (parent[node2] != node2) &#123;</span><br><span class="line">                <span class="comment">// 如果父亲节点不是自己，则有两个边指向它，标记为冲突</span></span><br><span class="line">                conflict = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[node2] = node1; <span class="comment">// 标记该边的父亲</span></span><br><span class="line">                <span class="keyword">if</span> (uf.<span class="built_in">find</span>(node1) == uf.<span class="built_in">find</span>(node2)) &#123;</span><br><span class="line">                    <span class="comment">// 如果两边的根节点相同，必有环</span></span><br><span class="line">                    cycle = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果无环，两节点可以归为一个集合</span></span><br><span class="line">                    uf.merge(node1, node2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看冲突的边和环路边</span></span><br><span class="line">        <span class="keyword">if</span> (conflict &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果无冲突边，则问题出在环路边，直接返回</span></span><br><span class="line">            <span class="keyword">auto</span> redundant = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;edges[cycle][<span class="number">0</span>], edges[cycle][<span class="number">1</span>]&#125;;</span><br><span class="line">            <span class="keyword">return</span> redundant;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，讨论是否有环路边</span></span><br><span class="line">            <span class="keyword">auto</span> conflictEdge = edges[conflict];</span><br><span class="line">            <span class="keyword">if</span> (cycle &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果有环路边，则应是另一个边，因为不能同时冲突和环路</span></span><br><span class="line">                <span class="keyword">auto</span> redundant = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;parent[conflictEdge[<span class="number">1</span>]], conflictEdge[<span class="number">1</span>]&#125;;</span><br><span class="line">                <span class="keyword">return</span> redundant;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果无环路边，显然问题出在最后一个冲突边</span></span><br><span class="line">                <span class="keyword">auto</span> redundant = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;conflictEdge[<span class="number">0</span>], conflictEdge[<span class="number">1</span>]&#125;;</span><br><span class="line">                <span class="keyword">return</span> redundant;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="dp-1"><a href="#dp-1" class="headerlink" title="dp"></a>dp</h1><h2 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h2><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.count(cur) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= nums[i]) &#123;</span><br><span class="line">                res += helper(nums, cur - nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[cur] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i]表示target为i时的方案数</span></span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="两种dp思路"><a href="#两种dp思路" class="headerlink" title="两种dp思路"></a>两种dp思路</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i]表示target为i时的方案数</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[j] &lt;= target) &#123;</span><br><span class="line">                    dp[i + nums[j]] += dp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>, <span class="number">0</span>)</span></span>;<span class="comment">//防止溢出。</span></span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span> ; s &lt;= target ; s++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++)</span><br><span class="line">              <span class="keyword">if</span>(nums[i] &lt;= s) </span><br><span class="line">                  dp[s] += dp[s-nums[i]];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[target];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h2><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">题目链接</a></p>
<p>原始dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, len = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : strs[i]) &#123;</span><br><span class="line">                v[c - <span class="string">'0'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.emplace_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= cnt[k][<span class="number">0</span>]; --i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= cnt[k][<span class="number">1</span>]; --j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], <span class="number">1</span> + dp[i - cnt[k][<span class="number">0</span>]][j - cnt[k][<span class="number">1</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化后</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zeros = <span class="number">0</span>, ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;str : strs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; c : str) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'0'</span>) zeros++;</span><br><span class="line">                <span class="keyword">else</span> ones++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= zeros; --i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= ones; --j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], <span class="number">1</span> + dp[i - zeros][j - ones]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            zeros = <span class="number">0</span>; ones= <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="最长湍流子数组"><a href="#最长湍流子数组" class="headerlink" title="最长湍流子数组"></a>最长湍流子数组</h2><p><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/" target="_blank" rel="noopener">题目链接</a></p>
<p>参考官方题解，但是分组的时候出现了边界处理的问题。最后还是捋清楚了，保留了状态转移方程中对更新区间的原始公式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, len = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">int</span> type[len - <span class="number">1</span>]; <span class="built_in">memset</span>(type, <span class="number">0</span>, <span class="keyword">sizeof</span> type); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i + <span class="number">1</span>] &gt; A[i]) type[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (A[i + <span class="number">1</span>] == A[i]) type[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> type[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// traversing type array</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!type[i]) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (i - <span class="number">1</span>) - start + <span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (type[i] + type[i - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, (i - <span class="number">1</span>) - start + <span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (len - <span class="number">2</span>) - start + <span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分割回文串II"><a href="#分割回文串II" class="headerlink" title="分割回文串II"></a>分割回文串II</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>
<p>和分割回文串I一样，在动态规划预处理后，进行简单dp计算，计算顺序可通过画图确定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">isPal</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">true</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                isPal[i][j] = isPal[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i] == s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPal[<span class="number">0</span>][i]) f[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isPal[j + <span class="number">1</span>][i]) f[i] = <span class="built_in">min</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h2><p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p>
<p>二分法的if条件是<code>m</code>正处于下坡，此时将二分区间定在左侧必然能锁定到一个峰值（拉格朗日）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt; nums[m + <span class="number">1</span>]) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="字典序排数"><a href="#字典序排数" class="headerlink" title="字典序排数"></a>字典序排数</h2><p>给定一个整数 <em>n</em>, 返回从 <em>1</em> 到 <em>n</em> 的字典顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> base, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (base &gt; n) <span class="keyword">return</span>;</span><br><span class="line">        ans.push_back(base);</span><br><span class="line">        base *= <span class="number">10</span>; <span class="comment">// 基数显示该层的量级</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            helper(n, base + i, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            helper(n, i, ans);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">题目链接</a></p>
<p>这题要是不是二叉搜索树的话会很麻烦，所以要利用好二叉搜索树的性质。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == root-&gt;val) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;val == root-&gt;val) <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; l;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; mp;</span><br><span class="line">    <span class="comment">// val设置成迭代器，这样erase的删除时间复杂度减到O(1)</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.count(key) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = (*mp[key]).second;</span><br><span class="line">            <span class="comment">// 更新访问元素在队列中的位置</span></span><br><span class="line">            l.erase(mp[key]);</span><br><span class="line">            l.push_front(make_pair(key, res));</span><br><span class="line">            mp[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.count(key) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l.erase(mp[key]);</span><br><span class="line">            l.push_front(make_pair(key, value));</span><br><span class="line">            mp[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l.<span class="built_in">size</span>() == cap)</span><br><span class="line">            &#123;</span><br><span class="line">                mp.erase(l.back().first);</span><br><span class="line">                l.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            l.push_front(make_pair(key, value));</span><br><span class="line">            mp[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="缺失数字"><a href="#缺失数字" class="headerlink" title="缺失数字"></a>缺失数字</h2><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p>
<p>将nums中所有数字加一遍，再把[0,n]所有数加一遍，相差的绝对值为结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            sum += (nums[i] - i);</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">题目链接</a></p>
<p>状态方程+树形dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">status</span> &#123;</span></span><br><span class="line">    <span class="comment">// a root放摄像，全部摄像头 </span></span><br><span class="line">    <span class="comment">// b root不一定放摄像，全部摄像头</span></span><br><span class="line">    <span class="comment">// c 覆盖两颗子树总摄像头(无论root是否被监控)</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">status <span class="title">dfs</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!r) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">10000</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [la, lb, lc] = dfs(r-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> [ra, rb, rc] = dfs(r-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> a = lc + rc + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">min</span>(a, <span class="built_in">min</span>(la + rb, lb + ra));</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">min</span>(a, lb + rb);</span><br><span class="line">        <span class="keyword">return</span> &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> [a, b, c] = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记VII</title>
    <url>/2020/10/05/Leetcode%E6%97%A5%E8%AE%B0VII/</url>
    <content><![CDATA[<p>Leetcode日记VII，计划主要磕dp。</p>
<a id="more"></a>

<h1 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h1><h2 id="树中距离之和"><a href="#树中距离之和" class="headerlink" title="树中距离之和"></a>树中距离之和</h2><p>给定一个无向、连通的树。树中有 <code>N</code> 个标记为 <code>0...N-1</code> 的节点以及 <code>N-1</code> 条边 。</p>
<p>第 <code>i</code> 条边连接节点 <code>edges[i][0]</code> 和 <code>edges[i][1]</code> 。</p>
<p>返回一个表示节点 <code>i</code> 与其他所有节点距离之和的列表 <code>ans</code>。</p>
<p>标记为<code>0</code>的节点默认为整个树的根节点。</p>
<p><a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/solution/shou-hua-tu-jie-shu-zhong-ju-chi-zhi-he-shu-xing-d/" target="_blank" rel="noopener">树形dp超易懂题解</a></p>
<p>一次后序遍历得到子树中节点的距离之和</p>
<p>再利用根节点的正确性向下递推前序遍历得到答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nodeNum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans, <span class="keyword">int</span> cur, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 后序遍历构造nodeNum和第一次ans</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;child : graph[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == parent) <span class="keyword">continue</span>; <span class="comment">// 防止两个节点无限重复访问</span></span><br><span class="line">            postorder(nodeNum, ans, child, cur); <span class="comment">// child 变为 cur  cur 变为 parent</span></span><br><span class="line">            nodeNum[cur] += nodeNum[child];</span><br><span class="line">            ans[cur] += (ans[child] + nodeNum[child]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nodeNum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans, <span class="keyword">int</span> cur, <span class="keyword">int</span> N, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前序遍历并根据根节点向下递推获得答案</span></span><br><span class="line">        <span class="comment">// 递推公式：ans[i] = ans[root] - (nodeNum[i]) + (N - nodeNum[i])</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;child : graph[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == parent) <span class="keyword">continue</span>;</span><br><span class="line">            ans[child] = ans[cur] + N - <span class="number">2</span> * nodeNum[child];</span><br><span class="line">            preorder(nodeNum, ans, child, N, cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sumOfDistancesInTree</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次代表第i个节点到子树距离和</span></span><br><span class="line">        <span class="comment">// 第二次代表第i个节点到所有节点距离和（即答案）</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nodeNum</span><span class="params">(N, <span class="number">1</span>)</span></span>; <span class="comment">// 代表第i个节点的子节点数量</span></span><br><span class="line">        graph.resize(N);</span><br><span class="line">        <span class="comment">// 构造邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;edge : edges) &#123;</span><br><span class="line">            graph[edge[<span class="number">0</span>]].emplace_back(edge[<span class="number">1</span>]);</span><br><span class="line">            graph[edge[<span class="number">1</span>]].emplace_back(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(nodeNum, ans, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        preorder(nodeNum, ans, <span class="number">0</span>, N, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<h3 id="回溯（超时）"><a href="#回溯（超时）" class="headerlink" title="回溯（超时）"></a>回溯（超时）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> cur, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == target || valid) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start == nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur + nums[i] &lt;= target) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; cur &lt;&lt; "+" &lt;&lt; nums[i] &lt;&lt; "=" &lt;&lt; cur + nums[i] &lt;&lt; endl;</span></span><br><span class="line">                helper(nums, i + <span class="number">1</span>, cur + nums[i], target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;num : nums) sum += num;</span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            helper(nums, i, <span class="number">0</span>, target);</span><br><span class="line">            <span class="keyword">if</span> (valid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二维dp"><a href="#二维dp" class="headerlink" title="二维dp"></a>二维dp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> Max = *max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (Max &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Max == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dp[len][target + <span class="number">1</span>]; <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 赋初值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;<span class="comment">// 对应[0, i]数的选择</span></span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; ++j) &#123; <span class="comment">// 调试对应目标值下的bool</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= num) &#123; <span class="comment">// 如果此时选择的目标比当前数要大</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - num]; <span class="comment">// 不选这个数或者选这个数（那么对于前[0,i-1]只需要满足j-num的target即可）</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="一维dp（滚动数组优化）"><a href="#一维dp（滚动数组优化）" class="headerlink" title="一维dp（滚动数组优化）"></a>一维dp（滚动数组优化）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> Max = *max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (Max &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Max == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dp[target + <span class="number">1</span>]; <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;<span class="comment">// 对应[0, i]数的选择</span></span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= num; --j) &#123; <span class="comment">// 这里倒序的原因和背包II一样</span></span><br><span class="line">                dp[j] |= dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="买卖股票专题"><a href="#买卖股票专题" class="headerlink" title="买卖股票专题"></a>买卖股票专题</h2><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121 买卖股票的最佳时机"></a>121 买卖股票的最佳时机</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>要求只能买卖一次</p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>维护一个当前最小的数和当前最大的差值</p>
<p><strong>最优化证明</strong></p>
<p>证明：当$prices[j] - prices[i]$最小，易得不存在一个$k &lt; i$，使得$prices[k] &lt; prices[i]$，因此$prices[i]$就是$[0, i]$区间的最小值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minBuy = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> maxPro = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            minBuy = (prices[i] &lt; minBuy) ? prices[i] : minBuy;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                maxPro = <span class="built_in">max</span>(maxPro, prices[i] - minBuy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122 买卖股票的最佳时机II"></a>122 买卖股票的最佳时机II</h3><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><p>允许买卖多次</p>
<h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[len][<span class="number">2</span>]; <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>滚动数组优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy, sel;</span><br><span class="line">        buy = -prices[<span class="number">0</span>];</span><br><span class="line">        sel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy = <span class="built_in">max</span>(sel - prices[i], buy);</span><br><span class="line">            sel = <span class="built_in">max</span>(buy + prices[i], sel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="123-买卖股票的最佳时机III"><a href="#123-买卖股票的最佳时机III" class="headerlink" title="123 买卖股票的最佳时机III"></a>123 买卖股票的最佳时机III</h3><h4 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h4><p>最多交易两次</p>
<h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h4><p>个人解法（错误）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">3</span>][len]; <span class="comment">// 1维：0买入/1卖出 2维：0次、1次、2次（买入/卖出） 3维：股票在第i天情况</span></span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 第0天买入第1次为-prices[0]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="comment">// 第1次买入 -&gt; 第1次买入，第0次卖出</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][i] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">0</span>][i - <span class="number">1</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 第1次卖出 -&gt; 第1次卖出，第1次买入 + price</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>][i] = <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>][i - <span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 第2次买入 -&gt; 第2次买入，第1次卖出 - price </span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">2</span>][i] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">2</span>][i - <span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">1</span>][i - <span class="number">1</span>] - prices[i]); </span><br><span class="line">            <span class="comment">// 第2次卖出 -&gt; 第2次卖出，第2次买入</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>][i] = <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">2</span>][i - <span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">2</span>][i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>][len - <span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">2</span>][len - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>错误原因：将第二次买入的设置的初值为0，导致$i = 1$时的过程就将第二次卖出的状态值更新为$prices[i]$（实际上第1天根本无法第二次卖出股票）</p>
<p>修正：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">3</span>][len];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][i] = -prices[i];</span><br><span class="line">            <span class="comment">// 第1次买入 -&gt; 第1次买入，第0次卖出</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][i] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">0</span>][i - <span class="number">1</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 第1次卖出 -&gt; 第1次卖出，第1次买入 + price</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>][i] = <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>][i - <span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 第2次买入 -&gt; 第2次买入，第1次卖出 - price </span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">2</span>][i] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">2</span>][i - <span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">1</span>][i - <span class="number">1</span>] - prices[i]); </span><br><span class="line">            <span class="comment">// 第2次卖出 -&gt; 第2次卖出，第2次买入</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>][i] = <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">2</span>][i - <span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">2</span>][i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>][len - <span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">2</span>][len - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>滚动数组优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t_01 = dp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> t_11 = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> t_02 = dp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 第1次买入 -&gt; 第1次买入，第0次卖出</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">max</span>(t_01, -prices[i]);</span><br><span class="line">            <span class="comment">// 第1次卖出 -&gt; 第1次卖出，第1次买入 + price</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(t_11, t_01 + prices[i]);</span><br><span class="line">            <span class="comment">// 第2次买入 -&gt; 第2次买入，第1次卖出 - price </span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="built_in">max</span>(t_02, t_11 - prices[i]); </span><br><span class="line">            <span class="comment">// 第2次卖出 -&gt; 第2次卖出，第2次买入</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">2</span>], t_02 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="188-买卖股票的最佳时机IV"><a href="#188-买卖股票的最佳时机IV" class="headerlink" title="188 买卖股票的最佳时机IV"></a>188 买卖股票的最佳时机IV</h3><h4 id="要求-3"><a href="#要求-3" class="headerlink" title="要求"></a>要求</h4><p>最多交易k次</p>
<h4 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h4><p>分类讨论</p>
<ul>
<li>当$k &gt; \frac{n} {2}$，此时原问题转换为122（因为此时$k$的限定相当于允许多次交易）</li>
<li>else，采用本题的解法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfitHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = -prices[<span class="number">0</span>], sel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            buy = <span class="built_in">max</span>(buy, sel - prices[i]);</span><br><span class="line">            sel = <span class="built_in">max</span>(sel, buy + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; n / <span class="number">2</span>) <span class="keyword">return</span> maxProfitHelper(prices);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dp[n][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) dp[<span class="number">0</span>][i][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) res = <span class="built_in">max</span>(dp[n - <span class="number">1</span>][i][<span class="number">1</span>], res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>滚动数组优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfitHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将原问题转换为II</span></span><br><span class="line">        <span class="keyword">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = -prices[<span class="number">0</span>], sel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            buy = <span class="built_in">max</span>(buy, sel - prices[i]);</span><br><span class="line">            sel = <span class="built_in">max</span>(sel, buy + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; n / <span class="number">2</span>) <span class="keyword">return</span> maxProfitHelper(prices);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dp[k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) dp[i][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">                dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j][<span class="number">1</span>], dp[j][<span class="number">0</span>] + prices[i]);</span><br><span class="line">                dp[j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j][<span class="number">0</span>], dp[j - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) res = <span class="built_in">max</span>(dp[i][<span class="number">1</span>], res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714 买卖股票的最佳时机含手续费"></a>714 买卖股票的最佳时机含手续费</h3><h4 id="要求-4"><a href="#要求-4" class="headerlink" title="要求"></a>要求</h4><p>含手续费fee</p>
<h4 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[len][<span class="number">2</span>]; <span class="comment">// dp[i][0]代表第i天为买入状态的最大利润 dp[i][1]代表第i天为卖出状态的最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 卖出的时候才交手续费</span></span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee, dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="308-最佳买卖股票时机含冷冻期"><a href="#308-最佳买卖股票时机含冷冻期" class="headerlink" title="308 最佳买卖股票时机含冷冻期"></a>308 最佳买卖股票时机含冷冻期</h3><h4 id="要求-5"><a href="#要求-5" class="headerlink" title="要求"></a>要求</h4><p>每次卖完股票后有一天的冷冻期</p>
<h4 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// f[i][0]代表目前持有一支股票</span></span><br><span class="line">    <span class="comment">// f[i][1]代表第i天结束后，位于冷冻期</span></span><br><span class="line">    <span class="comment">// f[i][2]代表当前不持股，也不位于冷冻期</span></span><br><span class="line">    <span class="keyword">if</span>(pricesSize==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[pricesSize][<span class="number">3</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; pricesSize; i++)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = fmax(f[i<span class="number">-1</span>][<span class="number">0</span>], f[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">        f[i][<span class="number">2</span>] = fmax(f[i<span class="number">-1</span>][<span class="number">2</span>], f[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmax(f[pricesSize<span class="number">-1</span>][<span class="number">1</span>],f[pricesSize<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>滚动数组优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = -prices[<span class="number">0</span>], sel = <span class="number">0</span>, fre = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sel = <span class="built_in">max</span>(sel, fre);</span><br><span class="line">            fre = buy + prices[i];</span><br><span class="line">            buy = <span class="built_in">max</span>(buy, sel - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(fre, sel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="视频拼接"><a href="#视频拼接" class="headerlink" title="视频拼接"></a>视频拼接</h2><p><a href="https://leetcode-cn.com/problems/video-stitching/" target="_blank" rel="noopener">题目链接</a></p>
<p>计算顺序为顺序，边界条件是当前指针i是否处于当前遍历到的clip的区间内。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(T + <span class="number">1</span>, T + <span class="number">1</span>)</span></span>; dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= T; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;clip : clips) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clip[<span class="number">0</span>] &lt;= i &amp;&amp; clip[<span class="number">1</span>] &gt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[clip[<span class="number">0</span>]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[T] == T + <span class="number">1</span>) ? <span class="number">-1</span> : dp[T];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="K个逆序对数组"><a href="#K个逆序对数组" class="headerlink" title="K个逆序对数组"></a>K个逆序对数组</h2><p>给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。</p>
<p>逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i &lt; j且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。</p>
<p>由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。</p>
<p>思路：<a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/solution/jie-jue-dpwen-ti-de-chang-yong-tao-lu-zhuan-yi-fan/" target="_blank" rel="noopener">参考题解</a></p>
<p>用依次插入的方式考虑，得到公式，将公式转换变量联立，得到dp的递推公式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kInversePairs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                dp[i][j] = (dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">                    dp[i][j] = ((dp[i][j] - dp[i - <span class="number">1</span>][j - i]) % mod + mod) % mod; <span class="comment">// 对于减法有可能答案是负数取余加上mod再取余数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p><a href="https://leetcode-cn.com/problems/distinct-subsequences/solution/shou-hua-tu-jie-xiang-jie-liang-chong-ji-4r2y/" target="_blank" rel="noopener">参考题解</a></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>就是将问题简单的分而治之。超时严重</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subProblems</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="built_in">string</span> &amp;t, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// string t matching one sign</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> subProblems(s, t, i - <span class="number">1</span>, j) + subProblems(s, t, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> subProblems(s, t, i - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.<span class="built_in">size</span>(), tLen = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> subProblems(s, t, sLen - <span class="number">1</span>, tLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> memo[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subProblems</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="built_in">string</span> &amp;t, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// string t matching one sign</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            memo[i][j] = subProblems(s, t, i - <span class="number">1</span>, j) + subProblems(s, t, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memo[i][j] = subProblems(s, t, i - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.<span class="built_in">size</span>(), tLen = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> subProblems(s, t, sLen - <span class="number">1</span>, tLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="dp-1"><a href="#dp-1" class="headerlink" title="dp"></a>dp</h3><p>根据记忆化搜索的逻辑直接转为dp。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.<span class="built_in">size</span>(), tLen = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">long</span> dp[sLen + <span class="number">1</span>][tLen + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= tLen; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sLen][tLen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="不同的子序列II"><a href="#不同的子序列II" class="headerlink" title="不同的子序列II"></a>不同的子序列II</h2><p>给定一个字符串 <code>S</code>，计算 <code>S</code> 的不同非空子序列的个数。</p>
<p>因为结果可能很大，所以<strong>返回答案模</strong> <strong><code>10^9 + 7</code></strong>.</p>
<p><a href="https://leetcode-cn.com/problems/distinct-subsequences-ii/solution/c-python3-dp-mei-tian-jia-yi-ge-dian-ta-lgl9p/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distinctSubseqII</span><span class="params">(<span class="built_in">string</span> S)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));      <span class="comment">//虚指 S的前i个，有多少种情况</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;                                      <span class="comment">//S的第-1个元素，就是空“”，也是一种情况</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; last_appear_idx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = S[i];</span><br><span class="line">            dp[i + <span class="number">1</span>] = dp[i] * <span class="number">2</span>;                        <span class="comment">//前面原有的是一份， 加上我又是一份</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (last_appear_idx.count(c) != <span class="number">0</span>)          <span class="comment">//如果前面自己出现过一次</span></span><br><span class="line">                dp[i + <span class="number">1</span>] -= dp[last_appear_idx[c]];    <span class="comment">//减掉自己在前面的贡献值</span></span><br><span class="line">            </span><br><span class="line">            dp[i + <span class="number">1</span>] %= <span class="number">1000000007</span>;</span><br><span class="line">            last_appear_idx[c] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[n] - <span class="number">1</span> &lt; <span class="number">0</span>)                   <span class="comment">//中途取余，可能会导致大的反而小了，做差会出现负</span></span><br><span class="line">            dp[n] += <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (dp[n] - <span class="number">1</span>) % <span class="number">1000000007</span>;                <span class="comment">//前面的计算，都把空“”算进去了</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：<span class="number">849061136</span></span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/distinct-subsequences-ii/solution/c-python3-dp-mei-tian-jia-yi-ge-dian-ta-lgl9p/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="1349-参加考试的最大学生数"><a href="#1349-参加考试的最大学生数" class="headerlink" title="1349. 参加考试的最大学生数"></a><a href="https://leetcode-cn.com/problems/maximum-students-taking-exam/" target="_blank" rel="noopener">1349. 参加考试的最大学生数</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxStudents</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = seats.<span class="built_in">size</span>(), n = seats[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; n))</span></span>; <span class="comment">// [行数][所有可能状态数]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= m; ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); ++state) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">bitset</span>&lt;8&gt; <span class="title">bs</span><span class="params">(state)</span></span>; <span class="comment">// 十进制转二进制bit位</span></span><br><span class="line">                <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 对于每一个状态，首先看该状态 对应的人坐在了坏椅子上 或者 含有相邻座位</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( (bs[col] &amp;&amp; seats[row - <span class="number">1</span>][col] == <span class="string">'#'</span>) || (col &lt; n - <span class="number">1</span> &amp;&amp; bs[col] &amp;&amp; bs[col + <span class="number">1</span>]) ) &#123;</span><br><span class="line">                        ok = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">                    dp[row][state] = <span class="number">-1</span>; <span class="comment">// 将该行该状态不行保存下来</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 本行状态满足要求，再check上一行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> lastRowState = <span class="number">0</span>; lastRowState &lt; (<span class="number">1</span> &lt;&lt; n); ++lastRowState) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[row - <span class="number">1</span>][lastRowState] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="function"><span class="built_in">bitset</span>&lt;8&gt; <span class="title">lastbs</span><span class="params">(lastRowState)</span></span>;</span><br><span class="line">                    <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 排除上一行和这一行有对角线坐人的不合法情况</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">                        <span class="comment">// 上一行坐人的位置在本行的 左上 或 右上 的情况</span></span><br><span class="line">                        <span class="keyword">if</span> (lastbs[col] &amp;&amp; ((col &gt; <span class="number">0</span> &amp;&amp; bs[col - <span class="number">1</span>]) || col &lt; n - <span class="number">1</span> &amp;&amp; bs[col + <span class="number">1</span>])) &#123;</span><br><span class="line">                            ok = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                        <span class="comment">// 该状态合法，可以进行状态转移</span></span><br><span class="line">                        dp[row][state] = <span class="built_in">max</span>(dp[row][state], dp[row - <span class="number">1</span>][lastRowState] + (<span class="keyword">int</span>)bs.count());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++s) ans = <span class="built_in">max</span>(ans, dp[m][s]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/maximum-students-taking-exam/solution/xiang-jie-ya-suo-zhuang-tai-dong-tai-gui-hua-jie-f/" target="_blank" rel="noopener">参考题解</a></p>
<p>以上的代码还可以进行如下改进：</p>
<ul>
<li><p>枚举状态时，只讨论当前座位的分布的子集（例如：座位为[0, 1, 0, 1, 0]，那么坐人的情况只有四种[0, 1, 0, 1, 0]，[0, 0, 0, 1, 0]，[0, 1, 0, 0, 0]，[0, 0, 0, 0, 0]，可以省掉很多操作）</p>
</li>
<li><p>在判断同一行是否有相邻坐学生和上一行与该行之间有没有对角线相邻坐学生的代码还可以简化成<strong>state左移一位与state不等于0或者state右移一位与state不等于0</strong></p>
</li>
<li><p>获取1的数目方法：<code>cnt = __builtin_popcount(state)</code></p>
</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/maximum-students-taking-exam/solution/c4msya-zhuang-dp-by-monologue-s-c81x/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxStudents</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = seats.<span class="built_in">size</span>(), m = seats[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; m))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c: seats[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">'.'</span>) state = state &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> state &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t = state; t; t = (t - <span class="number">1</span>) &amp; state)&#123; <span class="comment">// 枚举二进制子集</span></span><br><span class="line">                <span class="keyword">if</span>(t &amp; (t &lt;&lt; <span class="number">1</span>) || t &amp; (t &gt;&gt; <span class="number">1</span>)) <span class="keyword">continue</span>; <span class="comment">// 删除不合法</span></span><br><span class="line">                <span class="keyword">int</span> cnt = __builtin_popcount(t); <span class="comment">// 记录本行学生人数</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; m); ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(t &amp; (j &lt;&lt; <span class="number">1</span>) || t &amp; (j &gt;&gt; <span class="number">1</span>)) <span class="keyword">continue</span>; <span class="comment">// 删除不合法</span></span><br><span class="line">                    dp[i][t] = <span class="built_in">max</span>(dp[i][t], dp[i - <span class="number">1</span>][j] + cnt); <span class="comment">// 用上一行答案更新本行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于当前行不坐学生，答案是上一行的最大值</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = *max_element(dp[i - <span class="number">1</span>].<span class="built_in">begin</span>(), dp[i - <span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.back().<span class="built_in">begin</span>(), dp.back().<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：Monologue-S</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/maximum-students-taking-exam/solution/c4msya-zhuang-dp-by-monologue-s-c81x/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT总结</title>
    <url>/2021/02/24/PAT%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>将之前做过的PAT题目进行总结和复习。</p>
<a id="more"></a>

<h1 id="题目分类"><a href="#题目分类" class="headerlink" title="题目分类"></a>题目分类</h1><h2 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><p>可以用STL系列<br>栈：1051<br>堆：1098<br>队列：1014、1056<br>链表：1032、1052、1074、1097、1133<br>并查集：1107、1114、1118<br>树状数组：1057<br>树：1004、1053、1079、1090、1094、1102、1106<br>二叉树：1020、1043、1064、1066、1086、1099、1110、1115、1119、1127、1135、1147、1151、1155</p>
<h2 id="2、基础算法"><a href="#2、基础算法" class="headerlink" title="2、基础算法"></a>2、基础算法</h2><p>复习一下基础系列<br>模拟：1002、1009、1017、1026、1042、1046、1065、1105、1153<br>排序：1012、1016、1025、1028、1055、1062、1075、1080、1083、1113、1125、1141<br>字符串处理：1001、1005、1023、1024、1035、1060、1061、1073、1077、1082、1108、1140、1150、1152<br>二分查找：1010、1044、1085<br>查找元素：1006、1011、1036<br>分数模拟：1081、1088<br>贪心：1033、1037、1038、1067、1070</p>
<h2 id="3、图论相关"><a href="#3、图论相关" class="headerlink" title="3、图论相关"></a>3、图论相关</h2><p>多背一背模板系列<br>最短路径：1003、1018、1030、1072、1087、1111<br>深度优先搜索DFS：1013、1021、1034、1103、1130、1131、1134<br>广度优先搜索BFS：1076、1091<br>记忆化搜索：1007、1040、1045、1068、1101<br>其他的图论：1123、1126、1142<br>拓扑排序：1146</p>
<h1 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h1><p>1001 两数相加，转为数字逗号形式(字符串加法)</p>
<p>1002 两多项式相加(模拟)</p>
<p>1003 无向图得到最短路径数(DFS)</p>
<p>1004 get二叉树最多结点层数(BFS)</p>
<p>1005 数位总和转英文读法</p>
<p>1006 根据进出办公室时间判断开锁锁门人(排序)</p>
<p>1007 最大子数组和(双指针)</p>
<p>1008 模拟电梯</p>
<p>1009 多项式相乘(模拟)</p>
<p>1010</p>
<p>1011 赌球(贪心)</p>
<p>1012 根据四种成绩排序</p>
<p>1013 毁灭城市，断其边，为了团结修路(并查集)</p>
<p>1014 银行排队问题(模拟时间)</p>
<p>1015 将给的十进制数短除法得到对应进制数，将其翻转后问其数值是否为素数</p>
<p>1016 </p>
<p>1017</p>
<p>1018 公共自行车系统(DFS / Dijkstra + DFS)</p>
<p>1019 对应进制数转换后判断回文</p>
<p>1020 中序后序转层序前序</p>
<p>1021 找最深的节点(并查集+DFS)</p>
<p>1022 数字博物馆(排序)</p>
<p>1023 模拟乘2</p>
<p>1024 模拟迭代加法后判断回文</p>
<p>1025 PAT排名(排序，编号，处理并列情况)</p>
<p>1026 </p>
<p>1027 十三进制转十六进制</p>
<p>1028 表格排序</p>
<p>1029 两个序列组合后的中位数(归并排序)</p>
<p>1030 最小cost路径(DFS)</p>
<p>1031 “U”字形打印</p>
<p>1032 找链表的共有节点</p>
<p><strong>1033 一条路走到头，在哪加油？(贪心模拟)</strong></p>
<p>1034 土匪头子(并查集+结构体整合信息)</p>
<p>1035 字符串转换</p>
<p>1036 </p>
<p>…</p>
<h1 id="近年真题"><a href="#近年真题" class="headerlink" title="近年真题"></a>近年真题</h1><h2 id="2020秋"><a href="#2020秋" class="headerlink" title="2020秋"></a>2020秋</h2><ol>
<li>奶牛喝奶<ul>
<li>正向扫一遍，反向扫一遍，取最大</li>
</ul>
</li>
<li>子数组的连续和小于m<ul>
<li>前缀和后暴力搜索（也可以采用树状数组，不过这题数据量不大）</li>
</ul>
</li>
<li>二叉树的左视图<ul>
<li>中序前序结合建立二叉树</li>
<li>二叉树层序遍历的左节点</li>
</ul>
</li>
<li><strong>有向图中以每个节点为起点的双标尺迪杰斯特拉算法</strong></li>
</ol>
<h2 id="2020春"><a href="#2020春" class="headerlink" title="2020春"></a>2020春</h2><ol>
<li>暴力+素数判断</li>
<li>理解题意后，hash存储出现过的节点，暴力判断是否来自于前面的节点</li>
<li>相邻节点不能存储同类种族，dfs判断</li>
<li>置换选择算法<ul>
<li>优先级队列维护当前待排的元素</li>
<li>不断将当前队列中的最小元素出栈（只要它大于之前置换出去的元素）。当此次队列中不存在元素后，统计当前的出栈序列输出换行，迭代向下进行。</li>
</ul>
</li>
</ol>
<h2 id="2019冬"><a href="#2019冬" class="headerlink" title="2019冬"></a>2019冬</h2><ol>
<li>格式化输入格式化输出</li>
<li>将链表每k个置换一次，PAT经典链表题</li>
<li>数据量不大，和之前判断cluster那题的题意一模一样</li>
<li>已知中序序列和最小堆的条件，求层序遍历。</li>
</ol>
<h2 id="2019秋"><a href="#2019秋" class="headerlink" title="2019秋"></a>2019秋</h2><ol start="2">
<li><p>链表合并</p>
</li>
<li><p>算符树的遍历</p>
</li>
<li><p>迪杰斯特拉序列的检验</p>
<ul>
<li>求得迪杰斯特拉的最短路径后，读取输入序列，若对应的dis数组非降序排列则为yes，反之为false。</li>
</ul>
</li>
</ol>
<h2 id="2019春"><a href="#2019春" class="headerlink" title="2019春"></a>2019春</h2><ol>
<li><p>无脑素数</p>
</li>
<li><p>字符串排序类问题，map存储字符串出没出现过，并将所有来宾中的字符串进行生日排序，生日排序按照先年份后月份日子来排。</p>
</li>
<li><p>图论</p>
<ol>
<li><p>题意</p>
<ul>
<li><p>电信诈骗嫌疑犯的定义是，在一天之中给不同的人短通信超过了k次，且不超过五分之一的人会回复。</p>
</li>
<li><p>如果两个嫌疑人进行过通话，那么都是同伙</p>
</li>
<li><p>短电话的定义为通信时间不超过五分钟。</p>
</li>
</ul>
</li>
<li><p>解法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存储方式：</span><br><span class="line">邻接表</span><br><span class="line">	存储了每个人的连通点</span><br><span class="line">	用来遍历图</span><br><span class="line">邻接矩阵 </span><br><span class="line">	每个被存储的节点包含的信息为短通信的次数</span><br><span class="line">	用来以常数时间访问到两个人之间是否进行通信</span><br><span class="line">vis</span><br><span class="line">	用来存储两个人之间的通话是否已经记录防止重复</span><br><span class="line">并查集</span><br><span class="line">	方便归类</span><br><span class="line">	</span><br><span class="line">对每一个人，我们枚举它的连通点，对每一个连通点，通过邻接矩阵得到它的短通信次数，只要非零，那么就对应的cnt+1，最后统计它的诈骗通话比例是否达到0.8，若达到则加入嫌疑人数组。</span><br><span class="line"></span><br><span class="line">最后，暴力枚举每两个嫌疑人，之间如果有过通话，则纳入同一个集合。最后处理并查集即可。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>中序和后序建树，对每个问题遍历就行了。</p>
</li>
</ol>
<h1 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h1><h2 id="1-二叉树变通题"><a href="#1-二叉树变通题" class="headerlink" title="1. 二叉树变通题"></a>1. 二叉树变通题</h2><h3 id="1-0-基础术语"><a href="#1-0-基础术语" class="headerlink" title="1.0 基础术语"></a>1.0 基础术语</h3><table>
<thead>
<tr>
<th>简称</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>CBT</td>
<td>完全二叉树</td>
</tr>
<tr>
<td>FBT</td>
<td>满二叉树（国内的表示特殊的完全二叉树）</td>
</tr>
<tr>
<td>BST</td>
<td>二叉搜索树</td>
</tr>
<tr>
<td>AVL</td>
<td>平衡二叉搜索树</td>
</tr>
</tbody></table>
<h3 id="1-1-已知前序中序转后序"><a href="#1-1-已知前序中序转后序" class="headerlink" title="1.1 已知前序中序转后序"></a>1.1 已知前序中序转后序</h3><p>出自1138</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> ps, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is &lt;= ie) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = is;</span><br><span class="line">        <span class="keyword">while</span> (inorder[idx] != preorder[ps]) idx++;</span><br><span class="line">        postorder(ps + <span class="number">1</span>, is, idx - <span class="number">1</span>);</span><br><span class="line">        postorder(ps + <span class="number">1</span> + idx - is, idx + <span class="number">1</span>, ie);</span><br><span class="line">        post.push_back(preorder[ps]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-最近公共祖先"><a href="#1-2-最近公共祖先" class="headerlink" title="1.2 最近公共祖先"></a>1.2 最近公共祖先</h3><h4 id="1-2-1-已知BST的前序"><a href="#1-2-1-已知BST的前序" class="headerlink" title="1.2.1 已知BST的前序"></a>1.2.1 已知BST的前序</h4><p>出自1143</p>
<p>前序遍历永远优先访问到根节点，所以在BST中，两个结点u、v的最近祖先一定是<strong>第一个</strong>数值位于u和v中间的结点（画树的图看中序遍历可知）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line"><span class="keyword">int</span> anc;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    anc = pre[i];</span><br><span class="line">    <span class="keyword">if</span> (anc &lt;= u &amp;&amp; anc &gt;= v || anc &lt;= v &amp;&amp; anc &gt;= u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-已知二叉树的中序和后序"><a href="#1-2-2-已知二叉树的中序和后序" class="headerlink" title="1.2.2 已知二叉树的中序和后序"></a>1.2.2 已知二叉树的中序和后序</h4><p>出自1151</p>
<p>分析：和1.2.1的不同在于不是二叉搜索树了，所以需要将中序遍历的每一个元素<code>in[i]</code>利用哈希表与其索引<code>i</code>进行绑定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos; <span class="comment">// in[i] -&gt; i</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line"><span class="keyword">int</span> anc, apos;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    anc = pre[i];</span><br><span class="line">    apos = pos[anc];</span><br><span class="line">    <span class="keyword">int</span> posu = pos[u], posv = pos[v];</span><br><span class="line">    <span class="keyword">if</span> (apos &lt;= posu &amp;&amp; apos &gt;= posv || apos &gt;= posu &amp;&amp; apos &lt;= posv) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-已知层序遍历求三序遍历（保证输入是CBT）"><a href="#1-3-已知层序遍历求三序遍历（保证输入是CBT）" class="headerlink" title="1.3 已知层序遍历求三序遍历（保证输入是CBT）"></a>1.3 已知层序遍历求三序遍历（保证输入是CBT）</h3><p>出自1147</p>
<p>以后序遍历为例，设计虚拟索引：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    postorder(idx * <span class="number">2</span>);</span><br><span class="line">    postorder(idx * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    ans.push_back(a[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-已知层序遍历数组判断堆的性质"><a href="#1-4-已知层序遍历数组判断堆的性质" class="headerlink" title="1.4 已知层序遍历数组判断堆的性质"></a>1.4 已知层序遍历数组判断堆的性质</h3><p>出自1147</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxn = <span class="number">1</span>, minn = <span class="number">1</span>; <span class="comment">// 大顶堆和小顶堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; a[i / <span class="number">2</span>]) maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; a[i / <span class="number">2</span>]) minn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxn == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Max Heap"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (minn == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Min Heap"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Not Heap"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-5-构建BST树"><a href="#1-5-构建BST树" class="headerlink" title="1.5 构建BST树"></a>1.5 构建BST树</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-已知前序和后序求中序"><a href="#1-6-已知前序和后序求中序" class="headerlink" title="1.6 已知前序和后序求中序"></a>1.6 已知前序和后序求中序</h3><p>出自1119</p>
<p>得到的二叉树可能唯一也可能不唯一。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> unq = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getIn</span><span class="params">(<span class="keyword">int</span> prl, <span class="keyword">int</span> prr, <span class="keyword">int</span> pol, <span class="keyword">int</span> por)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prl == prr) &#123;</span><br><span class="line">        in.push_back(pre[prr]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span> (pre[prl] == post[por]) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = prl + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= prr &amp;&amp; pre[i] != post[por - <span class="number">1</span>]) ++i; <span class="comment">// i指向前序中与后序的倒数第二个相等的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i - prl &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            len = i - <span class="number">1</span> - prl;</span><br><span class="line">            getIn(prl + <span class="number">1</span>, i - <span class="number">1</span>, pol, pol + len - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unq = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        in.push_back(post[por]);</span><br><span class="line">        getIn(i, prr, pol + len, por - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-7-构建AVL树"><a href="#1-7-构建AVL树" class="headerlink" title="1.7 构建AVL树"></a>1.7 构建AVL树</h3><h4 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TreeNode *root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">    root = insert(root, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构建AVL树和基本四操作"><a href="#构建AVL树和基本四操作" class="headerlink" title="构建AVL树和基本四操作"></a>构建AVL树和基本四操作</h4><p>不同的是中间要加入是否AVL的判定和可能的修改。</p>
<p>当新添加的结点在左子树：</p>
<ul>
<li><p>如果不平衡了</p>
<ul>
<li>当新值小于根节点左子树的值（LL型），右单旋</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">   /</span></span><br><span class="line"><span class="comment">  2      -&gt;    2</span></span><br><span class="line"><span class="comment"> /            / \</span></span><br><span class="line"><span class="comment">1            1   3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">rightRotate</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    TreeNode *tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left = tmp-&gt;right;</span><br><span class="line">    tmp-&gt;right = root;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当新值大于等于根节点左子树的值（LR型），左右旋</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  3             3        </span></span><br><span class="line"><span class="comment"> /             /</span></span><br><span class="line"><span class="comment">1     -&gt;      2     -&gt;      2</span></span><br><span class="line"><span class="comment"> \           /             / \</span></span><br><span class="line"><span class="comment">  2         1             1   3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">leftRight</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;left = leftRotate(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当新添加的结点在右子树：</p>
<ul>
<li><p>如果不平衡了：</p>
<ul>
<li>当新值大于根节点右子树的值（RR型），左单旋</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">leftRotate</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    TreeNode *tmp = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = root;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当新值小于等于根节点右子树的值（RL型），右左旋</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rightLeft</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;right = rightRotate(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>插入算法逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">insert</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">int</span> ld = getDep(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rd = getDep(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (ld - rd &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; root-&gt;left-&gt;val) &#123;</span><br><span class="line">                root = rightRotate(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = leftRight(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">int</span> ld = getDep(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rd = getDep(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rd - ld &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; root-&gt;right-&gt;val) &#123;</span><br><span class="line">                root = leftRotate(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = rightLeft(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-8-已知前序和BST的条件求后序"><a href="#1-8-已知前序和BST的条件求后序" class="headerlink" title="1.8 已知前序和BST的条件求后序"></a>1.8 已知前序和BST的条件求后序</h3><p>出自1043</p>
<p><strong>注意：数组中可能有数值重复的元素！不能用前序中序转后序那套了</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpost</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root &gt; tail) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// i为右子树的前序遍历结果的头部</span></span><br><span class="line">    <span class="comment">// j为左子树的前序遍历结果的尾部</span></span><br><span class="line">    <span class="keyword">int</span> i = root + <span class="number">1</span>, j = tail;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= tail &amp;&amp; pre[root] &gt; pre[i]) ++i;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; root &amp;&amp; pre[root] &lt;= pre[j]) --j;</span><br><span class="line">    <span class="keyword">if</span> (i - j != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    getpost(root + <span class="number">1</span>, j);</span><br><span class="line">    getpost(i, tail);</span><br><span class="line">    post.push_back(pre[root]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-9-已知三序遍历和CBT条件（以中序遍历为例）求层序遍历"><a href="#1-9-已知三序遍历和CBT条件（以中序遍历为例）求层序遍历" class="headerlink" title="1.9 已知三序遍历和CBT条件（以中序遍历为例）求层序遍历"></a>1.9 已知三序遍历和CBT条件（以中序遍历为例）求层序遍历</h3><p>出自1064</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inorder(root * <span class="number">2</span>);</span><br><span class="line">        lev[root] = in[t++];</span><br><span class="line">        inorder(root * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inorder(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h3 id="1-10-红黑树定义"><a href="#1-10-红黑树定义" class="headerlink" title="1.10 红黑树定义"></a>1.10 红黑树定义</h3><ol>
<li>所有节点不是红色就是黑色</li>
<li>根节点是黑色</li>
<li>所有叶子节点也是黑色</li>
<li>如果一个节点是红色，那么它的两个孩子节点是黑色</li>
<li>对于每一个节点，它到每一个叶子节点路径上的黑色节点数量相同</li>
</ol>
<h2 id="2-图论"><a href="#2-图论" class="headerlink" title="2. 图论"></a>2. 图论</h2><h3 id="2-1-dfs"><a href="#2-1-dfs" class="headerlink" title="2.1 dfs"></a>2.1 dfs</h3><h4 id="01dfs"><a href="#01dfs" class="headerlink" title="01dfs"></a>01dfs</h4><p>从给定的序列中，选择特定的几个对象得到符合条件的答案。$n &lt; 100$</p>
<h4 id="可重复选择dfs"><a href="#可重复选择dfs" class="headerlink" title="可重复选择dfs"></a>可重复选择dfs</h4><p>在给定的序列中，可以重复选择的选定几个对象得到符合条件的答案。</p>
<h3 id="2-2-并查集"><a href="#2-2-并查集" class="headerlink" title="2.2 并查集"></a>2.2 并查集</h3><p>并查集在查找的时候，一定要用<code>find(x)</code>函数而不是直接<code>father[x]</code>因为路径压缩可能导致不正确的结果。</p>
<h3 id="2-3-dijkstra"><a href="#2-3-dijkstra" class="headerlink" title="2.3 dijkstra"></a>2.3 dijkstra</h3><h4 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dis[Start] = <span class="number">0</span>; <span class="comment">// 设定起点！！！！</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 在当前还未找到最短路径的顶点集中选取具有最短距离的顶点idx</span></span><br><span class="line">		minDis = maxWeight; <span class="comment">// 初始化最大权重</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ismin[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; minDis) &#123;</span><br><span class="line">				idx = j; <span class="comment">// 更新集合MST到外中最小距离的idx </span></span><br><span class="line">				minDis = dist[j]; <span class="comment">// 同时更新当前最小距离</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span> (minDis == maxWeight) <span class="keyword">return</span>; <span class="comment">// 如果没有路径，直接结束算法</span></span><br><span class="line">        ismin[idx] = <span class="number">1</span>; <span class="comment">// 将其纳入MST集合中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ismin[j] == <span class="number">0</span> &amp;&amp; graph[idx][j] &lt; maxWeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[u] + graph[idx][j] &lt; dist[j]) &#123; <span class="comment">// 第一标尺</span></span><br><span class="line">                    <span class="comment">// 针对那些不在MST但与MST连通的点中，尝试更新其当前最短路径，并同时更新其上一个结点的位置</span></span><br><span class="line">                    dist[j] = dist[idx] + graph[idx][j];</span><br><span class="line">                    path[j] = idx;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> () &#123; <span class="comment">// 第二标尺</span></span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变通"><a href="#变通" class="headerlink" title="变通"></a>变通</h4><ol>
<li>枚举每一个候选地点，不断更新最优解（1072 Gas Station）</li>
<li>Dijkstra + DFS，从a点到b点的最优路径类问题（1087 All Roads Lead To Rome）<ul>
<li>a到b可能有多条最优路径，path从一维数组变为<code>vector&lt;int&gt; path[n]</code>，此时的path就是一个地图，用dfs的方式从start走到end并在终点处判断哪个路径为最优解。</li>
</ul>
</li>
</ol>
<h3 id="2-4-BFS"><a href="#2-4-BFS" class="headerlink" title="2.4 BFS"></a>2.4 BFS</h3><p>涉及题型：连通块探索，a点到b点的最短路径，单源发散</p>
<h3 id="2-5-拓扑排序"><a href="#2-5-拓扑排序" class="headerlink" title="2.5 拓扑排序"></a>2.5 拓扑排序</h3><ol>
<li>构建邻接表结构和入度图</li>
<li>将当前入度为0的节点入栈，并在下一次循环中将其不断出栈（更新入度表），形成拓扑排序。</li>
</ol>
<p>拓扑排序的检验1146</p>
<h2 id="3-查找类型"><a href="#3-查找类型" class="headerlink" title="3. 查找类型"></a>3. 查找类型</h2><h3 id="3-1-hash探测"><a href="#3-1-hash探测" class="headerlink" title="3.1 hash探测"></a>3.1 hash探测</h3><h4 id="二次探测再散列"><a href="#二次探测再散列" class="headerlink" title="二次探测再散列"></a>二次探测再散列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ms; ++j) &#123;</span><br><span class="line">    <span class="keyword">int</span> pos = (a + j * j) % ms;</span><br><span class="line">    <span class="keyword">if</span> (hash[pos] == <span class="number">0</span>) &#123;</span><br><span class="line">        hash[pos] = a;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-排序类型"><a href="#4-排序类型" class="headerlink" title="4. 排序类型"></a>4. 排序类型</h2><h3 id="4-1-sort函数的运用"><a href="#4-1-sort函数的运用" class="headerlink" title="4.1 sort函数的运用"></a>4.1 sort函数的运用</h3><p>当涉及顺序较多时，将所有信息封存在一个结构体中，并将获取信息的语句封装在<code>getInfo()</code>函数中。</p>
<h2 id="5-模拟类型"><a href="#5-模拟类型" class="headerlink" title="5. 模拟类型"></a>5. 模拟类型</h2><h3 id="5-1-全模拟"><a href="#5-1-全模拟" class="headerlink" title="5.1 全模拟"></a>5.1 全模拟</h3><h3 id="5-2-模拟堆栈"><a href="#5-2-模拟堆栈" class="headerlink" title="5.2 模拟堆栈"></a>5.2 模拟堆栈</h3><h2 id="6-数论"><a href="#6-数论" class="headerlink" title="6. 数论"></a>6. 数论</h2><h3 id="6-1-求各子数组的元素加和的总和"><a href="#6-1-求各子数组的元素加和的总和" class="headerlink" title="6.1 求各子数组的元素加和的总和"></a>6.1 求各子数组的元素加和的总和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%llf"</span>, &amp;cur);</span><br><span class="line">        sum += (cur * i * (n - i + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h2><h3 id="7-1-堆结构"><a href="#7-1-堆结构" class="headerlink" title="7.1 堆结构"></a>7.1 堆结构</h3><ol>
<li><p>检查堆的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minn = <span class="number">1</span>, maxn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[i] &gt; heap[i / <span class="number">2</span>]) maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (heap[i] &lt; heap[i / <span class="number">2</span>]) minn = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxn == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Max Heap\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (minn == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Min Heap\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Not Heap\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dfs输出堆路径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">traversal</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;curPath, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    curPath.push_back(heap[idx]);</span><br><span class="line">    <span class="keyword">int</span> right = traversal(idx * <span class="number">2</span> + <span class="number">1</span>, curPath, heap);</span><br><span class="line">    <span class="keyword">int</span> left = traversal(idx * <span class="number">2</span>, curPath, heap);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">-1</span> &amp;&amp; right == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 碰到叶子节点</span></span><br><span class="line">        ans.push_back(curPath);</span><br><span class="line">    &#125;</span><br><span class="line">    curPath.pop_back();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="7-2-进制转换（短除法）"><a href="#7-2-进制转换（短除法）" class="headerlink" title="7.2 进制转换（短除法）"></a>7.2 进制转换（短除法）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> ans;</span><br><span class="line"><span class="keyword">while</span> (num) &#123;</span><br><span class="line">    tmp.push_back(num % base);</span><br><span class="line">    num /= base;</span><br><span class="line">&#125;</span><br><span class="line">rev(ans);</span><br></pre></td></tr></table></figure>



<h3 id="7-3-素数判断"><a href="#7-3-素数判断" class="headerlink" title="7.3 素数判断"></a>7.3 素数判断</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-4-优先队列"><a href="#7-4-优先队列" class="headerlink" title="7.4 优先队列"></a>7.4 优先队列</h3><h3 id="7-5-数据读取"><a href="#7-5-数据读取" class="headerlink" title="7.5 数据读取"></a>7.5 数据读取</h3><p>读取一行中不确定长度的用空格间隔的几个字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> keyword[maxN];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; keyword[i++]) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = gethchar();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令行</title>
    <url>/2020/07/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<p>Linux命令行的工具手册。</p>
<a id="more"></a>

<h1 id="开关机等基本命令"><a href="#开关机等基本命令" class="headerlink" title="开关机等基本命令"></a>开关机等基本命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sync &#x2F;&#x2F; 将数据由内存同步到硬盘中</span><br><span class="line">shutdown &#x2F;&#x2F; 关机</span><br><span class="line">reboot</span><br><span class="line">halt &#x2F;&#x2F; 关闭系统</span><br></pre></td></tr></table></figure>



<h1 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h1><h2 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">绝对目录 &#x2F;user&#x2F;share&#x2F;doc</span><br><span class="line">相对目录 (从&#x2F;user&#x2F;share&#x2F;doc到&#x2F;user&#x2F;share&#x2F;man)</span><br><span class="line">        ..&#x2F;man</span><br></pre></td></tr></table></figure>



<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ls</code></td>
<td align="center">查看该级文件</td>
</tr>
<tr>
<td align="center"><code>ls -a</code></td>
<td align="center">查看该级隐藏文件</td>
</tr>
<tr>
<td align="center"><code>ls /</code></td>
<td align="center">查看该级所有文件</td>
</tr>
<tr>
<td align="center"><code>ls -l</code></td>
<td align="center">查看长文件信息</td>
</tr>
<tr>
<td align="center"><code>ls -lh</code></td>
<td align="center">大小用k、M、G显示</td>
</tr>
<tr>
<td align="center"><code>ls -d</code></td>
<td align="center">查看当前目录信息</td>
</tr>
<tr>
<td align="center"><code>ls -i</code></td>
<td align="center">查看文件id</td>
</tr>
<tr>
<td align="center"><code>ls xx</code>+<code>tab</code></td>
<td align="center">补齐文件开头为<code>xx</code>的文件</td>
</tr>
</tbody></table>
<h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>print working directory 输出当前路径</p>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>cd /home/test</code></td>
<td align="center">访问xx目录</td>
</tr>
<tr>
<td align="center"><code>cd ..</code></td>
<td align="center">访问上一级</td>
</tr>
<tr>
<td align="center"><code>cd /</code></td>
<td align="center">访问根目录</td>
</tr>
<tr>
<td align="center"><code>cd ~</code></td>
<td align="center">访问主目录(home)</td>
</tr>
</tbody></table>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>mkdir test</code></td>
<td align="center">新建test文件夹</td>
</tr>
<tr>
<td align="center"><code>mkdir -p /test/123</code></td>
<td align="center">递归创建目录</td>
</tr>
<tr>
<td align="center"><code>mkdir t1 t2 t3</code></td>
<td align="center">同时创建多个目录</td>
</tr>
</tbody></table>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>移动文件或重命名</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>mv file_1 file_2</code></td>
<td align="center">将file_1重命名为file_2</td>
</tr>
<tr>
<td align="center"><code>mv file /dir</code></td>
<td align="center">将file移动到目录dir中</td>
</tr>
<tr>
<td align="center"><code>mv /dir1 /dir2</code></td>
<td align="center">将目录dir1移动到dir2</td>
</tr>
<tr>
<td align="center"><code>mv /dir1/*</code></td>
<td align="center">将dir1下的文件移动到当前目录</td>
</tr>
</tbody></table>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>rmdir test</code></td>
<td align="center">删除一个空目录</td>
</tr>
<tr>
<td align="center"><code>rm -rf abc</code></td>
<td align="center">将当前目录中所有内容强制删除</td>
</tr>
</tbody></table>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>cp-rf e1 e2</code></td>
<td align="center">复制文件或目录</td>
</tr>
<tr>
<td align="center"><code>move hi hello</code></td>
<td align="center">重命名文件或目录</td>
</tr>
</tbody></table>
<h2 id="归档压缩"><a href="#归档压缩" class="headerlink" title="归档压缩"></a>归档压缩</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>tar -cvf f.tar f1 f2 f3</code></td>
<td align="center">将文件归档成档案包</td>
</tr>
<tr>
<td align="center"><code>tar -xvf f.tar</code></td>
<td align="center">还原档案包到当前路径</td>
</tr>
<tr>
<td align="center"><code>tar -xvf f.tar -C xxx/</code></td>
<td align="center">还原档案包到指定路径</td>
</tr>
<tr>
<td align="center"><code>tar -zcvf f.tar.gz f1 f2 f3</code></td>
<td align="center">归档并压缩</td>
</tr>
<tr>
<td align="center"><code>tar -zxvf f.tar.gz</code></td>
<td align="center">解压缩到当前路径</td>
</tr>
</tbody></table>
<h1 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h1><p><a href="https://mp.weixin.qq.com/s/AndIwanhZ3Tlg0iQe8a4lQ" target="_blank" rel="noopener">参考文档</a></p>
<h2 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h2><ul>
<li>命令模式</li>
<li>输入模式</li>
<li>底线命令模式</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMIxVoDyQ4LWxSbHDjAYfHuId7xfHHichtqZK2ehsXvcC9KiaibPf68s9dg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<ul>
<li><code>i</code>切换到输入模式，以输入字符</li>
<li><code>x</code>删除当前光标所在处的字符</li>
<li><code>:</code>切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[Ctrl] + [f]</td>
<td>[Page Down]</td>
</tr>
<tr>
<td>[Ctrl] + [b]</td>
<td>[Page Up]</td>
</tr>
<tr>
<td>[Ctrl] + [d]</td>
<td>屏幕向下移动半页</td>
</tr>
<tr>
<td>[Ctrl] + [u]</td>
<td>屏幕向上移动半页</td>
</tr>
<tr>
<td>+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td>-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td>n [Space]</td>
<td>后退几格</td>
</tr>
<tr>
<td>n [Enter]</td>
<td>后退几行</td>
</tr>
<tr>
<td>gg</td>
<td>移动到第一行</td>
</tr>
<tr>
<td>G</td>
<td>移动到最后一行</td>
</tr>
<tr>
<td>[0]/[Home]</td>
<td>移动到该行头部</td>
</tr>
<tr>
<td>[$]/[End]</td>
<td>移动到该行尾部</td>
</tr>
</tbody></table>
<h3 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h3><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/word</td>
<td>从光标向下找名为word的字符串</td>
</tr>
<tr>
<td>?word</td>
<td>从光标向上找名为word的字符串</td>
</tr>
<tr>
<td>n</td>
<td>n代表重复上一个搜索的动作</td>
</tr>
<tr>
<td>N</td>
<td>N代表反向重复上一个动作</td>
</tr>
</tbody></table>
<h3 id="删除复制与粘贴"><a href="#删除复制与粘贴" class="headerlink" title="删除复制与粘贴"></a>删除复制与粘贴</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d -&gt; delete</span><br><span class="line">y -&gt; copy</span><br><span class="line">d和y的命令是互通的，并未全部列举</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>dd</td>
<td>删除游标所在的一整行</td>
</tr>
<tr>
<td>yy</td>
<td>复制游标所在的一整行</td>
</tr>
<tr>
<td>ndd</td>
<td>删除光标所在的向下n行</td>
</tr>
<tr>
<td>d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td>d$</td>
<td>删除光标到该行末尾的数据</td>
</tr>
<tr>
<td>d0</td>
<td>删除光标到该行开头的数据</td>
</tr>
<tr>
<td>u</td>
<td>复原前一个动作</td>
</tr>
<tr>
<td>[Ctrl] + r</td>
<td>重做上一个动作</td>
</tr>
</tbody></table>
<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><ul>
<li>df：列出文件系统的整体磁盘使用量</li>
<li>du：检查磁盘空间使用量</li>
</ul>
<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h &#x2F;etc # 将&#x2F;etc下可用的磁盘容量以易读的容量格式显示。</span><br></pre></td></tr></table></figure>

<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>使用方法同df</p>
<h2 id="磁盘挂载与卸载"><a href="#磁盘挂载与卸载" class="headerlink" title="磁盘挂载与卸载"></a>磁盘挂载与卸载</h2><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>PAT日记</title>
    <url>/2020/11/27/PAT%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>使用C+STL的编程风格刷PAT，备战PAT甲级考试。</p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/type/7" target="_blank" rel="noopener">题目来源：PAT官网</a></p>
<a id="more"></a>

<h1 id="001-A-B-Format"><a href="#001-A-B-Format" class="headerlink" title="001 A+B Format"></a>001 A+B Format</h1><p>题目大意：将两个整数相加，并按美式标准逗号写法(例：$1,102,342$)将结果输出。</p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805528788582400" target="_blank" rel="noopener">具体题目</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">int</span> neg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        neg = <span class="number">1</span>;</span><br><span class="line">        c = <span class="number">0</span> - c;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s; <span class="comment">// 用一个堆栈保存结果的"反向"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (c) &#123;</span><br><span class="line">        s.push(c % <span class="number">10</span> + <span class="string">'0'</span>); <span class="built_in">size</span>++;</span><br><span class="line">        c /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> % <span class="number">3</span> == <span class="number">0</span>) s.push(<span class="string">','</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.top() == <span class="string">','</span>) s.pop();</span><br><span class="line">    <span class="keyword">if</span> (neg) s.push(<span class="string">'-'</span>);</span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        ans.push_back(s.top());</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="002-A-B-for-polynomials"><a href="#002-A-B-for-polynomials" class="headerlink" title="002 A+B for polynomials"></a>002 A+B for polynomials</h1><p>题目大意：输入两行数字，每行包括的是该多项式的信息（系数、对应次方项），最后将两多项式相加，结果保留一位小数的输出。</p>
<p>题目重点：</p>
<ul>
<li>构建的数组大小根据多项式的系数次方项上限1000来定</li>
<li>结果保留一位小数的写法</li>
</ul>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000" target="_blank" rel="noopener">具体题目</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">    <span class="keyword">double</span> m[<span class="number">1005</span>]; <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span> m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx; <span class="keyword">double</span> num;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; idx &gt;&gt; num;</span><br><span class="line">        m[idx] += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx; <span class="keyword">double</span> num;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; idx &gt;&gt; num;</span><br><span class="line">        m[idx] += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 数出不为0的项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;it : m) <span class="keyword">if</span> (it) cnt++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1000</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[i]) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; m[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="003-Emergency"><a href="#003-Emergency" class="headerlink" title="003 Emergency"></a>003 Emergency</h1><p>题目大意：给出各个待救援位置的相对距离，求C1到C2的最短路径数以及最大救援队的数量。</p>
<p>题目重点：当形成环时，及时退出dfs</p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">具体题目</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minLen, resT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vis, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res_num, <span class="keyword">int</span> cur, <span class="keyword">int</span> len, <span class="keyword">int</span> team, <span class="keyword">int</span> dst, <span class="keyword">int</span> src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == dst) &#123;</span><br><span class="line">        minLen.emplace_back(len);</span><br><span class="line">        resT.emplace_back(team);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cur == src &amp;&amp; len) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[<span class="number">0</span>].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[cur][i] != INT_MAX &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = i;</span><br><span class="line">            vis[next] = <span class="number">1</span>;</span><br><span class="line">            dfs(graph, vis, res_num, next, len + graph[cur][next], team + res_num[next], dst, src);</span><br><span class="line">            vis[next] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, C1, C2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; C1 &gt;&gt; C2;</span><br><span class="line">    vector&lt;int&gt; res_num(N), vis(N, 0);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, INT_MAX))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">cin</span> &gt;&gt; res_num[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> f, s, len;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f &gt;&gt; s &gt;&gt; len;</span><br><span class="line">        graph[f][s] = len; graph[s][f] = len;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(graph, vis, res_num, C1, <span class="number">0</span>, res_num[C1], C2, C1);</span><br><span class="line">    <span class="keyword">int</span> minP = INT_MAX; <span class="comment">// 最小距离初始化为无穷大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;l : minLen) minP = <span class="built_in">min</span>(l, minP);</span><br><span class="line">    <span class="keyword">int</span> maxR = INT_MIN; <span class="comment">// 最大救援队初始化为无穷小</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// cnt是最小距离的路径数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minLen[i] == minP) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            maxR = <span class="built_in">max</span>(resT[i], maxR);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">" "</span> &lt;&lt; maxR &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="004-counting-leaves"><a href="#004-counting-leaves" class="headerlink" title="004 counting leaves"></a>004 counting leaves</h1><p>题目大意：题目输入得到一棵树，然后要求输出每一层的叶子节点个数。难度不大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; graph;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans; <span class="comment">// record leaves node</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> parent; <span class="keyword">int</span> K;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; parent &gt;&gt; K;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; ++j) &#123;</span><br><span class="line">            <span class="built_in">string</span> child;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; child;</span><br><span class="line">            graph[parent].emplace_back(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BFS to find the leaf</span></span><br><span class="line">    <span class="built_in">string</span> root = <span class="string">"01"</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// find its child in graph</span></span><br><span class="line">            <span class="keyword">if</span> (graph.<span class="built_in">find</span>(tmp) != graph.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graph[tmp].<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                    q.push(graph[tmp][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">        <span class="keyword">if</span> (i != ans.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="006-sign-in-and-sign-out"><a href="#006-sign-in-and-sign-out" class="headerlink" title="006 sign in and sign out"></a>006 sign in and sign out</h1><p>题目大意：</p>
<p>给定如下输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">CS301111 15:30:28 17:00:10</span><br><span class="line">SC3021234 08:00:00 11:25:25</span><br><span class="line">CS301133 21:45:00 21:58:40</span><br></pre></td></tr></table></figure>

<p>下面三行分别代表<code>id | signin time | signout time</code>，先进的开门，后进的锁门，返回对应的开门和锁门人的id号码。</p>
<p>题目重点：</p>
<ul>
<li>一开始在排序自定义函数的return那里写的<code>s1 &lt; s2</code>，显然这表明我的判断语句没用了，根据自定义条件返回true或false才是排序的真谛！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; SignIn;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; SignOut;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; idToString;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; timeToId;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stringToValue</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret =  (s[<span class="number">0</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + (s[<span class="number">1</span>] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hour1, hour2;</span><br><span class="line">    <span class="keyword">int</span> min1, min2;</span><br><span class="line">    <span class="keyword">int</span> sec1, sec2;</span><br><span class="line">    hour1 = stringToValue(s1.substr(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">    hour2 = stringToValue(s2.substr(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">    min1 = stringToValue(s1.substr(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">    min2 = stringToValue(s2.substr(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">    sec1 = stringToValue(s1.substr(<span class="number">6</span>, <span class="number">2</span>));</span><br><span class="line">    sec2 = stringToValue(s2.substr(<span class="number">6</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">if</span> (hour1 &lt; hour2 || (hour1 == hour2 &amp;&amp; min1 &lt; min2) || (hour1 == hour2 &amp;&amp; min1 == min2 &amp;&amp; sec1 &lt; sec2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> s1, s2, s3;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;</span><br><span class="line">        timeToId[s2] = s1;</span><br><span class="line">        timeToId[s3] = s1;</span><br><span class="line">        SignIn.emplace_back(s2);</span><br><span class="line">        SignOut.emplace_back(s3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(SignIn.<span class="built_in">begin</span>(), SignIn.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    sort(SignOut.<span class="built_in">begin</span>(), SignOut.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">string</span> s1 = timeToId[SignIn[<span class="number">0</span>]];</span><br><span class="line">    <span class="built_in">string</span> s2 = timeToId[SignOut[N - <span class="number">1</span>]];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="string">" "</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="005-spell-it-right"><a href="#005-spell-it-right" class="headerlink" title="005 spell it right"></a>005 spell it right</h1><p>例：将”12345”转换成”one five”输出因为1+2+3+4+5=15</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s; <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="comment">// string to num</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">        sum += (c - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> tmp = to_string(sum);</span><br><span class="line">    <span class="built_in">string</span> num_to_english[<span class="number">10</span>] = &#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>, <span class="string">"six"</span>, <span class="string">"seven"</span>, <span class="string">"eight"</span>, <span class="string">"nine"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit = tmp[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num_to_english[digit];</span><br><span class="line">        <span class="keyword">if</span> (i != tmp.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="010-radix"><a href="#010-radix" class="headerlink" title="010 radix"></a>010 radix</h1><p>题目大意：判断N1是否等于N2，N1的每一位均具有不同的权值。给定N1或N2的权值，求出是否存在满足N1==N2的N2每位的radix。</p>
<p>题目重点：</p>
<ul>
<li>查找方法用二分优化（注意二分的边界）</li>
<li>查找区间非常讲究，假设已经得到N1的数值：<ul>
<li>查找的左区间应等于N2中的各数中最大的位+1（$min_radix$）</li>
<li>查找的右区间应等于$max(min_radix, N_1)$这个区间。</li>
</ul>
</li>
</ul>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536" target="_blank" rel="noopener">具体题目</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calVal</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算字符串对应的数值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> weight = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            c = s[i] - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c = s[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (weight * c);</span><br><span class="line">        weight *= radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calMin</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = *max_element(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> min_radix = (<span class="built_in">isdigit</span>(it)? it - <span class="string">'0'</span> : it - <span class="string">'a'</span> + <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> min_radix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;N1, <span class="built_in">string</span> &amp;N2, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res1 = calVal(N1, radix);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> min_radix = calMin(N2);</span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = min_radix, r = <span class="built_in">max</span>(res1, min_radix);</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res2 = calVal(N2, m);</span><br><span class="line">        <span class="keyword">if</span> (res2 &gt; res1 || res2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res2 &lt; res1) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> N1, N2;</span><br><span class="line">    <span class="keyword">int</span> tag, radix;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N1 &gt;&gt; N2 &gt;&gt; tag &gt;&gt; radix;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tag == <span class="number">1</span>) &#123;</span><br><span class="line">        res = helper(N1, N2, radix);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = helper(N2, N1, radix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="135-Is-It-A-Red-Black-Tree"><a href="#135-Is-It-A-Red-Black-Tree" class="headerlink" title="135 Is It A Red-Black Tree"></a>135 <strong>Is It A Red-Black Tree</strong></h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805346063728640" target="_blank" rel="noopener">题目链接</a></p>
<p>题目大意：判断题目给定的一系列前序序列的树是否为红黑树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildhelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = pe - ps + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[ps]);</span><br><span class="line">    <span class="keyword">int</span> rootidx = is;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = is; i &lt;= ie; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == preorder[ps]) &#123;</span><br><span class="line">            rootidx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len1 = rootidx - is;</span><br><span class="line">    <span class="keyword">int</span> len2 = n - len1 - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = buildhelper(preorder, inorder, ps + <span class="number">1</span>, ps + len1, is, is + len1 - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = buildhelper(preorder, inorder, pe - len2 + <span class="number">1</span>, pe, rootidx + <span class="number">1</span>, ie);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> buildhelper(p, i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a) &lt; <span class="built_in">abs</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge1</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// red node's child is black</span></span><br><span class="line">    <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;left != <span class="literal">NULL</span> &amp;&amp; r-&gt;left-&gt;val &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;right != <span class="literal">NULL</span> &amp;&amp; r-&gt;right-&gt;val &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judge1(r-&gt;left) &amp;&amp; judge1(r-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(TreeNode *r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = getNum(r-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = getNum(r-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (r-&gt;val &gt; <span class="number">0</span>) ? <span class="built_in">max</span>(left, right) + <span class="number">1</span> : <span class="built_in">max</span>(left, right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge2</span><span class="params">(TreeNode *r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// node to leaves have the same num of black</span></span><br><span class="line">    <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> left = getNum(r-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = getNum(r-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (left != right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> judge2(r-&gt;left) &amp;&amp; judge2(r-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iod = pre;</span><br><span class="line">    sort(iod.<span class="built_in">begin</span>(), iod.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    TreeNode *root = buildTree(pre, iod); <span class="comment">// get the tree we built</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;val &gt; <span class="number">0</span> &amp;&amp; judge1(root) &amp;&amp; judge2(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> num; <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inf</span><span class="params">(num)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp; <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            inf[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkValid(inf)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化建树部分（已知是一株二叉搜索树了，不需要再规规矩矩的采取前序和中序结合建树）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">build</span><span class="params">(node *root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> node();</span><br><span class="line">        root-&gt;val = v;</span><br><span class="line">        root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(v) &lt;= (root-&gt;val)) &#123;</span><br><span class="line">        root-&gt;left = build(root-&gt;left, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;right = build(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[j]);</span><br><span class="line">    root = build(root, arr[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="136-A-Delayed-Palindrome"><a href="#136-A-Delayed-Palindrome" class="headerlink" title="136 A Delayed Palindrome"></a>136 A Delayed Palindrome</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624" target="_blank" rel="noopener">题目链接</a></p>
<p>题目大意：判断给定的数是否为回文数，若不是不断和倒置数相加直到是回文数，若十次相加仍不满足则返回。</p>
<p>题目关键：</p>
<ul>
<li>注意给定的数就有可能是回文数，切不可上来直接相加！！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> N;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = num.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = num[l];</span><br><span class="line">        num[l] = num[r];</span><br><span class="line">        num[r] = tmp;</span><br><span class="line">        l++; r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add_</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 123 + 48 = 171</span></span><br><span class="line">    <span class="keyword">int</span> p1 = num1.<span class="built_in">size</span>() - <span class="number">1</span>, p2 = num2.<span class="built_in">size</span>() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> &amp;&amp; p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = (num1[p1--] - <span class="string">'0'</span>) + (num2[p2--] - <span class="string">'0'</span>) + carry;</span><br><span class="line">        ans.push_back((cur % <span class="number">10</span>) + <span class="string">'0'</span>);</span><br><span class="line">        carry = (cur &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    This part is needless, because the num1size == num2size</span></span><br><span class="line"><span class="comment">    while (p1 &gt;= 0) &#123;</span></span><br><span class="line"><span class="comment">        int cur = (num1[p1--] - '0') + carry;</span></span><br><span class="line"><span class="comment">        ans.push_back((cur % 10) + '0');</span></span><br><span class="line"><span class="comment">        carry = (cur &gt;= 10) ? 1 : 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    while (p2 &gt;= 0) &#123;</span></span><br><span class="line"><span class="comment">        int cur = (num2[p2--] - '0') + carry;</span></span><br><span class="line"><span class="comment">        ans.push_back((cur % 10) + '0');</span></span><br><span class="line"><span class="comment">        carry = (cur &gt;= 10) ? 1 : 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (carry) ans.push_back(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> rev(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pal</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[l++] != s[r--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">if</span> (pal(N)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; N &lt;&lt; <span class="string">" is a palindromic number."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> N_ = N, N_v = rev(N);</span><br><span class="line">        N = add_(N_, N_v);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; N_ &lt;&lt; <span class="string">" + "</span> &lt;&lt; N_v &lt;&lt; <span class="string">" = "</span> &lt;&lt; N &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (pal(N)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; N &lt;&lt; <span class="string">" is a palindromic number."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found in 10 iterations."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化加法部分代码量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = s1;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s1.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        s[i] = (s1[i] - <span class="string">'0'</span> + s2[i] - <span class="string">'0'</span> + carry) % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">        carry = (s1[i] - <span class="string">'0'</span> + s2[i] - <span class="string">'0'</span> + carry) / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) s = <span class="string">"1"</span> + s;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="137-final-grading"><a href="#137-final-grading" class="headerlink" title="137 final grading"></a>137 final grading</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805345401028608" target="_blank" rel="noopener">题目链接</a></p>
<p>题目关键：排序</p>
<h2 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; inf;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; nameToId;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; IdToName;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0] id</span></span><br><span class="line"><span class="comment">[1] Gp</span></span><br><span class="line"><span class="comment">[2] Gm</span></span><br><span class="line"><span class="comment">[3] Gf</span></span><br><span class="line"><span class="comment">[4] G</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> P, M, N, num = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; ++j) &#123;</span><br><span class="line">            inf[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computeG</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// compute</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inf[i][<span class="number">1</span>] &lt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> Grade = inf[i][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> (inf[i][<span class="number">2</span>] &gt; inf[i][<span class="number">3</span>]) Grade = <span class="number">0.4</span> * (<span class="keyword">double</span>)inf[i][<span class="number">2</span>] + <span class="number">0.6</span> * (<span class="keyword">double</span>)inf[i][<span class="number">3</span>];</span><br><span class="line">        inf[i][<span class="number">4</span>] = (<span class="keyword">int</span>)(Grade + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">4</span>] != b[<span class="number">4</span>]) <span class="keyword">return</span> a[<span class="number">4</span>] &gt; b[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IdToName[a[<span class="number">0</span>]] &lt; IdToName[b[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(inf.<span class="built_in">begin</span>(), inf.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inf[i][<span class="number">4</span>] &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> name = IdToName[inf[i][<span class="number">0</span>]];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; inf[i][<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; inf[i][<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; inf[i][<span class="number">3</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; inf[i][<span class="number">4</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readData</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> &amp;id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> name; <span class="keyword">int</span> score; <span class="keyword">int</span> who;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (nameToId.<span class="built_in">find</span>(name) == nameToId.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            IdToName[id] = name;</span><br><span class="line">            nameToId[name] = id++;</span><br><span class="line">            who = id - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            who = nameToId[name];</span><br><span class="line">        &#125;</span><br><span class="line">        inf[who][<span class="number">0</span>] = who;</span><br><span class="line">        inf[who][idx] = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; P &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    inf.assign(num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line">    IdToName.resize(num);</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    readData(<span class="number">1</span>, P, id);</span><br><span class="line">    readData(<span class="number">2</span>, M, id);</span><br><span class="line">    readData(<span class="number">3</span>, N, id);</span><br><span class="line">    computeG();</span><br><span class="line">    printAns();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有AC，有一个用例是段错误（用时和内存都没有太高），经过分析原因可能是：</p>
<ul>
<li><p><del>如果给定用例是6 6 7的话，那么可能最后的最大num应该是6+6+7，即这个num取三者最大值的方法是不对的，应该取MAX。</del></p>
</li>
<li><p>因为num取P+M+N就行了！！！！我上面都说出来了，我为了更保险改成10010，结果题目的10000的意思是每一个数字！！！也就是最后还是要30010才可以！！！WTF</p>
</li>
</ul>
<h2 id="柳神解法"><a href="#柳神解法" class="headerlink" title="柳神解法"></a>柳神解法</h2><p>学学人家的极简代码，另外就是这题用结构体排序开销更小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> gp, gm, gf, g;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.g != b.g ? a.g &gt; b.g : a.name &lt; b.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; idx;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p, m, n, score, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; v, ans;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">200</span>) &#123;</span><br><span class="line">            v.push_back(node&#123;s, score, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">            idx[s] = cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (idx[s] != <span class="number">0</span>) v[idx[s] - <span class="number">1</span>].gm = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (idx[s] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = idx[s] - <span class="number">1</span>;</span><br><span class="line">            v[temp].gf = v[temp].g = score;</span><br><span class="line">            <span class="keyword">if</span> (v[temp].gm &gt; v[temp].gf) v[temp].g = <span class="keyword">int</span>(v[temp].gm * <span class="number">0.4</span> + v[temp].gf * <span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (v[i].g &gt;= <span class="number">60</span>) ans.push_back(v[i]);</span><br><span class="line">    sort(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d %d %d %d\n"</span>, ans[i].name.c_str(), ans[i].gp, ans[i].gm, ans[i].gf, ans[i].g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="138-postorder-traversal"><a href="#138-postorder-traversal" class="headerlink" title="138 postorder traversal"></a>138 postorder traversal</h1><p>题目大意：题目给定前序和中序遍历，要求输出后序遍历的第一个数字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildT</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = pe - ps + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> rootidx = is;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[ps]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = is; i &lt;= ie; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == preorder[ps]) &#123;</span><br><span class="line">            rootidx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = rootidx - is;</span><br><span class="line">    <span class="keyword">int</span> len2 = n - len1 - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = buildT(preorder, inorder, ps + <span class="number">1</span>, ps + len1, is, is + len1 - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = buildT(preorder, inorder, pe - len2 + <span class="number">1</span>, pe, rootidx + <span class="number">1</span>, ie);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root, <span class="keyword">int</span> &amp;ans, <span class="keyword">bool</span> &amp;flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root &amp;&amp; flag == <span class="literal">false</span>) &#123;</span><br><span class="line">        postorder(root-&gt;left, ans, flag);</span><br><span class="line">        postorder(root-&gt;right, ans, flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">            ans = root-&gt;val;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    vector&lt;int&gt; preorder(N), inorder(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; preorder[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; inorder[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *root = buildT(preorder, inorder, <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>; <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    postorder(root, ans, flag);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化（根据前序和中序，直接得到后序遍历的方法）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> ps, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is &lt;= ie) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = is;</span><br><span class="line">        <span class="keyword">while</span> (inorder[idx] != preorder[ps]) idx++;</span><br><span class="line">        postorder(ps + <span class="number">1</span>, is, idx - <span class="number">1</span>);</span><br><span class="line">        postorder(ps + <span class="number">1</span> + idx - is, idx + <span class="number">1</span>, ie);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; preorder[ps];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="139-first-contact"><a href="#139-first-contact" class="headerlink" title="139 first contact"></a>139 first contact</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312" target="_blank" rel="noopener">题目链接</a></p>
<p>这题坑太多了，没有柳神我真做不出来……</p>
<p>题目关键：</p>
<ul>
<li>为了防止-0000和0000这种测试用例，最好还是用字符串承接，并通过字符串的位数来判断是否同性。</li>
<li>针对ABCD这个环形图来说，隐含有一个条件，那就是A和D，B和C不能是同一个人。</li>
<li>最后输出要用格式化输出，我个人猜想是最后一个测试用例隐含有小于四位数的数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">helper</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(helper &amp;x, helper &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.a) != (y.a) ? (x.a) &lt; (y.a) : (x.b) &lt; (y.b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; isFriend;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sameGender[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// find a's same gender friends and b's same gender friends, check if their are pair of friends</span></span><br><span class="line">    <span class="keyword">int</span> N, M, K;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> A, B;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B;</span><br><span class="line">        <span class="keyword">if</span> (A.<span class="built_in">size</span>() == B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// prove they are same gender</span></span><br><span class="line">            sameGender[<span class="built_in">abs</span>(stoi(A))].push_back(<span class="built_in">abs</span>(stoi(B)));</span><br><span class="line">            sameGender[<span class="built_in">abs</span>(stoi(B))].push_back(<span class="built_in">abs</span>(stoi(A)));</span><br><span class="line">        &#125;</span><br><span class="line">        isFriend[<span class="built_in">abs</span>(stoi(A)) * <span class="number">10000</span> + <span class="built_in">abs</span>(stoi(B))] = isFriend[<span class="built_in">abs</span>(stoi(B)) * <span class="number">10000</span> + <span class="built_in">abs</span>(stoi(A))] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> A, B; <span class="comment">// A fall in love to B</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B;</span><br><span class="line">        <span class="built_in">vector</span>&lt;helper&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sameGender[<span class="built_in">abs</span>(A)].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sameGender[<span class="built_in">abs</span>(B)].<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> C = sameGender[<span class="built_in">abs</span>(A)][j], D = sameGender[<span class="built_in">abs</span>(B)][k]; <span class="comment">// C and D are A's and B's friend</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(A) == D || <span class="built_in">abs</span>(B) == C) <span class="keyword">continue</span>; <span class="comment">// it's fuckin important</span></span><br><span class="line">                <span class="keyword">if</span> (isFriend[C * <span class="number">10000</span> + D] == <span class="literal">true</span>) ans.push_back(helper&#123;C, D&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); ++j) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%04d %04d\n"</span>, ans[j].a, ans[j].b); <span class="comment">// it's fuckin important</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="141-PAT-Ranking-of-Institutions"><a href="#141-PAT-Ranking-of-Institutions" class="headerlink" title="141 PAT Ranking of Institutions"></a>141 PAT Ranking of Institutions</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805344222429184" target="_blank" rel="noopener">题目链接</a></p>
<p>题目关键：</p>
<ul>
<li>最后的取整操作，要将所有的成绩按照double加和计算完了，再进行取整操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inf</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grade;</span><br><span class="line">    <span class="keyword">double</span> sumgrade;</span><br><span class="line">    <span class="keyword">int</span> id, rank, cnt;</span><br><span class="line">    <span class="built_in">string</span> sName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">char</span> lev, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lev == <span class="string">'A'</span>) <span class="keyword">return</span> grade;</span><br><span class="line">    <span class="keyword">if</span> (lev == <span class="string">'B'</span>) <span class="keyword">return</span> (<span class="keyword">double</span>)grade / <span class="number">1.5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lev == <span class="string">'T'</span>) <span class="keyword">return</span> (<span class="keyword">double</span>)grade * <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(inf f1, inf f2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)f1.sumgrade != (<span class="keyword">int</span>)f2.sumgrade) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)f1.sumgrade &gt; (<span class="keyword">int</span>)f2.sumgrade;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f1.cnt != f2.cnt) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.cnt &lt; f2.cnt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.sName &lt; f2.sName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;inf&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Id2sch;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sch2Id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// load the data</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">int</span> ord = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> id, school; <span class="keyword">int</span> grade;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; grade &gt;&gt; school;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; school.length(); ++i) &#123;</span><br><span class="line">           school[i] = <span class="built_in">tolower</span>(school[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sch2Id.<span class="built_in">find</span>(school) == sch2Id.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            sch2Id[school] = ord++;</span><br><span class="line">            Id2sch.emplace_back(school);</span><br><span class="line">            inf info;</span><br><span class="line">            info.sName = school;</span><br><span class="line">            info.id = sch2Id[school];</span><br><span class="line">            info.cnt = <span class="number">0</span>;</span><br><span class="line">            ans.push_back(info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> curGrade = getGrade(id[<span class="number">0</span>], grade);</span><br><span class="line">        ans[sch2Id[school]].grade.push_back(curGrade);</span><br><span class="line">        ans[sch2Id[school]].cnt++;</span><br><span class="line">        ans[sch2Id[school]].sumgrade += curGrade;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get the order</span></span><br><span class="line">    sort(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get the rank</span></span><br><span class="line">    ans[<span class="number">0</span>].rank = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>)ans[i].sumgrade == (<span class="keyword">int</span>)ans[i - <span class="number">1</span>].sumgrade) &#123;</span><br><span class="line">            ans[i].rank = ans[i - <span class="number">1</span>].rank;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[i].rank = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print the ans</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i].rank &lt;&lt; <span class="string">" "</span> &lt;&lt; Id2sch[ans[i].id] &lt;&lt; <span class="string">" "</span> &lt;&lt; (<span class="keyword">int</span>)ans[i].sumgrade &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[i].cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="142-Maximal-Clique"><a href="#142-Maximal-Clique" class="headerlink" title="142 Maximal Clique"></a>142 Maximal Clique</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343979159552" target="_blank" rel="noopener">题目链接</a></p>
<p>题目大意：团的定义是该集合中，所有点都两两连接。最大团的定义是，集合外不存在一个点使得加入现有集合仍为一个团。</p>
<p>adjacent 邻近的</p>
<p>clique 团</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> isEdge[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> Nv, Ne, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAns</span><span class="params">(<span class="keyword">int</span> K, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;isquery)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check if it's a clique</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; K; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEdge[cur[i]][cur[j]] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Not a Clique\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// check if it's maximal clique</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Nv; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isquery[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> maximal = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cur.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// at least one outer node is absolute connect(1) to the clique</span></span><br><span class="line">                <span class="keyword">if</span> (isEdge[i][cur[j]] == <span class="number">1</span>) maximal++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maximal == cur.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Not Maximal\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;Nv, &amp;Ne);</span><br><span class="line">    <span class="built_in">memset</span>(isEdge, <span class="number">0</span>, <span class="keyword">sizeof</span> isEdge);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Ne; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;r, &amp;c);</span><br><span class="line">        isEdge[r][c] = <span class="number">1</span>;</span><br><span class="line">        isEdge[c][r] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; M; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> K; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;K);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur</span>; <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">isquery</span><span class="params">(Nv + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp; <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            cur.emplace_back(tmp);</span><br><span class="line">            isquery[tmp] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printAns(K, cur, isquery);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="143-Lowest-Common-Ancestor"><a href="#143-Lowest-Common-Ancestor" class="headerlink" title="143 Lowest Common Ancestor"></a>143 Lowest Common Ancestor</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312" target="_blank" rel="noopener">题目链接</a></p>
<p>题目大意：找到两个点的最近公共祖先。</p>
<p>这题完全参考的柳神的题解，自己想到的思路是建树之后，再bfs得到结点-&gt;depth映射表，然后根据这个树再构建一个邻接表，对于每一个系统给定的U和V，遍历这个邻接表，如果找到一个结点能dfs到U、V并且其对应的depth最小，输出结果。这样估计必然超时。</p>
<p>柳神的解法是只用一个哈希表映射该结点数值是否在树中存在，然后对于每一组U和V，遍历pre数组，如果此时找到一个pre[i]满足在U和V中间，那么根据先序遍历的特点，扫描结点时先扫根部，一定先扫到的结点就是最近祖先。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; isExist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, U, V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(M, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">        isExist[pre[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;U, &amp;V); <span class="keyword">int</span> anc;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            anc = pre[j];</span><br><span class="line">            <span class="keyword">if</span> (anc &lt;= U &amp;&amp; anc &gt;= V || anc &lt;= V &amp;&amp; anc &gt;= U) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check existance</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isExist[U] == <span class="literal">false</span> &amp;&amp; isExist[V] == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d and %d are not found.\n"</span>, U, V);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isExist[U] == <span class="literal">false</span> || isExist[V] == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d is not found.\n"</span>, (isExist[U] == <span class="literal">false</span>) ? U : V);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U != anc &amp;&amp; V != anc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d.\n"</span>, U, V, anc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>, anc, (U == anc) ? V : U);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="145-hashing-average-search-time"><a href="#145-hashing-average-search-time" class="headerlink" title="145 hashing-average search time"></a>145 hashing-average search time</h1><p>Quadratic probing 平方探测法</p>
<p>prime 素数</p>
<p>题目大意：根据给定第一行数据凭借二次探测法构建哈希表，再根据第二行的元素搜索返回平均查找次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ms, n, m, a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;ms, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (!isPrime(ms)) ms++;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hash</span><span class="params">(ms, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ms; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> add = (a + j * j) % ms;</span><br><span class="line">            <span class="keyword">if</span> (hash[add] == <span class="number">0</span>) &#123;</span><br><span class="line">                hash[add] = a;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">"%d cannot be inserted.\n"</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= ms; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> add = (a + j * j) % ms;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">if</span> (hash[add] == a || hash[add] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// found or impossible to find</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, ans * <span class="number">1.0</span> / m);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="146-Topological-Order"><a href="#146-Topological-Order" class="headerlink" title="146 Topological Order"></a>146 Topological Order</h1><p>题目大意：根据题目信息，返回query中拓扑排序的正确性。</p>
<p>题目关键：</p>
<ul>
<li>当发现是错误的拓扑排序后，不能直接break，否则接下来的数据将不能scanf！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    indegree.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    graph.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        graph[u].emplace_back(v);</span><br><span class="line">        indegree[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ind = indegree;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">            <span class="keyword">if</span> (ind[u] != <span class="number">0</span>) &#123;</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; graph[u].<span class="built_in">size</span>(); ++w) &#123;</span><br><span class="line">                    <span class="keyword">int</span> v = graph[u][w];</span><br><span class="line">                    ind[v]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(i == ans.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python人脸识别</title>
    <url>/2020/09/21/Python%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>针对《Python人脸识别 从入门到工程实践》这本书入手，记一些简单的笔记。</p>
<a id="more"></a>

<h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><ul>
<li>被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。</li>
</ul>
]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记V</title>
    <url>/2020/08/17/Leetcode%E6%97%A5%E8%AE%B0V/</url>
    <content><![CDATA[<p>Leetcode日记V，最后一波，冲！</p>
<a id="more"></a>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="根据二叉树创建字符串"><a href="#根据二叉树创建字符串" class="headerlink" title="根据二叉树创建字符串"></a>根据二叉树创建字符串</h2><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>
<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    2     3</span><br><span class="line">   &#x2F;    </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">解释: 原本将是“1(2(4)())(3())”，</span><br><span class="line">在你省略所有不必要的空括号对之后，</span><br><span class="line">它将是“1(2(4))(3)”。</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    2     3</span><br><span class="line">     \  </span><br><span class="line">      4 </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2()(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">解释: 和第一个示例相似，</span><br><span class="line">除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</span><br></pre></td></tr></table></figure>

<p>递归+前序遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">            ans.append(to_string(t-&gt;val));</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) &#123; <span class="comment">// 左右均存在 或 左不存在右存在</span></span><br><span class="line">                ans += (<span class="string">"("</span> + tree2str(t-&gt;left) + <span class="string">")("</span> + tree2str(t-&gt;right) + <span class="string">")"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;left) &#123; <span class="comment">// 左存在右不存在</span></span><br><span class="line">                ans += (<span class="string">"("</span> + tree2str(t-&gt;left) + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h2><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*序列化+dfs*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// 序列 ：出现次数</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二叉树序列化</span></span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        <span class="comment">// 当前根节点的先序序列，由于空格的位数偏差，该序列是唯一的</span></span><br><span class="line">        str = to_string(r-&gt;val) + <span class="string">" "</span> + helper(r-&gt;left) + <span class="string">" "</span> + helper(r-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (m[str] == <span class="number">1</span>) ans.push_back(r); <span class="comment">// 如果已经出现了一次，则存在重复</span></span><br><span class="line">        m[str]++;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="输出二叉树"><a href="#输出二叉树" class="headerlink" title="输出二叉树"></a>输出二叉树</h2><p><a href="https://leetcode-cn.com/problems/print-binary-tree/" target="_blank" rel="noopener">题目链接</a></p>
<p>根据深度bfs，逐层修改结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (r == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">max</span>(getDepth(r-&gt;left), getDepth(r-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">printTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#123;<span class="string">""</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> d = getDepth(root); <span class="comment">// 树的深度等于行数</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">pow</span>(<span class="number">2</span>, d) - <span class="number">1</span>; <span class="comment">// 宽度为2 ^ d - 1</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">ans</span><span class="params">(d, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(c, <span class="string">""</span>))</span></span>; <span class="comment">// 初始化为全空</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">-1</span>; <span class="comment">// 当前树的高度</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; cur &lt; d - <span class="number">1</span>) &#123; <span class="comment">// bfs，跳出循环条件为层数达到d</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            cur++;</span><br><span class="line">            <span class="comment">// 该层第一个输出位的当前列下标为 (2^cur-1)/(2^(cur+1))</span></span><br><span class="line">            <span class="comment">// 每两个节点相隔2^(d-cur)</span></span><br><span class="line">            <span class="keyword">int</span> start = c / <span class="built_in">pow</span>(<span class="number">2</span>, cur + <span class="number">1</span>), len = <span class="built_in">pow</span>(<span class="number">2</span>, d - cur);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                ans[cur][start + len * i] = (tmp == <span class="literal">NULL</span>) ? <span class="string">""</span> : to_string(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">                    q.push(tmp-&gt;left);</span><br><span class="line">                    q.push(tmp-&gt;right);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 空节点也要占位</span></span><br><span class="line">                    q.push(<span class="literal">NULL</span>); q.push(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h2><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p>
<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p>
<h3 id="个人解法（超时）"><a href="#个人解法（超时）" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h3><p>bfs+层节点序列化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用一个字符串记录每层的非空节点</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>(); <span class="comment">// cnt为该层非空节点数量，若为0则break</span></span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">                    q.push(tmp-&gt;left);</span><br><span class="line">                    q.push(tmp-&gt;right);</span><br><span class="line">                    str.push_back(<span class="string">'*'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                    q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                    str.push_back(<span class="string">'#'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cnt = str.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = str.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 从后向前遍历层序列</span></span><br><span class="line">                <span class="keyword">if</span> (str[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; ans) &#123;</span><br><span class="line">                ans = cnt; <span class="comment">// 更新ans</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>存储每个非空节点的对应下标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.push(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            ans = <span class="built_in">max</span>(<span class="keyword">int</span>(q.back().second - q.front().second + <span class="number">1</span>), ans);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (tmp.first-&gt;left) q.push(&#123;tmp.first-&gt;left, tmp.second * <span class="number">2</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span> (tmp.first-&gt;right) q.push(&#123;tmp.first-&gt;right, tmp.second * <span class="number">2</span> + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt; m; <span class="comment">// depth : left 存储最左节点的下标</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* r, <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pos)</span> </span>&#123; <span class="comment">// 前序dfs 每当第一次访问每层，一定先访问到最左节点</span></span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">find</span>(d) == m.<span class="built_in">end</span>()) m[d] = pos;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (<span class="keyword">int</span>)(pos - m[d] + <span class="number">1</span>));</span><br><span class="line">        dfs(r-&gt;left, d + <span class="number">1</span>, pos * <span class="number">2</span>);</span><br><span class="line">        dfs(r-&gt;right, d + <span class="number">1</span>, pos * <span class="number">2</span> + <span class="number">1</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h2><p>将<code>val</code>插入二叉搜索树中。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) &#123;</span><br><span class="line">            root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *parent = root, *p = root;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            parent = p;</span><br><span class="line">            p = p-&gt;val &lt; val ? p-&gt;right : p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;val &lt; val) &#123;</span><br><span class="line">            parent-&gt;right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树中所有距离为K的结点"><a href="#二叉树中所有距离为K的结点" class="headerlink" title="二叉树中所有距离为K的结点"></a>二叉树中所有距离为K的结点</h2><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。</p>
<p>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。</p>
<h3 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h3><p>树-&gt;图，dfs</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(TreeNode* pre, TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            graph[r-&gt;val].push_back(pre-&gt;val); <span class="comment">// 前驱也是它的相邻节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;left) graph[r-&gt;val].push_back(r-&gt;left-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;right) graph[r-&gt;val].push_back(r-&gt;right-&gt;val);</span><br><span class="line"></span><br><span class="line">        createGraph(r, r-&gt;left); <span class="comment">// r变为前驱，左节点变为根</span></span><br><span class="line">        createGraph(r, r-&gt;right); <span class="comment">// r变为前驱，右节点变为根</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) ans.push_back(cur);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[cur].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nex = graph[cur][i];</span><br><span class="line">                <span class="keyword">if</span> (graph.<span class="built_in">find</span>(nex) != graph.<span class="built_in">end</span>() &amp;&amp; vis[nex] == <span class="number">0</span>) &#123;</span><br><span class="line">                    vis[nex] = <span class="number">1</span>;</span><br><span class="line">                    dfs(k - <span class="number">1</span>, nex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* r, TreeNode* target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将树转换成图</span></span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> &#123;target-&gt;val&#125;;</span><br><span class="line">        createGraph(<span class="literal">nullptr</span>, r);</span><br><span class="line">        <span class="comment">// 处理当图仅一个结点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (graph.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> &#123;r-&gt;val&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vis.resize(graph.<span class="built_in">size</span>(), <span class="number">0</span>); <span class="comment">// 构建vis数组</span></span><br><span class="line">        vis[target-&gt;val] = <span class="number">1</span>;</span><br><span class="line">        dfs(k, target-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>参考steven</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findDistK</span><span class="params">(TreeNode* r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!r || k &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 如果根节点为空或k不合法返回</span></span><br><span class="line">        <span class="keyword">if</span> (!k) ans.push_back(r-&gt;val);</span><br><span class="line">        findDistK(r-&gt;left, k - <span class="number">1</span>);</span><br><span class="line">        findDistK(r-&gt;right, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetParent</span><span class="params">(TreeNode* r, TreeNode* target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (r == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = findTargetParent(r-&gt;left, target, k);</span><br><span class="line">        <span class="keyword">int</span> right = findTargetParent(r-&gt;right, target, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果target在左分支</span></span><br><span class="line">            <span class="keyword">if</span> (left == k) &#123;</span><br><span class="line">                ans.push_back(r-&gt;val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; k) &#123;</span><br><span class="line">                findDistK(r-&gt;right, k - left - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果target在右分支</span></span><br><span class="line">            <span class="keyword">if</span> (right == k) &#123;</span><br><span class="line">                ans.push_back(r-&gt;val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &lt; k) &#123;</span><br><span class="line">                findDistK(r-&gt;left, k - right - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* r, TreeNode* target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> &#123;target-&gt;val&#125;;</span><br><span class="line">        findTargetParent(r, target, k);</span><br><span class="line">        findDistK(target, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="dfs-1"><a href="#dfs-1" class="headerlink" title="dfs"></a>dfs</h1><h2 id="扫雷游戏"><a href="#扫雷游戏" class="headerlink" title="扫雷游戏"></a>扫雷游戏</h2><p><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">题目链接</a></p>
<p>无脑dfs即可，注意当访问到的位修改后变成了数字（即其为炸弹的相邻位）修改原位直接返回即可，否则递归向下修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = board[r][c]; <span class="comment">// 保存元字符</span></span><br><span class="line">        board[r][c] = <span class="string">'#'</span>; <span class="comment">// 标志访问</span></span><br><span class="line">        <span class="keyword">int</span> cntM = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123; <span class="comment">// 首先探炸弹</span></span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge &amp;&amp; board[x][y] == <span class="string">'M'</span>) &#123;</span><br><span class="line">                cntM++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cntM) &#123; <span class="comment">// 如果四周没炸弹，递归向下继续dfs</span></span><br><span class="line">            board[r][c] = <span class="string">'B'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">                <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">                <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">                <span class="keyword">if</span> (notEdge &amp;&amp; board[x][y] == <span class="string">'E'</span>) &#123;</span><br><span class="line">                    dfs(board, x, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则修改后直接返回</span></span><br><span class="line">            board[r][c] = <span class="string">'0'</span> + cntM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; <span class="title">updateBoard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">click</span>)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>(); m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="built_in">click</span>[<span class="number">0</span>]][<span class="built_in">click</span>[<span class="number">1</span>]] == <span class="string">'M'</span>) &#123;</span><br><span class="line">            board[<span class="built_in">click</span>[<span class="number">0</span>]][<span class="built_in">click</span>[<span class="number">1</span>]] = <span class="string">'X'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(board, <span class="built_in">click</span>[<span class="number">0</span>], <span class="built_in">click</span>[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h2><p><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="dfs-2"><a href="#dfs-2" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查看graph[start]是否有end，若无继续dfs</span></span><br><span class="line">        vis[start] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[start].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[start][i] == <span class="built_in">end</span> &amp;&amp; vis[graph[start][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果遍历到了目标节点，返回true</span></span><br><span class="line">                vis[start] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graph[start][i] != <span class="built_in">end</span> &amp;&amp; vis[graph[start][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果遍历到的不是end，且当前未被访问过，继续dfs</span></span><br><span class="line">                <span class="keyword">if</span> (dfs(graph[start][i], <span class="built_in">end</span>)) &#123;</span><br><span class="line">                    vis[start] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[start] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLoop</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; edge)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向边(u,v)，是否存在另一条(u,v)的通路</span></span><br><span class="line"></span><br><span class="line">        vis[edge[<span class="number">0</span>]] = <span class="number">1</span>; <span class="comment">// 标记成已访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[edge[<span class="number">0</span>]].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[edge[<span class="number">0</span>]][i] == edge[<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// u-&gt;v跳过</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(graph[edge[<span class="number">0</span>]][i], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                vis[edge[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[edge[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先根据edges转换成邻接表结构</span></span><br><span class="line">        N = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        graph.resize(N + <span class="number">1</span>);</span><br><span class="line">        vis.assign(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 倒序访问边集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (isLoop(edges[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> edges[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 先根据edges转换成邻接表结构，并构建入度表 */</span></span><br><span class="line">        N = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        graph.resize(N + <span class="number">1</span>);</span><br><span class="line">        indegree.resize(N + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            indegree[edges[i][<span class="number">0</span>]]++;</span><br><span class="line">            indegree[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">1</span>) <span class="comment">// 入度为1的节点入队</span></span><br><span class="line">                q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123; <span class="comment">// 依次删除图中的入度为1的节点，并更新队列</span></span><br><span class="line">            <span class="keyword">int</span> temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[temp].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                indegree[graph[temp][i]]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[graph[temp][i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.push(graph[temp][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*经过拓扑排序之后，indegree中的所有入度大于1的节点的任意组合都是可删的边*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 倒序遍历边</span></span><br><span class="line">            <span class="keyword">if</span> (indegree[edges[i][<span class="number">0</span>]] &gt; <span class="number">1</span> &amp;&amp; indegree[edges[i][<span class="number">1</span>]] &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> edges[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 路径压缩，寻找根节点</span></span><br><span class="line">        <span class="keyword">int</span> a = x;</span><br><span class="line">        <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">            x = father[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (a != father[a]) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = a;</span><br><span class="line">            a = father[a];</span><br><span class="line">            father[z] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = edges.<span class="built_in">size</span>();</span><br><span class="line">        father.resize(N + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123; <span class="comment">// 初始化</span></span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123; <span class="comment">// 遍历边集合</span></span><br><span class="line">            <span class="keyword">int</span> res1 = findFather(edges[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> res2 = findFather(edges[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (res2 == res1) <span class="keyword">return</span> edges[i];</span><br><span class="line">            <span class="keyword">else</span> father[res1] = res2; <span class="comment">// 独立集合合并</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="冗余连接II"><a href="#冗余连接II" class="headerlink" title="冗余连接II"></a>冗余连接II</h2><p><a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ancestor;</span><br><span class="line"></span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        ancestor.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ancestor[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index == ancestor[index] ? index : ancestor[index] = <span class="built_in">find</span>(ancestor[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ancestor[<span class="built_in">find</span>(u)] = <span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nodesCount = edges.<span class="built_in">size</span>();</span><br><span class="line">        UnionFind uf = UnionFind(nodesCount + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nodesCount + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodesCount; ++i) &#123;</span><br><span class="line">            <span class="comment">// 初始化并查集</span></span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> conflict = <span class="number">-1</span>; <span class="comment">// 代表冲突的边</span></span><br><span class="line">        <span class="keyword">int</span> cycle = <span class="number">-1</span>; <span class="comment">// 代表环路的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodesCount; ++i) &#123;</span><br><span class="line">            <span class="comment">// 遍历边，构造并查集，同时记录最后一个冲突边和环路边</span></span><br><span class="line">            <span class="keyword">auto</span> edge = edges[i];</span><br><span class="line">            <span class="keyword">int</span> node1 = edge[<span class="number">0</span>], node2 = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (parent[node2] != node2) &#123;</span><br><span class="line">                <span class="comment">// 如果父亲节点不是自己，则有两个边指向它，标记为冲突</span></span><br><span class="line">                conflict = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[node2] = node1; <span class="comment">// 标记该边的父亲</span></span><br><span class="line">                <span class="keyword">if</span> (uf.<span class="built_in">find</span>(node1) == uf.<span class="built_in">find</span>(node2)) &#123;</span><br><span class="line">                    <span class="comment">// 如果两边的根节点相同，必有环</span></span><br><span class="line">                    cycle = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果无环，两节点可以归为一个集合</span></span><br><span class="line">                    uf.merge(node1, node2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看冲突的边和环路边</span></span><br><span class="line">        <span class="keyword">if</span> (conflict &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果无冲突边，则问题出在环路边，直接返回</span></span><br><span class="line">            <span class="keyword">auto</span> redundant = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;edges[cycle][<span class="number">0</span>], edges[cycle][<span class="number">1</span>]&#125;;</span><br><span class="line">            <span class="keyword">return</span> redundant;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，讨论是否有环路边</span></span><br><span class="line">            <span class="keyword">auto</span> conflictEdge = edges[conflict];</span><br><span class="line">            <span class="keyword">if</span> (cycle &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果有环路边，则应是另一个边，因为不能同时冲突和环路</span></span><br><span class="line">                <span class="keyword">auto</span> redundant = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;parent[conflictEdge[<span class="number">1</span>]], conflictEdge[<span class="number">1</span>]&#125;;</span><br><span class="line">                <span class="keyword">return</span> redundant;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果无环路边，显然问题出在最后一个冲突边</span></span><br><span class="line">                <span class="keyword">auto</span> redundant = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;conflictEdge[<span class="number">0</span>], conflictEdge[<span class="number">1</span>]&#125;;</span><br><span class="line">                <span class="keyword">return</span> redundant;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="个人解法（失败）"><a href="#个人解法（失败）" class="headerlink" title="个人解法（失败）"></a>个人解法（失败）</h3><p>hash表存储，在一条龙遍历。</p>
<p>当纯按字典序走的时候，会出现死胡同情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findItinerary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; ticket : tickets) &#123;</span><br><span class="line">            m[ticket[<span class="number">0</span>]].push_back(ticket[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : m) &#123;</span><br><span class="line">            sort(item.second.<span class="built_in">begin</span>(), item.second.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(<span class="string">"JFK"</span>);</span><br><span class="line">        <span class="built_in">string</span> cur = <span class="string">"JFK"</span>, nex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tickets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = m[cur].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m[cur].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">find</span>(m[cur][j]) != m.<span class="built_in">end</span>() || i == tickets.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                    nex = m[cur][j];</span><br><span class="line">                    ans.push_back(nex);</span><br><span class="line">                    m[cur].erase(it);</span><br><span class="line">                    cur = nex;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, priority_queue&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt;&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (vec.count(curr) &amp;&amp; vec[curr].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = vec[curr].top();</span><br><span class="line">            vec[curr].pop();</span><br><span class="line">            dfs(<span class="built_in">move</span>(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        stk.emplace_back(curr); <span class="comment">// 死胡同会先于活胡同入栈（死胡同必为最后一个节点）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findItinerary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : tickets) &#123;</span><br><span class="line">            vec[it[<span class="number">0</span>]].emplace(it[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">"JFK"</span>);</span><br><span class="line"></span><br><span class="line">        reverse(stk.<span class="built_in">begin</span>(), stk.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="喧闹和富有"><a href="#喧闹和富有" class="headerlink" title="喧闹和富有"></a>喧闹和富有</h2><p><a href="https://leetcode-cn.com/problems/loud-and-rich/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h3><p>dfs超时（这题不会记忆化，67/86个就超时了。。。）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; richerTable;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> poor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (richerTable[poor].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; richerTable[poor].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nexBig = richerTable[poor][i];</span><br><span class="line">            <span class="keyword">if</span> (nexBig &lt; root) &#123;</span><br><span class="line">                <span class="comment">// 如若下一个更大的已经计算出所有比它大的了，那就直接添加全部结点</span></span><br><span class="line">                <span class="keyword">if</span> (richerTable[nexBig].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; richerTable[nexBig].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    richerTable[root].push_back(richerTable[nexBig][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (richerTable[nexBig].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item : richerTable[nexBig]) &#123;</span><br><span class="line">                    richerTable[root].push_back(item);</span><br><span class="line">                    dfs(root, item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">loudAndRich</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = quiet.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        richerTable.assign(N, v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item : richer) &#123;</span><br><span class="line">            richerTable[item[<span class="number">1</span>]].push_back(item[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            dfs(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            richerTable[i].push_back(i); <span class="comment">// 添加自己</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = INT_MAX;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;rich : richerTable[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (quiet[rich] &lt; cur) &#123;</span><br><span class="line">                    cur = quiet[rich];</span><br><span class="line">                    ret = rich;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h3><p>参考wpn-zju的思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">loudAndRich</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(quiet.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec : richer)</span><br><span class="line">            graph[vec[<span class="number">1</span>]].push_back(vec[<span class="number">0</span>]);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(quiet.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            result[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; quiet.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            dfsFindRich(graph, quiet, result, i, i);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfsFindRich</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result, <span class="keyword">int</span> t, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*t为当前所求的结点，cur为当前与t比较的结点*/</span></span><br><span class="line">        <span class="keyword">if</span> (quiet[result[t]] &gt; quiet[cur])</span><br><span class="line">            result[t] = cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i : graph[cur]) &#123; <span class="comment">// 寻求当前比cur更rich的结点i</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; t) &#123; <span class="comment">// 如果i&lt;t，证明i已经得到了比他更小的结果result[i]，直接根据这个结果更新就好了</span></span><br><span class="line">                <span class="keyword">if</span> (quiet[result[t]] &gt; quiet[result[i]])</span><br><span class="line">                    result[t] = result[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则还得继续dfs</span></span><br><span class="line">                dfsFindRich(graph, quiet, result, t, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="使陆地分离的最少天数"><a href="#使陆地分离的最少天数" class="headerlink" title="使陆地分离的最少天数"></a>使陆地分离的最少天数</h2><p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的二维网格 <code>grid</code> ，其中 <code>0</code> 表示水，而 <code>1</code> 表示陆地。岛屿由水平方向或竖直方向上相邻的 <code>1</code> （陆地）连接形成。</p>
<p>如果 <strong>恰好只有一座岛屿</strong> ，则认为陆地是 <strong>连通的</strong> ；否则，陆地就是 <strong>分离的</strong> 。</p>
<p>一天内，可以将任何单个陆地单元（<code>1</code>）更改为水单元（<code>0</code>）。</p>
<p>返回使陆地分离的最少天数。</p>
<h3 id="个人解法（超时）-1"><a href="#个人解法（超时）-1" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h3><p>dfs</p>
<ol>
<li>首先判断是否是多个岛屿，如果是，返回0.</li>
<li>否则判断是否答案为1<ul>
<li>逐一将1改为0，再全局dfs判断是否多个岛屿。如果是，直接返回1</li>
<li>否则返回2</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; vis, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        vis[r][c] = <span class="number">1</span>; <span class="comment">// 标记1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[k];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[k];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge &amp;&amp; grid[x][y] == <span class="number">1</span> &amp;&amp; vis[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(grid, vis, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123; <span class="comment">// 返回是否有多个岛屿</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">vis</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>))</span></span>; <span class="comment">// dfs遍历时的vis数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; vis[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    dfs(grid, vis, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (check(grid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (check(grid)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法优化"><a href="#解法优化" class="headerlink" title="解法优化"></a>解法优化</h3><p>直接修改原<code>grid</code>(注意传参不能传引用了)，空间复杂度优化到$O(1)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[k];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[k];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(grid, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; grid)</span> </span>&#123; <span class="comment">// 返回是否有多个岛屿</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (check(grid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (check(grid)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果想多次dfs同一个图，切记</p>
<p><strong>不能先将该结点标记，再dfs后修改回原值！！</strong>如果想多次dfs同一个原图的话就采用传引用的方式或者vis数组。</p>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="找到K个最接近的元素"><a href="#找到K个最接近的元素" class="headerlink" title="找到K个最接近的元素"></a>找到K个最接近的元素</h2><p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。</p>
<h3 id="个人解法-2"><a href="#个人解法-2" class="headerlink" title="个人解法"></a>个人解法</h3><p>二分+双指针，由于insert性能糟糕</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 二分找下限</span></span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[m] &lt; x) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[l] != x &amp;&amp; l &gt;= <span class="number">1</span>) &#123; <span class="comment">// l修正为离x最近的元素</span></span><br><span class="line">            <span class="keyword">int</span> r1 = <span class="built_in">abs</span>(arr[l] - x);</span><br><span class="line">            <span class="keyword">int</span> r2 = <span class="built_in">abs</span>(arr[l - <span class="number">1</span>] - x);</span><br><span class="line">            l = (r1 &lt; r2) ? l : l - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r = l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= n - <span class="number">1</span> &amp;&amp; ans.<span class="built_in">size</span>() &lt; k) &#123; <span class="comment">// 从最近元素向两侧延申找结果</span></span><br><span class="line">            <span class="keyword">int</span> r1 = <span class="built_in">abs</span>(arr[l] - x);</span><br><span class="line">            <span class="keyword">int</span> r2 = <span class="built_in">abs</span>(arr[r] - x);</span><br><span class="line">            <span class="keyword">if</span> (r1 &lt;= r2) &#123;</span><br><span class="line">                ans.insert(ans.<span class="built_in">begin</span>(), arr[l]);</span><br><span class="line">                --l;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(arr[r]);</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &lt; k) &#123; <span class="comment">// 如果找到的元素还不够k</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果左侧达到上限，右侧全部纳入结果</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                    ans.push_back(arr[r]);</span><br><span class="line">                    ++r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r &gt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                    ans.insert(ans.<span class="built_in">begin</span>(), arr[l]);</span><br><span class="line">                    --l;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法优化-1"><a href="#解法优化-1" class="headerlink" title="解法优化"></a>解法优化</h3><p>解一定是原数组的一个子区间，直接二分法找到区间的起始下标即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x - arr[mid] &gt; arr[mid + k] - x)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(arr.<span class="built_in">begin</span>() + left, arr.<span class="built_in">begin</span>() + k + left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h1><h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>

<p>思路：依次选定一个由[2, n]的区间<code>len</code>，由中间向两侧递推dp得到该区间下的子串数。</p>
<p><a href="https://leetcode-cn.com/problems/palindromic-substrings/solution/c-dpjie-fa-by-hou-yong-sheng/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> dp[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == s[i]) dp[i - <span class="number">1</span>][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; v : dp) &#123;</span><br><span class="line">            ans = accumulate(v, v + n, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>

<p>顺向dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n]; <span class="comment">// 以nums[i]为结尾的最长升序长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;t : dp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &gt; ans) ans = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="最长递增子序列的个数"><a href="#最长递增子序列的个数" class="headerlink" title="最长递增子序列的个数"></a>最长递增子序列的个数</h2><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<p>与上一题结合，设置cnt数组进行逐个计数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n], cnt[n]; <span class="comment">// cnt[i]表示该处最长递增子序列的个数</span></span><br><span class="line">        <span class="keyword">int</span> tmp[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123; <span class="comment">// 更新一次序列，cnt与更新位相等</span></span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        cnt[i] = cnt[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i]) &#123; <span class="comment">// 找到了新的组合，cnt加上更新位</span></span><br><span class="line">                        cnt[i] += cnt[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; mLen) mLen = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == mLen) ans += cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a>预测赢家</h2><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p>
<p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
<h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>用到了<strong>相对分数</strong>的概念。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> <span class="built_in">turn</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">turn</span> * nums[l];</span><br><span class="line">        <span class="keyword">int</span> s1 = nums[l] * <span class="built_in">turn</span> + getScore(nums, l + <span class="number">1</span>, r, -<span class="built_in">turn</span>);</span><br><span class="line">        <span class="keyword">int</span> s2 = nums[r] * <span class="built_in">turn</span> + getScore(nums, l, r - <span class="number">1</span>, -<span class="built_in">turn</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(s1 * <span class="built_in">turn</span>, s2 * <span class="built_in">turn</span>) * <span class="built_in">turn</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScore(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="dp-1"><a href="#dp-1" class="headerlink" title="dp"></a>dp</h3><p><a href="https://leetcode-cn.com/problems/predict-the-winner/solution/bo-yi-dpmo-ban-san-chong-dpsi-lu-you-hua-kong-jian/" target="_blank" rel="noopener">参考题解</a></p>
<h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<h3 id="递归（官方题解）"><a href="#递归（官方题解）" class="headerlink" title="递归（官方题解）"></a>递归（官方题解）</h3><p>这个<code>string()</code>函数挺好的，直接把一串字母转换成字符串了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> src; </span><br><span class="line">    <span class="keyword">size_t</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDigits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; src.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(src[ptr])) &#123;</span><br><span class="line">            ret = ret * <span class="number">10</span> + src[ptr++] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr == src.<span class="built_in">size</span>() || src[ptr] == <span class="string">']'</span>) &#123;</span><br><span class="line">            <span class="comment">// String -&gt; EPS</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> cur = src[ptr]; <span class="keyword">int</span> repTime = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(cur)) &#123;</span><br><span class="line">            <span class="comment">// String -&gt; Digits [ String ] String</span></span><br><span class="line">            <span class="comment">// 解析 Digits</span></span><br><span class="line">            repTime = getDigits(); </span><br><span class="line">            <span class="comment">// 过滤左括号</span></span><br><span class="line">            ++ptr;</span><br><span class="line">            <span class="comment">// 解析 String</span></span><br><span class="line">            <span class="built_in">string</span> str = getString(); </span><br><span class="line">            <span class="comment">// 过滤右括号</span></span><br><span class="line">            ++ptr;</span><br><span class="line">            <span class="comment">// 构造字符串</span></span><br><span class="line">            <span class="keyword">while</span> (repTime--) ret += str; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(cur)) &#123;</span><br><span class="line">            <span class="comment">// String -&gt; Char String</span></span><br><span class="line">            <span class="comment">// 解析 Char</span></span><br><span class="line">            ret = <span class="built_in">string</span>(<span class="number">1</span>, src[ptr++]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret + getString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        src = s; <span class="comment">// 拷贝一份s</span></span><br><span class="line">        ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//string ans = "";</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; data; <span class="comment">// 存放括号内的数据</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rep; <span class="comment">// 存放repeat次数</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> cur = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                value = value * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">                rep.push(value);</span><br><span class="line">                data.push(cur);</span><br><span class="line">                value = <span class="number">0</span>;</span><br><span class="line">                cur = <span class="string">""</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &lt;= <span class="string">'z'</span> &amp;&amp; s[i] &gt;= <span class="string">'a'</span> || s[i] &lt;= <span class="string">'Z'</span> &amp;&amp; s[i] &gt;= <span class="string">'A'</span>) &#123;</span><br><span class="line">                cur += s[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> repeat = rep.top(); rep.pop(); <span class="comment">// 重复次数弹栈</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; repeat; ++i) &#123; <span class="comment">// 重复repeat次</span></span><br><span class="line">                    data.top() += cur;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = data.top();</span><br><span class="line">                data.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>字符串模拟栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.empty() &amp;&amp; s.back() == c) &#123;</span><br><span class="line">                s.pop_back();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.push_back(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="链表中的下一个更大节点"><a href="#链表中的下一个更大节点" class="headerlink" title="链表中的下一个更大节点"></a>链表中的下一个更大节点</h2><p><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="个人解法-3"><a href="#个人解法-3" class="headerlink" title="个人解法"></a>个人解法</h3><p>拷贝成数组，然后用单调递减栈原理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head-&gt;next) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            v.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(len)</span></span>;</span><br><span class="line">        ans[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mstk; <span class="comment">// 单调递减栈</span></span><br><span class="line">        mstk.push(v[len - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (mstk.empty()) &#123;</span><br><span class="line">                mstk.push(v[i]);</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[i] &lt; mstk.top()) &#123;</span><br><span class="line">                ans[i] = mstk.top();</span><br><span class="line">                mstk.push(v[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[i] &gt;= mstk.top()) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!mstk.empty() &amp;&amp; v[i] &gt;= mstk.top()) &#123;</span><br><span class="line">                    mstk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i] = (mstk.empty()) ? <span class="number">0</span> : mstk.top();</span><br><span class="line">                mstk.push(v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; ans[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="相对名次"><a href="#相对名次" class="headerlink" title="相对名次"></a>相对名次</h2><p>给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（”Gold Medal”, “Silver Medal”, “Bronze Medal”）。</p>
<p>(注：分数越高的选手，排名越靠前。)</p>
<h3 id="个人解法-4"><a href="#个人解法-4" class="headerlink" title="个人解法"></a>个人解法</h3><p>排序+hash</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRelativeRanks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums_ = nums;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [] (<span class="keyword">const</span> <span class="keyword">int</span> &amp;n1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n2) &#123;<span class="keyword">return</span> n1 &gt; n2;&#125;);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            m[nums[i]] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; nums[i] &lt;&lt; " " &lt;&lt; m[nums[i]] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> rank = m[nums_[i]];</span><br><span class="line">            <span class="keyword">if</span> (rank &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                ans.push_back(to_string(rank));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">3</span>) &#123;</span><br><span class="line">                ans.push_back(<span class="string">"Bronze Medal"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">2</span>) &#123;</span><br><span class="line">                ans.push_back(<span class="string">"Silver Medal"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(<span class="string">"Gold Medal"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h3><p>map自动排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">3</span>) <span class="keyword">return</span> to_string(n);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"Gold Medal"</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"Silver Medal"</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="string">"Bronze Medal"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRelativeRanks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;it : m) &#123;</span><br><span class="line">            ans[it.second] = getString(n--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分割数组为连续子序列"><a href="#分割数组为连续子序列" class="headerlink" title="分割数组为连续子序列"></a>分割数组为连续子序列</h2><p>给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。</p>
<p>如果可以完成上述分割，则返回 true ；否则，返回 false 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">你可以分割出这样两个连续子序列 : </span><br><span class="line">1, 2, 3</span><br><span class="line">3, 4, 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,4,5]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/solution/tan-xin-suan-fa-jian-cha-shu-zu-neng-fou-bei-fen-w/" target="_blank" rel="noopener">参考题解</a></p>
<p>贪心</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tail, cnt; <span class="comment">// tail表示以该元素为序列尾的序列个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            cnt[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[num] == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 没出现的不管</span></span><br><span class="line">            <span class="keyword">if</span> (cnt[num] &gt; <span class="number">0</span> &amp;&amp; tail[num - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果当前cnt不为0，且存在以前一个元素为尾的序列</span></span><br><span class="line">                cnt[num]--;</span><br><span class="line">                tail[num]++;</span><br><span class="line">                tail[num - <span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[num] &gt; <span class="number">0</span> &amp;&amp; cnt[num + <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[num + <span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 组成三连序列，优先级低于上侧的if</span></span><br><span class="line">                cnt[num]--;</span><br><span class="line">                cnt[num + <span class="number">1</span>]--;</span><br><span class="line">                cnt[num + <span class="number">2</span>]--;</span><br><span class="line">                tail[num + <span class="number">2</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="24点游戏"><a href="#24点游戏" class="headerlink" title="24点游戏"></a>24点游戏</h2><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 <code>*</code>，<code>/</code>，<code>+</code>，<code>-</code>，<code>(</code>，<code>)</code> 的运算得到 24。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4, 1, 8, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: (8-4) * (7-1) &#x3D; 24</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 1, 2]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<p>除法运算符 <code>/</code> 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p><a href="https://leetcode-cn.com/problems/24-game/solution/24-dian-you-xi-by-leetcode-solution/" target="_blank" rel="noopener">参考官方题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> TARGET = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> EPSLON = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> ADD = <span class="number">0</span>, MULTIPLY = <span class="number">1</span>, SUBTRACT = <span class="number">2</span>, DIVIDE = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgePoint24</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">            v.emplace_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fabs</span>(v[<span class="number">0</span>] - TARGET) &lt; EPSLON;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) &#123; <span class="comment">// 挑选两操作数</span></span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; lis = <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">size</span>; ++k) &#123; <span class="comment">// 剩余的操作数</span></span><br><span class="line">                        <span class="keyword">if</span> (k != j &amp;&amp; k != i) &#123;</span><br><span class="line">                            lis.emplace_back(v[k]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123; <span class="comment">// 被选召的操作数进行运算</span></span><br><span class="line">                        <span class="keyword">if</span> (k &lt; <span class="number">2</span> &amp;&amp; i &gt; j) &#123; <span class="comment">// 加乘可以交换律</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (k == ADD) &#123;</span><br><span class="line">                            lis.emplace_back(v[i] + v[j]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == MULTIPLY) &#123;</span><br><span class="line">                            lis.emplace_back(v[i] * v[j]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == SUBTRACT) &#123;</span><br><span class="line">                            lis.emplace_back(v[i] - v[j]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == DIVIDE) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[j]) &lt; EPSLON) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>; <span class="comment">// 跳过除0运算</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            lis.emplace_back(v[i] / v[j]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (solve(lis)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        lis.pop_back(); <span class="comment">// 如果这样不能解决，弹出回溯</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="将数据流变为多个不相交区间"><a href="#将数据流变为多个不相交区间" class="headerlink" title="将数据流变为多个不相交区间"></a>将数据流变为多个不相交区间</h2><p><a href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummaryRanges</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; intervals;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    SummaryRanges() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">newItv</span><span class="params">(&#123;val, val&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = intervals.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (it != intervals.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newItv[<span class="number">1</span>] + <span class="number">1</span> &lt; (*it)[<span class="number">0</span>]) &#123;</span><br><span class="line">                intervals.insert(it, newItv);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*it)[<span class="number">1</span>] + <span class="number">1</span> &lt; newItv[<span class="number">0</span>]) &#123;</span><br><span class="line">                it++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newItv[<span class="number">0</span>] = <span class="built_in">min</span>((*it)[<span class="number">0</span>], newItv[<span class="number">0</span>]); <span class="comment">// 更新左</span></span><br><span class="line">                newItv[<span class="number">1</span>] = <span class="built_in">max</span>((*it)[<span class="number">1</span>], newItv[<span class="number">1</span>]); <span class="comment">// 更新右</span></span><br><span class="line">                it = intervals.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        intervals.push_back(newItv);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getIntervals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法2（类似203次周赛题III）"><a href="#法2（类似203次周赛题III）" class="headerlink" title="法2（类似203次周赛题III）"></a>法2（类似203次周赛题III）</h3><p>平衡树</p>
<p><a href="https://www.acwing.com/solution/content/373/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummaryRanges</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; l, r;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    SummaryRanges() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 判断新添加的元素是否已经在某个区间内了</span></span><br><span class="line">            <span class="keyword">auto</span> it = r.upper_bound(val);</span><br><span class="line">            <span class="keyword">if</span> (it != r.<span class="built_in">begin</span>()) &#123; </span><br><span class="line">                it--; <span class="comment">// it为小于等于r的元素最后一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (val &lt;= it-&gt;second) &#123;</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 已经存在于区间中直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = l.count(val - <span class="number">1</span>), right = r.count(val + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 分三种情况讨论</span></span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="comment">// 左右均存在区间，此时将区间合并</span></span><br><span class="line">            <span class="comment">// 左端点右指针指向右端点 右端点左指针指向左端点</span></span><br><span class="line">            r[l[val - <span class="number">1</span>]] = r[val + <span class="number">1</span>];</span><br><span class="line">            l[r[val + <span class="number">1</span>]] = l[val - <span class="number">1</span>];</span><br><span class="line">            l.erase(val - <span class="number">1</span>); r.erase(val + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left) &#123;</span><br><span class="line">            <span class="comment">// 左存在 右不存在</span></span><br><span class="line">            r[l[val - <span class="number">1</span>]] = val;</span><br><span class="line">            l[val] = l[val - <span class="number">1</span>];</span><br><span class="line">            l.erase(val - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right) &#123;</span><br><span class="line">            <span class="comment">// 右存在 左不存在</span></span><br><span class="line">            l[r[val + <span class="number">1</span>]] = val;</span><br><span class="line">            r[val] = r[val + <span class="number">1</span>];</span><br><span class="line">            r.erase(val + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左右均不存在</span></span><br><span class="line">            l[val] = val;</span><br><span class="line">            r[val] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getIntervals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; tmp : r) &#123;</span><br><span class="line">            res.push_back(&#123;tmp.first, tmp.second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="在LR字符串中交换相邻字符"><a href="#在LR字符串中交换相邻字符" class="headerlink" title="在LR字符串中交换相邻字符"></a>在LR字符串中交换相邻字符</h2><p>在一个由 <code>&#39;L&#39;</code> , <code>&#39;R&#39;</code> 和 <code>&#39;X&#39;</code> 三个字符组成的字符串（例如<code>&quot;RXXLRXRXL&quot;</code>）中进行移动操作。一次移动操作指用一个<code>&quot;LX&quot;</code>替换一个<code>&quot;XL&quot;</code>，或者用一个<code>&quot;XR&quot;</code>替换一个<code>&quot;RX&quot;</code>。现给定起始字符串<code>start</code>和结束字符串<code>end</code>，请编写代码，当且仅当存在一系列移动操作使得<code>start</code>可以转换成<code>end</code>时， 返回<code>True</code>。</p>
<h3 id="个人解法（失败）-1"><a href="#个人解法（失败）-1" class="headerlink" title="个人解法（失败）"></a>个人解法（失败）</h3><p>企图模拟过程，没有抓住主要矛盾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canTransform</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">string</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = start.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; j &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start[i] == <span class="built_in">end</span>[j]) &#123;</span><br><span class="line">                ++i; ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">end</span>[j] == <span class="string">'L'</span> &amp;&amp; start[i] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; len &amp;&amp; start[i] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                        ++i;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">end</span>[i] != <span class="string">'X'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; len &amp;&amp; start[i] == <span class="string">'L'</span>) &#123;</span><br><span class="line">                        j = i + <span class="number">1</span>;</span><br><span class="line">                        i = j;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span>[j] == <span class="string">'X'</span> &amp;&amp; start[i] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; len &amp;&amp; <span class="built_in">end</span>[j] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                        ++j;</span><br><span class="line">                        <span class="keyword">if</span> (start[j] != <span class="string">'X'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; len &amp;&amp; <span class="built_in">end</span>[j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                        i = j + <span class="number">1</span>;</span><br><span class="line">                        j = i;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="答案解法"><a href="#答案解法" class="headerlink" title="答案解法"></a>答案解法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路分析： 题目的意思是说 ‘R’只能向右移动，并且只能移向’X’，‘L’只能向左移动，并且只能移向’X’。</span><br><span class="line"></span><br><span class="line">第一：如果将start、end中的‘X’全部去掉得到的newStart 和 newEnd相等才有可能转换成功。</span><br><span class="line">第二：如果start中&#39;R&#39;的左边&#39;X&#39;的个数超过在end中对应位置的&#39;R&#39;的左边&#39;X&#39;的个数，则不能转换成功，因为start中的&#39;R&#39;只能向右移动，右边的&#39;X&#39;只能增加不能减少</span><br><span class="line">第三：如果end中&#39;L&#39;的左边&#39;X&#39;的个数超过在start中对应位置的&#39;L&#39;的左边&#39;X&#39;的个数，则不能转换成功，因为start中的&#39;L&#39;只能向左移动，左边的&#39;X&#39;只能减少不能增加</span><br></pre></td></tr></table></figure>

<p>原来只需考虑个数即可，将三种不满足的情况排除就是<code>true</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canTransform</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">string</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = start.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; j &lt; len) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len &amp;&amp; start[i] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len &amp;&amp; <span class="built_in">end</span>[j] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (start[i] != <span class="built_in">end</span>[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> ((start[i] == <span class="string">'L'</span> &amp;&amp; i &lt; j) || (<span class="built_in">end</span>[j] == <span class="string">'R'</span> &amp;&amp; i &gt; j)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ++i; </span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; i == <span class="string">'X'</span>) ++i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len &amp;&amp; j == <span class="string">'X'</span>) ++j;</span><br><span class="line">        <span class="keyword">if</span> (i != j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="合并账户"><a href="#合并账户" class="headerlink" title="合并账户"></a>合并账户</h2><p><a href="https://leetcode-cn.com/problems/accounts-merge/" target="_blank" rel="noopener">题目链接</a></p>
<p>并查集解法 <a href="https://leetcode-cn.com/problems/accounts-merge/solution/zhi-nan-shen-mei-de-cbing-cha-ji-shi-xian-fang-fa-/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father; <span class="comment">// key:name val:father</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; emFather; <span class="comment">// key:email val:father</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">            x = father[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = findFather(a), fb = findFather(b);</span><br><span class="line">        <span class="keyword">if</span> (fa != fb) &#123;</span><br><span class="line">            father[fa] = fb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">accountsMerge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> len = accounts.<span class="built_in">size</span>();</span><br><span class="line">        father.resize(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) father[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; accounts[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 逐行遍历accounts数据</span></span><br><span class="line">                <span class="keyword">if</span> (emFather.count(accounts[i][j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果之前还没遍历到这个email</span></span><br><span class="line">                    emFather[accounts[i][j]] = i; <span class="comment">// 将其father修改成第一个遇到的人名</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果之前遍历到过这个email，证明它的父亲已经出现过了，并查集合并两个父亲</span></span><br><span class="line">                    merge(i, emFather[accounts[i][j]]); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; nameToEm; <span class="comment">// key:name val:emails</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = findFather(i); <span class="comment">// 获取现在这个人名的真实父亲</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; accounts[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 遍历这个人名的所有email数据，将其加入到自带查重的hash表中</span></span><br><span class="line">                nameToEm[t].insert(accounts[i][j]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 遍历nameToEm，得到结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item : nameToEm) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">            v.push_back(accounts[item.first][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;em : item.second) &#123;</span><br><span class="line">                v.push_back(em);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="乘积为正数的最长子数组长度"><a href="#乘积为正数的最长子数组长度" class="headerlink" title="乘积为正数的最长子数组长度"></a>乘积为正数的最长子数组长度</h2><p>给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。</p>
<p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p>
<p>请你返回乘积为正数的最长子数组长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历一遍之后得到0的位置</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">// 指示正负数，默认为正</span></span><br><span class="line">        <span class="keyword">int</span> first_neg = <span class="number">-1</span>; <span class="comment">// 区间第一个负数下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) flag *= (<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果区间积为正，更新ans</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果区间积为负</span></span><br><span class="line">                    <span class="keyword">if</span> (first_neg &gt;= <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, i - first_neg);</span><br><span class="line">                    <span class="keyword">else</span> first_neg = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                first_neg = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="第k个排列"><a href="#第k个排列" class="headerlink" title="第k个排列"></a>第k个排列</h2><p>给出集合 <code>[1,2,3,…,*n*]</code>，其所有元素共有 <em>n</em>! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记。</p>
<p>给定n和k，返回第k个排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求n!</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ans *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> to_string(nums[<span class="number">0</span>]); <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">int</span> grLen = f(len - <span class="number">1</span>); <span class="comment">// 求组长度</span></span><br><span class="line">        <span class="keyword">int</span> gr = k / grLen + <span class="number">1</span>; <span class="comment">// 当前元素在第几组</span></span><br><span class="line">        <span class="keyword">if</span> (k % grLen == <span class="number">0</span>) gr--; <span class="comment">// 组末位修正</span></span><br><span class="line">        <span class="keyword">int</span> tmp = nums[gr - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>();</span><br><span class="line">        advance(it, gr - <span class="number">1</span>); </span><br><span class="line">        nums.erase(it);</span><br><span class="line">        <span class="keyword">int</span> nexOrder = k % grLen; <span class="comment">// 下一个相对位置</span></span><br><span class="line">        <span class="keyword">if</span> (!nexOrder) nexOrder = grLen;</span><br><span class="line">        <span class="keyword">return</span> to_string(tmp) + helper(nums, nexOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cur</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cur[i - <span class="number">1</span>] = i;</span><br><span class="line">        <span class="keyword">return</span> helper(cur, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT日记III</title>
    <url>/2021/02/17/PAT%E6%97%A5%E8%AE%B0III/</url>
    <content><![CDATA[<p>PAT日记III</p>
<a id="more"></a>

<h1 id="1022-Digital-Library"><a href="#1022-Digital-Library" class="headerlink" title="1022 Digital Library"></a><strong>1022 Digital Library</strong></h1><p>题目大意：给出如下的信息输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N --- 图书总数</span><br><span class="line">(下面跟N*6行，每组内容如下)</span><br><span class="line">1. id</span><br><span class="line">2. 图书标题</span><br><span class="line">3. 作者</span><br><span class="line">4. 关键词(不多于5个)</span><br><span class="line">5. 发布者</span><br><span class="line">6. 发布时间</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">M -- 查询总数</span><br><span class="line">(下面跟M行，每行都给定一个编号代表查询方式，然后给定一个信息，输出所有符合该信息的id号)</span><br></pre></td></tr></table></figure>

<p>考点：</p>
<ul>
<li><p>cin读取一行为整个字符串的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> strOfThatLine;</span><br><span class="line">getline(<span class="built_in">cin</span>, strOfThatLine);</span><br></pre></td></tr></table></figure>
</li>
<li><p>cin读取一行中不确定长度的几个字符串的方法（关键词读取方法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> keyword[maxN];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; keyword[i++]) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = gethchar();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><a href="https://www.liuchuo.net/archives/2295" target="_blank" rel="noopener">参考blog</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt; <span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; title, author, key, pub, year;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="built_in">unordered_map</span>&lt; <span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;m, <span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.<span class="built_in">find</span>(str) != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = m[str].<span class="built_in">begin</span>(); it != m[str].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%07d\n"</span>, *it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Found\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, id, num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">string</span> ttitle, tauthor, tkey, tpub, tyear;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>, &amp;id);</span><br><span class="line">        getline(<span class="built_in">cin</span>, ttitle);</span><br><span class="line">        title[ttitle].insert(id);</span><br><span class="line">        getline(<span class="built_in">cin</span>, tauthor);</span><br><span class="line">        author[tauthor].insert(id);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; tkey) &#123;</span><br><span class="line">            key[tkey].insert(id);</span><br><span class="line">            <span class="keyword">char</span> c = getchar();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getline(<span class="built_in">cin</span>, tpub);</span><br><span class="line">        pub[tpub].insert(id);</span><br><span class="line">        getline(<span class="built_in">cin</span>, tyear);</span><br><span class="line">        year[tyear].insert(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d: "</span>, &amp;num);</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        getline(<span class="built_in">cin</span>, tmp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">": "</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) query(title, tmp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) query(author, tmp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">3</span>) query(key, tmp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">4</span>) query(pub, tmp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">5</span>) query(year, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1034-Head-of-a-Gang"><a href="#1034-Head-of-a-Gang" class="headerlink" title="1034 Head of a Gang"></a><strong>1034 Head of a Gang</strong></h1><p>题目大意：根据通话记录（无向图）抓土匪头子。根据给定的边、权值信息，获取以下信息：</p>
<ul>
<li>cluster的个数</li>
<li>每一个团是否满足：至少三人且权值和超过k</li>
<li>每一个团的通话时间最多之人为头目</li>
</ul>
<p>要求输出团的个数，每个团的人数和头目姓名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2010</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; nameToId;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; idToName;</span><br><span class="line"><span class="keyword">int</span> father[maxN];</span><br><span class="line"><span class="keyword">int</span> sumMins[maxN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != father[x]) &#123;</span><br><span class="line">        father[x] = <span class="built_in">find</span>(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">int</span> fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">        father[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">INF</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> numOfMem = <span class="number">0</span>, maxWeight = <span class="number">0</span>, maxWeightIdx = <span class="number">-1</span>, sumWeight = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Prt</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">INF ans[maxN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">string</span> u, v;</span><br><span class="line">    <span class="keyword">int</span> mins;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) father[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; mins;</span><br><span class="line">        <span class="keyword">if</span> (nameToId.<span class="built_in">find</span>(u) == nameToId.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            nameToId[u] = id++;</span><br><span class="line">            idToName.push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nameToId.<span class="built_in">find</span>(v) == nameToId.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            nameToId[v] = id++;</span><br><span class="line">            idToName.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        sumMins[nameToId[u]] += mins;</span><br><span class="line">        sumMins[nameToId[v]] += mins;</span><br><span class="line">        Union(nameToId[u], nameToId[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa = <span class="built_in">find</span>(i);</span><br><span class="line">        ans[fa].sumWeight += sumMins[i];</span><br><span class="line">        ans[fa].numOfMem++;</span><br><span class="line">        <span class="keyword">if</span> (sumMins[i] &gt; ans[fa].maxWeight) &#123;</span><br><span class="line">            ans[fa].maxWeight = sumMins[i];</span><br><span class="line">            ans[fa].maxWeightIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Prt&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i].numOfMem &gt; <span class="number">2</span> &amp;&amp; ans[i].sumWeight &gt; <span class="number">2</span> * k) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            Prt tmp;</span><br><span class="line">            tmp.id = idToName[ans[i].maxWeightIdx];</span><br><span class="line">            tmp.num = ans[i].numOfMem;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    sort(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), [](Prt &amp;p1, Prt &amp;p2)&#123;<span class="keyword">return</span> p1.id &lt; p2.id;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i].id &lt;&lt; <span class="string">" "</span> &lt;&lt; res[i].num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并查集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 7</span><br><span class="line">2 6</span><br><span class="line">-1 -3</span><br><span class="line">1 -2</span><br></pre></td></tr></table></figure>



<h1 id="1038-Recover-the-Smallest-Number"><a href="#1038-Recover-the-Smallest-Number" class="headerlink" title="1038 Recover the Smallest Number"></a>1038 Recover the Smallest Number</h1><p>题目大意：给你一串电话号码的每个部分，将其组合成一个最小的数输出。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32-321-3214-0229-87</span><br><span class="line">的最小组合为</span><br><span class="line">22932132143287</span><br></pre></td></tr></table></figure>

<p>注意删掉前导零。</p>
<p>思路：</p>
<ol>
<li>排序逻辑：<ul>
<li>首先按字符串<code>alphabetic order</code>排序。</li>
<li><strong>当位数不同，且有相同前缀时，将两字符串前后组合，找出最小的组合。</strong></li>
</ul>
</li>
<li>前导零要等组成最后字符串ans后再删去，因为电话号码中可能有多个<code>000</code>，<code>000...</code>这样的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1 = s1.<span class="built_in">size</span>(), l2 = s2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; l1 &amp;&amp; p &lt; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[p] != s2[p]) <span class="keyword">return</span> s1[p] &lt; s2[p];</span><br><span class="line">        <span class="keyword">else</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> sa = s1 + s2;</span><br><span class="line">    <span class="built_in">string</span> sb = s2 + s1;</span><br><span class="line">    <span class="keyword">return</span> sa &lt; sb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">lis</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; lis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(lis.<span class="built_in">begin</span>(), lis.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lis.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        ans += lis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] != <span class="string">'0'</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ans[p] == <span class="string">'0'</span>) ++p;</span><br><span class="line">        ans.erase(<span class="number">0</span>, p);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1043-Is-It-a-Binary-Search-Tree"><a href="#1043-Is-It-a-Binary-Search-Tree" class="headerlink" title="1043 Is It a Binary Search Tree"></a><strong>1043 Is It a Binary Search Tree</strong></h1><p>题目大意：根据题目给定的序列判定它是否是一株BST或者镜像BST的前序遍历结果，并给出后序遍历。</p>
<h2 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h2><ol>
<li>分别通过排序得到序列的顺序和逆序序列做为树的中序遍历数组。</li>
<li>尝试构建二叉树，构建方法为前序中序结合。</li>
</ol>
<p>失败。。。因为题目给定的序列中可能有重复的数字，此时前序中序结合建树的方法将由于重复数字的二义性失败。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, in[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> flag1 = <span class="literal">true</span>, flag2 = <span class="literal">true</span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr - pl + <span class="number">1</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(pre[pl]);</span><br><span class="line">    <span class="keyword">int</span> p = il;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= ir &amp;&amp; in[idx][p] != pre[pl]) ++p;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; ir) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">0</span>) flag1 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">1</span>) flag2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = build(pl + <span class="number">1</span>, pl + p - il, il, p - <span class="number">1</span>, idx);</span><br><span class="line">    root-&gt;right = build(pl + p - il + <span class="number">1</span>, pr, p + <span class="number">1</span>, ir, idx);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        postorder(root-&gt;left, ans);</span><br><span class="line">        postorder(root-&gt;right, ans);</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    pre.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    in[<span class="number">0</span>] = pre;</span><br><span class="line">    in[<span class="number">1</span>] = pre;</span><br><span class="line">    sort(in[<span class="number">0</span>].<span class="built_in">begin</span>(), in[<span class="number">0</span>].<span class="built_in">end</span>());</span><br><span class="line">    sort(in[<span class="number">1</span>].<span class="built_in">begin</span>(), in[<span class="number">1</span>].<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    TreeNode *root1 = build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    TreeNode *root2 = build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!flag1 &amp;&amp; !flag2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (flag1) &#123;</span><br><span class="line">            postorder(root1, ans);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            postorder(root2, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, ans[i], i == n - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="柳神解法"><a href="#柳神解法" class="headerlink" title="柳神解法"></a>柳神解法</h2><p>将前序和BST两个条件作为已知直接构建后序遍历数组，若最后<code>size != n</code>则失败。</p>
<p>重点逻辑：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = root + <span class="number">1</span>, j = tail; <span class="comment">// i为右子树的前序遍历结果的头部，j为左子树前序遍历结果的尾部</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= tail &amp;&amp; pre[root] &gt; pre[i]) ++i;</span><br><span class="line"><span class="keyword">while</span> (j &gt; root &amp;&amp; pre[root] &lt;= pre[j]) --j;</span><br></pre></td></tr></table></figure>

<p>源代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> isMirror = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, post;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpost</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root &gt; tail) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = root + <span class="number">1</span>, j = tail;</span><br><span class="line">    <span class="keyword">if</span> (!isMirror) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= tail &amp;&amp; pre[root] &gt; pre[i]) ++i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; root &amp;&amp; pre[root] &lt;= pre[j]) --j;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= tail &amp;&amp; pre[root] &lt;= pre[i]) ++i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; root &amp;&amp; pre[root] &gt; pre[j]) --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i - j != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    getpost(root + <span class="number">1</span>, j);</span><br><span class="line">    getpost(i, tail);</span><br><span class="line">    post.push_back(pre[root]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    pre.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">    getpost(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (post.<span class="built_in">size</span>() != n) &#123;</span><br><span class="line">        isMirror = <span class="literal">true</span>;</span><br><span class="line">        post.<span class="built_in">clear</span>();</span><br><span class="line">        getpost(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (post.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, post[i], i == n - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1044-Shopping-in-Mars"><a href="#1044-Shopping-in-Mars" class="headerlink" title="1044 Shopping in Mars"></a><strong>1044 Shopping in Mars</strong></h1><p>题目大意：截断一个项链，使得这段连续的珠宝价格的总和花费最少，且一定要超过m，求这些片段。</p>
<h2 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h2><p>前缀和$O(n^2)$，有部分超时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INT_MAX = <span class="number">1e9</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inf, pre;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    inf.resize(n);</span><br><span class="line">    pre.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] += (pre[i - <span class="number">1</span>] + inf[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">max</span>(INT_MAX, m);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = pre[j] - pre[i];</span><br><span class="line">            <span class="keyword">if</span> (cur == m) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                ans = m;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; m) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, cur);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[j] - pre[i] == ans) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d-%d\n"</span>, i + <span class="number">1</span>, j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="柳神解法-1"><a href="#柳神解法-1" class="headerlink" title="柳神解法"></a>柳神解法</h2><p>在前缀和数组里面进行二分查找。$O(nlog_2n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> &amp;j, <span class="keyword">int</span> &amp;tmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = i, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pre[mid] - pre[i - <span class="number">1</span>] &gt;= m) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    j = r;</span><br><span class="line">    tmp = pre[j] - pre[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    pre.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">        pre[i] += pre[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = pre[n];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ansArr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, tmp;</span><br><span class="line">        bs(i, j, tmp);</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; ans) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; ans) &#123;</span><br><span class="line">                ans = tmp;</span><br><span class="line">                ansArr.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123;i, j&#125;;</span><br><span class="line">            ansArr.push_back(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansArr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-%d\n"</span>, ansArr[i][<span class="number">0</span>], ansArr[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1045-Favorite-Color-Stripe"><a href="#1045-Favorite-Color-Stripe" class="headerlink" title="1045 Favorite Color Stripe"></a>1045 Favorite Color Stripe</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52254507" target="_blank" rel="noopener">参考题解</a></p>
<p>最长上升子序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, tmp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    vector&lt;int&gt; lis(n + 1, 0), stripe;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        lis[tmp] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (lis[tmp]) &#123;</span><br><span class="line">            stripe.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[k];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stripe.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lis[stripe[i]] &gt;= lis[stripe[j]]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(dp[i], ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1047-Student-List-for-Course"><a href="#1047-Student-List-for-Course" class="headerlink" title="1047 Student List for Course"></a><strong>1047 Student List for Course</strong></h1><p>题目大意：给定每个学生的选课情况，输出选xx课程的所有学生姓名。</p>
<p>这题不能用cin cout读取输出字符串，而是要用传统的c的方式开char二维数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; info;</span><br><span class="line"><span class="keyword">char</span> idToName[<span class="number">40010</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(idToName[a], idToName[b]) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> nam;</span><br><span class="line">    <span class="keyword">int</span> num, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    info.resize(m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d"</span>, &amp;idToName[id++], &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">            info[num].push_back(id - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, info[i].<span class="built_in">size</span>());</span><br><span class="line">        sort(info[i].<span class="built_in">begin</span>(), info[i].<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; info[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, idToName[info[i][j]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1049-Counting-Ones"><a href="#1049-Counting-Ones" class="headerlink" title="1049 Counting Ones"></a>1049 Counting Ones</h1><p>题目大意：数从1到n中所有数含”1”的总数。</p>
<h2 id="个人解法-2"><a href="#个人解法-2" class="headerlink" title="个人解法"></a>个人解法</h2><p>暴力+记忆化，超时两个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, num_ = num;</span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; maxn &amp;&amp; arr[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">            ret += arr[num];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num_ &lt; maxn) arr[num_] = ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">fill</span>(arr, arr + maxn, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans += cnt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><p><a href="https://blog.csdn.net/CV_Jason/article/details/85112495" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** @Brief:No.1049 of PAT advanced level.</span></span><br><span class="line"><span class="comment">** @Author:Jason.Lee</span></span><br><span class="line"><span class="comment">** @Date:2018-12-20</span></span><br><span class="line"><span class="comment">** @Solution: Accepted!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, left, right;</span><br><span class="line">    <span class="keyword">while</span> (n / a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = n / a % <span class="number">10</span>;</span><br><span class="line">        left = n / (a * <span class="number">10</span>);</span><br><span class="line">        right = n%a;</span><br><span class="line">        <span class="keyword">if</span> (now == <span class="number">0</span>)ans += left*a;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (now == <span class="number">1</span>)ans += left*a + <span class="number">1</span> + right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (now &gt; <span class="number">1</span>)ans += (left + <span class="number">1</span>)*a;</span><br><span class="line">        a *= <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1064-Complete-Binary-Search-Tree"><a href="#1064-Complete-Binary-Search-Tree" class="headerlink" title="1064 Complete Binary Search Tree"></a>1064 Complete Binary Search Tree</h1><p>题目大意：构建一株满足BST和CBT的树，并给出层序遍历。</p>
<h2 id="个人解法-3"><a href="#个人解法-3" class="headerlink" title="个人解法"></a>个人解法</h2><p>傻fufu的构造完全二叉树（从上至下）逐一寻找根节点分治解题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr, tree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>, len = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">pow</span>(<span class="number">2</span>, k) - <span class="number">1</span>) &lt;= len) &#123;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    --k;</span><br><span class="line">    <span class="keyword">int</span> bottomNum = len - <span class="built_in">pow</span>(<span class="number">2</span>, k) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> bottomMaxNum = <span class="built_in">pow</span>(<span class="number">2</span>, k);</span><br><span class="line">    <span class="keyword">int</span> tmp = bottomNum &gt; bottomMaxNum / <span class="number">2</span> ? bottomMaxNum / <span class="number">2</span>: bottomNum;</span><br><span class="line">    <span class="keyword">int</span> i = l + tmp + (<span class="built_in">pow</span>(<span class="number">2</span>, k - <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">    tree[idx] = arr[i];</span><br><span class="line">    build(idx * <span class="number">2</span>, l, i - <span class="number">1</span>);</span><br><span class="line">    build(idx * <span class="number">2</span> + <span class="number">1</span>, i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    arr.resize(n);</span><br><span class="line">    tree.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">    sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, tree[i], (i == n) ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="柳神解法-2"><a href="#柳神解法-2" class="headerlink" title="柳神解法"></a>柳神解法</h2><p>用递归（中序遍历）的思想解题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">1010</span>], level[<span class="number">1010</span>], n, t = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root &gt;= n) <span class="keyword">return</span> ;</span><br><span class="line">    inOrder(root * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    level[root] = in[t++];</span><br><span class="line">    inOrder(root * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">    sort(in, in + n);</span><br><span class="line">    inOrder(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, level[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, level[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1051-Pop-Sequence"><a href="#1051-Pop-Sequence" class="headerlink" title="1051 Pop Sequence"></a>1051 Pop Sequence</h1><p>题目大意：入栈顺序为1-n，出栈顺序随机。求序列是否可以由该规则出栈得到。</p>
<h2 id="个人解法-4"><a href="#个人解法-4" class="headerlink" title="个人解法"></a>个人解法</h2><p>模拟堆栈，部分案例失败，不知道哪没想到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>; <span class="comment">// 指向当前待加入堆栈的元素指针</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stk.empty()) &#123;</span><br><span class="line">            <span class="comment">// 如果当前栈为空，从当前p指针开始将小于当前元素的数依次进栈</span></span><br><span class="line">            <span class="keyword">while</span> (p &lt;= arr[i]) &#123;</span><br><span class="line">                stk.push(p++);</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">size</span>() &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.pop(); <span class="comment">// 将当前元素出栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == stk.top()) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; stk.top()) &#123;</span><br><span class="line">                <span class="comment">// 当前元素大于栈顶元素，操作为先入栈再出栈，序列指针前移一位</span></span><br><span class="line">                ++p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前元素小于栈顶元素</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.empty() &amp;&amp; p == n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    arr.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">0</span>; time &lt; k; ++time) &#123;</span><br><span class="line">        arr.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">        <span class="keyword">if</span> (check()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p><a href="https://www.cnblogs.com/keep23456/p/12323317.html" target="_blank" rel="noopener">参考题解</a></p>
<h3 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h3><p>抓住不变量：入栈顺序固定，使得逻辑简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;<span class="comment">//k次查询</span></span><br><span class="line">        <span class="keyword">while</span> (!st.empty())<span class="comment">//栈非空，就清空栈</span></span><br><span class="line">            st.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//读入数据</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">1</span>; <span class="comment">//指向出栈序列中的待出栈元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag == <span class="literal">true</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">size</span>() == m) &#123; <span class="comment">//栈满</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">            <span class="comment">//栈顶元素与出栈序列当前位置的元素相同时 </span></span><br><span class="line">            <span class="keyword">while</span> (!st.empty() &amp;&amp; st.top() == a[current]) &#123;</span><br><span class="line">                st.pop();<span class="comment">//循环弹出并令current++ </span></span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span> &amp;&amp; st.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>); <span class="comment">//栈空且入栈过程中始终不超出栈的容量</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h3><p>利用结论：<strong>出栈序列中每个元素的后面的所有比它小的元素，一定可以组成一个递减序列并且该序列中的元素个数一定小于栈的最大容量。</strong></p>
<h1 id="1067-Sort-With-Swap-0-i"><a href="#1067-Sort-With-Swap-0-i" class="headerlink" title="1067 Sort With Swap(0, i)"></a>1067 Sort With Swap(0, i)</h1><p>题目大意：给定数组里面只含有<code>[0, 1, .. N - 1]</code>的无序序列。求只交换数字0和其他数字使得数组有序的最小步骤。</p>
<p>思路：贪心。</p>
<p>存储每个元素的位置<code>pos[i]</code>。从头开始枚举第i个位置，如果该位置所在的数已经在正确的位置上，跳过。否则，将0不断与应该在当前0所在位置的数进行交换，直到0回到第0个位置，此时如果当前枚举的该位置所在数仍不满足<code>pos[i] == i</code>将0与其进行交换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tmp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        pos[tmp] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos[i] != i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pos[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                swap(pos[<span class="number">0</span>], pos[pos[<span class="number">0</span>]]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pos[i] != i) &#123;</span><br><span class="line">                swap(pos[i], pos[<span class="number">0</span>]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1068-Find-More-Coins"><a href="#1068-Find-More-Coins" class="headerlink" title="1068 Find More Coins"></a>1068 Find More Coins</h1><p>题目大意：从n个硬币组合中找出总和为m的最小序列。</p>
<h2 id="个人解法-5"><a href="#个人解法-5" class="headerlink" title="个人解法"></a>个人解法</h2><p>dfs，最后一个超时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cpy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) ret.push_back(a[i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printF</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == a.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> choose, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cur, <span class="keyword">int</span> curSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curSum == m) &#123;</span><br><span class="line">        <span class="comment">//printF(ans);</span></span><br><span class="line">        <span class="keyword">if</span> (ans.empty()) &#123;</span><br><span class="line">            ans = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(cur, ans)) ans = cpy(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; n || curSum &gt; m) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (choose) cur.push_back(arr[idx]);</span><br><span class="line">    dfs(idx + <span class="number">1</span>, <span class="number">1</span>, cur, curSum + choose * arr[idx]);</span><br><span class="line">    dfs(idx + <span class="number">1</span>, <span class="number">0</span>, cur, curSum + choose * arr[idx]);</span><br><span class="line">    <span class="keyword">if</span> (choose) cur.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr, arr + n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1, arr2;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">1</span>, arr2, <span class="number">0</span>);</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, arr1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, ans[i], i == ans.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="柳神解法-3"><a href="#柳神解法-3" class="headerlink" title="柳神解法"></a>柳神解法</h2><p>01背包模板，先将硬币倒序排序，保证序列最后为最小。每次更新（选择背包的时候标注choice数组），最后从<code>choice[n][m]</code>向前回溯得到路径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10010</span>], w[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">bool</span> choice[<span class="number">10010</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">    sort(w + <span class="number">1</span>, w + n + <span class="number">1</span>, cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= w[i]; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &lt;= dp[j-w[i]] + w[i]) &#123;</span><br><span class="line">                choice[i][j] = <span class="literal">true</span>;</span><br><span class="line">                dp[j] = dp[j-w[i]] + w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[m] != m) <span class="built_in">printf</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> v = m, index = n;</span><br><span class="line">        <span class="keyword">while</span>(v &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(choice[index][v] == <span class="literal">true</span>) &#123;</span><br><span class="line">                arr.push_back(w[index]);</span><br><span class="line">                v -= w[index];</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1072-Gas-Station"><a href="#1072-Gas-Station" class="headerlink" title="1072 Gas Station"></a>1072 Gas Station</h1><p>题目大意：给出m个加油站的潜在位置和n个用户区的位置，要求选出一个最佳位置使得该位置到用户区的最小距离最大，同时到所有用户区的位置都应该在管辖范围之内。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, Ds;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxWeight = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">1020</span>][<span class="number">1020</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1020</span>], ismin[<span class="number">1020</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; Ds;</span><br><span class="line">    <span class="built_in">fill</span>(weight[<span class="number">0</span>], weight[<span class="number">0</span>] + <span class="number">1020</span> * <span class="number">1020</span>, maxWeight);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1020</span>; ++i) weight[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> u, v;</span><br><span class="line">    <span class="keyword">int</span> U, V, d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d;</span><br><span class="line">        <span class="keyword">if</span> (u[<span class="number">0</span>] == <span class="string">'G'</span>) &#123;</span><br><span class="line">            U = n + stoi(u.substr(<span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            U = stoi(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="string">'G'</span>) &#123;</span><br><span class="line">            V = n + stoi(v.substr(<span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V = stoi(v);</span><br><span class="line">        &#125;</span><br><span class="line">        weight[U][V] = weight[V][U] = <span class="built_in">min</span>(d, weight[U][V]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ansId = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span> ansMin = <span class="number">-1</span>, ansAvg = maxWeight;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; ++i) &#123; <span class="comment">// 枚举每一个加油站候选地</span></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">double</span> minDis = maxWeight, curAvg = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fill</span>(dis, dis + <span class="number">1020</span>, maxWeight);</span><br><span class="line">        <span class="built_in">fill</span>(ismin, ismin + <span class="number">1020</span>, <span class="number">0</span>);</span><br><span class="line">        dis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> times = <span class="number">1</span>; times &lt;= n + m; ++times) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> curMinDis = maxWeight;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ismin[j] == <span class="number">0</span> &amp;&amp; dis[j] &lt; curMinDis) &#123;</span><br><span class="line">                    u = j;</span><br><span class="line">                    curMinDis = dis[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curMinDis == maxWeight) <span class="keyword">break</span>;</span><br><span class="line">            ismin[u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ismin[j] == <span class="number">0</span> &amp;&amp; dis[j] &gt; dis[u] + weight[u][j]) &#123;</span><br><span class="line">                    dis[j] = dis[u] + weight[u][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="comment">// 遍历得到到房子的最短距离</span></span><br><span class="line">            <span class="keyword">if</span> (dis[j] &gt; Ds) &#123;</span><br><span class="line">                minDis = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dis[j] &lt; minDis) minDis = dis[j];</span><br><span class="line">            curAvg += (<span class="number">1.0</span>) * dis[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minDis == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        curAvg = curAvg / n;</span><br><span class="line">        <span class="keyword">if</span> (minDis &gt; ansMin) &#123;</span><br><span class="line">            ansAvg = curAvg;</span><br><span class="line">            ansMin = minDis;</span><br><span class="line">            ansId = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minDis == ansMin &amp;&amp; curAvg &lt; ansAvg) &#123;</span><br><span class="line">            ansAvg = curAvg;</span><br><span class="line">            ansId = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ansId == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"G%d\n"</span>, ansId - n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1lf %.1lf\n"</span>, ansMin, ansAvg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="1074-Reversing-Linked-List"><a href="#1074-Reversing-Linked-List" class="headerlink" title="1074 Reversing Linked List"></a>1074 Reversing Linked List</h1><p>题目大意：将链表的每k个元素进行逆转，如果剩余未逆转序列小于k则不逆转，输出链表的地址和数据信息。</p>
<p>注意：链表中不一定所有结点都有效，最后的n应该是实际有效的n。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> address, val, next;</span><br><span class="line">&#125;;</span><br><span class="line">node lis[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> start, n, k;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; arr, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    node tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;tmp.address, &amp;tmp.val, &amp;tmp.next);</span><br><span class="line">        lis[tmp.address] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = start;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        arr.push_back(lis[p]);</span><br><span class="line">        p = lis[p].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> group = arr.<span class="built_in">size</span>() / k, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; group) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt * k - <span class="number">1</span>; i &gt;= cnt * k - k; --i) &#123;</span><br><span class="line">            ans.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">size</span>() != arr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.<span class="built_in">size</span>(); i &lt; arr.<span class="built_in">size</span>(); ++i) ans.push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>, ans[i].address, ans[i].val, ans[i + <span class="number">1</span>].address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>, ans[arr.<span class="built_in">size</span>() - <span class="number">1</span>].address, ans[arr.<span class="built_in">size</span>() - <span class="number">1</span>].val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1076-Forwards-on-Weibo"><a href="#1076-Forwards-on-Weibo" class="headerlink" title="1076 Forwards on Weibo"></a>1076 Forwards on Weibo</h1><p>题目大意：给出用户互关有向图，求某用户的推文的最多被转发次数（层数限制在$l$以内）</p>
<p>BFS+vis数组标记+set去重</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, l, m, tmp, k, q;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; graph[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    q.push(start);</span><br><span class="line">    vis[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lev++ &lt;= l &amp;&amp; !q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (lev != <span class="number">1</span>) &#123;</span><br><span class="line">                s.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[tmp].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[graph[tmp][j]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(graph[tmp][j]);</span><br><span class="line">                    vis[graph[tmp][j]] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(vis, vis + <span class="number">1005</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            graph[tmp].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, BFS(q));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1079-Total-Sales-of-Supply-Chain"><a href="#1079-Total-Sales-of-Supply-Chain" class="headerlink" title="1079 Total Sales of Supply Chain"></a>1079 Total Sales of Supply Chain</h1><p>题目大意：求出供应商-经销商-零售商销售商品的总和价格。</p>
<p><strong>注意：递归过程会损失精度？最后根据叶节点的深度dep进行幂次方运算的答案是保证正确的。</strong></p>
<h2 id="个人解法-6"><a href="#个人解法-6" class="headerlink" title="个人解法"></a>个人解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, tmp;</span><br><span class="line"><span class="keyword">double</span> p, r;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; graph;</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">INF</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> type = <span class="number">1</span>; <span class="comment">// 0 supplier 1 distributor 2 retailer</span></span><br><span class="line">    <span class="keyword">double</span> numOfProduct = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">INF lis[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">double</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lis[idx].type == <span class="number">2</span>) &#123;</span><br><span class="line">        ans += cur * (<span class="keyword">double</span>)lis[idx].numOfProduct;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[idx].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        dfs(graph[idx][i], cur * (<span class="number">1.0</span> + <span class="number">0.01</span> * r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; r;</span><br><span class="line">    graph.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            lis[i].type = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;lis[i].numOfProduct);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">                graph[i].push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lis[<span class="number">0</span>].type = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="柳神解法-4"><a href="#柳神解法-4" class="headerlink" title="柳神解法"></a>柳神解法</h2><p>到达叶子节点后用<code>pow(1 + r, depth)</code>得到结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; v;</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0.0</span>, p, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v[index].child.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        ans += v[index].data * <span class="built_in">pow</span>(<span class="number">1</span> + r, depth);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[index].child.<span class="built_in">size</span>(); i++)</span><br><span class="line">        dfs(v[index].child[i], depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %lf %lf"</span>, &amp;n, &amp;p, &amp;r);</span><br><span class="line">    r = r / <span class="number">100</span>;</span><br><span class="line">    v.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;v[i].data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">                v[i].child.push_back(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, ans * p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="1081-Rational-Sum"><a href="#1081-Rational-Sum" class="headerlink" title="1081 Rational Sum"></a>1081 Rational Sum</h1><p>题目大意：对分数进行加减法。</p>
<p>辗转相除法求最大公约数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">MAX</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line">    ll c = b;</span><br><span class="line">    <span class="keyword">while</span> (a % b != <span class="number">0</span>) &#123;</span><br><span class="line">        c = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接求最小公倍数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">MIN</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 求最小公倍数</span></span><br><span class="line">    <span class="keyword">return</span> a * b / MAX(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟分数加法代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> isNeg[<span class="number">105</span>];</span><br><span class="line">ll nums[<span class="number">105</span>][<span class="number">2</span>];</span><br><span class="line">ll i1, i2;</span><br><span class="line"><span class="function">ll <span class="title">MAX</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line">    ll c = b;</span><br><span class="line">    <span class="keyword">while</span> (a % b != <span class="number">0</span>) &#123;</span><br><span class="line">        c = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">MIN</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 求最小公倍数</span></span><br><span class="line">    <span class="keyword">return</span> a * b / MAX(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i1' / i2' = i1 / i2 + nums[idx][0] / nums[idx][1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找i2和nums[idx][1]的最小公倍数</span></span><br><span class="line">    ll z = MIN(nums[idx][<span class="number">1</span>], i2), n1 = nums[idx][<span class="number">0</span>], n2 = nums[idx][<span class="number">1</span>];</span><br><span class="line">    i1 *= z / i2;</span><br><span class="line">    n1 *= z / n2;</span><br><span class="line">    <span class="keyword">if</span> (isNeg[idx]) n1 *= <span class="number">-1</span>;</span><br><span class="line">    i1 += n1;</span><br><span class="line">    i2 = z;</span><br><span class="line">    <span class="comment">// 找i1'和i2'的最大公约数</span></span><br><span class="line">    ll factor = MAX(i1, i2);</span><br><span class="line">    i1 /= factor;</span><br><span class="line">    i2 /= factor;</span><br><span class="line">    ADD(idx + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            isNeg[i] = <span class="number">1</span>;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; s.<span class="built_in">size</span>() &amp;&amp; s[q] != <span class="string">'/'</span>) &#123;</span><br><span class="line">            ++q;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i][<span class="number">0</span>] = stoi(s.substr(p, q - p));</span><br><span class="line">        nums[i][<span class="number">1</span>] = stoi(s.substr(q + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    i1 = nums[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    i2 = nums[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (isNeg[<span class="number">0</span>]) i1 *= <span class="number">-1</span>;</span><br><span class="line">    ADD(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (i1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i1 &lt; i2) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i1 &lt;&lt; <span class="string">"/"</span> &lt;&lt; i2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i1 &gt;= i2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i1 % i2 == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; i1 / i2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; i1 / i2 &lt;&lt; <span class="string">" "</span> &lt;&lt; i1 % i2 &lt;&lt; <span class="string">"/"</span> &lt;&lt; i2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1087-All-Roads-Lead-to-Rome"><a href="#1087-All-Roads-Lead-to-Rome" class="headerlink" title="1087 All Roads Lead to Rome"></a>1087 All Roads Lead to Rome</h1><p>题目大意：找最短路径，标尺1：距离，标尺2：总幸福度，标尺3：平均幸福度</p>
<p>思路：dijkstra+dfs</p>
<p>出错点：</p>
<ol>
<li>忘记初始化dijkstra的dis数组了</li>
<li>dijkstra的两个if逻辑没记好</li>
<li>输出int忘记转换double了</li>
<li>读题草率，输出信息获取错误</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, Start, End;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxWeight = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="built_in">string</span> start, u, v;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> id, score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; name2id;</span><br><span class="line">node lis[<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> e[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">210</span>];</span><br><span class="line"><span class="keyword">bool</span> isMin[<span class="number">210</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> cntPath = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> avgScore, sumScore;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ansPath;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> curSum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;curPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == Start) &#123;</span><br><span class="line">        <span class="comment">// if arrived at target</span></span><br><span class="line">        <span class="keyword">int</span> cnt = curPath.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> avg = curSum / (<span class="number">1.0</span> * cnt);</span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; sumScore) &#123;</span><br><span class="line">            sumScore = curSum;</span><br><span class="line">            avgScore = avg;</span><br><span class="line">            ansPath = curPath;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curSum == sumScore &amp;&amp; avg &gt; avgScore) &#123;</span><br><span class="line">            avgScore = avg;</span><br><span class="line">            ansPath = curPath;</span><br><span class="line">        &#125;</span><br><span class="line">        cntPath++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path[cur].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        curPath.push_back(path[cur][i]);</span><br><span class="line">        dfs(path[cur][i], curSum + lis[path[cur][i]].score, curPath);</span><br><span class="line">        curPath.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; start;</span><br><span class="line">    lis[<span class="number">0</span>].name = start;</span><br><span class="line">    lis[<span class="number">0</span>].score = <span class="number">0</span>;</span><br><span class="line">    lis[<span class="number">0</span>].id = <span class="number">0</span>;</span><br><span class="line">    name2id[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// init!!!</span></span><br><span class="line">    <span class="built_in">fill</span>(dis, dis + <span class="number">210</span>, maxWeight);</span><br><span class="line">    <span class="built_in">fill</span>(e[<span class="number">0</span>], e[<span class="number">0</span>] + <span class="number">210</span> * <span class="number">210</span>, maxWeight);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; lis[i].name &gt;&gt; lis[i].score;</span><br><span class="line">        name2id[lis[i].name] = i;</span><br><span class="line">        lis[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> idu = name2id[u], idv = name2id[v];</span><br><span class="line">        e[idu][idv] = tmp;</span><br><span class="line">        e[idv][idu] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Start = name2id[start];</span><br><span class="line">    End = name2id[<span class="string">"ROM"</span>];</span><br><span class="line">    dis[Start] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> minDist = maxWeight, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMin[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; minDist) &#123;</span><br><span class="line">                minDist = dis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        isMin[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMin[j] == <span class="literal">false</span> &amp;&amp; e[u][j] != maxWeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[j] &gt; dis[u] + e[u][j]) &#123;</span><br><span class="line">                    dis[j] = dis[u] + e[u][j];</span><br><span class="line">                    path[j].<span class="built_in">clear</span>();</span><br><span class="line">                    path[j].push_back(u);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis[j] == dis[u] + e[u][j]) &#123;</span><br><span class="line">                    path[j].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123;End&#125;;</span><br><span class="line">    dfs(End, lis[End].score, arr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>, cntPath, dis[End], (<span class="keyword">int</span>)sumScore, (<span class="keyword">int</span>)avgScore);</span><br><span class="line">    <span class="keyword">if</span> (cntPath == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ansPath.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lis[ansPath[i]].name;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1091-Acute-Stroke"><a href="#1091-Acute-Stroke" class="headerlink" title="1091 Acute Stroke"></a>1091 Acute Stroke</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>超了俩</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, l, t;</span><br><span class="line"><span class="keyword">int</span> graph[<span class="number">1300</span>][<span class="number">150</span>][<span class="number">70</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1300</span>][<span class="number">150</span>][<span class="number">70</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dz[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">		<span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">		<span class="keyword">int</span> nz = z + dz[i];</span><br><span class="line">		<span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m || nz &lt; <span class="number">0</span> || nz &gt;= l || vis[nx][ny][nz] == <span class="number">1</span> || graph[nx][ny][nz] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		vis[nx][ny][nz] = <span class="number">1</span>;</span><br><span class="line">		ret += dfs(nx, ny, nz, cnt);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ret + <span class="number">1</span>; <span class="comment">// plus itself</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;graph[j][k][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> (graph[j][k][i] == <span class="number">1</span> &amp;&amp; vis[j][k][i] == <span class="number">0</span>) &#123;</span><br><span class="line">					vis[j][k][i] = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">int</span> tmp = dfs(j, k, i, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (tmp &gt;= t) ans += tmp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, l, t;</span><br><span class="line"><span class="keyword">int</span> graph[<span class="number">1300</span>][<span class="number">150</span>][<span class="number">70</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1300</span>][<span class="number">150</span>][<span class="number">70</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dz[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;graph[j][k][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> (vis[j][k][i] == <span class="literal">false</span> &amp;&amp; graph[j][k][i] == <span class="number">1</span>) &#123;</span><br><span class="line">					node start;</span><br><span class="line">                    start.x = j; </span><br><span class="line">                    start.y = k; </span><br><span class="line">                    start.z = i;</span><br><span class="line">                    vis[j][k][i] = <span class="literal">true</span>;</span><br><span class="line">					<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">					q.push(start);</span><br><span class="line">					<span class="keyword">int</span> thisCnt = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">						thisCnt++;</span><br><span class="line">						node tmp = q.front();</span><br><span class="line">						q.pop();</span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">6</span>; ++dir) &#123;</span><br><span class="line">							<span class="keyword">int</span> nx = tmp.x + dx[dir];</span><br><span class="line">							<span class="keyword">int</span> ny = tmp.y + dy[dir];</span><br><span class="line">							<span class="keyword">int</span> nz = tmp.z + dz[dir];</span><br><span class="line">							<span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m || nz &lt; <span class="number">0</span> || nz &gt;= l || graph[nx][ny][nz] != <span class="number">1</span> || vis[nx][ny][nz] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">							node Node; </span><br><span class="line">                            Node.x = nx; </span><br><span class="line">                            Node.y = ny; </span><br><span class="line">                            Node.z = nz;</span><br><span class="line">                            vis[nx][ny][nz] = <span class="literal">true</span>;</span><br><span class="line">                            q.push(Node);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (thisCnt &gt;= t) ans += thisCnt;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>STL整理</title>
    <url>/2020/07/29/STL%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>是一个标准模板库的使用字典。</p>
<a id="more"></a>

<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;vector&gt;</code></p>
<h2 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h2><h3 id="单个访问"><a href="#单个访问" class="headerlink" title="单个访问"></a>单个访问</h3><ol>
<li>下标访问</li>
<li>begin()函数(<code>*(v.begin + i)</code>)  <strong>只有string和vector支持这种访问方法</strong></li>
</ol>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li>for循环利用下标<code>i</code></li>
<li>for循环利用迭代器<ul>
<li><code>for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)</code></li>
<li><code>for(auto temp:v)</code></li>
</ul>
</li>
</ol>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul>
<li><code>push_back(x)</code> —$O(1)$</li>
<li><code>pop_back()</code> —$O(1)$</li>
<li><code>size()</code> —$O(1)$</li>
<li><code>clear()</code> —$O(n)$</li>
<li><code>insert(it, x)</code> —$O(n)$</li>
<li><code>erase(it)</code>/ <code>erase(first, last)</code> —$O(n)$</li>
</ul>
<h2 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h2><ol>
<li>存储数据</li>
<li>充当数组</li>
<li>邻接表存储图</li>
</ol>
<hr>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p><strong>内部有序</strong>且不含<strong>重复元素</strong>的容器。</p>
<h2 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;set&gt;</code></p>
<h2 id="访问方式-1"><a href="#访问方式-1" class="headerlink" title="访问方式"></a>访问方式</h2><p>只能通过迭代器访问</p>
<h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><p><code>insert(x)</code> —$O(logn)$</p>
</li>
<li><p><code>find(value)</code> —$O(logn) $ </p>
<p><strong>返回的是对应值为value的迭代器</strong></p>
</li>
<li><p><code>erase()</code></p>
<ul>
<li><p>通过迭代器删除单个元素 <code>st.erase(it)</code> —$O(1)$</p>
<p>配合<code>find()</code>使用场景：<code>st.erase(st.find(100))</code></p>
</li>
<li><p>通过值删除单个元素<code>st.erase(value)</code> —$O(logn)$</p>
</li>
<li><p>通过迭代器删除区间元素 <code>st.erase(first, last)</code> — $O(last - first)$</p>
</li>
</ul>
</li>
<li><p><code>size()</code> —$O(1)$</p>
</li>
<li><p><code>clear()</code> —$O(n)$</p>
</li>
</ol>
<h2 id="常见用途-1"><a href="#常见用途-1" class="headerlink" title="常见用途"></a>常见用途</h2><ol>
<li>自动去重并按升序排列</li>
<li>扩展容器<strong>unordered_set</strong>，只去重，不排序。</li>
</ol>
<hr>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="头文件-2"><a href="#头文件-2" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;string&gt;</code></p>
<h2 id="访问方式-2"><a href="#访问方式-2" class="headerlink" title="访问方式"></a>访问方式</h2><ol>
<li>下标访问</li>
<li>迭代器访问</li>
</ol>
<h2 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><p><code>+=</code></p>
</li>
<li><p><code>&gt;</code>、<code>&lt;</code>、<code>==</code>(比较字典序)</p>
</li>
<li><p><code>length()</code> / <code>size()</code> —$O(1)$</p>
</li>
<li><p><code>insert()</code> —$O(n)$</p>
<ul>
<li><p><code>str.insert(pos, string)</code> 向<code>str[3]</code>的位置插入字符串<code>string</code></p>
</li>
<li><p><code>str.insert(it, it2, it3)</code>向<code>str</code>字符串中插入另一字符串的首尾迭代器<code>it2</code>和<code>it3</code>之间</p>
</li>
</ul>
</li>
<li><p><code>erase()</code> —$O(n)$</p>
<ul>
<li><code>erase(it)</code></li>
<li><code>erase(first, last)</code></li>
<li><code>erase(pos, length)</code></li>
</ul>
</li>
<li><p><code>clear()</code> —$O(1)$</p>
</li>
<li><p><code>substr(pos, len)</code> —$O(len)$</p>
</li>
<li><p><code>find()</code> —$O(nm)$ </p>
<ul>
<li><p><code>str.find(str2)</code> </p>
<p>当<code>str2</code>是<code>str</code>的子串，返回其在<code>str</code>中第一次出现的位置。否则返回<code>npos</code>。</p>
</li>
<li><p><code>str.find(str2, pos)</code></p>
<p>以<code>pos</code>（int）位为起点，开始向后匹配。</p>
</li>
</ul>
</li>
<li><p><code>string::npos</code> 当作<code>find()</code>函数失配的返回值</p>
</li>
<li><p><code>replace()</code> —$O(str.length())$</p>
<ul>
<li><p><code>str.replace(pos, len, str2)</code></p>
<p>把<code>str</code>从<code>pos</code>位开始，长度为<code>len</code>的子串替换为<code>str2</code></p>
</li>
<li><p><code>str.replace(it1, it2, str2)</code></p>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map可以建立键值对的映射，且会以<strong>键从小到大的顺序自动排序</strong>。</p>
<h2 id="头文件-3"><a href="#头文件-3" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;map&gt;</code></p>
<h2 id="访问方式-3"><a href="#访问方式-3" class="headerlink" title="访问方式"></a>访问方式</h2><ol>
<li>下标访问</li>
<li>迭代器访问<ul>
<li>key：<code>it-&gt;first</code></li>
<li>val：<code>it-&gt;second</code></li>
</ul>
</li>
</ol>
<h2 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><code>find(key)</code> —$O(logn)$</li>
<li><code>erase()</code><ul>
<li><code>erase(it)</code> —$O(1)$</li>
<li><code>erase(key)</code> —$O(logn)$</li>
<li><code>erase(first, last)</code> —$O(last - first)$</li>
</ul>
</li>
<li><code>size()</code> —$O(1)$</li>
<li><code>clear()</code> —$O(1)$</li>
</ol>
<h2 id="常见用途-2"><a href="#常见用途-2" class="headerlink" title="常见用途"></a>常见用途</h2><ol>
<li>建立字符(字符串)到整数的映射</li>
<li>判断大整数或者其他数据是否存在</li>
<li>字符串映射</li>
<li><code>unordered_map</code>建立哈希表</li>
</ol>
<hr>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><h2 id="头文件-4"><a href="#头文件-4" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;queue&gt;</code></p>
<h2 id="访问方式-4"><a href="#访问方式-4" class="headerlink" title="访问方式"></a>访问方式</h2><p><code>q.front()</code> / <code>q.back()</code></p>
<h2 id="常用函数-4"><a href="#常用函数-4" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><code>front()</code>,<code>back()</code> —$O(1)$</li>
<li><code>pop()</code> —$O(1)$</li>
<li><code>empty()</code> —$O(1)$</li>
<li><code>size()</code> —$O(1)$</li>
</ol>
<h2 id="常见用途-3"><a href="#常见用途-3" class="headerlink" title="常见用途"></a>常见用途</h2><p>广度优先搜索</p>
<hr>
<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>双端队列</strong>，允许在首尾两端快速插入以及删除。</p>
<h2 id="头文件-5"><a href="#头文件-5" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;deque&gt;</code></p>
<h2 id="访问方式-5"><a href="#访问方式-5" class="headerlink" title="访问方式"></a>访问方式</h2><p><code>q.front()</code> —$O(1)$</p>
<p><code>q.back()</code> —$O(1)$</p>
<p><code>q.at(int pos)</code> —$O(1)$</p>
<h2 id="常用函数-5"><a href="#常用函数-5" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><code>empty()</code> —$O(1)$</li>
<li><code>size()</code>  —$O(1)$</li>
<li><code>insert(it, val)</code> —$O(n)$</li>
<li><code>push_back()</code> —$O(1)$</li>
<li><code>push_front()</code> —$O(1)$</li>
<li><code>front()</code> —$O(1)$</li>
<li><code>back()</code> —$O(1)$</li>
<li><code>pop_front()</code> —$O(1)$</li>
<li><code>pop_back()</code> —$O(1)$</li>
</ol>
<hr>
<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><strong>优先队列</strong>，底层用堆进行实现。队列中，队首元素一定是<strong>当前队列中优先级最高的元素</strong>。</p>
<h2 id="头文件-6"><a href="#头文件-6" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;queue&gt;</code></p>
<h2 id="访问方式-6"><a href="#访问方式-6" class="headerlink" title="访问方式"></a>访问方式</h2><p><code>q.top()</code>访问队首元素</p>
<h2 id="常用函数-6"><a href="#常用函数-6" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><code>push()</code> —$O(logn)$</li>
<li><code>top()</code> —$O(1)$</li>
<li><code>pop()</code> —$O(logn)$</li>
<li><code>empty()</code> —$O(1)$</li>
<li><code>size()</code> —$O(1)$</li>
</ol>
<h2 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h2><h3 id="基本数据类型设置"><a href="#基本数据类型设置" class="headerlink" title="基本数据类型设置"></a>基本数据类型设置</h3><p><code>priority_queue&lt;int&gt; q</code></p>
<p>优先级按照元素<strong>从大到小</strong>降序排列</p>
<p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code></p>
<p>优先级按照元素<strong>从小到大</strong>降序排列</p>
<h3 id="结构体的优先级设置"><a href="#结构体的优先级设置" class="headerlink" title="结构体的优先级设置"></a>结构体的优先级设置</h3><p>以水果为例，根据水果的名称和价格建立一个结构体。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在希望按照其<strong>价格从高到低获取水果名称</strong>，需要重载运算符，重载运算符函数加入到结构体的定义中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> fruit &amp;f1, <span class="keyword">const</span> fruit &amp;f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，可以直接定义<code>fruit</code>类型的优先队列<code>priority_queue&lt;fruit&gt; q;</code>，其内部以价格高的水果为高优先级。</p>
<p>如想以低价格为优先级高，只需将return语句中的<code>&lt;</code>改成<code>&gt;</code>即可。</p>
<p><strong>另外，如果想将重载写在结构体之外，声明方式和队列的定义方式也需要发生一定的改变。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> fruit &amp;f1, <span class="keyword">const</span> fruit &amp;f2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;fruit, <span class="built_in">vector</span>&lt;fruit&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure>

<p>其他的STL容器也可以用类似的方法来定义优先级。</p>
<hr>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><h2 id="头文件-7"><a href="#头文件-7" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;stack&gt;</code></p>
<h2 id="访问方式-7"><a href="#访问方式-7" class="headerlink" title="访问方式"></a>访问方式</h2><p><code>s.top()</code></p>
<h2 id="常用函数-7"><a href="#常用函数-7" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><code>push()</code> —$O(1)$</li>
<li><code>top()</code> —$O(1)$</li>
<li><code>pop()</code> —$O(1)$</li>
<li><code>empty()</code> —$O(1)$</li>
<li><code>size()</code> —$O(1)$</li>
</ol>
<h2 id="常见用途模拟递归"><a href="#常见用途模拟递归" class="headerlink" title="常见用途模拟递归"></a>常见用途模拟递归</h2><p>模拟递归，防止递归层数过多。</p>
<hr>
<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><h2 id="头文件-8"><a href="#头文件-8" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;utility&gt;</code> / <code>#include &lt;map&gt;</code></p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p><code>p.first</code></p>
<p><code>p.second</code></p>
<h2 id="常用函数-8"><a href="#常用函数-8" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><p>赋值函数：<code>p = make_pair(&quot;666&quot;, 666);</code></p>
</li>
<li><p>比较操作数：直接用操作数比较</p>
<p>标准：<strong>先以first的大小作为标准，当first相等时再去判定second的大小</strong></p>
</li>
</ol>
<h2 id="常见用途-4"><a href="#常见用途-4" class="headerlink" title="常见用途"></a>常见用途</h2><ol>
<li><p>代替二元结构体，节省代码</p>
</li>
<li><p>作为map值进行插入(其实用{}的方式插入应该也可以)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">m.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">"haha"</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>将一个元素的相关信息与其绑定（例如&lt;节点，深度&gt;）</p>
</li>
</ol>
<hr>
<h1 id="algorithm头文件下的其他常用函数"><a href="#algorithm头文件下的其他常用函数" class="headerlink" title="algorithm头文件下的其他常用函数"></a>algorithm头文件下的其他常用函数</h1><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><p><code>fill(a, a+4, 0)</code> </p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">int</span> r; <span class="comment">// 排名</span></span><br><span class="line">&#125; stu[<span class="number">10010</span>];</span><br></pre></td></tr></table></figure>

<p>对所有学生的成绩按从高到低排列，分数相同的按照姓名的字典序从小到大排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score != b.score) <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.name, b.name) &lt; <span class="number">0</span>; <span class="comment">// 比较两个char型数组的字典序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lower-bound-amp-upper-bound"><a href="#lower-bound-amp-upper-bound" class="headerlink" title="lower_bound() &amp; upper_bound()"></a>lower_bound() &amp; upper_bound()</h2><p>这两个函数需要用在一个有序数组或容器中。</p>
<p>复杂度 —$O(log(last-first))$</p>
<p><code>lower_bound(first, last, val)</code>用来寻找在数组或容器的$[first, last)$范围内第一个值大于等于<code>val</code>的元素的位置。</p>
<ul>
<li>如果是数组，则返回该位置指针。</li>
<li>如果是容器，则返回该位置迭代器。</li>
</ul>
<p><code>upperbound(frist, last, val)</code>用于寻找在数组或容器的$[first, last)$范围内第一个大于<code>val</code>的元素的位置。</p>
<ul>
<li>如果是数组，则返回该位置指针。</li>
<li>如果是容器，则返回该位置迭代器。</li>
</ul>
<p><strong>如果数组或容器中，没有需要寻找的元素，则返回可以插入该元素位置的指针或迭代器。</strong></p>
<p><strong>如果只想获取其下标，则将返回值减去首地址/首迭代器。</strong></p>
<h2 id="advance"><a href="#advance" class="headerlink" title="advance()"></a>advance()</h2><p>将迭代器前移或后退指定距离。</p>
<p><code>advance(it, dis)</code></p>
<h2 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate()"></a>accumulate()</h2><p><code>accumulate(it_begin, it_end, beginSum, lambda)</code></p>
<p><strong>int, string均可加</strong></p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*数组求和*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val = &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> sum = accumulate(val.<span class="built_in">begin</span>(), val.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*应用lambda表达式*/</span></span><br><span class="line"><span class="comment">// 以The numbers are 为初始值，向后依次以": x"为模板向后累加</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> s = accumulate(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="string">"The numbers are"</span>,[](strings str, <span class="keyword">int</span> n)&#123; <span class="keyword">return</span> str + <span class="string">" : "</span> + <span class="built_in">std</span>::to_string(n);&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//Output: The numbers are: 1: 2: 3: 10: 11: 12</span></span><br></pre></td></tr></table></figure>



<h2 id="max-element和min-element"><a href="#max-element和min-element" class="headerlink" title="max_element和min_element"></a>max_element和min_element</h2><p><code>int maxValue = *max_element(nums.begin(), nums.end())</code></p>
]]></content>
      <categories>
        <category>应试</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cs知识储备</title>
    <url>/2021/03/18/cs%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><h2 id="GDB调试器和GCC编译器"><a href="#GDB调试器和GCC编译器" class="headerlink" title="GDB调试器和GCC编译器"></a>GDB调试器和GCC编译器</h2><p><a href="https://www.jianshu.com/p/ffbc358150b9" target="_blank" rel="noopener">参考文档</a></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h2><p>ELF（Executable Linkable Format）可执行可链接的格式</p>
<ul>
<li>ELF文件的header<ul>
<li>文件内容的分布</li>
<li>指令集体系结构(x86-64..)</li>
<li>入口地址（Entry Point Address）</li>
<li>Application Binary Interface（ABI）</li>
<li>…</li>
</ul>
</li>
<li>ELF的program headers<ul>
<li>决定ELF应该如何被加载器加载</li>
</ul>
</li>
</ul>
<h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><p><code>gcc -c hello.c</code> 编译hello.c，生成一个hello.o文件，用以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file hello.o</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ELF 64-bit LSB relocatable, x86-64...</span></span><br></pre></td></tr></table></figure>

<p>再进行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ld hello.o</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> warning: undefined reference to <span class="string">'puts'</span></span></span><br></pre></td></tr></table></figure>

<p>报undefined是因为编译器做的优化，，</p>
]]></content>
  </entry>
  <entry>
    <title>python常用操作</title>
    <url>/2021/03/22/python%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>主要涉及机器学习，数据处理等方面。</p>
<a id="more"></a>

<h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="如何避免函数修改实参"><a href="#如何避免函数修改实参" class="headerlink" title="如何避免函数修改实参"></a>如何避免函数修改实参</h3><p>将一个不可变的对象传入函数中，如果修改后，实参也会发生相应改变。</p>
<p><strong>并且不能用深拷贝，并在返回前将深拷贝的副本返还给形参这种操作来规避！</strong></p>
<p>方法1：</p>
<p>在进入函数前，深拷贝一个副本，函数结束后将副本返还给对象。</p>
<p>方法2：</p>
<p>在进入函数后，深拷贝一个副本，在函数返回时将副本也返还，并让这个对象承接这个返回值。</p>
<h3 id="保留n位小数"><a href="#保留n位小数" class="headerlink" title="保留n位小数"></a>保留n位小数</h3><p><code>round(num, n)</code></p>
<h2 id="list-dict"><a href="#list-dict" class="headerlink" title="list, dict"></a>list, dict</h2><h3 id="找字典最大值的key"><a href="#找字典最大值的key" class="headerlink" title="找字典最大值的key"></a>找字典最大值的key</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">max(dic, key=dic.get)</span><br></pre></td></tr></table></figure>

<h3 id="for循环时更改字典"><a href="#for循环时更改字典" class="headerlink" title="for循环时更改字典"></a>for循环时更改字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> list(self.isDiscrete.keys()): <span class="comment"># 不加list会报错</span></span><br></pre></td></tr></table></figure>



<h2 id="np"><a href="#np" class="headerlink" title="np"></a>np</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.r_[a, b] <span class="comment"># 扩展行的长度，即a,b按照列进行拼接</span></span><br><span class="line">np.c_[a, b] <span class="comment"># 扩展列的长度，即a,b按照行进行拼接</span></span><br></pre></td></tr></table></figure>



<h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><h3 id="删除DataFrame有指定个数NaN的列"><a href="#删除DataFrame有指定个数NaN的列" class="headerlink" title="删除DataFrame有指定个数NaN的列"></a>删除DataFrame有指定个数NaN的列</h3><p>法1:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = frame.isna().sum() == <span class="number">3</span></span><br><span class="line">frame.drop(df[df.values == <span class="literal">True</span>].index.tolist(), axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>法2:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.T[frame.isna().sum(axis=<span class="number">0</span>) != <span class="number">3</span>].T</span><br></pre></td></tr></table></figure>

<h3 id="检查并删除重复行"><a href="#检查并删除重复行" class="headerlink" title="检查并删除重复行"></a>检查并删除重复行</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dframe.duplicated() <span class="comment"># 返回bool类Series</span></span><br><span class="line">dframe.drop_duplicates() <span class="comment"># 进行删除</span></span><br></pre></td></tr></table></figure>



<h3 id="遍历修改DataFrame中的数值"><a href="#遍历修改DataFrame中的数值" class="headerlink" title="遍历修改DataFrame中的数值"></a>遍历修改DataFrame中的数值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> feature, col <span class="keyword">in</span> dframe.iteritems():</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> dframe.index:</span><br><span class="line">        dframe.loc[idx, feature] = <span class="number">10</span></span><br></pre></td></tr></table></figure>



<h3 id="用该列所含最多的元素填充样例缺失值"><a href="#用该列所含最多的元素填充样例缺失值" class="headerlink" title="用该列所含最多的元素填充样例缺失值"></a>用该列所含最多的元素填充样例缺失值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[column_name].fillna(data[column_name].value_counts().idxmax(), inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>





<h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><h3 id="折线图平滑化"><a href="#折线图平滑化" class="headerlink" title="折线图平滑化"></a>折线图平滑化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.interpolate <span class="keyword">import</span> make_interp_spline</span><br><span class="line"></span><br><span class="line">x_smooth = np.linspace(x.min(), x.max(), <span class="number">300</span>)</span><br><span class="line">y_smooth = make_interp_spline(x, y)(x_smooth)</span><br><span class="line">plt.plot(x_smooth, y_smooth)</span><br></pre></td></tr></table></figure>



<h3 id="可视化直方图-density曲线"><a href="#可视化直方图-density曲线" class="headerlink" title="可视化直方图+density曲线"></a>可视化直方图+density曲线</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax = train_df[<span class="string">"Age"</span>].hist(bins=<span class="number">15</span>, density=<span class="literal">True</span>, stacked=<span class="literal">True</span>, color=<span class="string">'teal'</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">train_df[<span class="string">"Age"</span>].plot(kind=<span class="string">'density'</span>, color=<span class="string">'teal'</span>)</span><br><span class="line">ax.set(xlabel=<span class="string">'Age'</span>)</span><br><span class="line">plt.xlim(<span class="number">-10</span>,<span class="number">85</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT日记II</title>
    <url>/2021/01/25/PAT%E6%97%A5%E8%AE%B0II/</url>
    <content><![CDATA[<p>从现在开始每天至少3道，考前可刷完。</p>
<a id="more"></a>

<h1 id="1147-Heaps"><a href="#1147-Heaps" class="headerlink" title="1147 Heaps"></a>1147 Heaps</h1><p>题目大意：根据层序遍历判断为最大最小堆或者不是堆？并给出其树结构的后序遍历。</p>
<h2 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h2><p>题目关键：</p>
<ul>
<li>通过相与操作来判断。全满足最大堆的性质或最小堆的性质，相与后标志数仍为1。</li>
<li>层序遍历还原通过队列还原。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(TreeNode *root, <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; &amp;qval, <span class="built_in">queue</span>&lt;TreeNode*&gt; &amp;qnode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(qval.front());</span><br><span class="line">        qval.pop();</span><br><span class="line">        qnode.push(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!qval.empty()) &#123;</span><br><span class="line">            TreeNode *tmp = qnode.front();</span><br><span class="line">            qnode.pop();</span><br><span class="line"></span><br><span class="line">            tmp-&gt;left = <span class="keyword">new</span> TreeNode(qval.front());</span><br><span class="line">            qval.pop();</span><br><span class="line">            <span class="keyword">if</span> (qval.empty()) <span class="keyword">return</span> root;</span><br><span class="line">            qnode.push(tmp-&gt;left);</span><br><span class="line"></span><br><span class="line">            tmp-&gt;right = <span class="keyword">new</span> TreeNode(qval.front());</span><br><span class="line">            qval.pop();</span><br><span class="line">            qnode.push(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> &amp;times, TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        postorder(times, root-&gt;left);</span><br><span class="line">        postorder(times, root-&gt;right);</span><br><span class="line">        times++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, root-&gt;val);</span><br><span class="line">        <span class="built_in">printf</span>((times == m) ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">0</span>; time &lt; n; ++time) &#123;</span><br><span class="line">        <span class="keyword">int</span> heap[m];</span><br><span class="line">        <span class="keyword">int</span> maxH = <span class="number">1</span>, minH = <span class="number">1</span>, notH = <span class="number">0</span>;</span><br><span class="line">        TreeNode* root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qval;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qnode;</span><br><span class="line">        <span class="keyword">int</span> lev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;heap[i]);</span><br><span class="line">            qval.push(heap[i]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pow</span>(<span class="number">2</span>, lev) == qval.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="comment">// after traversal for a level</span></span><br><span class="line">                root = build(root, qval, qnode);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= i - <span class="built_in">pow</span>(<span class="number">2</span>, lev) &amp;&amp; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j % <span class="number">2</span>) &#123;</span><br><span class="line">                        maxH &amp;= (heap[j] &lt;= heap[(j - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">                        minH &amp;= (heap[j] &gt;= heap[(j - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        maxH &amp;= (heap[j] &lt;= heap[(j - <span class="number">2</span>) / <span class="number">2</span>]);</span><br><span class="line">                        minH &amp;= (heap[j] &gt;= heap[(j - <span class="number">2</span>) / <span class="number">2</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ++lev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= m - qval.<span class="built_in">size</span>(); --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">2</span>) &#123;</span><br><span class="line">                maxH &amp;= (heap[j] &lt;= heap[(j - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">                minH &amp;= (heap[j] &gt;= heap[(j - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxH &amp;= (heap[j] &lt;= heap[(j - <span class="number">2</span>) / <span class="number">2</span>]);</span><br><span class="line">                minH &amp;= (heap[j] &gt;= heap[(j - <span class="number">2</span>) / <span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root = build(root, qval, qnode);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxH &amp;&amp; minH || (!maxH &amp;&amp; !minH)) notH = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (notH) <span class="built_in">printf</span>(<span class="string">"Not Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (maxH) <span class="built_in">printf</span>(<span class="string">"Max Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Min Heap\n"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        postorder(times, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p>但是真正的大佬柳神只用25行就解决了，实在是让人高兴不起来啊！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>], m, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(index * <span class="number">2</span>);</span><br><span class="line">    postOrder(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[index], index == <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> minn = <span class="number">1</span>, maxn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i / <span class="number">2</span>]) maxn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i / <span class="number">2</span>]) minn = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxn == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Max Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (minn == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Min Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Not Heap\n"</span>);</span><br><span class="line">        postOrder(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法关键：</p>
<ul>
<li>不需要直接构建树，而是利用层序遍历的特点，直接通过数组还原后序遍历。</li>
<li>而且也不需要判断i是否能被2整除，根据整数向下取整的特点，直接除以二判断。</li>
<li>而且也不需要用什么相与，直接将问题取反，判断是否不存在大顶堆小顶堆的条件，将标志数置为0即可。</li>
</ul>
<h1 id="1148-Werewolf-Simple-Version"><a href="#1148-Werewolf-Simple-Version" class="headerlink" title="1148 Werewolf - Simple Version"></a>1148 Werewolf - Simple Version</h1><p>题目大意：这是一个游戏，每个人会说某个人是狼人或好人。其实这些人里面有2个狼人，2个狼人其中一个说了谎，另一个说了谎的是好人。求人群中狼人序号的最小解。</p>
<h2 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h2><p>我的想法是假设人群中说谎的人是i,j，然后根据当前事实来判断狼人的归属。发现最后有点难以收场。</p>
<h2 id="柳神解法"><a href="#柳神解法" class="headerlink" title="柳神解法"></a>柳神解法</h2><p>其实最简单的解法还是假设人群中狼人是i,j，再根据当前事实遍历来判断：</p>
<ol>
<li>有几个人说谎？若不是2个人，则false</li>
<li>说谎的2人人中是否只有一个是狼人？若不是，则false</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; saying;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w1 = i, w2 = j;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; liars;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (saying[k] &gt; <span class="number">0</span> &amp;&amp; (<span class="built_in">abs</span>(saying[k]) == w1 || <span class="built_in">abs</span>(saying[k]) == w2)) liars.push_back(k);</span><br><span class="line">                <span class="keyword">if</span> (saying[k] &lt; <span class="number">0</span> &amp;&amp; (<span class="built_in">abs</span>(saying[k]) != w1 &amp;&amp; <span class="built_in">abs</span>(saying[k]) != w2)) liars.push_back(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (liars.<span class="built_in">size</span>() != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (liars[<span class="number">0</span>] == w1 &amp;&amp; liars[<span class="number">1</span>] == w2 || liars[<span class="number">0</span>] != w1 &amp;&amp; liars[<span class="number">1</span>] != w2) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; w1 &lt;&lt; <span class="string">" "</span> &lt;&lt; w2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    saying.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;saying[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1149-Dangerous-Goods-Packaging"><a href="#1149-Dangerous-Goods-Packaging" class="headerlink" title="1149 Dangerous Goods Packaging"></a>1149 Dangerous Goods Packaging</h1><p>题目大意：根据不能同时将哪些货物包裹放到一个口袋里的规则，输出对应的口袋是否满足规则。直接遍历即可。</p>
<p>针对这种用到name2Id数组的题有以下需要总结：</p>
<ol>
<li>只有结果需要排序的时候，建议用结构体构造，且一定要包括id属性。</li>
<li>要求输出包含原始字符串信息的时候需要id2name数组，否则如果只是一下yesno信息的话，则不需要id2name。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; graph[<span class="number">20010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cfl</span><span class="params">(<span class="keyword">int</span> g1, <span class="keyword">int</span> g2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[g1].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (graph[g1][i] == g2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, k, id = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> u, v;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; name2Id;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">0</span>; time &lt; n; ++time) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		<span class="keyword">if</span> (name2Id.<span class="built_in">find</span>(u) == name2Id.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			name2Id[u] = id++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (name2Id.<span class="built_in">find</span>(v) == name2Id.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			name2Id[v] = id++;</span><br><span class="line">		&#125;</span><br><span class="line">		graph[name2Id[u]].push_back(name2Id[v]);</span><br><span class="line">		graph[name2Id[v]].push_back(name2Id[u]);		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">0</span>; time &lt; m; ++time) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">list</span>[k];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">			<span class="built_in">string</span> tmp; <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            <span class="keyword">if</span> (name2Id.<span class="built_in">find</span>(tmp) == name2Id.<span class="built_in">end</span>())  <span class="comment">// it's impossible to cause conflicts</span></span><br><span class="line">                <span class="built_in">list</span>[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">list</span>[i] = name2Id[tmp];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; flag == <span class="literal">false</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; ++j) &#123;</span><br><span class="line">				<span class="keyword">int</span> g1 = <span class="built_in">list</span>[i], g2 = <span class="built_in">list</span>[j];</span><br><span class="line">                <span class="keyword">if</span> (g1 == <span class="number">-1</span> || g2 == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span> (cfl(g1, g2)) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1150-Travelling-Salesman-Problem"><a href="#1150-Travelling-Salesman-Problem" class="headerlink" title="1150 Travelling Salesman Problem"></a>1150 Travelling Salesman Problem</h1><p>题目大意：得到旅行商问题的对应解。</p>
<p>题目关键：验证条件，分为四种结果。</p>
<ol>
<li>是否路径中有不存在的路？<ul>
<li>若是，提前输出NA的情形</li>
</ul>
</li>
<li>是不是起始点和结束点是同一个城市？是不是浏览过了所有的城市？<ul>
<li>若不是，提前输出不是TSP，但是有路径的解。</li>
</ul>
</li>
<li>旅行路径是否和城市数量相等<ul>
<li>若相等，为Simple Tsp，否则为Tsp。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VALUE 99999999</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, p, k, c1, c2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> dist[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;c1, &amp;c2, &amp;p);</span><br><span class="line">        dist[c1][c2] = p; dist[c2][c1] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">path_dis</span><span class="params">(p + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case 1:a path is not existing 2:not all the cities have been visited 3:the last city is not the origin</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> order = <span class="number">1</span>; order &lt;= p; ++order) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> route[k];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visit</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> status = <span class="number">-2</span>; <span class="comment">// -1(dist not exist) 0(Not Ts) 1(Ts) 2(Simple Ts)</span></span><br><span class="line">        <span class="keyword">int</span> sumdist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;route[i]);</span><br><span class="line">            visit[route[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[route[i]][route[i - <span class="number">1</span>]] == <span class="number">0</span>) status = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> sumdist += dist[route[i]][route[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: NA (Not a TS cycle)\n"</span>, order);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (route[<span class="number">0</span>] != route[k - <span class="number">1</span>] || accumulate(visit.<span class="built_in">begin</span>(), visit.<span class="built_in">end</span>(), <span class="number">0</span>) != n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (Not a TS cycle)\n"</span>, order, sumdist);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path_dis[order] = sumdist;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; n + <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Path %d: %d (TS cycle)\n"</span>, order, sumdist);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Path %d: %d (TS simple cycle)\n"</span>, order, sumdist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">SD</span> = MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path_dis.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path_dis[i] &gt; <span class="number">0</span> &amp;&amp; path_dis[i] &lt; <span class="built_in">SD</span>) &#123;</span><br><span class="line">            <span class="built_in">SD</span> = path_dis[i];</span><br><span class="line">            idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Shortest Dist(%d) = %d\n"</span>, idx, <span class="built_in">SD</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1151-LCA-in-a-Binary-Tree"><a href="#1151-LCA-in-a-Binary-Tree" class="headerlink" title="1151 LCA in a Binary Tree"></a>1151 LCA in a Binary Tree</h1><p>与1143有相同之处，不同的是这题不是BST了，所以中间需要做一个inorder-&gt;inorder_pos的映射表，就和原题一样了。这种不建树解决问题的模板要熟练掌握！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, in;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAns</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> ps, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is &gt; ie) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> root = pre[ps]; <span class="keyword">int</span> rpos = pos[root];</span><br><span class="line">    <span class="keyword">int</span> posu = pos[u]; <span class="keyword">int</span> posv = pos[v];</span><br><span class="line">    <span class="keyword">if</span> ((posu &lt; rpos &amp;&amp; posv &gt; rpos) || (posu &gt; rpos &amp;&amp; posv &lt; rpos)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d.\n"</span>, u, v, root);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (posu &lt; rpos &amp;&amp; posv &lt; rpos) &#123;</span><br><span class="line">        getAns(u, v, ps + <span class="number">1</span>, is, rpos - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (posu &gt; rpos &amp;&amp; posv &gt; rpos) &#123;</span><br><span class="line">        getAns(u, v, ps + <span class="number">1</span> + (rpos - is), rpos + <span class="number">1</span>, ie);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rpos == posu) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>, u, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rpos == posv) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>, v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    pre.resize(n + <span class="number">1</span>);</span><br><span class="line">    in.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">1</span>; time &lt;= n; ++time) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[time]);</span><br><span class="line">        pos[in[time]] = time; <span class="comment">// use inorder to get the BST's pos</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">1</span>; time &lt;= n; ++time) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[time]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">0</span>; time &lt; m; ++time) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span> (pos[u] == <span class="number">0</span> &amp;&amp; pos[v] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d and %d are not found.\n"</span>, u, v);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos[u] == <span class="number">0</span> || pos[v] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d is not found.\n"</span>, (pos[u] == <span class="number">0</span>) ? u : v);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getAns(u, v, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1153-Decode-Registration-Card-of-PAT"><a href="#1153-Decode-Registration-Card-of-PAT" class="headerlink" title="1153 Decode Registration Card of PAT"></a>1153 Decode Registration Card of PAT</h1><p>一道基础信息题，活用结构体和结构体排序即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inf</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> level;</span><br><span class="line">    <span class="keyword">int</span> site, tnum, score;</span><br><span class="line">    <span class="built_in">string</span> date, card;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;inf&gt; testees;</span><br><span class="line"><span class="function">inf <span class="title">getInf</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">    inf info;</span><br><span class="line">    info.level = s[<span class="number">0</span>];</span><br><span class="line">    info.site = stoi(s.substr(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">    info.tnum = stoi(s.substr(<span class="number">10</span>, <span class="number">3</span>));</span><br><span class="line">    info.score = score;</span><br><span class="line">    info.date = s.substr(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">    info.card = s;</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] == b[<span class="number">1</span>] ? a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] : a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAns</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> order)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;inf&gt; ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case %d: %d "</span>, order, type);</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> lv; <span class="built_in">cin</span> &gt;&gt; lv;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, lv);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;t : testees) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.level == lv) ans.emplace_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans.empty()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), [](inf &amp;a, inf &amp;b)&#123;<span class="keyword">return</span> a.score != b.score ? a.score &gt; b.score : a.card &lt; b.card;&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i].card &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[i].score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> site; <span class="built_in">cin</span> &gt;&gt; site;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, site);</span><br><span class="line">        <span class="keyword">int</span> sumScore = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;t : testees) </span><br><span class="line">            <span class="keyword">if</span> (t.site == site) &#123;</span><br><span class="line">                sumScore += t.score;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, cnt, sumScore);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> date; <span class="built_in">cin</span> &gt;&gt; date;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; date &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">1000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;t: testees) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.date == date) &#123;</span><br><span class="line">                num[t.site]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">101</span>; i &lt; num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] != <span class="number">0</span>) res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;i, num[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.empty()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, res[i][<span class="number">0</span>], res[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, type;</span><br><span class="line">    <span class="built_in">string</span> s; <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; score;</span><br><span class="line">        testees.push_back(getInf(s, score));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;type);</span><br><span class="line">        getAns(type, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1155-Heap-Paths"><a href="#1155-Heap-Paths" class="headerlink" title="1155 Heap Paths"></a>1155 Heap Paths</h1><p>题目大意：根据给定的堆的层序遍历写出其从根节点到叶子节点的所有路径，并且给出堆的性质。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minn = <span class="number">1</span>, maxn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[i] &gt; heap[i / <span class="number">2</span>]) maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (heap[i] &lt; heap[i / <span class="number">2</span>]) minn = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxn == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Max Heap\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (minn == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Min Heap\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Not Heap\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">traversal</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;curPath, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    curPath.push_back(heap[idx]);</span><br><span class="line">    <span class="keyword">int</span> right = traversal(idx * <span class="number">2</span> + <span class="number">1</span>, curPath, heap);</span><br><span class="line">    <span class="keyword">int</span> left = traversal(idx * <span class="number">2</span>, curPath, heap);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">-1</span> &amp;&amp; right == <span class="number">-1</span>) &#123;</span><br><span class="line">        ans.push_back(curPath);</span><br><span class="line">    &#125;</span><br><span class="line">    curPath.pop_back();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curPath;</span><br><span class="line">    traversal(<span class="number">1</span>, curPath, heap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">heap</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;heap[i]);</span><br><span class="line">    printPath(heap);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(j == ans[i].<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    checkheap(heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1103-Integer-Factorization"><a href="#1103-Integer-Factorization" class="headerlink" title="1103 Integer Factorization"></a>1103 Integer Factorization</h1><p>题目大意：整数分解，将某个整数N分解成K个数的P次方。</p>
<p>题目解法：可重复序列dfs。</p>
<p>题目关键：</p>
<ul>
<li><p>提前建好表$idx \rarr idx^P$</p>
</li>
<li><p>dfs需要倒序遍历</p>
</li>
<li><p>维护一个curFactorSum以满足题目中要求的factor和最大</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getVal;</span><br><span class="line"><span class="keyword">int</span> n, k, p;</span><br><span class="line"><span class="keyword">int</span> maxFacSum = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans, curAns;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 0 1 4..</span></span><br><span class="line">    <span class="keyword">while</span> (tmp &lt;= n) &#123;</span><br><span class="line">        getVal.push_back(tmp);</span><br><span class="line">        tmp = <span class="built_in">pow</span>(++idx, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curK, <span class="keyword">int</span> curN, <span class="keyword">int</span> curFSum, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curK == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curN == n &amp;&amp; curFSum &gt; maxFacSum) &#123;</span><br><span class="line">            ans = curAns;</span><br><span class="line">            maxFacSum = curFSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curN + getVal[i] &lt;= n) &#123;</span><br><span class="line">            curAns[curK] = i;</span><br><span class="line">            dfs(curK + <span class="number">1</span>, curN + getVal[i], curFSum + i, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;k, &amp;p);</span><br><span class="line">    cal();</span><br><span class="line">    curAns.resize(k);</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, getVal.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans.empty()) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d = "</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d^%d"</span>, ans[i], p);</span><br><span class="line">            <span class="built_in">printf</span>(i == ans.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" + "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1104-Sum-of-Number-Segments"><a href="#1104-Sum-of-Number-Segments" class="headerlink" title="1104 Sum of Number Segments"></a><strong>1104</strong> Sum of Number Segments</h1><p>题目大意：将题目中给出的数字序列的所有连续分段可能的sum加和输出。</p>
<h2 id="个人解法-2"><a href="#个人解法-2" class="headerlink" title="个人解法"></a>个人解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> cur;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;cur);</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] + cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++j) &#123;</span><br><span class="line">            sum += (pre[j] - pre[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前缀和$O(n^2)$，后两个测试点超时。</p>
<h2 id="柳神解法-1"><a href="#柳神解法-1" class="headerlink" title="柳神解法"></a>柳神解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> sum = <span class="number">0</span>, cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%llf"</span>, &amp;cur);</span><br><span class="line">        sum += (cur * i * (n - i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2llf\n"</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每一个元素，它在所有片段的出现次数可以根据其在原序列中的相对位置i求得，次数是[i]前面的$i$个数和后面$n - i + 1$个数的任意组合，即$i*(n - i + 1)$。</p>
<h1 id="1105-spiral-matrix"><a href="#1105-spiral-matrix" class="headerlink" title="1105 spiral matrix"></a>1105 spiral matrix</h1><p>题目大意：将题目给定的随机序列，按增序螺旋顺时针填充到矩阵中。</p>
<p><a href="https://www.cnblogs.com/zlrrrr/p/10355978.html" target="_blank" rel="noopener">参考这位用户的题解写的</a></p>
<p>大致思路：</p>
<p>例如如下4 * 3矩阵空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.空矩阵</span><br><span class="line">. . .</span><br><span class="line">. . .</span><br><span class="line">. . .</span><br><span class="line">. . .</span><br><span class="line">2.第一次遍历从左到右，并且up++以等待下一层遍历</span><br><span class="line">* * *</span><br><span class="line">. . .</span><br><span class="line">. . .</span><br><span class="line">. . .</span><br><span class="line">3. 第二次遍历从上到下，并且right--以等待下一层遍历</span><br><span class="line">* * *</span><br><span class="line">. . *</span><br><span class="line">. . *</span><br><span class="line">. . *</span><br><span class="line">4. 5. ...</span><br><span class="line">* * *</span><br><span class="line">* . *</span><br><span class="line">* . *</span><br><span class="line">* * *</span><br><span class="line">至此完成第一层遍历，此时上下左右的边界指针也移到了第二层的边界处，循环向下执行即可。</span><br></pre></td></tr></table></figure>

<p>具体代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans, vis;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">int</span> m, n, p = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, n, m; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    arr.resize(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">    sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">sqrt</span>((<span class="keyword">double</span>)N); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N % i == <span class="number">0</span>) &#123;</span><br><span class="line">            n = i;</span><br><span class="line">            m = N / i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.assign(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">0</span>, left = <span class="number">0</span>, down = m - <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= right; ++j) ans[up][j] = arr[p++];</span><br><span class="line">        <span class="keyword">if</span> (++up &gt; down) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = up; i &lt;= down; ++i) ans[i][right] = arr[p++];</span><br><span class="line">        <span class="keyword">if</span> (--right &lt; left) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = right; j &gt;= left; --j) ans[down][j] = arr[p++];</span><br><span class="line">        <span class="keyword">if</span> (--down &lt; up) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = down; i &gt;= up; --i) ans[i][left] = arr[p++];</span><br><span class="line">        <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (j != n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1108-Finding-Average"><a href="#1108-Finding-Average" class="headerlink" title="1108 Finding Average"></a>1108 Finding Average</h1><p>题目大意：求序列中满足题目要求的数的平均值。要求是范围在$[-1000,1000]$且精确了两位小数。</p>
<h2 id="第一次提交"><a href="#第一次提交" class="headerlink" title="第一次提交"></a>第一次提交</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stod</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        neg = <span class="literal">true</span>;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) <span class="keyword">return</span> stoi(s);</span><br><span class="line">    <span class="keyword">double</span> p1 = stoi(s.substr(p, pos - p));</span><br><span class="line">    <span class="keyword">double</span> p2 = stoi(s.substr(pos + <span class="number">1</span>, s.<span class="built_in">size</span>() - pos - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">double</span> res = p1 + p2 / <span class="built_in">pow</span>(<span class="number">10</span>, s.<span class="built_in">size</span>() - pos - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (neg == <span class="literal">true</span>) ? -res : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Isdigit</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span>) p++;</span><br><span class="line">    <span class="keyword">if</span> (p == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt; s.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the pos of '.' is [size() - 3] or [size() - 2]</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, cntDot = <span class="number">0</span>, dpos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            cntDot++;</span><br><span class="line">            dpos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cntDot &gt; <span class="number">1</span> || dpos == <span class="number">0</span> || dpos == s.<span class="built_in">size</span>() - <span class="number">1</span> || (dpos &lt;= s.<span class="built_in">size</span>() - <span class="number">4</span> &amp;&amp; dpos &gt;= <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (cntDot == <span class="number">0</span>) <span class="keyword">return</span> Isdigit(s) &amp;&amp; stoi(s) &gt;= <span class="number">-1000</span> &amp;&amp; stoi(s) &lt;= <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[p] == <span class="string">'-'</span>) p++;</span><br><span class="line">    <span class="built_in">string</span> pre = s.substr(p, dpos - p);</span><br><span class="line">    <span class="built_in">string</span> pst = s.substr(dpos + <span class="number">1</span>, s.<span class="built_in">size</span>() - dpos - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Isdigit(pre) || !Isdigit(pst)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">double</span> res = stod(s);</span><br><span class="line">    <span class="keyword">if</span> (res &lt;= <span class="number">1000</span> &amp;&amp; res &gt;= <span class="number">-1000</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (valid(s)) &#123;</span><br><span class="line">            sum += stod(s);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: "</span> &lt;&lt; s &lt;&lt; <span class="string">" is not a legal number"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"The average of 0 numbers is Undefined\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"The average of 1 number is %.2lf\n"</span>, sum);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"The average of %d numbers is %.2lf\n"</span>, cnt, sum / cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二次提交"><a href="#第二次提交" class="headerlink" title="第二次提交"></a>第二次提交</h2><p>更改如下：</p>
<ul>
<li>避免了-1.-1的错误</li>
<li>1.和.1这种写法也是可以的</li>
<li>注意.size()是无符号整数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Isdigit</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt; s.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, cntDot = <span class="number">0</span>, dpos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            cntDot++;</span><br><span class="line">            dpos = i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'-'</span> &amp;&amp; i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cntDot &gt; <span class="number">1</span> || (dpos + <span class="number">4</span> &lt;= s.<span class="built_in">size</span>() &amp;&amp; dpos &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// multiple '.' or accuracy more than 2 places</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cntDot == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span>) p++;</span><br><span class="line">        <span class="keyword">if</span> (p == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Isdigit(s, p) &amp;&amp; stoi(s) &gt;= <span class="number">-1000</span> &amp;&amp; stoi(s) &lt;= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cntDot == <span class="number">1</span> &amp;&amp; s != <span class="string">"-."</span> &amp;&amp; s != <span class="string">"."</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> res = stof(s);</span><br><span class="line">        <span class="keyword">if</span> (res &lt;= <span class="number">1000</span> &amp;&amp; res &gt;= <span class="number">-1000</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (valid(s)) &#123;</span><br><span class="line">            sum += stof(s);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: "</span> &lt;&lt; s &lt;&lt; <span class="string">" is not a legal number"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"The average of 0 numbers is Undefined\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"The average of 1 number is %.2lf\n"</span>, sum);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"The average of %d numbers is %.2lf\n"</span>, cnt, sum / (<span class="keyword">double</span>)cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1109-Group-Photo"><a href="#1109-Group-Photo" class="headerlink" title="1109 Group Photo"></a>1109 Group Photo</h1><p>题目大意：排队照相。要求：</p>
<ol>
<li>从第一排开始，每排要求站<code>N/K</code>个人，剩余的所有人站在最后一排。</li>
<li>前一排的最高的人也要比后一排最矮的人矮。</li>
<li>每一排里，假设它们的身高提前有序的非递增排列好，那么最高的人($arr[0]$)先排到第$m / 2 + 1$的位置上去，然后依次将<code>arr[1], arr[2] ..</code>排到最高的人右边、左边、右边……以此类推。</li>
<li>输出先输出最后一排，然后倒二……也就是与照相人是镜面站立的。</li>
</ol>
<p>题目关键：</p>
<ul>
<li>读懂题！由于镜面站立，第三条要求要明白左右究竟在哪边</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inf</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> hgt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;inf&gt; <span class="title">crowd</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        inf t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t.name &gt;&gt; t.hgt;</span><br><span class="line">        crowd[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(crowd.<span class="built_in">begin</span>(), crowd.<span class="built_in">end</span>(), [](inf &amp;f1, inf &amp;f2)&#123;<span class="keyword">return</span> (f1.hgt == f2.hgt) ? f1.name &lt; f2.name : f1.hgt &gt; f2.hgt;&#125;);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, row = k, curnum = n - n / k * (k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; k) curnum = n / k;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">tmp</span><span class="params">(curnum + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = curnum / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        tmp[i] = crowd[p++].name;</span><br><span class="line">        <span class="comment">// right and left alternatively</span></span><br><span class="line">        <span class="keyword">int</span> r = i - <span class="number">1</span>, l = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; curnum - <span class="number">1</span>; ++t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// right</span></span><br><span class="line">                tmp[r--] = crowd[p++].name;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// left</span></span><br><span class="line">                tmp[l++] = crowd[p++].name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//print</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= curnum; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tmp[j];</span><br><span class="line">            <span class="built_in">printf</span>(j == curnum ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        row--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1111-Online-Map"><a href="#1111-Online-Map" class="headerlink" title="1111 Online Map"></a>1111 Online Map</h1><p>题目大意：输入信息里面包括两个结点间的路程差和时间差，分别根据这些信息输出有向图的u-&gt;v的最短路径和最快路径。</p>
<h2 id="第一次提交-1"><a href="#第一次提交-1" class="headerlink" title="第一次提交"></a>第一次提交</h2><p>DFS，差最后一个用例超时？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnum = <span class="number">0x7fffffff</span>; <span class="comment">// 2^31-1</span></span><br><span class="line"><span class="keyword">int</span> Time[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inf</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Time = <span class="number">0</span>, dis = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">copy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;curPath)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curPath.<span class="built_in">size</span>(); ++i) ans.emplace_back(curPath[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> dst, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;curPath, inf &amp;ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vis, <span class="keyword">int</span> t, <span class="keyword">int</span> d, <span class="keyword">int</span> cnt, <span class="keyword">int</span> choice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == dst &amp;&amp; choice == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans.cnt == <span class="number">0</span> || d &lt; ans.dis || (d == ans.dis &amp;&amp; t &lt; ans.Time)) &#123;</span><br><span class="line">            ans.dis = d;</span><br><span class="line">            ans.Time = t;</span><br><span class="line">            ans.cnt = cnt;</span><br><span class="line">            ans.path = copy(curPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cur == dst &amp;&amp; choice == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans.cnt == <span class="number">0</span> || t &lt; ans.Time || (t == ans.Time &amp;&amp; cnt &lt; ans.cnt)) &#123;</span><br><span class="line">            ans.dis = d;</span><br><span class="line">            ans.Time = t;</span><br><span class="line">            ans.cnt = cnt;</span><br><span class="line">            ans.path = copy(curPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[cur][i] != <span class="number">0</span> &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            curPath.emplace_back(i);</span><br><span class="line">            dfs(i, dst, n, curPath, ans, vis, t + Time[cur][i], d + dis[cur][i], cnt + <span class="number">1</span>, choice);</span><br><span class="line">            curPath.pop_back();</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, u, v, b, d, t, <span class="built_in">size</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d"</span>, &amp;u, &amp;v, &amp;b, &amp;d, &amp;t);</span><br><span class="line">        dis[u][v] = d;</span><br><span class="line">        Time[u][v] = t;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            dis[v][u] = d;</span><br><span class="line">            Time[v][u] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">    inf ans_dis, ans_time;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curPath1 = &#123;u&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dfs(u, v, n, curPath1, ans_dis, vis, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    vis.assign(n, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curPath2 = &#123;u&#125;;</span><br><span class="line">    dfs(u, v, n, curPath2, ans_time, vis, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans_dis.path == ans_time.path) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d; Time = %d: "</span>, ans_dis.dis, ans_dis.Time);</span><br><span class="line">        <span class="built_in">size</span> = ans_dis.path.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, ans_dis.path[i], i == <span class="built_in">size</span> - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" -&gt; "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d: "</span>, ans_dis.dis);</span><br><span class="line">        <span class="built_in">size</span> = ans_dis.path.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, ans_dis.path[i], i == <span class="built_in">size</span> - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" -&gt; "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Time = %d: "</span>, ans_time.Time);</span><br><span class="line">        <span class="built_in">size</span> = ans_time.path.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, ans_time.path[i], i == <span class="built_in">size</span> - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" -&gt; "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二次提交-1"><a href="#第二次提交-1" class="headerlink" title="第二次提交"></a>第二次提交</h2><p>dijkstra维护当前结果 03.09</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, u, v, b, l, t, Start, End;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxWeight = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> Leng[maxN][maxN], Time[maxN][maxN]; <span class="comment">// information</span></span><br><span class="line"><span class="keyword">int</span> disLen[maxN], disTim[maxN], num[maxN]; <span class="comment">// measurement</span></span><br><span class="line"><span class="keyword">bool</span> isMin[maxN]; <span class="comment">// vis array</span></span><br><span class="line"><span class="keyword">int</span> pathLen[maxN], pathTim[maxN]; <span class="comment">// path array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findShortest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(disLen, disLen + maxN, maxWeight);</span><br><span class="line">    <span class="built_in">fill</span>(disTim, disTim + maxN, maxWeight);</span><br><span class="line">    <span class="built_in">fill</span>(isMin, isMin + maxN, <span class="literal">false</span>);</span><br><span class="line">    disLen[Start] = <span class="number">0</span>;</span><br><span class="line">    disTim[Start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> minDist = maxWeight, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMin[j] == <span class="number">0</span> &amp;&amp; disLen[j] &lt; minDist) &#123;</span><br><span class="line">                minDist = disLen[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        isMin[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMin[j] == <span class="number">0</span> &amp;&amp; Leng[u][j] != maxWeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (disLen[j] &gt; disLen[u] + Leng[u][j]) &#123; <span class="comment">// first measurement</span></span><br><span class="line">                    disLen[j] = disLen[u] + Leng[u][j];</span><br><span class="line">                    disTim[j] = disTim[u] + Time[u][j];</span><br><span class="line">                    pathLen[j] = u;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (disLen[j] == disLen[u] + Leng[u][j] &amp;&amp; disTim[j] &gt; disTim[u] + Time[u][j]) &#123; <span class="comment">// second measurement</span></span><br><span class="line">                    disTim[j] = disTim[u] + Time[u][j];</span><br><span class="line">                    pathLen[j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findFastest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(disTim, disTim + maxN, maxWeight);</span><br><span class="line">    <span class="built_in">fill</span>(num, num + maxN, maxWeight);</span><br><span class="line">    <span class="built_in">fill</span>(isMin, isMin + maxN, <span class="literal">false</span>);</span><br><span class="line">    disTim[Start] = <span class="number">0</span>;</span><br><span class="line">    num[Start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> minTime = maxWeight, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMin[j] == <span class="number">0</span> &amp;&amp; disTim[j] &lt; minTime) &#123;</span><br><span class="line">                minTime = disTim[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        isMin[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMin[j] == <span class="number">0</span> &amp;&amp; Time[u][j] != maxWeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (disTim[j] &gt; disTim[u] + Time[u][j]) &#123;</span><br><span class="line">                    disTim[j] = disTim[u] + Time[u][j];</span><br><span class="line">                    num[j] = num[u] + <span class="number">1</span>;</span><br><span class="line">                    pathTim[j] = u;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (disTim[j] == disTim[u] + Time[u][j] &amp;&amp; num[j] &gt; num[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                    num[j] = num[u] + <span class="number">1</span>;</span><br><span class="line">                    pathTim[j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">fill</span>(Leng[<span class="number">0</span>], Leng[<span class="number">0</span>] + maxN * maxN, maxWeight);</span><br><span class="line">    <span class="built_in">fill</span>(Time[<span class="number">0</span>], Time[<span class="number">0</span>] + maxN * maxN, maxWeight);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d"</span>, &amp;u, &amp;v, &amp;b, &amp;l, &amp;t);</span><br><span class="line">        Leng[u][v] = l;</span><br><span class="line">        Time[u][v] = t;</span><br><span class="line">        <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">            Leng[v][u] = l;</span><br><span class="line">            Time[v][u] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Start &gt;&gt; End;</span><br><span class="line">    </span><br><span class="line">    findShortest();</span><br><span class="line">    findFastest();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据path数组向前回溯得到路径</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pL, pT;</span><br><span class="line">    <span class="keyword">int</span> p1 = End, p2 = End;</span><br><span class="line">    <span class="keyword">while</span> (p1 != Start) &#123;</span><br><span class="line">        pL.push_back(p1);</span><br><span class="line">        p1 = pathLen[p1];</span><br><span class="line">    &#125;</span><br><span class="line">    pL.push_back(Start);</span><br><span class="line">    <span class="keyword">while</span> (p2 != Start) &#123;</span><br><span class="line">        pT.push_back(p2);</span><br><span class="line">        p2 = pathTim[p2];</span><br><span class="line">    &#125;</span><br><span class="line">    pT.push_back(Start);</span><br><span class="line">    <span class="keyword">if</span> (isSame(pL, pT)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d; Time = %d: "</span>, disLen[End], disTim[End]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pL.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, pL[i], i == <span class="number">0</span> ? <span class="string">"\n"</span> : <span class="string">" -&gt; "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d: "</span>, disLen[End]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pL.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, pL[i], i == <span class="number">0</span> ? <span class="string">"\n"</span> : <span class="string">" -&gt; "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Time = %d: "</span>, disTim[End]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pT.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, pT[i], i == <span class="number">0</span> ? <span class="string">"\n"</span> : <span class="string">" -&gt; "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1112-stucked-keyboard"><a href="#1112-stucked-keyboard" class="headerlink" title="1112 stucked keyboard"></a>1112 stucked keyboard</h1><p>题目大意：你的某一个键帽卡住了，卡住的键帽敲击一次将永远造成多输入<code>k-1</code>次的情况。现在你要根据该键盘输入的一个序列，来判断到底是哪些键帽出现了卡塞现象，并输出正确语句。</p>
<p>题目关键：</p>
<ul>
<li>输出的检测到有卡住的符号应该按照<strong>发现的顺序</strong>，而不是按照映射表中的顺序。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. cnt[i] % n != 0</span></span><br><span class="line"><span class="comment">2. when not consecutive, check if cnt[i] % n != 0 ? if yes, notStuck[i] = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIdx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= <span class="number">122</span> &amp;&amp; c &gt;= <span class="number">97</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">11</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt;= <span class="number">9</span>) <span class="keyword">return</span> <span class="string">'0'</span> + idx;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (idx == <span class="number">10</span>) <span class="keyword">return</span> <span class="string">'_'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'a'</span> + idx - <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n; <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">37</span>]; <span class="comment">// 0-9 _ (11-36)a-z</span></span><br><span class="line">    <span class="keyword">int</span> notStuck[<span class="number">37</span>];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(notStuck, <span class="number">0</span>, <span class="keyword">sizeof</span> notStuck);</span><br><span class="line">    <span class="keyword">int</span> lastIdx = getIdx(s[<span class="number">0</span>]), cscLen = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        idx = getIdx(s[p]);</span><br><span class="line">        cnt[idx]++;</span><br><span class="line">        <span class="keyword">if</span> (idx == lastIdx) &#123;</span><br><span class="line">            cscLen++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cscLen % n != <span class="number">0</span> || cnt[lastIdx] % n != <span class="number">0</span>) &#123;</span><br><span class="line">            notStuck[lastIdx] = <span class="number">1</span>;</span><br><span class="line">            cscLen = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cscLen = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastIdx = idx;</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cscLen % n != <span class="number">0</span> || cnt[lastIdx] % n != <span class="number">0</span>) &#123;</span><br><span class="line">        notStuck[lastIdx] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; isStuck;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = getIdx(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (isStuck[index] == <span class="literal">false</span> &amp;&amp; cnt[index] &amp;&amp; cnt[index] % n == <span class="number">0</span> &amp;&amp; notStuck[index] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; getChar(index);</span><br><span class="line">            isStuck[index] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = getIdx(s[p]);</span><br><span class="line">        ans.push_back(s[p]);</span><br><span class="line">        <span class="keyword">if</span> (isStuck[i]) &#123;</span><br><span class="line">            p += n;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1114-Family-Property"><a href="#1114-Family-Property" class="headerlink" title="1114 Family Property"></a>1114 Family Property</h1><p>题目大意：根据输入的信息：<code>id</code> <code>father</code> <code>mother</code> <code>k</code> <code>child[0] .. child[k - 1]</code> <code>M_estate</code> <code>area</code>信息分析输出n个家庭的<code>minId</code> <code>size</code> <code>avg_est</code> <code>avg_area</code>信息。</p>
<p>题目分析：</p>
<ul>
<li><p>是一道较为复杂的并查集题目。</p>
</li>
<li><p>数据结构设计如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inf</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> member = MAXLen + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum_area = <span class="number">0</span>, sum_est = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> avg_area, avg_est;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路是先边读取信息，边构造并查集（由于最后的输出要求<code>minId</code>，所以构建的时候要让根结点的id为最小值，Union函数中的构造语句修改为<code>father[max(fx, fy)] = min(fx, fy);</code>）。</p>
</li>
<li><p>构造完成之后，遍历<code>[1000, 9999]</code>这些所有可能的id，针对其中每个id，找到它的<code>root</code>。并更新<code>root</code>中的所有信息（有的是直接代替，有的是进行累加）。</p>
</li>
<li><p>再次遍历<code>[1000, 9999]</code>这些所有id，对于所有的根节点（<code>list[id].size != 0</code>），将其添加入<code>ans</code>数组中，进行排序操作，并格式化输出即可。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLen = <span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inf</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> member = MAXLen + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum_area = <span class="number">0</span>, sum_est = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> avg_area, avg_est;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXLen];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; isExist;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">estInfo</span><span class="params">(MAXLen)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;inf&gt; <span class="title">list</span><span class="params">(MAXLen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != father[x]) &#123;</span><br><span class="line">        father[x] = <span class="built_in">find</span>(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">int</span> fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) father[<span class="built_in">max</span>(fx, fy)] = <span class="built_in">min</span>(fx, fy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(inf &amp;f1, inf &amp;f2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f1.avg_area == f2.avg_area) ? f1.member &lt; f2.member : f1.avg_area &gt; f2.avg_area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, id, fa, mo, k, M, area; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXLen; ++i) father[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; fa &gt;&gt; mo &gt;&gt; k;</span><br><span class="line">        isExist[id] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (fa != <span class="number">-1</span>) &#123;</span><br><span class="line">            Union(id, fa);</span><br><span class="line">            isExist[fa] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mo != <span class="number">-1</span>) &#123;</span><br><span class="line">            Union(id, mo);</span><br><span class="line">            isExist[mo] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> child;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; child;</span><br><span class="line">            isExist[child] = <span class="number">1</span>;</span><br><span class="line">            Union(id, child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; M &gt;&gt; area;</span><br><span class="line">        estInfo[id].push_back(M);</span><br><span class="line">        estInfo[id].push_back(area);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXLen; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isExist[i]) &#123;</span><br><span class="line">            inf info;</span><br><span class="line">            <span class="keyword">int</span> root = <span class="built_in">find</span>(i);</span><br><span class="line">            <span class="built_in">list</span>[root].member = root;</span><br><span class="line">            <span class="built_in">list</span>[root].<span class="built_in">size</span>++;</span><br><span class="line">            <span class="keyword">if</span> (estInfo[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">list</span>[root].sum_area += estInfo[i][<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">list</span>[root].sum_est += estInfo[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;inf&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXLen; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>[i].<span class="built_in">size</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span>[i].avg_area = <span class="built_in">list</span>[i].sum_area / <span class="built_in">list</span>[i].<span class="built_in">size</span>;</span><br><span class="line">            <span class="built_in">list</span>[i].avg_est = <span class="built_in">list</span>[i].sum_est / <span class="built_in">list</span>[i].<span class="built_in">size</span>;</span><br><span class="line">            ans.push_back(<span class="built_in">list</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%04d %d %.3lf %.3lf\n"</span>, ans[i].member, ans[i].<span class="built_in">size</span>, ans[i].avg_est, ans[i].avg_area);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1115-counting-nodes-in-a-BST"><a href="#1115-counting-nodes-in-a-BST" class="headerlink" title="1115 counting nodes in a BST"></a>1115 counting nodes in a BST</h1><p>题目大意：根据序列构建二叉搜索树，并返回最后两层的结点数。</p>
<p>思路：</p>
<ul>
<li>根据序列依次递归建立二叉搜索树</li>
<li>遍历结点得到树的深度</li>
<li>BFS遍历，并在深度为倒数第二和倒数第一时进行输出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TreeNode *root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            insert(root-&gt;left, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;left = <span class="keyword">new</span> TreeNode(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            insert(root-&gt;right, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;right = <span class="keyword">new</span> TreeNode(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDep</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (root == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">max</span>(getDep(root-&gt;left), getDep(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, node;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node);</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(node);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node);</span><br><span class="line">        insert(root, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> depth = getDep(root), curdep = <span class="number">0</span>, n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">        curdep++;</span><br><span class="line">        <span class="keyword">if</span> (curdep == depth - <span class="number">1</span>) n2 = <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">if</span> (curdep == depth) n1 = <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;left) q.push(tmp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;right) q.push(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d\n"</span>, n1, n2, n1 + n2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1119-Pre-and-Post-order-Traversals"><a href="#1119-Pre-and-Post-order-Traversals" class="headerlink" title="1119 Pre- and Post-order Traversals"></a>1119 Pre- and Post-order Traversals</h1><p>题目大意：根据树的前序和后序遍历返回对应的中序遍历，以及当前的前序和后序是否能够唯一确定一棵二叉树。</p>
<p>思路：</p>
<ul>
<li>首先选定前序的当前第一位和后序的当前最后位</li>
<li>然后check后序的倒数第二位在前序序列中的对应位，借此将前序和后序分成左子树和右子树。</li>
<li>当出现<code>pre:3 4</code>和<code>post:4 3</code>这样的序列时，二叉树不唯一，因为此时3和4的左右子树位置无法确定。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in, pre, post;</span><br><span class="line"><span class="keyword">bool</span> unq = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getIn</span><span class="params">(<span class="keyword">int</span> prl, <span class="keyword">int</span> prr, <span class="keyword">int</span> pol, <span class="keyword">int</span> por)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prl == prr) &#123;</span><br><span class="line">        in.push_back(pre[prr]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span> (pre[prl] == post[por]) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = prl + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= prr &amp;&amp; pre[i] != post[por - <span class="number">1</span>]) ++i;</span><br><span class="line">        <span class="keyword">if</span> (i - prl &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            len = i - <span class="number">1</span> - prl;</span><br><span class="line">            getIn(prl + <span class="number">1</span>, i - <span class="number">1</span>, pol, pol + len - <span class="number">1</span>); <span class="comment">// left tree</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unq = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        in.push_back(post[por]); <span class="comment">// root</span></span><br><span class="line">        getIn(i, prr, pol + len, por - <span class="number">1</span>); <span class="comment">// right tree</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    pre.resize(n); post.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;post[i]);</span><br><span class="line">    getIn(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (unq) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, in[i], (i == n - <span class="number">1</span>) ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1123-Is-It-a-Complete-AVL-Tree"><a href="#1123-Is-It-a-Complete-AVL-Tree" class="headerlink" title="1123 Is It a Complete AVL Tree"></a>1123 Is It a Complete AVL Tree</h1><p>题目大意：根据给定的序列，构建一株平衡二叉搜索树，并给出树的层序遍历，以及这是不是一株完全二叉树。</p>
<p>思路：</p>
<ul>
<li>构建平衡二叉搜索树需要有四个基本操作，每一次递归建树的时候，当左右子树高度差大于等于2时，要采取对应的左右旋操作。</li>
<li>层序遍历的时候，一旦遍历到某个结点的左子树或右子树为空时，再在后序的遍历中发现类似情况则可判定不是完全二叉树。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TreeNode* <span class="title">LL</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    TreeNode *tmp = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = root;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">RR</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    TreeNode *tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left = tmp-&gt;right;</span><br><span class="line">    tmp-&gt;right = root;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">LR</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;left = LL(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> RR(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">RL</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;right = RR(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> LL(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDep</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="built_in">max</span>(getDep(root-&gt;left), getDep(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode *<span class="title">insert</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">int</span> ld = getDep(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rd = getDep(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (ld - rd &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; root-&gt;left-&gt;val) &#123;</span><br><span class="line">                root = RR(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = LR(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">int</span> ld = getDep(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rd = getDep(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rd - ld &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; root-&gt;right-&gt;val) &#123;</span><br><span class="line">                root = LL(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = RL(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> isComplete = <span class="number">1</span>, after = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        TreeNode *tmp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        v.push_back(tmp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (after) isComplete = <span class="number">0</span>;</span><br><span class="line">            q.push(tmp-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            after = <span class="number">1</span>; <span class="comment">// if left is null and then their is another node appear at any level</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (after) isComplete = <span class="number">0</span>;</span><br><span class="line">            q.push(tmp-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            after = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tmp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    TreeNode *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        root = insert(root, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = bfs(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, v[i], i == v.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, isComplete ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1126-Eulerian-Path"><a href="#1126-Eulerian-Path" class="headerlink" title="1126 Eulerian Path"></a>1126 Eulerian Path</h1><p>题目大意：判断无向图是否是欧拉？半欧拉？非欧拉图？</p>
<p>题目关键：</p>
<ul>
<li>要遍历一遍图看看是否能走到全部节点从而判断连通性（欧拉图和半欧拉图的必要条件）！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; graph;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    vis[cur] = <span class="number">1</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[cur].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[graph[cur][i]] == <span class="number">0</span>) dfs(graph[cur][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, u, v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    graph.resize(n + <span class="number">1</span>);</span><br><span class="line">    vis.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        graph[u].push_back(v);</span><br><span class="line">        graph[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>, even = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        degree[i] = graph[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (degree[i] % <span class="number">2</span> == <span class="number">0</span>) even++;</span><br><span class="line">        <span class="keyword">else</span> odd++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, degree[i], i == n ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (even == n &amp;&amp; cnt == n) <span class="built_in">printf</span>(<span class="string">"Eulerian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (odd == <span class="number">2</span> &amp;&amp; cnt == n) <span class="built_in">printf</span>(<span class="string">"Semi-Eulerian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Non-Eulerian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1129-Recommendation-System"><a href="#1129-Recommendation-System" class="headerlink" title="1129 Recommendation System"></a>1129 Recommendation System</h1><p>题目大意：简单的一个推荐系统。对于给定序列的每个元素的推荐的机制为首先推荐出现次数最多的元素，若元素的出现次数相等，则按索引的升序排列。推荐的个数不超过k个。</p>
<h2 id="第一次提交-2"><a href="#第一次提交-2" class="headerlink" title="第一次提交"></a>第一次提交</h2><p>暴力排序法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, cnt = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node &amp;n1, node &amp;n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1.cnt == n2.cnt ? n1.id &lt; n2.id : n1.cnt &gt; n2.cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            cnt[tmp]++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">                node ob;</span><br><span class="line">                ob.id = i;</span><br><span class="line">                ob.cnt = cnt[i];</span><br><span class="line">                inf.emplace_back(ob);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(inf.<span class="built_in">begin</span>(), inf.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: "</span>, tmp);</span><br><span class="line">        <span class="keyword">int</span> printSize = <span class="built_in">min</span>(k, inf.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; printSize; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, inf[i].id, i == printSize - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[tmp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$O(n<em>(n + n</em>logn))$–超时了三个用例。</p>
<h2 id="第二次提交-2"><a href="#第二次提交-2" class="headerlink" title="第二次提交"></a>第二次提交</h2><p>指针法，每一次都只有一个元素的cnt会增加，那么想要实现自动排序只需尝试将这个元素向前移动即可。至于增加它的cnt的工作，在一个按照原索引排序的数组inf里面对对应下标的inf[i]进行cnt更改即可自动在sorted里面相同的指针实现相同的cnt修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, cnt = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;node*&gt; <span class="title">inf</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node*&gt; sorted;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        inf[i] = <span class="keyword">new</span> node;</span><br><span class="line">        inf[i]-&gt;id = i;</span><br><span class="line">        sorted.push_back(inf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> p;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; sorted.<span class="built_in">size</span>(); ++p)</span><br><span class="line">                <span class="keyword">if</span> (sorted[p]-&gt;cnt == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">min</span>(k, p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d: "</span>, tmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, sorted[j]-&gt;id, j == len - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        inf[tmp]-&gt;cnt++;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sorted[p]-&gt;id != tmp) ++p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sorted[j]-&gt;cnt &lt; sorted[p]-&gt;cnt || (sorted[j]-&gt;cnt == sorted[p]-&gt;cnt &amp;&amp; sorted[j]-&gt;id &gt; sorted[p]-&gt;id)) &#123;</span><br><span class="line">                node* t = sorted[j];</span><br><span class="line">                sorted[j] = sorted[p];</span><br><span class="line">                sorted[p] = t;</span><br><span class="line">                p--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不用排序，但是仍然$O(n^2)$，超时了两个用例。</p>
<h2 id="柳神解法-2"><a href="#柳神解法-2" class="headerlink" title="柳神解法"></a>柳神解法</h2><p>set解决，之前一直以为set是$O(nlogn)$没想到只有$O(logn)$复杂度。用set可以飞速解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> times[<span class="number">50001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, cnt;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// operator &lt; overloading</span></span><br><span class="line">        <span class="keyword">return</span> (cnt != a.cnt) ? cnt &gt; a.cnt : val &lt; a.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d:"</span>, num);</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); tmp &lt; k &amp;&amp; it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>, it-&gt;val);</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it = s.<span class="built_in">find</span>(node&#123;num, times[num]&#125;); <span class="comment">// O(logn)</span></span><br><span class="line">        <span class="keyword">if</span> (it != s.<span class="built_in">end</span>()) s.erase(it);</span><br><span class="line">        times[num]++;</span><br><span class="line">        s.insert(node&#123;num, times[num]&#125;); <span class="comment">// O(logn)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1012-The-Best-Rank"><a href="#1012-The-Best-Rank" class="headerlink" title="1012 The Best Rank"></a>1012 The Best Rank</h1><p>题目大意：给出<code>id grade1 grade2 grade3</code>的输入集，将所给信息按照<code>avgGrade &gt; grade1 &gt; grade2 &gt; grade3</code>的顺序进行排序。要求输出每个id的四项成绩中最好排名以及对应的科目。</p>
<p>题目关键：</p>
<ul>
<li>avg需要四舍五入<code>(a+b+c)/3.0+0.5</code></li>
<li>排名要求并列时同名次，下一个排名+并列人数，例如：<code>1 1 3 3 5</code>。</li>
</ul>
<p>思路：</p>
<ul>
<li>优先级通过先后进行四次排序实现，每次排序标准不一样</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">4</span>], rank[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> idToidx[<span class="number">1000000</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; arr;</span><br><span class="line"><span class="keyword">char</span> rk2Char[<span class="number">4</span>] = &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, id;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    arr.resize(n);</span><br><span class="line">    <span class="built_in">fill</span>(idToidx, idToidx + <span class="number">1000000</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;arr[i].id, &amp;arr[i].score[<span class="number">1</span>], &amp;arr[i].score[<span class="number">2</span>], &amp;arr[i].score[<span class="number">3</span>]);</span><br><span class="line">        arr[i].score[<span class="number">0</span>] = (arr[i].score[<span class="number">1</span>] + arr[i].score[<span class="number">2</span>] + arr[i].score[<span class="number">3</span>]) / <span class="number">3.0</span> + <span class="number">0.5</span>; <span class="comment">// round()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rank the list</span></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; <span class="number">4</span>; ++idx) &#123;</span><br><span class="line">        sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](Node &amp;n1, Node &amp;n2)&#123;<span class="keyword">return</span> n1.score[idx] &gt; n2.score[idx];&#125;);</span><br><span class="line">        arr[<span class="number">0</span>].rank[idx] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j].score[idx] == arr[j - <span class="number">1</span>].score[idx]) &#123;</span><br><span class="line">                arr[j].rank[idx] = arr[j - <span class="number">1</span>].rank[idx];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[j].rank[idx] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// id -&gt; arr[idx]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        idToidx[arr[i].id] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do the query</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;id);</span><br><span class="line">        <span class="keyword">if</span> (idToidx[id] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rk = <span class="number">2005</span>, rk_idx;</span><br><span class="line">            <span class="keyword">int</span> index = idToidx[id];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[index].rank[j] &lt; rk) &#123;</span><br><span class="line">                    rk = arr[index].rank[j];</span><br><span class="line">                    rk_idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %c\n"</span>, rk, rk2Char[rk_idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"N/A\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1013-Battle-Over-Cities"><a href="#1013-Battle-Over-Cities" class="headerlink" title="1013 Battle Over Cities"></a>1013 Battle Over Cities</h1><p>题目大意：给定一个无向图，当某个结点（城市）被毁灭，其所有边被毁，问最少需要额外多少条边将剩下的结点连接起来。</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul>
<li>将边逐一读入edge里面</li>
<li>以所有没有被毁的边为依据建立并查集，并数数得到cnt-2即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, k, u, v;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edge;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != father[x]) &#123;</span><br><span class="line">        father[x] = <span class="built_in">find</span>(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="keyword">int</span> fb = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (fa != fb) &#123;</span><br><span class="line">        father[fa] = fb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        edge.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) father[i] = i; <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i][<span class="number">0</span>] == u || edge[i][<span class="number">1</span>] == u) <span class="keyword">continue</span>;</span><br><span class="line">            Union(edge[i][<span class="number">0</span>], edge[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">isRoot</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            isRoot[<span class="built_in">find</span>(i)] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = accumulate(isRoot.<span class="built_in">begin</span>(), isRoot.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>类似于填充问题，<a href="https://www.liuchuo.net/archives/2346" target="_blank" rel="noopener">参考柳神</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    visit[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i] == <span class="literal">false</span> &amp;&amp; v[node][i] == <span class="number">1</span>)</span><br><span class="line">            dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, k, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        v[a][b] = v[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">fill</span>(visit, visit + <span class="number">1010</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        visit[a] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[j] == <span class="literal">false</span>) &#123;</span><br><span class="line">                dfs(j);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1014-Waiting-in-Line"><a href="#1014-Waiting-in-Line" class="headerlink" title="1014 Waiting in Line"></a>1014 Waiting in Line</h1><p>题目大意：银行处理业务。从8点开始，n个窗口每个最大排队人数为m，将当前所有人排序<code>1,2,3...k</code>，按照以下方式先站队（n=2，m=2）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">窗口1 person1 person3</span><br><span class="line">窗口2 person2 person4</span><br><span class="line">黄线外 person5 ... personk</span><br></pre></td></tr></table></figure>

<p>每次当某个窗口的某人业务处理完，黄线外的人以队伍长短和窗口编号为优先级跟队，给定每个人的业务消耗时间。</p>
<p>要求输出每个人的业务完成终止时间，注意17点银行下班，<strong>17点之后不处理新的业务，但是17点前所接的业务，无论多晚必须完成！</strong></p>
<p>题目关键：如果某人19:02处理完业务，但是他是从16:59开始处理的，那么负责任的银行会加班帮他完成，而不是sorry！这简直太敬业了！！吐~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;node[<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; q[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getTime</span><span class="params">(<span class="keyword">int</span> dtime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">8</span>, m = <span class="number">0</span>;</span><br><span class="line">    h += (dtime / <span class="number">60</span>);</span><br><span class="line">    m += (dtime % <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (h &gt; <span class="number">24</span>) h %= <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (h &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        ans.push_back(<span class="string">'0'</span>);</span><br><span class="line">        ans.push_back(<span class="string">'0'</span> + h);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans.push_back(h / <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">        ans.push_back(h % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(<span class="string">':'</span>);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        ans.push_back(<span class="string">'0'</span>);</span><br><span class="line">        ans.push_back(<span class="string">'0'</span> + m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans.push_back(m / <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">        ans.push_back(m % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!q[i].empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, Q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node[i].cost);</span><br><span class="line">        node[i].num = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// build queue</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; waitLine;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= k &amp;&amp; p &lt;= n * m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            q[j].push(node[p++]);</span><br><span class="line">            <span class="keyword">if</span> (p &gt; k) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n * m + <span class="number">1</span>; i &lt;= k; ++i) waitLine.push(node[i]);</span><br><span class="line">    <span class="comment">// simulating</span></span><br><span class="line">    <span class="keyword">int</span> mins = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastFinalTime[n]; <span class="comment">// the last one of that window who has finished the transaction --- current time</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(k + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">memset</span>(lastFinalTime, <span class="number">0</span>, <span class="keyword">sizeof</span> lastFinalTime);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(n)) &#123;</span><br><span class="line">        <span class="comment">// traverse every window</span></span><br><span class="line">        ++mins;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].front().cost == (mins - lastFinalTime[i])) &#123;</span><br><span class="line">                ans[q[i].front().num] = lastFinalTime[i] &lt; <span class="number">540</span> ? mins : <span class="number">-1</span>; <span class="comment">// check if bank will process this</span></span><br><span class="line">                q[i].pop();</span><br><span class="line">                <span class="keyword">if</span> (!waitLine.empty()) &#123;</span><br><span class="line">                    <span class="comment">// gurantee the waitline is not empty</span></span><br><span class="line">                    q[i].push(waitLine.front());</span><br><span class="line">                    waitLine.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                lastFinalTime[i] = mins; <span class="comment">// update lastFinalTime</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (ans[tmp] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; getTime(ans[tmp]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Sorry\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1018-Public-Bike-Management"><a href="#1018-Public-Bike-Management" class="headerlink" title="1018 Public Bike Management"></a><strong>1018 Public Bike Management</strong></h1><p>题目大意：</p>
<p><img src="https://images.ptausercontent.com/213" alt=""></p>
<p>在如上类似的图中，表示一个自行车管理系统，总站可以发出车辆，也可以收集车辆，而每个station最合适的车辆数为该s最多容纳数量cmax的一半。现在要求到目标地的最短路径上的所有车站的车辆都最佳（达到cmax/2），致力于求出该路径以及需要从总站发出的数量和带回到总站的数量。</p>
<p>思路：</p>
<ul>
<li><p>最短路径直接深搜即可。</p>
</li>
<li><p>当满足dfs递归出口，此时开始计算<code>sent</code>和<code>back</code>的车子数量。计算逻辑是先得到<code>sent</code>再直接得到<code>back</code>，<code>sent</code>和<code>back</code>的获得方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (curDis &lt;= ansDis) &#123;</span><br><span class="line">    inf info;</span><br><span class="line">    info.ans = copy(route);</span><br><span class="line">    info.dist = curDis;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>; <span class="comment">// tmp保存的是所有车站当前车子数量的前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; route.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        tmp += cur[route[i]]; <span class="comment">// 更新tmp</span></span><br><span class="line">        info.sent = <span class="built_in">max</span>(info.sent, tmp); <span class="comment">// 要始终保证当前行进的管理人员手上始终有足够的车辆送</span></span><br><span class="line">    &#125;</span><br><span class="line">    info.back = info.sent - tmp; <span class="comment">// 根据路程上的车辆总和和sent直接求出back</span></span><br><span class="line">    information.push_back(info);</span><br><span class="line">    ansDis = curDis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>最后要将得到的所有可能的结果进行排序，排序的依据如题。先要求sent最少，次要求back最少。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inf</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> sent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> back = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> cur[<span class="number">510</span>];</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dis</span><span class="params">(<span class="number">510</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">510</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line"><span class="keyword">int</span> ansDis = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> cmax, n, sp, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;inf&gt; information;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">copy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) ret.emplace_back(arr[i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;route, <span class="keyword">int</span> curDis, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curDis &lt;= ansDis) &#123;</span><br><span class="line">            inf info;</span><br><span class="line">            info.ans = copy(route);</span><br><span class="line">            info.dist = curDis;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; route.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                tmp += cur[route[i]];</span><br><span class="line">                info.sent = <span class="built_in">max</span>(info.sent, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            info.back = info.sent - tmp;</span><br><span class="line">            information.push_back(info);</span><br><span class="line">            ansDis = curDis;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[start][i] != <span class="number">-1</span> &amp;&amp; vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            route.emplace_back(i);</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(i, <span class="built_in">end</span>, route, curDis + dis[start][i], vis);</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">            route.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(inf &amp;f1, inf &amp;f2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f1.dist != f2.dist) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.dist &lt; f2.dist;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f1.sent != f2.sent) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.sent &lt; f2.sent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.back &lt; f2.back;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, d;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cmax &gt;&gt; n &gt;&gt; sp &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cur[i]);</span><br><span class="line">        cur[i] = cmax / <span class="number">2</span> - cur[i]; <span class="comment">// cur[i] represent how many bikes are we going to collect(-)/give(+)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;d);</span><br><span class="line">        dis[u][v] = d;</span><br><span class="line">        dis[v][u] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; route = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dfs(<span class="number">0</span>, sp, route, <span class="number">0</span>, vis);</span><br><span class="line">    sort(information.<span class="built_in">begin</span>(), information.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; information[<span class="number">0</span>].sent &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; information[<span class="number">0</span>].ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, information[<span class="number">0</span>].ans[i], i == information[<span class="number">0</span>].ans.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="string">" "</span> : <span class="string">"-&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; information[<span class="number">0</span>].back &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1021-Deepest-Root"><a href="#1021-Deepest-Root" class="headerlink" title="1021 Deepest Root"></a>1021 Deepest Root</h1><p>题目大意：给定一个无向图，要求得到以哪些结点为根的树高度最高。若不满足树的特征，找出其连通分量块多少。</p>
<p>题目思路：</p>
<ul>
<li>并查集得到连通分量个数</li>
<li>由于题目的输入集确定了边的数量是n-1，所以只要连通分量为1就满足树的特征的条件。</li>
<li>对所有节点逐一dfs得到最长长度（高度）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">10005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="keyword">int</span> n, u, v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> cnt, <span class="keyword">int</span> &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (graph[cur].<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(cnt, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[cur].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> nex = graph[cur][i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[nex]) &#123;</span><br><span class="line">            vis[nex] = <span class="number">1</span>;</span><br><span class="line">            dfs(nex, cnt + <span class="number">1</span>, ans);</span><br><span class="line">            vis[nex] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != father[x]) &#123;</span><br><span class="line">        father[x] = Find(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = Find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = Find(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">        father[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    graph.resize(n + <span class="number">1</span>);</span><br><span class="line">    vis.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) father[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        graph[u].push_back(v);</span><br><span class="line">        graph[v].push_back(u);</span><br><span class="line">        Union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dfs to check if there is a cycle and the connectiveness</span></span><br><span class="line">    <span class="keyword">int</span> isRoot[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(isRoot, <span class="number">0</span>, <span class="keyword">sizeof</span> isRoot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) isRoot[Find(i)] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cnt += isRoot[i];</span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %d components\n"</span>, cnt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxDep(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(i, <span class="number">0</span>, maxDep[i]);</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dep = *max_element(maxDep.<span class="built_in">begin</span>(), maxDep.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxDep[i] == dep) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记_1</title>
    <url>/2020/07/01/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>主要介绍python的第三方库Requests库的应用场景。</p>
<a id="more"></a>
<h3 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h3><p>requests是使用Apache2 licensed 许可证的HTTP库，用python编写，比urllib2模块更简洁。主要用于<strong>自动爬取HTML页面&amp;自动网络请求提交</strong>。Requests一般掌握<code>get()</code>和<code>head()</code>两个方法就足够使用。</p>
<p>请看Requests库的主要七个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.request()  <span class="comment">#构造一个请求，支撑以下各方法的基础方法</span></span><br><span class="line">requests.get()  <span class="comment"># 获取HTML网页的主要方法，对应于HTTP的GET</span></span><br><span class="line">requests.head()  <span class="comment"># 获取HTML网页头信息的方法，对应于HTTP的HEAD</span></span><br><span class="line">requests.post()  <span class="comment"># 向HTML网页提交POST请求的方法，对应于HTTP的POST</span></span><br><span class="line">requests.put()  <span class="comment"># 向HTML网页提交PUT请求的方法，对应于HTTP的PUT</span></span><br><span class="line">requstes.patch()  <span class="comment"># 向HTML网页提交局部修改请求，对应于HTTP的PATCH</span></span><br><span class="line">requests.delete()  <span class="comment">#向HTML页面提交删除请求，对应于HTTP的DELETE</span></span><br></pre></td></tr></table></figure>
<p>上图七种方法所对应的HTTP协议对资源的操作其实与Requests库的方法是一致的，不必深究。<br>值得一提的是，<code>patch()</code>相对于<code>put()</code>的好处就是，只用修改局部字段即可。</p>
<hr>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(url)</span><br><span class="line"><span class="comment"># r是爬虫返回的内容，称为Response对象</span></span><br></pre></td></tr></table></figure>

<p>Response对象具有很多有用的属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>r.status_code</code></td>
<td align="center">HTTP请求的返回状态，200表示成功</td>
</tr>
<tr>
<td align="center"><code>r.text</code></td>
<td align="center">HTTP响应内容的字符串形式–url对应的页面内容</td>
</tr>
<tr>
<td align="center"><code>r.encoding</code></td>
<td align="center">从HTTP header中猜测的响应内容编码方式</td>
</tr>
<tr>
<td align="center"><code>r.apparent_encoding</code></td>
<td align="center">从内容中分析出响应内容编码方式（备选内容编码方式）</td>
</tr>
<tr>
<td align="center"><code>r.content</code></td>
<td align="center">HTTP响应内容的二进制形式</td>
</tr>
<tr>
<td align="center"><code>r.raise_for_status()</code></td>
<td align="center">如果不是200，产生异常（类型为requests.HTTPError）</td>
</tr>
</tbody></table>
<p>基于以上介绍的Response对象的属性，利用try-except方法爬取页面的的通用代码的框架基本形成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout = <span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="head-方法"><a href="#head-方法" class="headerlink" title="head()方法"></a>head()方法</h4><p><code>head()</code>方法适合只访问头部信息的这种场景，此时调用<code>r.text</code>返回的内容为空：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://www.baidu.com"</span></span><br><span class="line">r = requests.head(url)</span><br><span class="line">print(r.headers)  <span class="comment"># 返回头部信息内容</span></span><br><span class="line">print(r.text)  <span class="comment"># 空</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="post-方法"><a href="#post-方法" class="headerlink" title="post()方法"></a>post()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/put'</span>,data = payload)</span><br><span class="line">print(r.text)</span><br><span class="line"><span class="comment"># 此时的r.text将是原内容加上payload的内容</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="request-方法"><a href="#request-方法" class="headerlink" title="request()方法"></a>request()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.request(method, url, **kwargs)</span><br><span class="line"><span class="comment"># method:请求方式，对应get,post...</span></span><br><span class="line"><span class="comment"># **kwargs:控制访问的参数，共13个</span></span><br></pre></td></tr></table></figure>
<p>以下是可选的参数（只列出9个）：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>params</code></td>
<td align="center">字典或字节序列，作为参数<strong>增加到url中</strong></td>
</tr>
<tr>
<td align="center"><code>data</code></td>
<td align="center">字典、字节序列或文件对象，作为<strong>Request的内容</strong></td>
</tr>
<tr>
<td align="center"><code>json</code></td>
<td align="center">JSON格式数据，作为<strong>Request的内容</strong></td>
</tr>
<tr>
<td align="center"><code>headers</code></td>
<td align="center">字典，HTTP定制头</td>
</tr>
<tr>
<td align="center"><code>cookies</code></td>
<td align="center">字典或CookieJar，Request中的cookie</td>
</tr>
<tr>
<td align="center"><code>auth</code></td>
<td align="center">元组，支持HTTP认证功能</td>
</tr>
<tr>
<td align="center"><code>files</code></td>
<td align="center">字典类型，传输文件</td>
</tr>
<tr>
<td align="center"><code>timeout</code></td>
<td align="center">设定超时时间，秒为单位</td>
</tr>
<tr>
<td align="center"><code>proxies</code></td>
<td align="center">字典类型，设定访问代理服务器，可增加登录认证</td>
</tr>
</tbody></table>
<hr>
<h4 id="爬虫实例"><a href="#爬虫实例" class="headerlink" title="爬虫实例"></a>爬虫实例</h4><h5 id="爬取亚马逊商品页面（更改用户代理）"><a href="#爬取亚马逊商品页面（更改用户代理）" class="headerlink" title="爬取亚马逊商品页面（更改用户代理）"></a>爬取亚马逊商品页面（更改用户代理）</h5><p><code>User-Agent</code>会告诉网站服务器，访问者是通过什么工具来请求的，如果是爬虫请求，一般会拒绝，如果是用户浏览器，就会应答。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://www.amazon.cn/gp/product/B01M8L5Z3Y"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">    r = requests.get(url, headers=kv)  <span class="comment"># 将User-Agent由python请求修改为用户请求</span></span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[<span class="number">1000</span>:<span class="number">2000</span>])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="百度搜索关键词提交"><a href="#百度搜索关键词提交" class="headerlink" title="百度搜索关键词提交"></a>百度搜索关键词提交</h5><p><em>注意：不同的搜索引擎关键词接口(wd)不一样</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">keyword = <span class="string">"Python"</span></span><br><span class="line">url = <span class="string">"https://www.baidu.com"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'Wd'</span>:keyword&#125;</span><br><span class="line">    r = requests.get(url, params = kv)</span><br><span class="line">    print(r.request.url)</span><br><span class="line">    <span class="comment"># 'https://www.baidu.com/s?wd=Python'</span></span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    print(len(r.text))</span><br><span class="line">    <span class="comment"># 302829</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="网络图片爬取"><a href="#网络图片爬取" class="headerlink" title="网络图片爬取"></a>网络图片爬取</h5><ul>
<li>os库用于判断路径是否存在</li>
<li>保存的文件名为网站源文件的名称</li>
<li>将图片以二进制的形式<code>r.content</code>写入<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://image.nationalgeographic.com.cn/2017/0211/20170211061910157.jpg"</span></span><br><span class="line">root = <span class="string">"D://pic//"</span></span><br><span class="line">path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">        os.mkdir(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">            f.close()</span><br><span class="line">            print(<span class="string">"文件保存成功"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"文件已存在"</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="IP地址查询代码"><a href="#IP地址查询代码" class="headerlink" title="IP地址查询代码"></a>IP地址查询代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://m.ip138.com/ip.asp?ip="</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url + <span class="string">'202.204.80.112'</span>)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[<span class="number">-500</span>:])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记_2</title>
    <url>/2020/07/03/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>主要介绍python的第三方库BS4库的应用场景。</p>
<a id="more"></a>
<h3 id="BS4库"><a href="#BS4库" class="headerlink" title="BS4库"></a>BS4库</h3><p>BS4库主要用于<strong>HTML页面的解析</strong>。是解析、遍历、维护“标签树”的功能库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">demo = requests.get(url).text</span><br><span class="line">soup = BeautifulSoup(demo, <span class="string">"html.parser"</span>)</span><br></pre></td></tr></table></figure>
<p><code>soup</code>便承载了解析后的<code>标签树</code>。</p>
<table>
<thead>
<tr>
<th align="center">基本元素</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Tag</td>
<td align="center">标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾</td>
</tr>
<tr>
<td align="center">Name</td>
<td align="center">标签的名字，格式：<code>&lt;tag&gt;.name</code></td>
</tr>
<tr>
<td align="center">Attributes</td>
<td align="center">标签的属性，字典形式组织，格式：<code>&lt;tag&gt;.attrs</code></td>
</tr>
<tr>
<td align="center">NavigableString</td>
<td align="center">标签内非属性字符串，格式：<code>&lt;tag&gt;.string</code></td>
</tr>
<tr>
<td align="center">Comment</td>
<td align="center">标签内字符串的注释部分，一种特殊的Comment类型</td>
</tr>
</tbody></table>
<h4 id="标签树的遍历"><a href="#标签树的遍历" class="headerlink" title="标签树的遍历"></a>标签树的遍历</h4><h5 id="下行遍历"><a href="#下行遍历" class="headerlink" title="下行遍历"></a>下行遍历</h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.contents</code></td>
<td align="center">子节点的列表，将<code>&lt;tag&gt;</code>所有儿子节点存入列表</td>
</tr>
<tr>
<td align="center"><code>.children</code></td>
<td align="center">子节点的迭代类型，与<code>contents</code>类似，用于循环遍历儿子节点</td>
</tr>
<tr>
<td align="center"><code>.descendants</code></td>
<td align="center">子孙节点的迭代类型，包含所有子孙节点</td>
</tr>
</tbody></table>
<p>迭代类型的下行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> demoSoup.body.children: <span class="comment"># descendants是子孙结点</span></span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure>

<h5 id="上行遍历"><a href="#上行遍历" class="headerlink" title="上行遍历"></a>上行遍历</h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.parent</code></td>
<td align="center">节点的父亲标签</td>
</tr>
<tr>
<td align="center"><code>.parents</code></td>
<td align="center">节点先辈标签的迭代类型，用于循环遍历先辈节点</td>
</tr>
</tbody></table>
<p>迭代类型的上行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> demoSoup.a.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(parent.name)</span><br></pre></td></tr></table></figure>

<h5 id="平行遍历"><a href="#平行遍历" class="headerlink" title="平行遍历"></a>平行遍历</h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.next_sibling</code></td>
<td align="center">返回按照HTML文本顺序的下一个平行节点标签</td>
</tr>
<tr>
<td align="center"><code>.previous_sibling</code></td>
<td align="center">返回按照HTML文本顺序的上一个平行节点标签</td>
</tr>
<tr>
<td align="center"><code>.next_siblings</code></td>
<td align="center">迭代类型，返回按照HTML文本顺序的后续所有平行节点标签</td>
</tr>
<tr>
<td align="center"><code>.previous_siblings</code></td>
<td align="center">迭代类型，返回按照HTML文本顺序的前续所有平行节点标签</td>
</tr>
</tbody></table>
<p>迭代类型的上行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> demoSoup.a.next_siblings:  <span class="comment"># or previous_siblings</span></span><br><span class="line">    print(sibling)</span><br></pre></td></tr></table></figure>

<h4 id="美化标签"><a href="#美化标签" class="headerlink" title="美化标签"></a>美化标签</h4><p><code>soup.prettify()</code></p>
<h4 id="信息提取方法"><a href="#信息提取方法" class="headerlink" title="信息提取方法"></a>信息提取方法</h4><p>信息标记的三种形式XML,JSON和YAML<br><code>.find_all</code>方法，返回一个列表类型，存储查找的结果。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>name</code></td>
<td align="center">对标签名称的检索字符串</td>
</tr>
<tr>
<td align="center"><code>attrs</code></td>
<td align="center">对标签属性值的检索字符串，可标注属性检索</td>
</tr>
<tr>
<td align="center"><code>recursive</code></td>
<td align="center">是否对子孙全部检索，默认True</td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td align="center">&lt;&gt;…&lt;/&gt;中字符串区域的检索字符串</td>
</tr>
</tbody></table>
<h3 id="实例：全球大学学术排名"><a href="#实例：全球大学学术排名" class="headerlink" title="实例：全球大学学术排名"></a>实例：全球大学学术排名</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"爬取失败"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):  <span class="comment"># Tag是bs4定义的标签类型</span></span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">4</span>].string])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt1 = <span class="string">"&#123;0:^10&#125;\t&#123;1:^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    tplt2 = <span class="string">"&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(<span class="string">"全球大学学术排名情况\n"</span>)</span><br><span class="line">    ls = [<span class="string">"排名"</span>,<span class="string">"学校名称"</span>,<span class="string">"得分"</span>]</span><br><span class="line">    print(tplt1.format(ls[<span class="number">0</span>], ls[<span class="number">1</span>], ls[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(tplt2.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">"http://www.zuihaodaxue.cn/ARWU2019.html"</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>涉及知识点：</p>
<ul>
<li>下行遍历<ol>
<li>遍历tsbody中的tr，并依次输出每个tr下的td</li>
<li>遍历时不只有td这样的标签，还会有像<code>navigablestring</code>..所以要先check是否是bs4定义的标签类型</li>
</ol>
</li>
<li>中文对齐–char(12288)来控制中文对齐</li>
</ul>
]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>dp每日一题</title>
    <url>/2021/04/05/dp%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<p>现在开始每天一道dp，2021.04.05.</p>
<a id="more"></a>

<h1 id="1641-统计字典序元音字符串的数目"><a href="#1641-统计字典序元音字符串的数目" class="headerlink" title="1641. 统计字典序元音字符串的数目"></a><a href="https://leetcode-cn.com/problems/count-sorted-vowel-strings/" target="_blank" rel="noopener">1641. 统计字典序元音字符串的数目</a></h1><p>给你一个整数 <code>n</code>，请返回长度为 <code>n</code> 、仅由元音 (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) 组成且按 <strong>字典序排列</strong> 的字符串数量。</p>
<p>字符串 <code>s</code> 按 <strong>字典序排列</strong> 需要满足：对于所有有效的 <code>i</code>，<code>s[i]</code> 在字母表中的位置总是与 <code>s[i+1]</code> 相同或在 <code>s[i+1]</code> 之前。</p>
<h2 id="二维dp"><a href="#二维dp" class="headerlink" title="二维dp"></a>二维dp</h2><p>分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&#x3D;1 -&gt; n&#x3D;2的过程</span><br><span class="line">a -&gt; aa ae ai ao au</span><br><span class="line">e -&gt;    ee ei eo eu</span><br><span class="line">i -&gt;       ii io iu</span><br><span class="line">o -&gt;          oo ou</span><br><span class="line">u -&gt;             uu</span><br><span class="line">从中可以推断出从该层推到下一层时，可在前一层的基础上讨论问题，且由于字典序的限制，只与上一层的尾部字母的字典序有关。</span><br><span class="line">这启发我们用dp[i][j]数组来表示对应以相应的字母序j为结尾的n &#x3D; i的所有数量！</span><br><span class="line">以下一个要添加的字母为o为例，此时上一层尾字符为a,e,i,o都可以考虑，即</span><br><span class="line">dp[i][3] &#x3D; dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]，递推公式推广后如下：</span><br><span class="line">dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</span><br></pre></td></tr></table></figure>

<p>程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>][<span class="number">5</span>]; <span class="comment">// dp[i][j]以相应的字母序j为结尾的n = i的所有数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) dp[<span class="number">1</span>][i] = <span class="number">1</span>; <span class="comment">// n = 1的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>]; <span class="comment">// 以a为结尾只有可能上一层的结尾也是a</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 以上一层相同字母序为结尾的直接继承（与上面的a同理）</span></span><br><span class="line">                dp[i][j] += dp[i][j - <span class="number">1</span>]; <span class="comment">// 累加上比自己字母序小的所有情况（比自己字母序小的字母能加入则自己也可）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) ans += dp[n][i]; <span class="comment">// 将尾部为aeiou五种情况的数量依次相加</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="变量dp"><a href="#变量dp" class="headerlink" title="变量dp"></a>变量dp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, e = <span class="number">1</span>, i = <span class="number">1</span>, o = <span class="number">1</span>, u = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">            a = a + e + i + o + u;</span><br><span class="line">            e = e + i + o + u;</span><br><span class="line">            i = i + o + u;</span><br><span class="line">            o = o + u;</span><br><span class="line">            u = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a + e + i + o + u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="1314-矩阵区域和"><a href="#1314-矩阵区域和" class="headerlink" title="1314. 矩阵区域和"></a><a href="https://leetcode-cn.com/problems/matrix-block-sum/" target="_blank" rel="noopener">1314. 矩阵区域和</a></h1><p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code> 和一个整数 <code>K</code> ，请你返回一个矩阵 <code>answer</code> ，其中每个<code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和： </p>
<ul>
<li><code>i - K &lt;= r &lt;= i + K, j - K &lt;= c &lt;= j + K</code> </li>
<li><code>(r, c)</code> 在矩阵内。</li>
</ul>
<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>二维前缀和建立模板：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + mat[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>dp[i][j]</code>就表示<code>(0, 0)</code>到<code>(i - 1, j - 1)</code>位置的矩形和。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int get(const vector&lt;vector&lt;int&gt;&gt;&amp; pre, int n, int m, int x, int y) &#123;</span><br><span class="line">        x = max(min(x, m), <span class="number">0</span>);</span><br><span class="line">        y = max(min(y, n), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> pre[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrixBlockSum(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int K) &#123;</span><br><span class="line">        int n = mat.size(), m = mat[<span class="number">0</span>].size();</span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; ans(n, vector&lt;int&gt;(m));</span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; dp(n + <span class="number">1</span>, vector&lt;int&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + mat[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                ans[i][j] = get(dp, m, n, i + K + <span class="number">1</span>, j + K + <span class="number">1</span>) - get(dp, m, n, i - K, j + K + <span class="number">1</span>) - get(dp, m, n, i + K + <span class="number">1</span>, j - K) + get(dp, m, n, i - K, j - K);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></h1><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict*，判定 *s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>判断s是否能恰好分为由wordDict的子集（且子集中的元素可以重复使用）组成。</strong></p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; m;</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[s.substr(start, i - start + <span class="number">1</span>)] == <span class="literal">true</span>) &#123;</span><br><span class="line">                dfs(s, i + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordDict.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            m[wordDict[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="DFS-记忆化"><a href="#DFS-记忆化" class="headerlink" title="DFS + 记忆化"></a>DFS + 记忆化</h2><p>用memo[i]表示以i为开头的s的子串能否完成单词拆分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; dict;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.<span class="built_in">size</span>() || memo[start] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[start] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict[s.substr(start, i - start + <span class="number">1</span>)] == <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">if</span> (dfs(s, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    memo[start] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[start] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        memo.assign(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<span class="keyword">word</span> : wordDict) &#123;</span><br><span class="line">            dict[<span class="keyword">word</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; dict;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<span class="keyword">word</span> : wordDict) &#123;</span><br><span class="line">            dict[<span class="keyword">word</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">// store the current index</span></span><br><span class="line">        q.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (start == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dict[s.substr(start, i - start + <span class="number">1</span>)] == <span class="literal">true</span>) &#123;</span><br><span class="line">                    q.push(i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="BFS-记忆化"><a href="#BFS-记忆化" class="headerlink" title="BFS + 记忆化"></a>BFS + 记忆化</h2><p>对于这株树来说，只要有一个子节点遍历得到的start到达字符串的尾部就说明BFS算法是成功的。条条大路通罗马，之前以<code>i</code>为start的结点已经<strong>将后续有可能到达尾部的潜在start入队了</strong>，那么下次再次遍历到以<code>i</code>为start的节点时，就应该进行剪枝了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;string, bool&gt; dict;</span><br><span class="line">    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;bool&gt; vis(n, false);</span><br><span class="line">        <span class="keyword">for</span> (const auto &amp;word : wordDict) &#123;</span><br><span class="line">            dict[word] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;int&gt; q; // store the current start</span><br><span class="line">        q.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            int start = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (start == n) <span class="keyword">return</span> true;</span><br><span class="line">            <span class="keyword">if</span> (vis[start] == true) <span class="keyword">continue</span>;</span><br><span class="line">            vis[start] = true;</span><br><span class="line">            <span class="keyword">for</span> (int i = start; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dict[s.substr(start, i - start + <span class="number">1</span>)] == true) &#123;</span><br><span class="line">                    q.push(i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><p>这个dp还是很贼的，坑点：</p>
<ul>
<li>计算顺序：枚举每一个<code>i</code>后，应该向前看，轮番计算后，定下当前的<code>dp[i]</code>的值不变了，再向后枚举<code>i</code></li>
<li>break：每次dp[i]更新的结果如果变成了true，要及时break，以<code>&quot;Leetcode&quot;</code>为例，按照计算顺序我们先检查<code>&quot;Leet&quot;,&quot;code&quot;</code>能否成功，显然可以，但是当循环继续到下一步，检查<code>&quot;Lee&quot;,&quot;tcode&quot;</code>时，<code>dp[8]</code>直接被覆盖成了<code>false</code>，这显然是错误的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        dp[i]表示前[0, i - 1]部分的字符能否由dict组合</span></span><br><span class="line"><span class="comment">        对于j属于[0, i - 1], dp[i] = true if (word[j, i - 1] in dict &amp;&amp; dp[j]) else false</span></span><br><span class="line"><span class="comment">        dp[0]为true</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">dict</span><span class="params">(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">bool</span> isFound = dict.<span class="built_in">find</span>(s.substr(j, (i - <span class="number">1</span>) - j + <span class="number">1</span>)) != dict.<span class="built_in">end</span>();</span><br><span class="line">                dp[i] = (dp[j] &amp;&amp; isFound);</span><br><span class="line">                <span class="keyword">if</span> (dp[i]) <span class="keyword">break</span>; <span class="comment">// ！！如果当前有满足的就跳出，否则会被覆盖啊！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a><a href="https://leetcode-cn.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">368. 最大整除子集</a></h1><p>给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：</p>
<ul>
<li><code>answer[i] % answer[j] == 0</code> ，或</li>
<li><code>answer[j] % answer[i] == 0</code></li>
</ul>
<p>如果存在多个有效解子集，返回其中任何一个均可。</p>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>按从小到大排序，然后比已经构成子集的最大元素大且能与其整除的元素可以被添加入集合。但是这个用例就过不了了<code>[5,9,18,54,108,540,90,180,360,720]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 90 180 360 720 </span><br><span class="line">9 18 54 108 540 </span><br><span class="line">18 54 108 540 </span><br><span class="line">.. </span><br><span class="line">720</span><br></pre></td></tr></table></figure>

<p>原因是：第二行不选108的话后面的360和720都能被选中，数量更大，这启发我们用dp方法来修改代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = &#123;nums[i]&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] % tmp.back() == <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp.push_back(nums[j]); <span class="comment">// 可以整除最大，则可以添加到结果集合中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dp-1"><a href="#dp-1" class="headerlink" title="dp"></a>dp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 从小到大排列</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>; <span class="comment">// dp[i]对应的是集合前i个元素的最大整除子集</span></span><br><span class="line">        dp[<span class="number">0</span>] = &#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 枚举元素nums[i]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="comment">// 对于每个j &lt; i(dp[j]已经计算完毕)，逐一判断第i个元素能否加入dp[j]使得dp[i]更大</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; dp[i].<span class="built_in">size</span>() &lt; dp[j].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 可以加入集合，且加入后能使得dp[i]扩容</span></span><br><span class="line">                    dp[i].assign(dp[j].<span class="built_in">begin</span>(), dp[j].<span class="built_in">end</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i].push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>, maxIdx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 输出最大size的整除子集</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i].<span class="built_in">size</span>() &gt; maxSize) &#123;</span><br><span class="line">                maxSize = dp[i].<span class="built_in">size</span>();</span><br><span class="line">                maxIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[maxIdx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></h1><p>返回乘积最大子数组长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i]代表前i个最大乘积</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> minVal = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpMin = minVal, tmpMax = maxVal;</span><br><span class="line">            minVal = <span class="built_in">min</span>(tmpMin * nums[i], <span class="built_in">min</span>(tmpMax * nums[i], nums[i]));</span><br><span class="line">            maxVal = <span class="built_in">max</span>(tmpMin * nums[i], <span class="built_in">max</span>(tmpMax * nums[i], nums[i]));</span><br><span class="line">            ans = <span class="built_in">max</span>(maxVal, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<h2 id="dp1"><a href="#dp1" class="headerlink" title="dp1"></a>dp1</h2><p>dp[i]代表前i个房屋中，选择该房屋的情况下进行抢劫的最大利益。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[i] = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = <span class="number">-1</span>, maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; maxVal) &#123;</span><br><span class="line">                maxIdx = i;</span><br><span class="line">                maxVal = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxIdx == <span class="number">-1</span> ? <span class="number">0</span> : dp[maxIdx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dp2"><a href="#dp2" class="headerlink" title="dp2"></a>dp2</h2><p>dp[i]代表讨论前i个房屋的最大利益。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h1><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n]; <span class="comment">// dp[i]表示以第i个字符为结尾的最长子串长度</span></span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>; <span class="comment">// 当结尾的")"正好上一个就是"("，即构成"()"</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> j = i - dp[i - <span class="number">1</span>]; <span class="comment">// j用以上同样的方式更新</span></span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((j &gt;= <span class="number">2</span> ? dp[j - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>); <span class="comment">// 当前连续括号个数 = 上一组连续个数 + 与前面衔接的个数(子问题)</span></span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></h1><h2 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h2><p>边界条件官方给出的解释是：空字符串的解码方式，有1个空字符串…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= n) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 这个边界很重要！在相信转移方程的前提下，这个值是0还是1由例子决定（从递归状态判断确实是0，，，以l为开头的字符串都越界了，怎么能是1呢？）</span></span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果首字符是0，不可能以它为开头构成</span></span><br><span class="line">        <span class="keyword">if</span> (memo[l] != <span class="number">-1</span>) <span class="keyword">return</span> memo[l]; <span class="comment">// 记忆化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> case1 = helper(s, l + <span class="number">1</span>); <span class="comment">// 以s[l]为单字符的所有情况</span></span><br><span class="line">        <span class="keyword">int</span> case2 = <span class="number">0</span>; <span class="comment">// 以"s[l]s[l+1]"为双字符的所有情况</span></span><br><span class="line">        <span class="keyword">int</span> nex2 = stoi(s.substr(l, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (nex2 &lt;= <span class="number">26</span> &amp;&amp; nex2 &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 双字符合法</span></span><br><span class="line">            case2 = helper(s, l + <span class="number">2</span>); <span class="comment">// 转换成子问题</span></span><br><span class="line">        &#125;</span><br><span class="line">        memo[l] = case1 + case2;</span><br><span class="line">        <span class="keyword">return</span> case1 + case2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分成若干字符串，每个子串满足"1,2..11,12..26"之中其一</span></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        memo.assign(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dp-2"><a href="#dp-2" class="headerlink" title="dp"></a>dp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 空字符串的解码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] != <span class="string">'0'</span>) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s[i - <span class="number">2</span>] != <span class="string">'0'</span> &amp;&amp; ((s[i - <span class="number">2</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + (s[i - <span class="number">1</span>] - <span class="string">'0'</span>)) &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h1><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
<h2 id="二维前缀和-1"><a href="#二维前缀和-1" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转成二维前缀和</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从最大的正方形min(m, n)为基准递减边长向下搜索，遇到解直接返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="built_in">min</span>(m, n); l &gt;= <span class="number">0</span>; --l) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - l; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m - l; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> squareSum = dp[i + l][j + l] + dp[i][j] - dp[i + l][j] - dp[i][j + l];</span><br><span class="line">                    <span class="keyword">if</span> (squareSum == l * l) <span class="keyword">return</span> l * l;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二维dp-1"><a href="#二维dp-1" class="headerlink" title="二维dp"></a>二维dp</h2><p>状态：</p>
<p><code>dp[i][j]</code>表示以(i, j)为结尾的正方形的最大边长</p>
<p>状态转移方程：<br>$$<br>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i-1][j -1])<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">305</span>][<span class="number">305</span>]; <span class="comment">// 表示以i, j为结尾的正方形的最大值，如果为0，则为0</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = <span class="built_in">max</span>(dp[i][j], ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. 组合总和 Ⅳ</a></h1><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<h2 id="记忆化DFS"><a href="#记忆化DFS" class="headerlink" title="记忆化DFS"></a>记忆化DFS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> memo[<span class="number">205</span>][<span class="number">1005</span>]; <span class="comment">// 记录对应l,target下的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[l][target]) <span class="keyword">return</span> memo[l][target];</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ret += helper(nums, l, target - nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[l][target] = ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后一个样例超时</p>
<h2 id="记忆化DFS2"><a href="#记忆化DFS2" class="headerlink" title="记忆化DFS2"></a>记忆化DFS2</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp.count(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[target];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[i])</span><br><span class="line">                ret += helper(nums, target - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[target] = ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dp-3"><a href="#dp-3" class="headerlink" title="dp"></a>dp</h2><p>注意题目提到了答案保证符合32位整数的特点，如果在dp更新迭代的时候产生了溢出的结果，证明此时<strong>要找到所需的答案，必须凭藉溢出来找到，即答案错误，没有需要的答案，此时的dp不需要更新。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= num &amp;&amp; dp[i] &lt;= INT_MAX - dp[i - num]) <span class="comment">// 防溢出</span></span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="衍生困惑"><a href="#衍生困惑" class="headerlink" title="衍生困惑"></a>衍生困惑</h2><p>出现在记忆化2中：</p>
<ol>
<li>memo数组开静态1005过不了</li>
<li>memo开unordered_map速过</li>
<li>memo开动态数组，性能堪比dp</li>
</ol>
<h1 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></h1><h2 id="差分dp"><a href="#差分dp" class="headerlink" title="差分dp"></a>差分dp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>; <span class="comment">// 振动是1，下一个差要小于0。振动是0，下一个差要大于0</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((pre &lt;= <span class="number">0</span> &amp;&amp; sub &gt; <span class="number">0</span>) || (pre &gt;= <span class="number">0</span> &amp;&amp; sub &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                pre = sub; <span class="comment">// 当状态转移时，pre才被更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="双标志位dp"><a href="#双标志位dp" class="headerlink" title="双标志位dp"></a>双标志位dp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>; <span class="comment">// up和down分别代表上一个是上升或下降的最长长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) up = down + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) down = up + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记-3</title>
    <url>/2020/07/05/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<p>主要介绍re库和相关实例。</p>
<a id="more"></a>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="正则表达式的概述"><a href="#正则表达式的概述" class="headerlink" title="正则表达式的概述"></a>正则表达式的概述</h4><p>正则表达式是用来<strong>简洁</strong>表达一组字符串的表达式。</p>
<p>正则表达式的使用：通过编译，将符合正则表达式语法的字符串转换成正则表达式特征。</p>
<h4 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h4><p>语法表</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.</code></td>
<td align="center">表示任何单个字符</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center"><code>[]</code></td>
<td align="center">字符集，对单个字符给出取值范围</td>
<td align="center">[abc]/[a-z]</td>
</tr>
<tr>
<td align="center"><code>[^]</code></td>
<td align="center">非字符集，对单个字符给出排除范围</td>
<td align="center">[^abc]表示非a非b非c的单个字符</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">前一个字符0次或无限次扩展</td>
<td align="center">abc*-&gt;ab、abc、abcc……</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center">前一个字符1次或无限次扩展</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center"><code>?</code></td>
<td align="center">前一个字符0次或1次扩展</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center">`</td>
<td align="center">左右表达式任意一个</td>
</tr>
<tr>
<td align="center"><code>{m}</code></td>
<td align="center">扩展前一个字符m次</td>
<td align="center">ab{2}c-&gt;abbc</td>
</tr>
<tr>
<td align="center"><code>{m,n}</code></td>
<td align="center">扩展前一个字符m至n次(含n)</td>
<td align="center">ab{1,2}c-&gt;abc、abbc</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">匹配字符串开头</td>
<td align="center">^abc表示abc且在一个字符串的开头</td>
</tr>
<tr>
<td align="center"><code>$</code></td>
<td align="center">匹配字符串结尾</td>
<td align="center">abc$表示abc且在一个字符串的结尾</td>
</tr>
<tr>
<td align="center"><code>()</code></td>
<td align="center">分组标记，内部只能用`</td>
<td align="center">`</td>
</tr>
<tr>
<td align="center"><code>\d</code></td>
<td align="center">数字，等价于[0-9]</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center"><code>\w</code></td>
<td align="center">单词字符，等价于[A-Za-z0-9_]</td>
<td align="center">略</td>
</tr>
</tbody></table>
<p>经典正则表达式实例：<br>|表达式|意义|<br>|:–:|:–:|<br>|<code>^[A-Za-z]+$</code>|26个字母组成的字符串|<br>|<code>^-?\d+$</code>|整数形式的字符串|<br>|<code>^[0-9]*[1-9][0-9]*$</code>|正整数形式字符串|<br>|<code>[1-9]\d{5}</code>|中国境内邮政编码，6位|<br>|<code>[\u4e00-\u9fa5]</code>|匹配中文字符|<br>|<code>\d{3}-\d{8}|\d{4}-\d{7}</code>|国内电话号码|<br>|<code>[1-9]?\d</code>|0-99|<br>|<code>1\d{2}</code>|100-199|</p>
<p>表示0-255：<br><code>([1‐9]?\d | 1\d{2} | 2[0‐4]\d | 25[0‐5])</code></p>
<p>表示IP地址：<br><code>(([1‐9]?\d|1\d{2}|2[0‐4]\d|25[0‐5]).){3}([1‐9]?\d|1\d{2}|2[0‐4]\d|25[0‐5])</code></p>
<h3 id="re库"><a href="#re库" class="headerlink" title="re库"></a>re库</h3><p>正则表达式的表示类型：<br><strong>raw string</strong>类型：<code>r&#39;text&#39;</code>–不包含转义符的类型</p>
<h4 id="re库主要功能函数"><a href="#re库主要功能函数" class="headerlink" title="re库主要功能函数"></a>re库主要功能函数</h4><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>re.search()</code></td>
<td align="center">在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象</td>
</tr>
<tr>
<td align="center"><code>re.match()</code></td>
<td align="center">从一个字符串的开始位置起匹配正则表达式，返回match对象</td>
</tr>
<tr>
<td align="center"><code>re.findall()</code></td>
<td align="center">搜索字符串，以列表类型返回全部能匹配的子串</td>
</tr>
<tr>
<td align="center"><code>re.split()</code></td>
<td align="center">将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td>
</tr>
<tr>
<td align="center"><code>re.finditer()</code></td>
<td align="center">搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象</td>
</tr>
<tr>
<td align="center"><code>re.sub()</code></td>
<td align="center">在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">常用标记</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>re.I</code></td>
<td align="center">忽略正则表达式的大小写，<code>[A‐Z]</code>能够匹配小写字符</td>
</tr>
<tr>
<td align="center"><code>re.M</code></td>
<td align="center">正则表达式中的<code>^</code>操作符能够将给定字符串的每行当作匹配开始</td>
</tr>
<tr>
<td align="center"><code>re.S</code></td>
<td align="center">正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符</td>
</tr>
</tbody></table>
<h4 id="re库面向对象用法"><a href="#re库面向对象用法" class="headerlink" title="re库面向对象用法"></a>re库面向对象用法</h4><p>一次编译后，可以多次使用该正则表达式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pat = re.compile(<span class="string">r'[1-9]\d&#123;5&#125;'</span>)</span><br><span class="line">rst = pat.research(<span class="string">'BIT 100081'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="match对象"><a href="#match对象" class="headerlink" title="match对象"></a>match对象</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.string</code></td>
<td align="center">带匹配的文本</td>
</tr>
<tr>
<td align="center"><code>.re</code></td>
<td align="center">匹配时使用的patter对象（正则表达式）</td>
</tr>
<tr>
<td align="center"><code>.pos</code></td>
<td align="center">正则表达式搜索文本的开始位置</td>
</tr>
<tr>
<td align="center"><code>.endpos</code></td>
<td align="center">正则表达式搜索文本的结束位置</td>
</tr>
<tr>
<td align="center"><code>.group(0)</code></td>
<td align="center">获得匹配后的字符串</td>
</tr>
<tr>
<td align="center"><code>.start()</code></td>
<td align="center">匹配字符串在原始字符串的开始位置</td>
</tr>
<tr>
<td align="center"><code>.end()</code></td>
<td align="center">匹配字符串在原始字符串的结束位置</td>
</tr>
<tr>
<td align="center"><code>.span()</code></td>
<td align="center">返回(<code>.start()</code>,<code>.end()</code>)</td>
</tr>
</tbody></table>
<h4 id="贪婪匹配和最小匹配"><a href="#贪婪匹配和最小匹配" class="headerlink" title="贪婪匹配和最小匹配"></a>贪婪匹配和最小匹配</h4><p>Re库默认采用贪婪匹配，即输出匹配最长的子串。<br>最小匹配需要引入最小匹配操作符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>*?</code></td>
<td align="center">最小的..</td>
</tr>
<tr>
<td align="center"><code>+?</code></td>
<td align="center">最小的..</td>
</tr>
<tr>
<td align="center"><code>??</code></td>
<td align="center">最小的..</td>
</tr>
<tr>
<td align="center"><code>{m,n}?</code></td>
<td align="center">最小的..</td>
</tr>
</tbody></table>
<h3 id="实例：淘宝商品比价定向爬取"><a href="#实例：淘宝商品比价定向爬取" class="headerlink" title="实例：淘宝商品比价定向爬取"></a>实例：淘宝商品比价定向爬取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        header = &#123;</span><br><span class="line">            <span class="string">'authority'</span>: <span class="string">'s.taobao.com'</span>,</span><br><span class="line">            <span class="string">'cache-control'</span>: <span class="string">'max-age=0'</span>,</span><br><span class="line">            <span class="string">'upgrade-insecure-requests'</span>: <span class="string">'1'</span>,</span><br><span class="line">            <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-site'</span>: <span class="string">'same-origin'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-mode'</span>: <span class="string">'navigate'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-user'</span>: <span class="string">'?1'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-dest'</span>: <span class="string">'document'</span>,</span><br><span class="line">            <span class="string">'referer'</span>: <span class="string">'https://s.taobao.com/search?q=%E4%B9%A6%E5%8C%85'</span>,</span><br><span class="line">            <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">            <span class="string">'cookie'</span>: <span class="string">'cna=4gSsFiILVA8CAbRPiIEJDXhF; miid=1778120109322818651; t=a3a888add051197e89322f6ac86403c5; sgcookie=EELv%2B4XJBYFwT%2Bhuy%2FTQ%2B; uc3=id2=UNkwd%2Ftz5MUGAw%3D%3D&amp;lg2=VFC%2FuZ9ayeYq2g%3D%3D&amp;nk2=F5REODHw3K6Q%2BD8%3D&amp;vt3=F8dBxGJrlnv3T4HD81o%3D; lgc=tb162242636; uc4=nk4=0%40FY4Pam9Lwk6E41txt%2F1TC19ozrosnQ%3D%3D&amp;id4=0%40Ug46uCfrf6NfVRrSuV4vCECMhqce; tracknick=tb162242636; _cc_=URm48syIZQ%3D%3D; tfstk=c7F5BRa8S3x7eJWeaz_q4yEfcjGFaejjoTi8P--2OluGb34SDsYH_cGl7JxDMA3f.; enc=qCR4%2Bv6cUjkOuvgrakFshhE%2F46cDPAwDb8Gev5FH7UI1LN0ry3vlgtuMnhJU%2BKlc%2FspoGvT9CB7NKS2BEruk%2Fg%3D%3D; mt=ci=22_1; thw=cn; cookie2=7d4e0cb8e8f704666b1c1961f5f55cd9; _tb_token_=3bb5e05733efb; v=0; uc1=cookie14=UoTV6OIrH78%2Bvw%3D%3D; JSESSIONID=CAB751B32AF7D64E317AA254FB07BFB2; l=eBaLBPIVqovCAMUoBOfanurza77tbIRYSuPzaNbMiOCP_bCH59jdWZlodgLMCnGVhs9BR3ow4YKgBeYBqS24n5U62j-laTDmn; isg=BLGxbgYJSkcl6-TbYQmF-OWzwD1LniUQmN7K7JPGuniXutEM2-xT4FtY2E7cd71I'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        r = requests.get(url, headers = header)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"get_false"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(ilt, html)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        plt = re.findall(<span class="string">r'\"view_price\":\"\d+\.\d*\"'</span>, html)</span><br><span class="line">        tlt = re.findall(<span class="string">r'\"raw_title\":\".*?\"'</span>, html)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plt)):</span><br><span class="line">            price = eval(plt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])</span><br><span class="line">            title = eval(tlt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])</span><br><span class="line">            ilt.append([price, title])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"parse_falut"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGoodsList</span><span class="params">(ilt)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"序号"</span>, <span class="string">"价格"</span>, <span class="string">"商品名称"</span>))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> g <span class="keyword">in</span> ilt:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        print(tplt.format(count, g[<span class="number">0</span>], g[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    goods = <span class="string">'书包'</span></span><br><span class="line">    depth = <span class="number">3</span></span><br><span class="line">    start_url = <span class="string">'https://s.taobao.com/search?q='</span> + goods</span><br><span class="line">    infoList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(depth):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            url = start_url + <span class="string">'&amp;s='</span> + str(<span class="number">44</span> * i)</span><br><span class="line">            html = getHTMLText(url)</span><br><span class="line">            parsePage(infoList, html)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            print(<span class="string">"&#123;&#125;层fault"</span>.format(depth))</span><br><span class="line">    printGoodsList(infoList)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>与MOOC上的有些许出入，主要是淘宝最近增加了反爬虫机制（是不是教学视频火了，让学习狗把淘宝爬急了hh），参照这位大神的方法可成<br><a href="https://blog.csdn.net/Guanhai1617/article/details/104120581" target="_blank" rel="noopener">入口</a></p>
<p>实例中的正则表达式：</p>
<table>
<thead>
<tr>
<th align="center">原式</th>
<th align="center">正则语法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“raw_title”=”某某书包”</td>
<td align="center"><code>r&#39;\&quot;view_price\&quot;:\&quot;\d+\.\d*\&quot;&#39;</code></td>
</tr>
<tr>
<td align="center">“view_price”=”125.00”</td>
<td align="center"><code>r&#39;\&quot;raw_title\&quot;:\&quot;.*?\&quot;&#39;</code></td>
</tr>
</tbody></table>
<h3 id="实例：股票信息爬取"><a href="#实例：股票信息爬取" class="headerlink" title="实例：股票信息爬取"></a>实例：股票信息爬取</h3><p>链接已挂，不过源代码值得学习一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStockList</span><span class="params">(lst, stockURL)</span>:</span></span><br><span class="line">    html = getHTMLText(stockURL)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)  <span class="comment"># 针对url1进行解析</span></span><br><span class="line">    a = soup.find_all(<span class="string">'a'</span>)  <span class="comment"># 获取a标签内容，解析其中有用的字段，以应用到后面百度股票的url尾部信息</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            href = i.attrs[<span class="string">'href'</span>]</span><br><span class="line">            lst.append(re.findall(<span class="string">r'[s][hz]\d&#123;6&#125;'</span>, href)[<span class="number">0</span>])  <span class="comment"># sh100000 或 sz0219012</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStockInfo</span><span class="params">(lst, stockURL, fpath)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> stock <span class="keyword">in</span> lst:</span><br><span class="line">        url = stockURL + stock + <span class="string">".html"</span></span><br><span class="line">        html = getHTMLText(url)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> html == <span class="string">""</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            infoDict = &#123;&#125;</span><br><span class="line">            soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)  <span class="comment"># 针对url2进行解析</span></span><br><span class="line">            stockInfo = soup.find(<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'stock-bets'</span>&#125;)</span><br><span class="line"></span><br><span class="line">            name = stockInfo.find_all(attrs=&#123;<span class="string">'class'</span>: <span class="string">'bets-name'</span>&#125;)[<span class="number">0</span>]</span><br><span class="line">            infoDict.update(&#123;<span class="string">'股票名称'</span>: name.text.split()[<span class="number">0</span>]&#125;)</span><br><span class="line"></span><br><span class="line">            keyList = stockInfo.find_all(<span class="string">'dt'</span>)</span><br><span class="line">            valueList = stockInfo.find_all(<span class="string">'dd'</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(keyList)):</span><br><span class="line">                key = keyList[i].text</span><br><span class="line">                val = valueList.text</span><br><span class="line">                infoDict[key] = val</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> open(fpath, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(str(infoDict) + <span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 思路：通过东方财富网获取股票列表，根据股票列表逐个到百度股票获取个股信息</span></span><br><span class="line">    stock_list_url = <span class="string">'https://quote.eastmoney.com/stocklist.html'</span></span><br><span class="line">    stock_info_url = <span class="string">'https://gupiao.baidu.com/stock/'</span></span><br><span class="line">    output_file = <span class="string">'D://University-Learning//computer//Python编程//python爬虫//StockInfo.txt'</span></span><br><span class="line">    slist = []</span><br><span class="line">    getStockList(slist, stock_list_url)</span><br><span class="line">    getStockInfo(slist, stock_info_url, output_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记-4</title>
    <url>/2020/07/20/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-4/</url>
    <content><![CDATA[<p>主要介绍模块库scrapy。</p>
<a id="more"></a>
<h3 id="scrapy库"><a href="#scrapy库" class="headerlink" title="scrapy库"></a>scrapy库</h3><h4 id="scrapy爬虫框架"><a href="#scrapy爬虫框架" class="headerlink" title="scrapy爬虫框架"></a>scrapy爬虫框架</h4><p><img src="https://www.runoob.com/wp-content/uploads/2018/10/8c591d54457bb033812a2b0364011e9c_articlex.png" alt="框架图"><br>Scrapy Engine(引擎): 负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。</p>
<ul>
<li><strong>Scheduler(调度器)</strong>: 它负责接受引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。</li>
<li><strong>Downloader（下载器）</strong>：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理，</li>
<li><strong>Spider（爬虫）</strong>：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器).</li>
<li><strong>Item Pipeline(管道)</strong>：它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方。</li>
<li><strong>Downloader Middlewares（下载中间件）</strong>：你可以当作是一个可以自定义扩展下载功能的组件。</li>
<li><strong>Spider Middlewares（Spider中间件）</strong>：你可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses;和从Spider出去的Requests）</li>
</ul>
<h4 id="scrapy常用命令"><a href="#scrapy常用命令" class="headerlink" title="scrapy常用命令"></a>scrapy常用命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
<th align="center">格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong><code>startproject</code></strong></td>
<td align="center">创建一个工程</td>
<td align="center"><code>scrapy startproject &lt;name&gt; [dir]</code></td>
</tr>
<tr>
<td align="center"><strong><code>genspider</code></strong></td>
<td align="center">创建一个爬虫</td>
<td align="center"><code>scrapy genspider [options] &lt;name&gt; &lt;domain&gt;</code></td>
</tr>
<tr>
<td align="center"><code>settings</code></td>
<td align="center">获得爬虫配置信息</td>
<td align="center"><code>scrapy settings [options]</code></td>
</tr>
<tr>
<td align="center"><strong><code>crawl</code></strong></td>
<td align="center">运行一个爬虫</td>
<td align="center"><code>scrapy crawl &lt;spider&gt;</code></td>
</tr>
<tr>
<td align="center"><code>list</code></td>
<td align="center">列出工程中所有爬虫</td>
<td align="center"><code>scrapy list</code></td>
</tr>
<tr>
<td align="center"><code>shell</code></td>
<td align="center">启用URL调试命令行</td>
<td align="center"><code>scrapy shell [url]</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>上机模板</title>
    <url>/2020/07/13/%E4%B8%8A%E6%9C%BA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>上机必掌握模板！</p>
<a id="more"></a>

<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="二维数组空间申请-C语言"><a href="#二维数组空间申请-C语言" class="headerlink" title="二维数组空间申请(C语言)"></a>二维数组空间申请(C语言)</h4><h5 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h5><ul>
<li>适用于每行元素数不同的情况。</li>
<li>同一行中元素地址是连续的，不同行中元素地址不一定是连续的。</li>
<li>释放空间时，每行都需<code>free(p[i])</code>，最后要<code>free(p)</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> **p = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *) * arrSize);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrSize; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * colSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h5><ul>
<li>整个数组地址都是连续的。</li>
<li>不适用于每行元素数量不同的情况<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(*p)[colSize] = (<span class="keyword">int</span>(*)[colSize])<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * arrSize * colSize);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="一维数组模拟二维数组"><a href="#一维数组模拟二维数组" class="headerlink" title="一维数组模拟二维数组"></a>一维数组模拟二维数组</h5><h4 id="二维数组空间申请-C"><a href="#二维数组空间申请-C" class="headerlink" title="二维数组空间申请(C++)"></a>二维数组空间申请(C++)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请空间为n*n的数组，并将其初始化为全0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, n));</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><hr>
<h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><h4 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> revx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        revx *= <span class="number">10</span>;</span><br><span class="line">        revx += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> revx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h4><p>含哑结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">reverseHead</span><span class="params">(struct ListNode* dummyhead)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">r</span> = <span class="title">dummyhead</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// 保存头结点以后信息</span></span><br><span class="line">    dummyhead-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头结点独立</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">curr</span> = <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">t</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// 保存当前结点后所有信息</span></span><br><span class="line">        curr-&gt;next = prev; <span class="comment">// curr结点的下一个为prev</span></span><br><span class="line">        prev = curr; <span class="comment">// prev更新为curr（前移一位）</span></span><br><span class="line">        curr = t; <span class="comment">// 当前结点更新为当前结点原来的后面信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head = prev; <span class="comment">// 此时prev为头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不含哑结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">reverseArray</span><span class="params">(<span class="keyword">int</span> *arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (arr.length + <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">// 求中位数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++) &#123;  <span class="comment">// 遍历[0:mid]</span></span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span> - i;  <span class="comment">// 求出下半部分交换数的索引</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><h4 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> &amp;num1, <span class="built_in">string</span> &amp;num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>, j = num2.<span class="built_in">size</span>() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.at(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.at(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">        ans.push_back(result % <span class="number">10</span>); <span class="comment">// 先将其压入整数</span></span><br><span class="line">        add = result / <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c: ans) &#123;</span><br><span class="line">        c += <span class="string">'0'</span>; <span class="comment">// 再转换成对应的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈-链表-相加"><a href="#栈-链表-相加" class="headerlink" title="栈(链表)相加"></a>栈(链表)相加</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addStack</span><span class="params">(<span class="built_in">stack</span> s1, <span class="built_in">stack</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s1.empty() || !s2.empty() || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = s1.empty() ? <span class="number">0</span> : s1.top();</span><br><span class="line">        <span class="keyword">int</span> b = s2.empty() ? <span class="number">0</span> : s2.top();</span><br><span class="line">        <span class="keyword">if</span> (!s1.empty()) s1.pop();</span><br><span class="line">        <span class="keyword">if</span> (!s2.empty()) s2.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = a + b + carry;</span><br><span class="line">        <span class="keyword">auto</span> temp = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        temp-&gt;next = dummyHead-&gt;next;</span><br><span class="line">        dummyHead-&gt;next = temp;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>应试</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>二级cpp突击</title>
    <url>/2020/09/23/%E4%BA%8C%E7%BA%A7cpp%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<p>周天就考计算机二级了，这两天突击一下，主要是面向对象这部分忘差不多了。</p>
<a id="more"></a>

<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="成员函数声明"><a href="#成员函数声明" class="headerlink" title="成员函数声明"></a>成员函数声明</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>在类中直接给出函数体（可以采用内联函数）</p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>在类外声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Hour, Minutes, Second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Clock :: setTime(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS) &#123;</span><br><span class="line">    Hour = NewH;</span><br><span class="line">    Minute = NewM;</span><br><span class="line">    Second = NewS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Clock :: showTime（ ）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Hour &lt;&lt; <span class="string">":"</span> &lt;&lt; Minute &lt;&lt; <span class="string">":"</span> &lt;&lt; Second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>函数名与类名一样</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul>
<li>是一种特殊的构造函数，其形参为<strong>本类的对象</strong>的<strong>引用</strong>。</li>
<li>每一个类中必须有一个拷贝构造函数。</li>
<li>作用：<strong>用<u>作为初始值的对象的每一个<em>数据成员</em>的值</u>，初始化将要建立的对象的对应数据成员</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) &#123;</span><br><span class="line">        x = xx;</span><br><span class="line">        y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    Point(<span class="keyword">const</span> Point&amp; p);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> x&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> y&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point :: Point (<span class="keyword">const</span> Point &amp;p) &#123;</span><br><span class="line">    x = p.x;</span><br><span class="line">    y = p.y;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三种调用方式"><a href="#三种调用方式" class="headerlink" title="三种调用方式"></a>三种调用方式</h4><ol>
<li>用类的一个对象去初始该类的另一个对象时系统自动调用（对象赋值）</li>
<li>函数的形参为类对象，调用函数时，实参赋值给形参（与1类似），系统自动调用。</li>
<li>函数的返回值为类对象时，系统自动调用。</li>
</ol>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul>
<li><p>完成对象被删除之前的清理工作。</p>
</li>
<li><p>在对象的<strong>生存期结束的时刻</strong>自动调用，然后再释放此对象所属的空间。</p>
</li>
<li><p>调用构造函数的顺序与创建对象的顺序相同，调用析构函数的顺序与创建对象的顺序相反（即<strong>后创建的先析构</strong>）</p>
</li>
</ul>
<h2 id="构造函数和析构函数调用顺序实例"><a href="#构造函数和析构函数调用顺序实例" class="headerlink" title="构造函数和析构函数调用顺序实例"></a>构造函数和析构函数调用顺序实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">    Point(Point&amp; p) &#123;</span><br><span class="line">        x = p.x;</span><br><span class="line">        y = p.y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Point() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"X="</span> &lt;&lt; x &lt;&lt; <span class="string">",Y="</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point :: Point ( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span><br><span class="line">&#123;     x = a;   y = b;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"构造函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1(3, 4), p2(5, 6);</span><br><span class="line">    <span class="function">Point <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">    p3.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造函数被调用</span><br><span class="line">构造函数被调用</span><br><span class="line">拷贝构造函数被调用</span><br><span class="line">X&#x3D;5, Y&#x3D;6</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></table></figure>



<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><ul>
<li>需要为某个类的所有对象分配一个共享存储空间。</li>
<li>不论定义多少个对象，这个静态成员只有一个实例，并被所有对象所共享。</li>
</ul>
<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ul>
<li>必须进行初始化，最好在类的实现部分完成静态数据成员的初始化。</li>
</ul>
<h4 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; &lt;类名&gt; :: &lt;静态数据成员名&gt; = &lt;value&gt;</span><br><span class="line">    <span class="keyword">int</span> Point :: z = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt; :: &lt;静态成员&gt;</span><br><span class="line">对象.&lt;静态成员&gt;</span><br><span class="line">对象指针-&gt;静态成员</span><br></pre></td></tr></table></figure>

<h3 id="静态函数成员"><a href="#静态函数成员" class="headerlink" title="静态函数成员"></a>静态函数成员</h3><h4 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt; :: 静态成员函数(实参表);</span><br><span class="line">对象名.静态成员函数(实参表);</span><br><span class="line">对象指针-&gt;静态成员函数(实参表);</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>静态成员函数可以直接访问该类中的静态数据和静态函数成员。</li>
<li>静态成员函数不能随意访问类的==非静态数据成员==。</li>
</ul>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul>
<li><p>友元是<strong>普通函数</strong>或<strong>另一个类的成员函数</strong>，称为友元函数。</p>
</li>
<li><p>如果友元是一个类，则称为友元类。友元类的所有成员函数都成为友元函数。</p>
</li>
<li><p>友元必须在类的声明体中定义，但<strong>不是类的成员</strong>，但可以访问类中的所有成员（==包括私有成员==）</p>
</li>
</ul>
<p>友元函数和友元类在被访问的类中声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> &lt;返回值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;);</span><br><span class="line"><span class="keyword">friend</span> &lt;类名&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol>
<li>单向性（一厢情愿）</li>
<li>没有传递性</li>
</ol>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><code>this</code>指针</h2><ul>
<li>隐含于每一个类的成员函数中。每一个成员函数都有一个<code>this</code>指针参数，指向<strong>调用该函数的对象</strong>。</li>
<li>当一个对象调用成员函数时，<strong>编译程序先将对象的地址赋给this指针</strong>，然后调用成员函数，每次成员函数存取数据成员时，则隐含使用this指针，通常不显式地使用this指针来引用数据成员。</li>
<li>可以用<code>*this</code>的方式来表示调用该成员函数的当前对象。<strong>静态成员函数不能访问<code>this</code>指针</strong>。</li>
<li>一般被用于返回当前对象本身。</li>
</ul>
<h1 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h1><h2 id="声明格式"><a href="#声明格式" class="headerlink" title="声明格式"></a>声明格式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 继承方式 基类名</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h2><h3 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h3><ol>
<li>基类的<code>public</code>和<code>protected</code>成员的访问属性在派生类中保持不变。</li>
<li>派生类中的<strong>成员函数</strong>可以直接访问基类的<code>public</code>和<code>protected</code>成员，但不能访问<code>private</code>。</li>
<li>通过派生类的对象只能访问基类的<code>public</code>。</li>
</ol>
<h3 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h3><ol>
<li>基类的成员都以<code>private</code>的身份出现在派生类中，但<strong>基类的<code>private</code>成员不可访问</strong>。</li>
<li>派生类中的成员函数可以直接访问基类中的<code>public</code>和<code>protected</code>，但不能访问基类的<code>private</code>。</li>
<li>通过派生类的对象不能访问基类中的任何成员。</li>
</ol>
<h3 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h3><ol>
<li>基类的<code>private</code>成员不可访问，其他的都以<code>protected</code>的身份出现在派生类中。</li>
<li>派生类的成员函数可以直接访问基类继承过来的<code>public</code>和<code>protected</code>，但不能访问基类的<code>private</code>。</li>
<li>通过派生类的对象不能访问基类中的任何成员。</li>
</ol>
<p>ps：<code>protected</code>成员的意义</p>
<ul>
<li>对其所在类的对象来说，与<code>private</code>相同。</li>
<li>对其派生类的对象来说，与<code>public</code>相同。</li>
</ul>
<h2 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><ul>
<li>派生类从多个基类派生。</li>
</ul>
<h4 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 继承方式<span class="number">1</span> 基类名<span class="number">1</span>, 继承方式<span class="number">2</span> 基类名<span class="number">2</span>, ... &#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="函数调用次序"><a href="#函数调用次序" class="headerlink" title="函数调用次序"></a>函数调用次序</h4><h5 id="构造函数调用次序"><a href="#构造函数调用次序" class="headerlink" title="构造函数调用次序"></a>构造函数调用次序</h5><ol>
<li>调用<strong>基类构造函数</strong>，调用顺序按照它们被继承时声明的顺序（从左向右）</li>
<li>调用<strong>成员对象</strong>的构造函数，调用顺序按照它们在类中的声明顺序。</li>
<li><strong>派生类的构造函数体</strong>内容</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>	//基类<span class="title">B1</span>，构造函数有参数</span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">public</span>:</span><br><span class="line">	B1(<span class="keyword">int</span> i) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"constructing B1 "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>	//基类<span class="title">B2</span>，构造函数有参数</span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">public</span>:</span><br><span class="line">	B2(<span class="keyword">int</span> j) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"constructing B2 "</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B3</span>	//基类<span class="title">B3</span>，构造函数无参数</span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">public</span>:</span><br><span class="line">	B3( )&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"constructing B3 *"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B2, <span class="keyword">public</span> B1, <span class="keyword">public</span> B3 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//派生类的公有成员</span></span><br><span class="line">	C(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d) </span><br><span class="line">          : B1(a), memberB2(d), memberB1(c), B2(b)</span><br><span class="line">    &#123;  &#125;</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//派生类的私有对象成员</span></span><br><span class="line">	B1 memberB1;</span><br><span class="line">	B2 memberB2;</span><br><span class="line">	B3 memberB3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> main（ ）</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">C <span class="title">obj</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对应1</span></span><br><span class="line">constructing B2 <span class="number">2</span></span><br><span class="line">constructing B1 <span class="number">1</span></span><br><span class="line">constructing B3 *</span><br><span class="line"><span class="comment">// 对应3</span></span><br><span class="line">constructing B1 <span class="number">3</span></span><br><span class="line">constructing B2 <span class="number">4</span></span><br><span class="line">constructing B3 *</span><br></pre></td></tr></table></figure>

<h5 id="析构函数调用次序"><a href="#析构函数调用次序" class="headerlink" title="析构函数调用次序"></a>析构函数调用次序</h5><p>照着构造函数反写即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对应1</span></span><br><span class="line">constructing B2 <span class="number">2</span></span><br><span class="line">constructing B1 <span class="number">1</span></span><br><span class="line">constructing B3 *</span><br><span class="line"><span class="comment">// 对应3</span></span><br><span class="line">constructing B1 <span class="number">3</span></span><br><span class="line">constructing B2 <span class="number">4</span></span><br><span class="line">constructing B3 *</span><br><span class="line">destructing B3</span><br><span class="line">destructing B2</span><br><span class="line">destructing B1</span><br><span class="line">destructing B3</span><br><span class="line">destructing B1</span><br><span class="line">destructing B2</span><br></pre></td></tr></table></figure>



<h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><h3 id="同名覆盖原则"><a href="#同名覆盖原则" class="headerlink" title="同名覆盖原则"></a>同名覆盖原则</h3><ul>
<li>当基类与派生类中有相同成员时：<ul>
<li>若未强行指名，则<strong>通过派生类对象</strong>使用的是派生类中的同名成员。</li>
<li>如要通过派生类对象访问基类中被覆盖的同名成员，应使用基类名限定。</li>
</ul>
</li>
</ul>
<h3 id="二义性问题"><a href="#二义性问题" class="headerlink" title="二义性问题"></a>二义性问题</h3><ul>
<li>在<strong>多继承</strong>时，基类与派生类之间，或基类之间出现同名成员时，将出现访问的二义性。==采用虚基类或同名覆盖原则解决==。</li>
<li>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性，采用虚基类来解决。</li>
</ul>
<h3 id="虚基类-1"><a href="#虚基类-1" class="headerlink" title="虚基类"></a>虚基类</h3><ul>
<li>子类只会继承虚基类的一份拷贝，而不会产生多次重复拷贝。</li>
<li>在整个继承结构中，直接或间接继承虚基类的<strong>所有派生类</strong>，都必须<strong>在构造函数的成员初始化表中给出对虚基类的构造函数的调用</strong>。</li>
<li>建立对象时，<strong>只有最远派生类的构造函数调用虚基类的构造函数</strong>，该派生类的其他基类对虚基类构造函数的调用被忽略。</li>
</ul>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><ul>
<li>用于有共同基类的场合</li>
</ul>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><ul>
<li>以<code>virtual</code>修饰说明基类</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>主要用来解决多继承时可能发生的<strong>对同一基类继承多次</strong>而产生的二义性问题.</li>
<li>为<strong>最远</strong>的派生类提供<strong>唯一的基类成员</strong>，而不重复产生多次拷贝</li>
</ul>
<h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><ul>
<li>在第一级继承时就要将共同基类设计为虚基类</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B0</span>	//声明基类<span class="title">B0</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:	<span class="comment">//外部接口</span></span><br><span class="line">	B0(<span class="keyword">int</span> n)&#123; nV=n;&#125;</span><br><span class="line">	<span class="keyword">int</span> nV;</span><br><span class="line">	<span class="keyword">void</span> fun（ ）</span><br><span class="line">         &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Member of B0"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B0	 </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:	</span><br><span class="line">	B1(<span class="keyword">int</span> a) : B0(a) &#123; &#125; <span class="comment">/*派生类在构造函数的成员初始化表中给出对虚基类的构造函数的调用*/</span></span><br><span class="line">	<span class="keyword">int</span> nV1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B0	 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	B2(<span class="keyword">int</span> a) : B0(a) &#123;&#125;</span><br><span class="line">	<span class="keyword">int</span> nV2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> B1, <span class="keyword">public</span> B2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	D1(<span class="keyword">int</span> a) : B0(a), B1(a), B2(a)&#123;&#125;</span><br><span class="line">	<span class="keyword">int</span> nVd;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fund</span><span class="params">( )</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Member of D1"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">D1 <span class="title">d1</span><span class="params">(<span class="number">4</span>)</span></span>;	</span><br><span class="line">	d1.nV=<span class="number">2</span>;</span><br><span class="line">	d1.fun( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚基类构造顺序"><a href="#虚基类构造顺序" class="headerlink" title="虚基类构造顺序"></a>虚基类构造顺序</h4><ul>
<li><p><strong>先调用虚基类的构造函数，再调用非虚基类的构造函数。</strong></p>
</li>
<li><p><strong>若同一层次中包含多个虚基类，其调用顺序按定义时顺序。</strong></p>
</li>
<li><p><strong>若虚基类由非虚基类派生而来，则仍按先调用基类构造函数，再调用派生类构造函数的顺序</strong>。</p>
</li>
</ul>
<p>即：<strong>先根据继承声明顺序将所有虚基类排序；其次构造这些虚基类；最后按继承声明顺序构造非虚基类。</strong></p>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Base1()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Base1"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Base2()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Base2"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Level1</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">virtual</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Level1()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Level1"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Level2</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">virtual</span> <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Level2( )&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Level2"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopLevel</span> :</span> <span class="keyword">public</span> Level1, <span class="keyword">virtual</span> <span class="keyword">public</span> Level2 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     TopLevel( )&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class TopLevel"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     TopLevel obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li><code>virtual</code>只能用来说明类声明中的原型，不能用在函数实现时</li>
<li>具有继承性，基类中的虚函数派生类同样为虚函数</li>
</ul>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>不是重载声明而是覆盖</p>
<h3 id="调用方式-2"><a href="#调用方式-2" class="headerlink" title="调用方式"></a>调用方式</h3><p>通过<strong>基类指针</strong>或<strong>引用</strong>，执行时会==根据指针指向的对象的类==，决定调用哪个函数</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B0</span>	//基类<span class="title">B0</span>声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:	<span class="comment">//外部接口</span></span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">void</span> <span class="built_in">display</span>（ ）</span><br><span class="line">     &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B0::display（ ）"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">                                         <span class="comment">//虚成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span> <span class="keyword">public</span> B0	<span class="comment">//公有派生</span></span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line">	  <span class="keyword">void</span> <span class="built_in">display</span>（ ）</span><br><span class="line">     &#123;  <span class="built_in">cout</span>&lt;&lt;<span class="string">"B1::display（ ）"</span>&lt;&lt;<span class="built_in">endl</span>;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> B1	<span class="comment">//公有派生</span></span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line">	  <span class="keyword">void</span> <span class="built_in">display</span>（ ）</span><br><span class="line">     &#123;  <span class="built_in">cout</span>&lt;&lt;<span class="string">"D1::display（ ）"</span>&lt;&lt;<span class="built_in">endl</span>;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(B0 *ptr)</span>	<span class="comment">//普通函数</span></span></span><br><span class="line"><span class="function"></span>&#123;    ptr-&gt;<span class="built_in">display</span>（ ）;    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main（ ）	<span class="comment">//主函数</span></span><br><span class="line">&#123;	B0 b0,  *p;	<span class="comment">//声明基类对象和指针</span></span><br><span class="line">	B1 b1;	<span class="comment">//声明派生类对象</span></span><br><span class="line">	D1 d1;	<span class="comment">//声明派生类对象</span></span><br><span class="line">	p=&amp;b0; <span class="comment">// 指针指向B0类的对象</span></span><br><span class="line">	fun(p);	<span class="comment">//调用基类B0函数成员</span></span><br><span class="line">	p=&amp;b1; <span class="comment">// 指针指向B1类对象（基类指针指向派生类对象）</span></span><br><span class="line">	fun(p);	<span class="comment">//调用派生类B1函数成员</span></span><br><span class="line">	p=&amp;d1;</span><br><span class="line">	fun(p);	<span class="comment">//调用派生类D1函数成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B0::display（ ）</span><br><span class="line">B1::display（ ）</span><br><span class="line">D1::display（ ）</span><br></pre></td></tr></table></figure>

<h3 id="静态联编与动态联编"><a href="#静态联编与动态联编" class="headerlink" title="静态联编与动态联编"></a>静态联编与动态联编</h3><h4 id="静态联编"><a href="#静态联编" class="headerlink" title="静态联编"></a>静态联编</h4><p>联编工作出现在编译阶段，用对象名或者类名来限定要调用的函数。</p>
<h4 id="动态联编"><a href="#动态联编" class="headerlink" title="动态联编"></a>动态联编</h4><p>联编工作在程序运行时执行，在程序运行时才确定将要调用的函数。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  类名</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">     <span class="keyword">virtual</span> 类型 函数名(参数表)=<span class="number">0</span>; </span><br><span class="line">                                          <span class="comment">//纯虚函数</span></span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>带有纯虚函数的类称为<strong>抽象类</strong></p>
<ul>
<li><p>抽象类为抽象和设计的目的而建立，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。</p>
</li>
<li><p>对于暂时无法实现的函数，可以声明为纯虚函数，==留给派生类去实现==。</p>
</li>
<li><p>抽象类只能作为基类来使用</p>
</li>
<li><p>抽象类的对象不能被声明。</p>
</li>
</ul>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul>
<li>只能重载c++已有的运算符</li>
<li>不改变原运算符的优先级和结核性</li>
<li>不能改变操作数的个数</li>
</ul>
<h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><ol>
<li>类成员函数</li>
<li>友元函数</li>
</ol>
<p>注意：对于同一个对象的同一种运算符号不能以两种形式同时存在。</p>
<h2 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h2><h3 id="声明方式-1"><a href="#声明方式-1" class="headerlink" title="声明方式"></a>声明方式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">函数类型  <span class="keyword">operator</span> 运算符（形参）</span><br><span class="line">&#123;</span><br><span class="line">       ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双目运算符"><a href="#双目运算符" class="headerlink" title="双目运算符"></a>双目运算符</h3><p>例：将”+”和”-“重载成复数类的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex() &#123; Real=Image=<span class="number">0.0</span>; &#125;</span><br><span class="line">	Complex (<span class="keyword">double</span> r, <span class="keyword">double</span> i) &#123; Real=r; Image=i; &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 注意此处只有一个参数</span></span><br><span class="line">	Complex <span class="keyword">operator</span> + (Complex c);</span><br><span class="line">	Complex <span class="keyword">operator</span> - (Complex c);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;Real&lt;&lt;<span class="string">","</span>&lt;&lt;Image&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	        &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> Real;        <span class="comment">//复数实部</span></span><br><span class="line">	<span class="keyword">double</span> Image;     <span class="comment">//复数虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> + (Complex c)&#123; <span class="comment">// 复数加法</span></span><br><span class="line">	Complex t;</span><br><span class="line">	t.Real = Real + c.Real;</span><br><span class="line">	t.Image = Image + c.Image;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> - (Complex c)&#123; <span class="comment">// 复数减法</span></span><br><span class="line">	Complex t;</span><br><span class="line">	t.Real = Real - c.Real;</span><br><span class="line">	t.Image = Image - c.Image;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span>     <span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;	 <span class="comment">//声明复数类的对象</span></span><br><span class="line">	Complex c1(5,4), c2(2,10), c3;  </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c1="</span>; c1.<span class="built_in">print</span>();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c2="</span>; c2.<span class="built_in">print</span>();</span><br><span class="line">	c3=c1-c2;	<span class="comment">//复数减法运算</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c3=c1-c2="</span>;</span><br><span class="line">	c3.<span class="built_in">print</span>();</span><br><span class="line">	c3=c1+c2;	<span class="comment">//复数加法运算</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c3=c1+c2="</span>;</span><br><span class="line">	c3.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="前置单目运算符（无参数）"><a href="#前置单目运算符（无参数）" class="headerlink" title="前置单目运算符（无参数）"></a>前置单目运算符（无参数）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">Complex <span class="keyword">operator</span> ++ ();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> ++() &#123; <span class="comment">//前置自增运算</span></span><br><span class="line">	Real++,	Image++;</span><br><span class="line">	<span class="function">Complex <span class="title">t</span><span class="params">(Real, Image)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> t; <span class="comment">//先增后用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后置单目运算符（一个参数）"><a href="#后置单目运算符（一个参数）" class="headerlink" title="后置单目运算符（一个参数）"></a>后置单目运算符（一个参数）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">Complex <span class="keyword">operator</span> ++ (<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> ++(<span class="keyword">int</span>) &#123; <span class="comment">//后置自增运算</span></span><br><span class="line">	<span class="function">Complex <span class="title">t</span><span class="params">(Real, Image)</span></span>;</span><br><span class="line">	Real++,	Image++;</span><br><span class="line">	<span class="keyword">return</span> t; <span class="comment">//先用后增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span>     <span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;	 <span class="comment">//声明复数类的对象</span></span><br><span class="line">	<span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">5</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c="</span>; c.<span class="built_in">print</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"++c : "</span>; (++c).<span class="built_in">print</span>();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c1="</span>; c.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c++ : "</span>; (c++).<span class="built_in">print</span>();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c="</span>; c.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><ul>
<li><p>双目运算符 B 重载后，<br> 表达式 <code>oprd1 B oprd2</code><br> 等同于 <code>operator B(oprd1,oprd2 )</code></p>
</li>
<li><p>前置单目运算符 B 重载后，<br> 表达式 <code>B oprd</code><br> 等同于 <code>operator B(oprd )</code></p>
</li>
<li><p>后置单目运算符 ++和–重载后，<br> 表达式 <code>oprd B</code><br> 等同于 <code>operator B(oprd,0 )</code></p>
</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//运算符*重载为友元函数</span></span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span> * (Complex c1, Complex c2);	</span><br><span class="line">    <span class="comment">//……其他详见前例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span> * (Complex c1, Complex c2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//(a+bi)(c+di)=(ac-bd)+(bc+ad)i</span></span><br><span class="line">	<span class="keyword">return</span> Complex(c1.Real*c2.Real-c1.Image*c2.Image,</span><br><span class="line">		                  c1.Image*c2.Real+c1.Real*c2.Image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span>     <span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//声明复数类的对象</span></span><br><span class="line">	Complex c1(5,4), c2(2,10), c3;  </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c1="</span>; c1.<span class="built_in">print</span>();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c2="</span>; c2.<span class="built_in">print</span>();</span><br><span class="line">	</span><br><span class="line">	c3=c1*c2;<span class="comment">//调用复数乘法友元函数</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c3=c1*c2="</span>; c3.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序输出的结果为：</span></span><br><span class="line"><span class="comment">c1=(5,4)</span></span><br><span class="line"><span class="comment">c2=(2,10)</span></span><br><span class="line"><span class="comment">c3=c1*c2=(-30,58)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>应试</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>十月散记</title>
    <url>/2020/10/03/%E5%8D%81%E6%9C%88%E6%95%A3%E8%AE%B0/</url>
    <content><![CDATA[<p>2020.10</p>
<a id="more"></a>

<h1 id="10-3"><a href="#10-3" class="headerlink" title="10.3"></a>10.3</h1><h2 id="待完成"><a href="#待完成" class="headerlink" title="待完成"></a>待完成</h2><ul>
<li>电动力学<ul>
<li>作业1、作业2</li>
</ul>
</li>
<li>热力学<ul>
<li>第二章 3 4 9 10</li>
</ul>
</li>
<li>原子物理<ul>
<li>第二章作业</li>
</ul>
</li>
<li>实验报告<ul>
<li>塞曼效应的数据处理</li>
<li>氢原子光谱预习报告</li>
</ul>
</li>
<li>图像处理作业<ul>
<li>小框架：读取图片显示图片</li>
</ul>
</li>
<li>人工智能作业<ul>
<li>小测试</li>
</ul>
</li>
<li>光学<ul>
<li>1、2、3次作业</li>
</ul>
</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>上午<ul>
<li>7:30-9:30，光学作业。</li>
<li>9:30-10:30，热力学第二章。</li>
<li>10:30-11:30，原子物理作业。</li>
</ul>
</li>
<li>下午<ul>
<li>14:00-15:00，电动力学。</li>
<li>15:30-18:00，实验报告。</li>
</ul>
</li>
<li>晚上<ul>
<li>pytorch+jupyterlab配置</li>
</ul>
</li>
</ul>
<h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><ul>
<li>13:30-15:00，光学笔记和1作业</li>
<li>15:00-16:00，热力学第二章</li>
<li>16:00-18:00，实验报告</li>
</ul>
<h2 id="小笔记"><a href="#小笔记" class="headerlink" title="小笔记"></a>小笔记</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="function">ios::sync with <span class="title">stdio</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以大大加快读取速度。</p>
<h1 id="10-6-10-20计划"><a href="#10-6-10-20计划" class="headerlink" title="10.6-10.20计划"></a>10.6-10.20计划</h1><h2 id="定量目标"><a href="#定量目标" class="headerlink" title="定量目标"></a>定量目标</h2><ol>
<li>科研训练ppt + 电子测试笔记</li>
<li>Leetcode+Acwing每天1-2道题，背包和dp</li>
<li>blog美化 + 扩展（评论，在线聊天，百度收录）</li>
<li>阿里云服务器 + blog迁移 + 编程环境配置 + 制作云盘</li>
<li>学pytorch</li>
<li>构思微信聊天机器人</li>
<li>两套六级</li>
</ol>
<h2 id="时间线安排"><a href="#时间线安排" class="headerlink" title="时间线安排"></a>时间线安排</h2><p>hw = homework</p>
<p>std = study</p>
<table>
<thead>
<tr>
<th></th>
<th>上午</th>
<th>下午</th>
<th>晚上</th>
</tr>
</thead>
<tbody><tr>
<td>Mon</td>
<td>pytorch</td>
<td>数据处理</td>
<td>专业课查漏补缺</td>
</tr>
<tr>
<td>Tue</td>
<td>听课</td>
<td>（待定）</td>
<td>组会</td>
</tr>
<tr>
<td>Wed</td>
<td>听课</td>
<td>专业课hw</td>
<td>pytorch</td>
</tr>
<tr>
<td>Thu</td>
<td>听课</td>
<td>原子物理+热力学hw</td>
<td>计组+汇编std</td>
</tr>
<tr>
<td>Fri</td>
<td>听课</td>
<td>pytorch</td>
<td>光学std</td>
</tr>
<tr>
<td>Sat</td>
<td>听课/Leetcode</td>
<td>六级+电动力学hw</td>
<td>光学hw</td>
</tr>
<tr>
<td>Sun</td>
<td>pytorch</td>
<td>pytorch</td>
<td>pytorch</td>
</tr>
</tbody></table>
<p>深夜：2、3、5</p>
<h1 id="10-6"><a href="#10-6" class="headerlink" title="10.6"></a>10.6</h1><h2 id="小笔记-1"><a href="#小笔记-1" class="headerlink" title="小笔记"></a>小笔记</h2><h3 id="view-和reshape"><a href="#view-和reshape" class="headerlink" title="view()和reshape()"></a>view()和reshape()</h3><ol>
<li>view 函数只能用于 contiguous 后的 tensor 上，也就是只能用于内存中连续存储的 tensor。如果对 tensor 调用过 transpose, permute 等操作的话会使该 tensor 在内存中变得不再连续，此时就不能再调用 view 函数。因此，需要先使用 contiguous 来返回一个 contiguous copy。</li>
<li>reshape 则不需要依赖目标 tensor 是否在内存中是连续的。</li>
</ol>
<h2 id="完成情况-1"><a href="#完成情况-1" class="headerlink" title="完成情况"></a>完成情况</h2><ul>
<li>pytorch第一章 + 第二章开头</li>
</ul>
<h2 id="近两周ddl"><a href="#近两周ddl" class="headerlink" title="近两周ddl"></a>近两周ddl</h2><h3 id="本周"><a href="#本周" class="headerlink" title="本周"></a>本周</h3><ul>
<li>电子测试笔记（10.09）</li>
<li>人工智能作业（10.08）</li>
</ul>
<h3 id="下周"><a href="#下周" class="headerlink" title="下周"></a>下周</h3><ul>
<li>科研训练作业（10.13）</li>
<li>图像处理作业（10.17）</li>
<li>科研训练课件（10.20）</li>
</ul>
<h1 id="10-7"><a href="#10-7" class="headerlink" title="10.7"></a>10.7</h1><h2 id="计划-1"><a href="#计划-1" class="headerlink" title="计划"></a>计划</h2><p>上午：听讲和人工智能作业</p>
<p>中午：Leetcode一道dp</p>
<p>下午：光学作业</p>
<p>晚上：pytorch</p>
<h2 id="完成情况-2"><a href="#完成情况-2" class="headerlink" title="完成情况"></a>完成情况</h2><p>100%</p>
<h1 id="10-8"><a href="#10-8" class="headerlink" title="10.8"></a>10.8</h1><h2 id="计划-2"><a href="#计划-2" class="headerlink" title="计划"></a>计划</h2><p>中午：打印人工智能作业</p>
<p>下午（14:00-18:00）：</p>
<ul>
<li>背包III</li>
<li>二维前缀和</li>
<li>计组2节</li>
<li>汇编1节</li>
</ul>
<p>晚上（19:00-22:00）:</p>
<ul>
<li>电子测试笔记</li>
<li>pytorch</li>
</ul>
<h2 id="完成情况-3"><a href="#完成情况-3" class="headerlink" title="完成情况"></a>完成情况</h2><p>一直疯狂pytorch，别的好像几乎都没有干。放弃那本书了，感觉写的真的不太行。</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ul>
<li><p>bp算法（反向传播）</p>
</li>
<li><p><a href="https://www.jianshu.com/p/79fe9fb9dfa0" target="_blank" rel="noopener">hexo隐藏首页文章</a></p>
</li>
</ul>
<h1 id="10-9"><a href="#10-9" class="headerlink" title="10.9"></a>10.9</h1><h2 id="计划-3"><a href="#计划-3" class="headerlink" title="计划"></a>计划</h2><p>上午：听课，课余时间看《机器学习实战》</p>
<p>中午：补电子测试笔记，并打印</p>
<p>下午：</p>
<ul>
<li>56节：光学剩下的两道题</li>
<li>78节：汇编1节，机器学习-k近邻</li>
</ul>
<p>晚上：学光学</p>
<p>深夜：</p>
<ul>
<li>背包III</li>
<li>二维前缀和</li>
</ul>
<h1 id="10-10"><a href="#10-10" class="headerlink" title="10.10"></a>10.10</h1><h2 id="计划-4"><a href="#计划-4" class="headerlink" title="计划"></a>计划</h2><p>上午：听课，看文献，东区吃饭</p>
<p>13:00-17:00，图书馆</p>
<ul>
<li>热力学补作业</li>
<li>六级（14:00-16:00）</li>
<li>电动力学作业1</li>
</ul>
<p>18:00-22:00，图书馆</p>
<ul>
<li>还书！借一本pytorch书/机器学习</li>
<li>电动力学作业2</li>
<li>pytorch</li>
</ul>
<h1 id="10-14"><a href="#10-14" class="headerlink" title="10.14"></a>10.14</h1><h2 id="计划-5"><a href="#计划-5" class="headerlink" title="计划"></a>计划</h2><p>上午：</p>
<ul>
<li>原子物理听课（Leetcode）</li>
<li>热力学听课</li>
</ul>
<p>中午：看文献，直接去教室</p>
<p>下午：带计算器，草稿纸</p>
<ul>
<li>实验数据处理</li>
<li>写图像处理的平移、缩放和旋转</li>
</ul>
<p>晚上：</p>
<ul>
<li>继续写图像处理/看文献</li>
</ul>
<p>深夜：</p>
<ul>
<li>图像处理或pytorch</li>
</ul>
<h1 id="10-15"><a href="#10-15" class="headerlink" title="10.15"></a>10.15</h1><h2 id="计划-6"><a href="#计划-6" class="headerlink" title="计划"></a>计划</h2><p>上午：</p>
<ul>
<li>电动力学：笔记，听课</li>
<li>pytorch</li>
</ul>
<p>中午：pytorch</p>
<p>下午：带电脑</p>
<ul>
<li>电动力学作业/文献</li>
<li>图像处理</li>
</ul>
<p>晚上：</p>
<ul>
<li>图像处理</li>
<li>图书馆<ul>
<li>看文献</li>
</ul>
</li>
</ul>
<p>深夜：</p>
<ul>
<li>数据处理</li>
</ul>
<h1 id="10-16"><a href="#10-16" class="headerlink" title="10.16"></a>10.16</h1><h2 id="计划-7"><a href="#计划-7" class="headerlink" title="计划"></a>计划</h2><p>上午：</p>
<ul>
<li>原子物理</li>
<li>热力学</li>
</ul>
<p>中午：看文献</p>
<p>下午：</p>
<ul>
<li>数据处理</li>
<li>pytorch</li>
</ul>
<p>晚上：早点去占一个电源</p>
<ul>
<li><p>最小二乘法图</p>
</li>
<li><p>pytorch</p>
</li>
</ul>
<p>深夜：</p>
<ul>
<li>图像处理</li>
</ul>
<h1 id="下阶段待完成任务"><a href="#下阶段待完成任务" class="headerlink" title="下阶段待完成任务"></a>下阶段待完成任务</h1><ol>
<li>科研训练ppt和通稿</li>
<li>大创comsol模拟</li>
<li>人工智能作业</li>
<li>pytorch</li>
</ol>
<h1 id="周末待完成任务"><a href="#周末待完成任务" class="headerlink" title="周末待完成任务"></a>周末待完成任务</h1><ol>
<li>电动力学作业2、4、5</li>
<li>光电子三道题</li>
<li>原子物理第三四章作业</li>
<li>comsol使用</li>
<li>科研训练ppt</li>
<li>人工智能作业<ul>
<li>贪婪</li>
<li>A*算法</li>
</ul>
</li>
<li>deepLearning</li>
</ol>
<h1 id="10-25"><a href="#10-25" class="headerlink" title="10.25"></a>10.25</h1><p>任务：</p>
<ul>
<li>02神经网络分类与回归任务</li>
<li>电动力学作业</li>
<li>光电子作业</li>
<li>2篇日志</li>
<li>科研训练ppt</li>
</ul>
<h2 id="小笔记-2"><a href="#小笔记-2" class="headerlink" title="小笔记"></a>小笔记</h2><p>查看被占用的端口的进程信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -ntulp | grep xxxx</span><br></pre></td></tr></table></figure>

<p>后台运行jupyter notebook并保存日志信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup jupyter notebook &gt; &#x2F;root&#x2F;anaconda3&#x2F;data&#x2F;jupyter&#x2F;jupyter.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>git clone 镜像源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将url修改为:添加地址第一级为gitclone.com即可</span><br></pre></td></tr></table></figure>



<h1 id="10-31"><a href="#10-31" class="headerlink" title="10.31"></a>10.31</h1><ul>
<li>comsol一级二级分形结构</li>
<li>实验报告拟合曲线程序</li>
<li>科研训练ppt和稿子</li>
</ul>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/07/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，创立了解决这类过程优化问题的新方法——<strong>动态规划</strong>。</p>
<a id="more"></a>
<p><a href="https://www.bilibili.com/video/BV1xb411e7ww?from=search&seid=6405207412150244964" target="_blank" rel="noopener">动态规划入门链接</a></p>
<h3 id="动态规划题目特点"><a href="#动态规划题目特点" class="headerlink" title="动态规划题目特点"></a>动态规划题目特点</h3><ol>
<li>计数</li>
<li>求最值</li>
<li>求存在性</li>
</ol>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="实例1–求最值"><a href="#实例1–求最值" class="headerlink" title="实例1–求最值"></a>实例1–求最值</h4><p>结账时，需要交价值27元，要求用2元、5元、7元想出一种使得<strong>纸币数最少</strong>的交钱方法。</p>
<h4 id="实例2–计数"><a href="#实例2–计数" class="headerlink" title="实例2–计数"></a>实例2–计数</h4><p>给定m行n列(m=4,n=8)的网络，有一个机器人从左上角(0,0)出发，每一步可以向下或者向右走一步。问有多少种不同的方式走到右下角？</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">起点</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">终点</td>
</tr>
</tbody></table>
<h4 id="实例3–存在性"><a href="#实例3–存在性" class="headerlink" title="实例3–存在性"></a>实例3–存在性</h4><p>有n块石头分别在x轴的0,1,…,n-1位置，一只青蛙在石头0，想跳到石头n-1。如果青蛙在第i块石头上，它最多可以向右跳距离$a_i$，问青蛙能否跳到石头n-1?</p>
<h4 id="实例4–求最值–多状态"><a href="#实例4–求最值–多状态" class="headerlink" title="实例4–求最值–多状态"></a>实例4–求最值–多状态</h4><p>出处：Leetcode309<br>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<h4 id="实例5–交错字符串"><a href="#实例5–交错字符串" class="headerlink" title="实例5–交错字符串"></a>实例5–交错字符串</h4><p>出处：Leetcode97<br>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<h3 id="动态规划四组成"><a href="#动态规划四组成" class="headerlink" title="动态规划四组成"></a>动态规划四组成</h3><h4 id="动态规划组成部分一：确定状态"><a href="#动态规划组成部分一：确定状态" class="headerlink" title="动态规划组成部分一：确定状态"></a>动态规划组成部分一：确定状态</h4><h5 id="两个意识"><a href="#两个意识" class="headerlink" title="两个意识"></a>两个意识</h5><ul>
<li>最后一步</li>
<li>子问题</li>
</ul>
<p>状态由<br>$$ f(x)=最少用多少枚硬币拼出27 $$<br>转换为<br>$$f(x)=最少用多少枚硬币拼出27-a_{k}$$<br>归纳为<br>$$状态f(x)=最少用多少枚硬币拼出x$$</p>
<p>根据最后一步分部考虑： </p>
<p>$$f(27) = min{f(27-2)+1, f(27-5)+1, f(27-7)+1}$$</p>
<p>我们根据这个公式可以写出一种递归算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res=np.inf  <span class="comment"># res初始化为极大值</span></span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">2</span>:</span><br><span class="line">        res=min(f(x<span class="number">-2</span>)+<span class="number">1</span>,res)</span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">5</span>:</span><br><span class="line">        res=min(f(x<span class="number">-5</span>)+<span class="number">1</span>,res)</span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">7</span>:</span><br><span class="line">        res=min(f(x<span class="number">-7</span>)+<span class="number">1</span>,res)</span><br><span class="line">    <span class="keyword">return</span> res  <span class="comment"># 当传入的x为1时，res返回的是inf，也就相当于不成立！！</span></span><br><span class="line">print(f(<span class="number">27</span>))</span><br></pre></td></tr></table></figure>

<h4 id="动态规划组成部分二：转移方程"><a href="#动态规划组成部分二：转移方程" class="headerlink" title="动态规划组成部分二：转移方程"></a>动态规划组成部分二：转移方程</h4><p>$$f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}$$</p>
<h4 id="动态规划组成部分三：初始条件和边界情况"><a href="#动态规划组成部分三：初始条件和边界情况" class="headerlink" title="动态规划组成部分三：初始条件和边界情况"></a>动态规划组成部分三：初始条件和边界情况</h4><p>初始条件：</p>
<p>$$f[0] = 0$$</p>
<p>边界情况：</p>
<p>$$数组不越界$$</p>
<h4 id="动态规划组成部分四：计算顺序"><a href="#动态规划组成部分四：计算顺序" class="headerlink" title="动态规划组成部分四：计算顺序"></a>动态规划组成部分四：计算顺序</h4><ul>
<li>正序</li>
<li>逆序</li>
<li>其他</li>
</ul>
<p>判断标准：当前的数据在已经算出后，前面（后面）的数据是否已经得出了。</p>
<h4 id="实例1解答"><a href="#实例1解答" class="headerlink" title="实例1解答"></a>实例1解答</h4><p>个人解答</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">f = [<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">28</span>)]</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">f[<span class="number">1</span>] = np.inf</span><br><span class="line">n = <span class="number">27</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>): <span class="comment"># 时间复杂度O(n)</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">7</span>):</span><br><span class="line">        f[i] = min(f[i<span class="number">-2</span>]+<span class="number">1</span>,f[i<span class="number">-5</span>]+<span class="number">1</span>,f[i<span class="number">-7</span>]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">7</span>&gt;i&gt;=<span class="number">5</span>):</span><br><span class="line">        f[i] = min(f[i<span class="number">-2</span>]+<span class="number">1</span>, f[i<span class="number">-5</span>]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">5</span>):</span><br><span class="line">        f[i] = f[i<span class="number">-2</span>]+<span class="number">1</span></span><br><span class="line">print(f[<span class="number">27</span>])</span><br></pre></td></tr></table></figure>
<p>完美改进</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *fun;</span><br><span class="line">    fun = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(M+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A)/<span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    fun[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= A[j] &amp;&amp; fun[i-A[j]] != INT_MAX)&#123; </span><br><span class="line">                <span class="comment">// 防止下标溢出；防止无穷大加法溢出！！</span></span><br><span class="line">                fun[i] = <span class="built_in">min</span>(fun[i-A[j]]+<span class="number">1</span>, fun[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fun[M]==INT_MAX)&#123;</span><br><span class="line">        fun[M] = <span class="number">-1</span>; <span class="comment">// 题目要求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态规划组成部分概括"><a href="#动态规划组成部分概括" class="headerlink" title="动态规划组成部分概括"></a>动态规划组成部分概括</h4><ol>
<li>确定状态<ul>
<li>最后一步（最优策略中使用的最后一枚硬币$a_k$）</li>
<li>化成子问题（最少的硬币拼出来更小的面值$27-a_k$）</li>
</ul>
</li>
<li>转移方程<ul>
<li>$f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}$</li>
</ul>
</li>
<li>初始条件和边界情况<ul>
<li>f[0] = 0，如果不能拼出Y，f[Y]=inf</li>
</ul>
</li>
<li>计算顺序<ul>
<li>正序</li>
</ul>
</li>
</ol>
<h3 id="利用动态规划解实例2"><a href="#利用动态规划解实例2" class="headerlink" title="利用动态规划解实例2"></a>利用动态规划解实例2</h3><ol>
<li>确定状态<ul>
<li>最后一步：到达(m-1,n-1)前的方法是以M种方法到(m-2,n-1)加上以N种方法到(m-1,n-2)</li>
<li>化成子问题：有多少种方法到达(m-2,n-1)或(m-1,n-2)</li>
<li>状态：设$f[i][j]$为从左上角有多少种路径走到$(i,j)$</li>
</ul>
</li>
<li>转移方程<ul>
<li>$f[i][j] = f[i-1][j] + f[i][j-1]$</li>
</ul>
</li>
<li>初始条件和边界情况<ul>
<li>初始条件：$f[0][0]=1$</li>
<li>边界情况：$i=j=0$时，$f[i][j]=1$</li>
</ul>
</li>
<li>计算顺序<ul>
<li>由左到右，逐行计算</li>
</ul>
</li>
</ol>
<p>代码解答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePath</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[m][n];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i = <span class="number">0</span> || j = <span class="number">0</span>)&#123;</span><br><span class="line">                f[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j] + f[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用动态规划解实例3"><a href="#利用动态规划解实例3" class="headerlink" title="利用动态规划解实例3"></a>利用动态规划解实例3</h3><ol>
<li>确定状态<ul>
<li>最后一步：到达n-1之前已经到达i</li>
<li>化成子问题：跳到n-1 -&gt; 跳到i</li>
<li>状态：设$f[j]$为青蛙能不能跳到石头j</li>
</ul>
</li>
<li>转移方程<ul>
<li>$f[j]=OR_{0&lt;=i&lt;j}(f[i] AND i +a[i]&gt;=j)$</li>
</ul>
</li>
<li>初始条件和边界情况<ul>
<li>初始条件：$f[0]=true$</li>
</ul>
</li>
<li>计算顺序<ul>
<li>从小到大</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span> *A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="keyword">sizeof</span>(A)/<span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> *f;</span><br><span class="line">    f = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        f[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[j] &amp;&amp; j+A[j] &gt;= i)&#123;</span><br><span class="line">                <span class="comment">// 能到达目标点前的这个点，并且还能跳到目标点，则能到达目标点</span></span><br><span class="line">                f[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^2)$<br>空间复杂度：$O(n)$</p>
<h3 id="利用动态规划解实例4"><a href="#利用动态规划解实例4" class="headerlink" title="利用动态规划解实例4"></a>利用动态规划解实例4</h3><ol>
<li><p>确定状态<br>用$f[i]$表示第i天结束后的累计最大收益，状态分为三种：</p>
<ul>
<li>持股状态：目前持有一种股票，累计最大收益为$f[i][0]$</li>
<li>冷冻期状态：该天结束后处于冷冻期，对应的累计最大收益为$f[i][1]$</li>
<li>双非状态：既不持有股票也不处于冷冻期状态，对应$f[i][2]$</li>
</ul>
</li>
<li><p>转移方程<br> 状态转移：<br>$$f[i][0] = max{f[i-1][0], f[i-1][2]-prices[i]}$$<br>$$f[i][1] = f[i-1][0] + prices[i]$$<br>$$f[i][2] = max{f[i-1][2], f[i-1][1]}$$<br> 结果：<br>$$result = max{f[n-1][1],f[n-1][2]}$$</p>
</li>
<li><p>初始条件和边界情况<br>$$f[0][0] = -prices[0]$$<br>$$f[0][1] = 0$$<br>$$f[0][2] = 0$$</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// f[i][0]代表目前持有一支股票</span></span><br><span class="line">    <span class="comment">// f[i][1]代表第i天结束后，位于冷冻期</span></span><br><span class="line">    <span class="comment">// f[i][2]代表当前不持股，也不位于冷冻期</span></span><br><span class="line">    <span class="keyword">if</span>(pricesSize==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[pricesSize][<span class="number">3</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; pricesSize; i++)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = fmax(f[i<span class="number">-1</span>][<span class="number">0</span>], f[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">        f[i][<span class="number">2</span>] = fmax(f[i<span class="number">-1</span>][<span class="number">2</span>], f[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmax(f[pricesSize<span class="number">-1</span>][<span class="number">1</span>],f[pricesSize<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="利用动态规划解实例5"><a href="#利用动态规划解实例5" class="headerlink" title="利用动态规划解实例5"></a>利用动态规划解实例5</h3><ol>
<li>确定状态：$f[i][j]=s_1的前i个和s_2的前j个能否交错成s3的前i+j个$</li>
<li>转移方程：<br>$$f[i][j] = [f[i-1][j] \ and \ s_1[i-1]=s_3[p]] or [f[i][j-1] \ and \ s_2[j-1]=s_3[p]]$$<br>其中$p=i+j-1$</li>
<li>初始条件和边界情况：<ul>
<li>初始条件：$f[0][0]=true$</li>
<li>边界条件：注意数组下标是否溢出</li>
</ul>
</li>
<li>计算顺序：从小到大</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span> n3 = s3.length();</span><br><span class="line">        <span class="keyword">if</span>(n1 + n2 != n3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dp[n1+<span class="number">1</span>][n2+<span class="number">1</span>];<span class="comment">// 起初开的空间是dp[n1][n2]，后来发现那样是无法考虑到s1前n个s2不考虑这种情况的，所以要开n1+1和n2+1</span></span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 对应s1==s2==s3==" "</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n2; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]) || (dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于边界情况的处理的优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    f[i][j] |= (f[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    f[i][j] |= (f[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外由于<strong>第i行与i-1行直接相关</strong>，所以可以利用滚动数组进行优化：<br>即将数组申请为<code>dp[n2+1]</code>，后面运算不用带上行下标即可。</p>
]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目Simple-Nes</title>
    <url>/2020/09/06/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AESimple-Nes/</url>
    <content><![CDATA[<p><a href="https://github.com/amhndu/SimpleNES" target="_blank" rel="noopener">项目来源</a></p>
<a id="more"></a>

<h1 id="compiling-need"><a href="#compiling-need" class="headerlink" title="compiling need"></a>compiling need</h1><ul>
<li>SFML 2.0+ development headers and library</li>
<li>C++11 compliant compiler</li>
<li>CMake build system</li>
</ul>
<h2 id="SFML"><a href="#SFML" class="headerlink" title="SFML"></a>SFML</h2><p><a href="https://blog.csdn.net/qq_33567644/article/details/91126507" target="_blank" rel="noopener">参考博客</a></p>
<p><strong>SFML</strong> 是<strong>多媒体库</strong>，它为PC的各个组件提供简单的界面，用来<em>简化游戏和多媒体应用程序的开发</em>。 主要由五个模块组成，分别是：<strong>系统，窗口，图形，音频和网络。</strong></p>
<p><strong>SFML</strong> 是跨平台的，通过 <strong>SFML</strong>，你的应用程序可以在最常见的操作系统上进行编译和运行：Windows，Linux，macOS以及Android和iOS。</p>
<p><strong>SFML</strong> 支持多种语言，具体可以在<a href="https://www.sfml-dev.org/download/bindings.php" target="_blank" rel="noopener">官网</a>查看支持的语言。</p>
<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake是一个开源、跨平台的工程构建工具，用于构建、测试和打包软件。CMake是用来控制软件编译过程使用简单的平台和编译器独立的配置文件，并生成本地makefile和工作区，可以在您选择的编译器环境中使用。</p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>序列模型的实现</title>
    <url>/2020/11/27/%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>不借助框架，通过numpy实现两个基本模型RNN和LSTM。</p>
<p><a href="https://blog.csdn.net/u013733326/article/details/80890454" target="_blank" rel="noopener">参考资料</a></p>
<a id="more"></a>

<h1 id="RNN前向传播"><a href="#RNN前向传播" class="headerlink" title="RNN前向传播"></a>RNN前向传播</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></span><br><span class="line">    e_x = np.exp(x - np.max(x))  <span class="comment"># 减去一个最大值防止溢出</span></span><br><span class="line">    <span class="keyword">return</span> e_x / np.sum(e_x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">input_x_size = 3</span></span><br><span class="line"><span class="string">input_y_size = 4</span></span><br><span class="line"><span class="string">hidden_x_size = 4</span></span><br><span class="line"><span class="string">hidden_y_size = 5</span></span><br><span class="line"><span class="string">output_x_size = 2</span></span><br><span class="line"><span class="string">output_y_size = 1</span></span><br><span class="line"><span class="string">T_x = 5</span></span><br><span class="line"><span class="string">x = np.random.randn(input_x_size, input_y_size, T_x)  # 输入</span></span><br><span class="line"><span class="string">a = np.random.randn(hidden_x_size, hidden_y_size)  # 激活值</span></span><br><span class="line"><span class="string">Waa = np.random.randn(hidden_x_size, hidden_x_size)  # 隐藏层间参数</span></span><br><span class="line"><span class="string">Wax = np.random.randn(hidden_x_size, input_x_size)  # 隐藏层和输入层间参数</span></span><br><span class="line"><span class="string">Wya = np.random.randn(output_x_size, hidden_x_size)  # 输出层和隐藏层间参数</span></span><br><span class="line"><span class="string">ba = np.random.randn(hidden_x_size, 1)</span></span><br><span class="line"><span class="string">by = np.random.randn(output_x_size, 1)</span></span><br><span class="line"><span class="string">parameters = &#123;"Waa": Waa, "Wax": Wax, "Wya": Wya, "ba": ba, "by": by&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rnn_cell_forward</span><span class="params">(x_prev, a_prev, parameters)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    每一个RNN单元内的前向传播</span></span><br><span class="line"><span class="string">    :param x_prev: 上一个时间步的x</span></span><br><span class="line"><span class="string">    :param a_prev: 上一个时间步的a</span></span><br><span class="line"><span class="string">    :param parameters: 所有权值的字典集合</span></span><br><span class="line"><span class="string">    :return: 下一个时间步的输出</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        xt -- 时间步“t”输入的数据，维度为（n_x, m）</span></span><br><span class="line"><span class="string">        a_prev -- 时间步“t - 1”的隐藏隐藏状态，维度为（n_a, m）</span></span><br><span class="line"><span class="string">        parameters -- 字典，包含了以下内容:</span></span><br><span class="line"><span class="string">                        Wax -- 矩阵，输入乘以权重，维度为（n_a, n_x）</span></span><br><span class="line"><span class="string">                        Waa -- 矩阵，隐藏状态乘以权重，维度为（n_a, n_a）</span></span><br><span class="line"><span class="string">                        Wya -- 矩阵，隐藏状态与输出相关的权重矩阵，维度为（n_y, n_a）</span></span><br><span class="line"><span class="string">                        ba  -- 偏置，维度为（n_a, 1）</span></span><br><span class="line"><span class="string">                        by  -- 偏置，隐藏状态与输出相关的偏置，维度为（n_y, 1）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        a_next -- 下一个隐藏状态，维度为（n_a， m）</span></span><br><span class="line"><span class="string">        yt_pred -- 在时间步“t”的预测，维度为（n_y， m）</span></span><br><span class="line"><span class="string">        cache -- 反向传播需要的元组，包含了(a_next, a_prev, xt, parameters)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取共享权值</span></span><br><span class="line">    Wax = parameters[<span class="string">"Wax"</span>]</span><br><span class="line">    Waa = parameters[<span class="string">"Waa"</span>]</span><br><span class="line">    Wya = parameters[<span class="string">"Wya"</span>]</span><br><span class="line">    ba = parameters[<span class="string">"ba"</span>]</span><br><span class="line">    by = parameters[<span class="string">"by"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主要计算过程</span></span><br><span class="line">    a_next = np.tanh(np.dot(Wax, x_prev) + np.dot(Waa, a_prev) + ba)</span><br><span class="line">    y_hat = softmax(np.dot(Wya, a_next) + by)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cache存储下一次前向传播用到的参数</span></span><br><span class="line">    cache = (a_next, a_prev, x_prev, parameters)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a_next, y_hat, cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rnn_forward</span><span class="params">(x, a_0, parameters)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    循环神经网络中的前向传播</span></span><br><span class="line"><span class="string">    :param x: 整个循环网络的输入</span></span><br><span class="line"><span class="string">    :param a_0: 初始激活值</span></span><br><span class="line"><span class="string">    :param parameters: 共享权值的字典集合</span></span><br><span class="line"><span class="string">    :return: RNN网络的输出</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        x -- 输入的全部数据，维度为(n_x, m, T_x)</span></span><br><span class="line"><span class="string">        a0 -- 初始化隐藏状态，维度为 (n_a, m)</span></span><br><span class="line"><span class="string">        parameters -- 字典，包含了以下内容:</span></span><br><span class="line"><span class="string">                        Wax -- 矩阵，输入乘以权重，维度为（n_a, n_x）</span></span><br><span class="line"><span class="string">                        Waa -- 矩阵，隐藏状态乘以权重，维度为（n_a, n_a）</span></span><br><span class="line"><span class="string">                        Wya -- 矩阵，隐藏状态与输出相关的权重矩阵，维度为（n_y, n_a）</span></span><br><span class="line"><span class="string">                        ba  -- 偏置，维度为（n_a, 1）</span></span><br><span class="line"><span class="string">                        by  -- 偏置，隐藏状态与输出相关的偏置，维度为（n_y, 1）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        a -- 所有时间步的隐藏状态，维度为(n_a, m, T_x)</span></span><br><span class="line"><span class="string">        y_pred -- 所有时间步的预测，维度为(n_y, m, T_x)</span></span><br><span class="line"><span class="string">        caches -- 为反向传播的保存的元组，维度为（【列表类型】cache, x)）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    caches = [] <span class="comment"># 初始化caches集合</span></span><br><span class="line"></span><br><span class="line">    n_x, m, t_len = x.shape</span><br><span class="line">    n_y, n_a = parameters[<span class="string">"Wya"</span>].shape</span><br><span class="line"></span><br><span class="line">    a = np.zeros((n_a, n_x, t_len))  <span class="comment"># 激活值集合</span></span><br><span class="line">    y_hat = np.zeros((n_y, n_x, t_len))  <span class="comment"># 输出值集合</span></span><br><span class="line">    a_next = a_0</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(t_len):</span><br><span class="line">        a_next, yt_hat, cache = rnn_cell_forward(x[:, :, t], a_next, parameters)</span><br><span class="line">        a[:, :, t] = a_next</span><br><span class="line">        y_hat[:, :, t] = yt_hat</span><br><span class="line">        caches.append(cache)</span><br><span class="line"></span><br><span class="line">    caches = (caches, x) <span class="comment"># 存储成元组以备后面的BPTT用到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a, y_hat, caches</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    x = np.random.randn(<span class="number">3</span>,<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">    a0 = np.random.randn(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">    Waa = np.random.randn(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">    Wax = np.random.randn(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">    Wya = np.random.randn(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">    ba = np.random.randn(<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">    by = np.random.randn(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    parameters = &#123;<span class="string">"Waa"</span>: Waa, <span class="string">"Wax"</span>: Wax, <span class="string">"Wya"</span>: Wya, <span class="string">"ba"</span>: ba, <span class="string">"by"</span>: by&#125;</span><br><span class="line"></span><br><span class="line">    a, y_pred, caches = rnn_forward(x, a0, parameters)</span><br><span class="line">    print(<span class="string">"a[4][1] = "</span>, a[<span class="number">4</span>][<span class="number">1</span>])</span><br><span class="line">    print(<span class="string">"a.shape = "</span>, a.shape)</span><br><span class="line">    print(<span class="string">"y_pred[1][3] ="</span>, y_pred[<span class="number">1</span>][<span class="number">3</span>])</span><br><span class="line">    print(<span class="string">"y_pred.shape = "</span>, y_pred.shape)</span><br><span class="line">    print(<span class="string">"caches[1][1][3] ="</span>, caches[<span class="number">1</span>][<span class="number">1</span>][<span class="number">3</span>])</span><br><span class="line">    print(<span class="string">"len(caches) = "</span>, len(caches))</span><br></pre></td></tr></table></figure>



<h1 id="LSTM前向传播"><a href="#LSTM前向传播" class="headerlink" title="LSTM前向传播"></a>LSTM前向传播</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> rnn_utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lstm_cell_forward</span><span class="params">(xt, a_prev, c_prev, parameters)</span>:</span></span><br><span class="line">    Wf = parameters[<span class="string">"Wf"</span>]</span><br><span class="line">    bf = parameters[<span class="string">"bf"</span>]</span><br><span class="line">    Wu = parameters[<span class="string">"Wu"</span>]</span><br><span class="line">    bu = parameters[<span class="string">"bu"</span>]</span><br><span class="line">    Wo = parameters[<span class="string">"Wo"</span>]</span><br><span class="line">    bo = parameters[<span class="string">"bo"</span>]</span><br><span class="line">    Wc = parameters[<span class="string">"Wc"</span>]</span><br><span class="line">    bc = parameters[<span class="string">"bc"</span>]</span><br><span class="line">    Wy = parameters[<span class="string">"Wy"</span>]</span><br><span class="line">    by = parameters[<span class="string">"by"</span>]</span><br><span class="line"></span><br><span class="line">    n_x, m = xt.shape</span><br><span class="line">    n_y, n_a = Wy.shape</span><br><span class="line"></span><br><span class="line">    cat = np.zeros([n_a + n_x, m])  <span class="comment"># 将a&lt;t-1&gt;和x&lt;t&gt;自然连接</span></span><br><span class="line">    cat[: n_a, :] = a_prev</span><br><span class="line">    cat[n_a:, :] = xt</span><br><span class="line"></span><br><span class="line">    <span class="comment"># forget gate</span></span><br><span class="line">    ft = sigmoid(np.dot(Wf, cat) + bf)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update gate</span></span><br><span class="line">    it = sigmoid(np.dot(Wu, cat) + bu)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tanh gate</span></span><br><span class="line">    cpt = np.tanh(np.dot(Wc, cat) + bc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output gate</span></span><br><span class="line">    ot = sigmoid(np.dot(Wo, cat) + bo)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># next output</span></span><br><span class="line">    ct = it * cpt + ft * c_prev</span><br><span class="line">    at = ot * np.tanh(ct)</span><br><span class="line">    yt_hat = softmax(np.dot(Wy, at) + by)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cache</span></span><br><span class="line">    cache = (at, ct, a_prev, c_prev, ft, it, cpt, ot, xt, parameters)</span><br><span class="line">    <span class="keyword">return</span> at, ct, yt_hat, cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lstm_forward</span><span class="params">(x, a0, parameters)</span>:</span></span><br><span class="line">    caches = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取维度信息</span></span><br><span class="line">    n_x, m, t_len = x.shape</span><br><span class="line">    n_y, n_a = parameters[<span class="string">"Wy"</span>].shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    a = np.zeros([n_a, m, t_len])</span><br><span class="line">    c = np.zeros([n_a, m, t_len]) <span class="comment"># c与激活值a的维度相同</span></span><br><span class="line">    y = np.zeros([n_y, m, t_len])</span><br><span class="line"></span><br><span class="line">    a_next = a0</span><br><span class="line">    c_next = np.zeros([n_a, m])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(t_len):</span><br><span class="line">        a_next, c_next, yt_hat, cache = lstm_cell_forward(x[:, :, t], a_next, c_next, parameters)</span><br><span class="line">        a[:, :, t] = a_next</span><br><span class="line">        c[:, :, t] = c_next</span><br><span class="line">        y[:, :, t] = yt_hat</span><br><span class="line">        caches.append(cache)</span><br><span class="line"></span><br><span class="line">    caches = (caches, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a, y, c, caches</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    x = np.random.randn(<span class="number">3</span>, <span class="number">10</span>, <span class="number">7</span>)</span><br><span class="line">    a0 = np.random.randn(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    Wf = np.random.randn(<span class="number">5</span>, <span class="number">5</span> + <span class="number">3</span>)</span><br><span class="line">    bf = np.random.randn(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">    Wu = np.random.randn(<span class="number">5</span>, <span class="number">5</span> + <span class="number">3</span>)</span><br><span class="line">    bu = np.random.randn(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">    Wo = np.random.randn(<span class="number">5</span>, <span class="number">5</span> + <span class="number">3</span>)</span><br><span class="line">    bo = np.random.randn(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">    Wc = np.random.randn(<span class="number">5</span>, <span class="number">5</span> + <span class="number">3</span>)</span><br><span class="line">    bc = np.random.randn(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">    Wy = np.random.randn(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">    by = np.random.randn(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    parameters = &#123;<span class="string">"Wf"</span>: Wf, <span class="string">"Wu"</span>: Wu, <span class="string">"Wo"</span>: Wo, <span class="string">"Wc"</span>: Wc, <span class="string">"Wy"</span>: Wy, <span class="string">"bf"</span>: bf, <span class="string">"bu"</span>: bu, <span class="string">"bo"</span>: bo, <span class="string">"bc"</span>: bc, <span class="string">"by"</span>: by&#125;</span><br><span class="line"></span><br><span class="line">    a, y, c, caches = lstm_forward(x, a0, parameters)</span><br><span class="line">    print(<span class="string">"a[4][3][6] = "</span>, a[<span class="number">4</span>][<span class="number">3</span>][<span class="number">6</span>])</span><br><span class="line">    print(<span class="string">"a.shape = "</span>, a.shape)</span><br><span class="line">    print(<span class="string">"y[1][4][3] ="</span>, y[<span class="number">1</span>][<span class="number">4</span>][<span class="number">3</span>])</span><br><span class="line">    print(<span class="string">"y.shape = "</span>, y.shape)</span><br><span class="line">    print(<span class="string">"caches[1][1[1]] ="</span>, caches[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">    print(<span class="string">"c[1][2][1]"</span>, c[<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>])</span><br><span class="line">    print(<span class="string">"len(caches) = "</span>, len(caches))</span><br></pre></td></tr></table></figure>



<h1 id="恐龙岛问题"><a href="#恐龙岛问题" class="headerlink" title="恐龙岛问题"></a>恐龙岛问题</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> cllm_utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据，得到词汇表</span></span><br><span class="line">data = open(<span class="string">"dinos.txt"</span>, <span class="string">"r"</span>).read()</span><br><span class="line">data = data.lower()</span><br><span class="line">chars = list(set(data))</span><br><span class="line">data_size, vocab_size = len(data), len(chars)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建映射</span></span><br><span class="line">char_to_ix = &#123;ch: i <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(sorted(chars))&#125;</span><br><span class="line">ix_to_char = &#123;i: ch <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(sorted(chars))&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义梯度修建操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clip</span><span class="params">(gradients, maxValue)</span>:</span></span><br><span class="line">    dWaa, dWax, dWya, db, dby = gradients[<span class="string">'dWaa'</span>], gradients[<span class="string">'dWax'</span>], gradients[<span class="string">'dWya'</span>], gradients[<span class="string">'db'</span>], gradients[</span><br><span class="line">        <span class="string">'dby'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> gradient <span class="keyword">in</span> [dWaa, dWax, dWya, db, dby]:</span><br><span class="line">        np.clip(gradient, -maxValue, maxValue, out=gradient)  <span class="comment"># 将梯度的数值限定在对称区间内</span></span><br><span class="line"></span><br><span class="line">    gradients = &#123;<span class="string">"dWaa"</span>: dWaa, <span class="string">"dWax"</span>: dWax, <span class="string">"dWya"</span>: dWya, <span class="string">"db"</span>: db, <span class="string">"dby"</span>: dby&#125;  <span class="comment"># 更新梯度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gradients</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 采样过程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span><span class="params">(parameters, char_to_ix, seed)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    根据RNN输出的概率分布序列对字符序列进行采样</span></span><br><span class="line"><span class="string">    :param parameters: 包含了Waa，Wax，Wya，by，b的字典</span></span><br><span class="line"><span class="string">    :param char_to_ix: 字符-索引</span></span><br><span class="line"><span class="string">    :param seed: 随机种子</span></span><br><span class="line"><span class="string">    :return: 包含采样字符索引的长度为n的列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取参数</span></span><br><span class="line">    Waa, Wax, Wya, by, b = parameters[<span class="string">'Waa'</span>], parameters[<span class="string">'Wax'</span>], parameters[<span class="string">'Wya'</span>], parameters[<span class="string">'by'</span>], parameters[<span class="string">'b'</span>]</span><br><span class="line">    vocab_size = by.shape[<span class="number">0</span>]</span><br><span class="line">    n_a = Waa.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    x = np.zeros((vocab_size, <span class="number">1</span>))  <span class="comment"># 创建one-hot向量</span></span><br><span class="line">    a_prev = np.zeros((n_a, <span class="number">1</span>))  <span class="comment"># 对a_0初始化</span></span><br><span class="line">    indices = []  <span class="comment"># 包含要生成的字符的索引的列表</span></span><br><span class="line">    idx = <span class="number">-1</span>  <span class="comment"># 检测换行符的标记，初始化为-1</span></span><br><span class="line"></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    newLine_character = char_to_ix[<span class="string">"\n"</span>]  <span class="comment"># 换行符所对应的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> idx != newLine_character <span class="keyword">and</span> cnt &lt; <span class="number">50</span>:</span><br><span class="line">        <span class="comment"># 进行前向传播</span></span><br><span class="line">        a = np.tanh(np.dot(Wax, x) + np.dot(Waa, a_prev) + b)</span><br><span class="line">        z = np.dot(Wya, a) + by</span><br><span class="line">        y = softmax(z)</span><br><span class="line"></span><br><span class="line">        np.random.seed(cnt + seed)  <span class="comment"># 由于是随机采样，随机数种子需要有一定变化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据一定概率从中抽取</span></span><br><span class="line">        idx = np.random.choice(list(range(vocab_size)), p=y.ravel()) <span class="comment"># ravel将矩阵向量化</span></span><br><span class="line">        indices.append(idx)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新下一个时间步输入的x</span></span><br><span class="line">        x = np.zeros((vocab_size, <span class="number">1</span>))</span><br><span class="line">        x[idx] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新a</span></span><br><span class="line">        a_prev = a</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 累加器</span></span><br><span class="line">        seed += <span class="number">1</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cnt == <span class="number">50</span>:</span><br><span class="line">        indices.append(char_to_ix[<span class="string">"\n"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indices</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(X, Y, a_prev, parameters, learning_rate=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    执行训练模型的单步优化</span></span><br><span class="line"><span class="string">    :param X: 整数列表，其中每个整数映射到词汇表中的字符</span></span><br><span class="line"><span class="string">    :param Y: 整数列表，与X完全相同，但向左移动了一个索引</span></span><br><span class="line"><span class="string">    :param a_prev: 上一个隐藏状态</span></span><br><span class="line"><span class="string">    :param parameters: 权重集合</span></span><br><span class="line"><span class="string">    :param learning_rate: 学习率</span></span><br><span class="line"><span class="string">    :return: loss, gradients, a[len(X) - 1]（最后的隐藏状态）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    loss, cache = rnn_forward(X, Y, a_prev, parameters)</span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    gradients, a = rnn_backward(X, Y, parameters, cache)</span><br><span class="line">    <span class="comment"># 梯度修建</span></span><br><span class="line">    gradients = clip(gradients, <span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    parameters = update_parameters(parameters, gradients, learning_rate)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loss, gradients, a[len(X) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(data, ix_to_char, char_to_ix, num_iterations=<span class="number">3500</span>, n_a=<span class="number">50</span>, dino_names=<span class="number">7</span>, vocab_size=<span class="number">27</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    训练模型，并生成恐龙名字</span></span><br><span class="line"><span class="string">    :param data: 语料库</span></span><br><span class="line"><span class="string">    :param ix_to_char:</span></span><br><span class="line"><span class="string">    :param char_to_ix:</span></span><br><span class="line"><span class="string">    :param num_iterations: 迭代次数</span></span><br><span class="line"><span class="string">    :param n_a: RNN单元数量</span></span><br><span class="line"><span class="string">    :param dino_names: 每次迭代中的采样的数量</span></span><br><span class="line"><span class="string">    :param vocab_size: 在文本中的唯一字符的数量</span></span><br><span class="line"><span class="string">    :return: 学习后的参数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    n_x, n_y = vocab_size, vocab_size</span><br><span class="line">    parameters = initialize_parameters(n_a, n_x, n_y)</span><br><span class="line">    loss = get_initial_loss(vocab_size, dino_names)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"dinos.txt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        examples = f.readlines()</span><br><span class="line">    examples = [x.lower().strip() <span class="keyword">for</span> x <span class="keyword">in</span> examples] <span class="comment"># examples表示了所有修改过的名字的列表</span></span><br><span class="line"></span><br><span class="line">    np.random.seed(<span class="number">0</span>)</span><br><span class="line">    np.random.shuffle(examples)</span><br><span class="line"></span><br><span class="line">    a_prev = np.zeros((n_a, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(num_iterations):</span><br><span class="line">        <span class="comment"># 定义一个训练样本</span></span><br><span class="line">        index = j % len(examples)</span><br><span class="line">        X = [<span class="literal">None</span>] + [char_to_ix[ch] <span class="keyword">for</span> ch <span class="keyword">in</span> examples[index]] <span class="comment"># 根据examples中的第index个单词构建一个输入</span></span><br><span class="line">        Y = X[<span class="number">1</span>:] + [char_to_ix[<span class="string">"\n"</span>]] <span class="comment"># Y初始化为X的除第一位加上一个换行符</span></span><br><span class="line"></span><br><span class="line">        cur_loss, gradients, a_prev = optimize(X, Y, a_prev, parameters)</span><br><span class="line"></span><br><span class="line">        loss = smooth(loss, cur_loss) <span class="comment"># 加速训练的操作，没懂</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每2000次迭代，通过sample()生成“\n”字符，检查模型是否学习正确</span></span><br><span class="line">        <span class="keyword">if</span> j % <span class="number">2000</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"第"</span> + str(j + <span class="number">1</span>) + <span class="string">"次迭代，损失值为："</span> + str(loss))</span><br><span class="line"></span><br><span class="line">            seed = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> range(dino_names):</span><br><span class="line">                <span class="comment"># 采样</span></span><br><span class="line">                sampled_indices = sample(parameters, char_to_ix, seed)</span><br><span class="line">                print_sample(sampled_indices, ix_to_char)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 为了得到相同的效果，随机种子+1</span></span><br><span class="line">                seed += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 开始时间</span></span><br><span class="line">    start_time = time.clock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始训练</span></span><br><span class="line">    parameters = model(data, ix_to_char, char_to_ix, num_iterations=<span class="number">3500</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结束时间</span></span><br><span class="line">    end_time = time.clock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算时差</span></span><br><span class="line">    minium = end_time - start_time</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"执行了："</span> + str(int(minium / <span class="number">60</span>)) + <span class="string">"分"</span> + str(int(minium % <span class="number">60</span>)) + <span class="string">"秒"</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据科学之Pytorch</title>
    <url>/2020/10/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B9%8BPytorch/</url>
    <content><![CDATA[<p><a href="https://github.com/fengdu78/Data-Science-Notes" target="_blank" rel="noopener">参考github项目地址</a></p>
<p>这是一个入门级的教程~</p>
<a id="more"></a>

<h1 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h1><h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x0 = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line">x1 = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype = torch.long)</span><br><span class="line">x2 = x2.new_ones(<span class="number">5</span>, <span class="number">3</span>, dtype = torch.double)</span><br><span class="line">x3 = torch.randn_like(x, dtype = torch.float)</span><br><span class="line">x4 = torch.eye(<span class="number">5</span>, <span class="number">3</span>) <span class="comment"># 单位矩阵</span></span><br></pre></td></tr></table></figure>

<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">y = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 直接相加 </span></span><br><span class="line">print(x + y) </span><br><span class="line"><span class="comment"># 或调用add方法</span></span><br><span class="line">print(torch.add(x, y))</span><br><span class="line"><span class="comment"># 给出一个输出张量作参数</span></span><br><span class="line">res = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">torch.add(x, y, out = res)</span><br><span class="line"><span class="comment"># 原地操作</span></span><br><span class="line">y.add_(x)</span><br></pre></td></tr></table></figure>



<h4 id="对应元素相乘除"><a href="#对应元素相乘除" class="headerlink" title="对应元素相乘除"></a>对应元素相乘除</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = a * b <span class="comment"># 对应元素相乘</span></span><br><span class="line">c = torch.mul(a, b)</span><br><span class="line">a.mul(b)</span><br><span class="line">a.mul_(b)</span><br></pre></td></tr></table></figure>

<p>对于除法为div</p>
<h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>设矩阵维度为$n$，</p>
<ul>
<li>当$n == 2$，矩阵相乘。</li>
<li>当$n &gt; 2$，仅在最后两个维度相乘，前面所有维度应 保持一致。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.mm(a, b)</span><br><span class="line">torch.matmul(a, b)</span><br><span class="line">c = a @ b</span><br></pre></td></tr></table></figure>



<h4 id="取整取余运算"><a href="#取整取余运算" class="headerlink" title="取整取余运算"></a>取整取余运算</h4><ul>
<li><code>.floor()</code> 向下取整</li>
<li><code>.ceil()</code> 向上取整</li>
<li><code>.round()</code> 四舍五入</li>
<li><code>.trunc()</code> 裁剪，只取整数部分</li>
<li><code>.frac()</code> 只取小数部分</li>
<li><code>%</code> 取余运算</li>
</ul>
<h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><p>以下参数略</p>
<ul>
<li><code>.eq(input, other)</code></li>
<li><code>.equal(tensor1, tensor2)</code> 只返回一个bool</li>
<li><code>.ge()</code> 大于等于</li>
<li><code>.gt()</code> 大于</li>
<li><code>.le()</code> 小于等于</li>
<li><code>.lt()</code> 小于</li>
<li><code>.ne()</code> 不等于</li>
</ul>
<h4 id="排序运算"><a href="#排序运算" class="headerlink" title="排序运算"></a>排序运算</h4><ul>
<li><code>.sort(input, dim=None, descending=False, out=None)</code> 对<code>input</code>进行排序，<code>dim</code>指定其维度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment"># torch.Size([2,5])</span></span><br><span class="line"><span class="comment"># 如果传参dim=0，按照每列大小排序</span></span><br><span class="line"><span class="comment"># 如果传参dim=1，按照每行大小排序</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>.topk(input, k, dim=None, largest=True, sorted=True, out=None)</code>沿着指定维度返回最大k个数值及其索引值</li>
<li><code>.kthvalue(input, k, dim=None, out=None)</code> 沿着指定维度返回第k个最小值及其索引</li>
</ul>
<h4 id="特殊数判断"><a href="#特殊数判断" class="headerlink" title="特殊数判断"></a>特殊数判断</h4><ul>
<li><code>.isinfinite(tensor)</code></li>
<li><code>.isinf(tensor)</code></li>
<li><code>.isnan()</code></li>
</ul>
<h4 id="广播机制-broadcasting"><a href="#广播机制-broadcasting" class="headerlink" title="广播机制(broadcasting)"></a>广播机制(broadcasting)</h4><p>定义：参与运算的张量参数可以<strong>自动扩展为相同大小</strong></p>
<p>前提条件：</p>
<ul>
<li>每个张量至少有一个维度</li>
<li>满足右对齐<ol>
<li>前缺位补1</li>
<li>对应维度上的值满足以下条件之一即可<ul>
<li>相等</li>
<li>有一个维度的值为1</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="两种存储类型的张量"><a href="#两种存储类型的张量" class="headerlink" title="两种存储类型的张量"></a>两种存储类型的张量</h3><h4 id="稀疏张量"><a href="#稀疏张量" class="headerlink" title="稀疏张量"></a>稀疏张量</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>定义：只存储非零元素的坐标值。</p>
<p>特点：</p>
<ul>
<li>优化参数个数（消去传参为0的形参）</li>
<li>优化内存空间</li>
</ul>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">dev = torch.device(<span class="string">"cuda:0"</span>)</span><br><span class="line">torch.tensor([<span class="number">2</span>, <span class="number">2</span>], </span><br><span class="line">             dtype = torch.float32, </span><br><span class="line">             device = dev)</span><br><span class="line"></span><br><span class="line">i = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]) <span class="comment"># 非零元素的坐标</span></span><br><span class="line">v = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># 非零元素的值</span></span><br><span class="line">a = torch.sparse_coo_tensor(i, v, (<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">b = a.to_dense() <span class="comment"># 转为稠密，所见即所得</span></span><br></pre></td></tr></table></figure>



<h4 id="稠密张量"><a href="#稠密张量" class="headerlink" title="稠密张量"></a>稠密张量</h4><h3 id="tensor和numpy的互换"><a href="#tensor和numpy的互换" class="headerlink" title="tensor和numpy的互换"></a>tensor和numpy的互换</h3><h4 id="tensor转换为numpy数组"><a href="#tensor转换为numpy数组" class="headerlink" title="tensor转换为numpy数组"></a>tensor转换为numpy数组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">b = a.numpy() <span class="comment"># 此时print(type(b))会得到 &lt;class 'numpy.ndarray'&gt;的结果</span></span><br><span class="line"><span class="comment"># 并且当原地修改a时，b也会改变</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy数组转换为tensor"><a href="#numpy数组转换为tensor" class="headerlink" title="numpy数组转换为tensor"></a>numpy数组转换为tensor</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">np.add(a, <span class="number">1</span>, out=a)</span><br></pre></td></tr></table></figure>

<h3 id="CUDA张量"><a href="#CUDA张量" class="headerlink" title="CUDA张量"></a>CUDA张量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过torch.device对象来将张量在GPU内进出</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">"cuda"</span>) <span class="comment"># 一个CUDA设备实例</span></span><br><span class="line">    y = torch.ones_like(x, device = device) <span class="comment"># 直接在GPU中创建一个tensor</span></span><br><span class="line">    x = x.to(device) <span class="comment"># 间接创建 也可以直接将device替换为"cuda"</span></span><br><span class="line">    z = x + y</span><br><span class="line">    print(x)</span><br><span class="line">    print(y)</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(<span class="string">"cpu"</span>, torch.double))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">tensor([1.0866], device&#x3D;&#39;cuda:0&#39;)</span><br><span class="line">tensor([1.], device&#x3D;&#39;cuda:0&#39;)</span><br><span class="line">tensor([2.0866], device&#x3D;&#39;cuda:0&#39;)</span><br><span class="line">tensor([2.0866], dtype&#x3D;torch.float64)</span><br></pre></td></tr></table></figure>



<h2 id="Pytorch与统计"><a href="#Pytorch与统计" class="headerlink" title="Pytorch与统计"></a>Pytorch与统计</h2><h3 id="统计学函数"><a href="#统计学函数" class="headerlink" title="统计学函数"></a>统计学函数</h3><ul>
<li><code>.mean()</code></li>
<li><code>.sum()</code></li>
<li><code>.prod()</code> 所有元素之积</li>
<li><code>.max()</code> <code>.min()</code></li>
<li><code>.argmax()</code> <code>.argmin()</code></li>
<li><code>.std()</code></li>
<li><code>.var()</code> 返回方差</li>
<li><code>.median()</code></li>
<li><code>.mode()</code></li>
<li><code>.histc()</code> 计算input的直方图</li>
<li><code>.bincount()</code> 返回每个值的频数</li>
</ul>
<h3 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h3><p><code>torch.distributions</code>包含可参数化的概率分布和采样函数</p>
<h3 id="随机抽样函数"><a href="#随机抽样函数" class="headerlink" title="随机抽样函数"></a>随机抽样函数</h3><ul>
<li>定义随机种子<ul>
<li><code>torch.manual_seed(seed)</code></li>
</ul>
</li>
<li>定义随机数满足的分布<ul>
<li><code>torch.normal()</code>正态分布</li>
</ul>
</li>
</ul>
<h3 id="线性代数运算"><a href="#线性代数运算" class="headerlink" title="线性代数运算"></a>线性代数运算</h3><h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><p>常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。</p>
<p>0/1/2/p/核范数……</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul>
<li><p><code>torch.dist(input, other, p = 2)</code> 计算p范数</p>
</li>
<li><p><code>torch.norm()</code>计算2范数</p>
<ul>
<li>矩阵范数：矩阵A的2范数就是 A的转置乘以A矩阵特征根最大值的开根号</li>
<li>向量范数：向量x的2范数就是x中各个元素平方之和再开根号</li>
</ul>
</li>
<li><p>核范数（针对<strong>低秩问题</strong>的求解 $\rarr$ 图像）</p>
<ul>
<li><code>p = &#39;fro&#39;</code></li>
</ul>
</li>
</ul>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol>
<li>用来定义<code>loss</code></li>
<li>进行参数约束（0范数、1范数）<ul>
<li>参数少或参数中0的个数多</li>
</ul>
</li>
</ol>
<h4 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h4><ol>
<li>LU分解<ul>
<li>$A = L * U$，其中$L$是下三角矩阵，$U$是上三角矩阵</li>
</ul>
</li>
<li>QR分解<ul>
<li>$A = Q * R$，其中$Q$是正交矩阵，$R$是上三角矩阵</li>
</ul>
</li>
<li>EVD分解 PCA（无监督）<ul>
<li>特征值分解 $A = Q \Sigma Q^{-1}$</li>
<li>PCA降维：将n维特征映射到k维上（提取主成分）$(k \times n) \times (n \times m) = k \times m$<ul>
<li>期望降维后同一维度的方差最大（丰富特征，降低噪声）</li>
<li>不同维度的相关性为0（降低信息冗余度）</li>
</ul>
</li>
</ul>
</li>
<li>SVD分解 LDA（有监督） <ul>
<li>奇异值分解 $A = U \Sigma V^{T}$</li>
<li>LDA降维：<ul>
<li>向$y = \omega^{T} x$投影后同类样本间距尽量小，不同类样本间距尽量大，确定直线斜率<ul>
<li>优化函数$J(\omega)$</li>
<li>新空间中的特征：$y$</li>
</ul>
</li>
</ul>
</li>
<li><code>torch.svd()</code></li>
</ul>
</li>
</ol>
<h5 id="相关知识补充"><a href="#相关知识补充" class="headerlink" title="相关知识补充"></a>相关知识补充</h5><h5 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h5><p>是各个向量元素之间的协方差。描述了<strong>方差和特征性</strong>。</p>
<p><strong>特征值分解（PCA）</strong></p>
<ul>
<li>$A$应该是一个满秩矩阵，而且应该是一个方阵（若不是应用SVD）</li>
<li>$Q$和$Q^{-1}$是两个特征向量，而$\Sigma$是一个对角线矩阵</li>
<li>特征向量相互正交</li>
</ul>
<p><strong>奇异值分解（LDA）</strong></p>
<ul>
<li>$m \times n = (m \times m) \times (m \times n) \times (n \times n)$</li>
</ul>
<h2 id="张量操作"><a href="#张量操作" class="headerlink" title="张量操作"></a>张量操作</h2><h3 id="裁剪运算"><a href="#裁剪运算" class="headerlink" title="裁剪运算"></a>裁剪运算</h3><ul>
<li>对tensor中的元素进行范围过滤</li>
<li>常用于梯度剪裁</li>
</ul>
<p><code>a.clamp(m, n)</code>将数据保持在$[m, n]$之间。</p>
<h3 id="索引和数据筛选"><a href="#索引和数据筛选" class="headerlink" title="索引和数据筛选"></a>索引和数据筛选</h3><ul>
<li><code>torch.where()</code></li>
<li><code>torch.gather()</code></li>
<li><code>torch.index_select()</code></li>
<li><code>torch.masked_select()</code></li>
<li><code>torch.take()</code></li>
<li><code>torch.nonzero()</code></li>
</ul>
<h3 id="组合和拼接"><a href="#组合和拼接" class="headerlink" title="组合和拼接"></a>组合和拼接</h3><ul>
<li><p><code>torch.cat()</code></p>
</li>
<li><p><code>torch.stack()</code></p>
</li>
<li><p><code>torch.gather()</code></p>
</li>
</ul>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><ul>
<li><code>torch.chunk()</code></li>
<li><code>torch.split()</code></li>
</ul>
<h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><ul>
<li><code>torch.reshape()</code></li>
<li><code>torch.t()</code>只针对2维tensor</li>
<li><code>torch.transpose()</code></li>
<li><code>torch.squeeze()</code></li>
<li><code>torch.unbind()</code></li>
<li><code>torch.unsqueeze()</code></li>
<li><code>torch.flip()</code></li>
<li><code>torch.rot90</code></li>
</ul>
<h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><ul>
<li><code>torch.fill((2, 3), 3.14)</code></li>
</ul>
<h3 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h3><h4 id="模型保存和加载"><a href="#模型保存和加载" class="headerlink" title="模型保存和加载"></a>模型保存和加载</h4><ul>
<li><code>torch.saves()</code></li>
<li><code>torch.load()</code></li>
</ul>
<h4 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h4><ul>
<li><p><code>torch.get_num_threads()</code> 获得线程数</p>
</li>
<li><p><code>torch.set_num_threads(int)</code> 设置线程数</p>
</li>
</ul>
<h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>单机多卡</p>
<h4 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">"cuda"</span>)</span><br><span class="line">    y = torch.ones_like(x, device = device)</span><br><span class="line">    x = x.to(device)</span><br></pre></td></tr></table></figure>



<h2 id="autograd"><a href="#autograd" class="headerlink" title="autograd"></a>autograd</h2><h2 id="自动求导"><a href="#自动求导" class="headerlink" title="自动求导"></a>自动求导</h2><p>Autograd(automatic defferentiation)</p>
<h3 id="张量-1"><a href="#张量-1" class="headerlink" title="张量"></a>张量</h3><p><code>torch.Tensor</code>是包的核心类。</p>
<p>如果将其属性<code>.requires_grad</code>设置为True，<strong>会开始跟踪其上的所有操作</strong>。完成计算后，可以调用<code>.backward()</code>并<strong>自动计算所有梯度</strong>。此张量的梯度将累积到<code>.grad</code>属性中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad = <span class="literal">True</span>) </span><br><span class="line"><span class="comment"># 在这里设置为True以跟踪其计算</span></span><br></pre></td></tr></table></figure>

<p>要阻止张量跟踪历史记录，可以调用<code>.detach()</code>将其从计算历史记录中分离出来，并防止将来的计算被跟踪。</p>
<p>要防止张量跟踪历史记录（和使用内存），可以使用<code>torch.no_grad()</code>包装代码块；在<strong>评估模型时</strong>，这会很有用，因为模型可能会具有<code>requires_grad = True</code>的可训练参数，但我们实际上不需要梯度。</p>
<p>此外，Function类对于autograd的实现也是至关重要。</p>
<p>Tensor和Function互相连接并构建一个非循环图构建一个完整的计算过程。每个张量都有一个<code>.grad_fn</code>属性，该属性引用已创建Tensor的Function（<strong>除了用户创建的Tensors - 它们的<code>grad_fn</code>为<code>None</code></strong>）。</p>
<p>如果要计算导数，可以在Tensor上调用<code>.backward()</code>。如果Tensor是标量（即它包含一个元素数据），则不需要为<code>backward()</code>指定任何参数，但是如果它有更多元素，则需要指定一个梯度参数，该参数是匹配形状的张量。</p>
<p><em>此处涉及到的数学知识较复杂，先记下来等学到后面功夫自然成</em></p>
<ul>
<li><p><code>requires_grad</code>，是否跟踪</p>
</li>
<li><p><code>.grad_fn</code>，跟踪历史记录</p>
</li>
<li><p><code>.backward()</code>，计算导数</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = x + <span class="number">2</span></span><br><span class="line">print(y.grad_fn) <span class="comment"># 输出：&lt;AddBackward0 object at 0x000001E020B794A8&gt;</span></span><br><span class="line">print(x.grad_fn) <span class="comment"># 输出：None</span></span><br></pre></td></tr></table></figure>

<p>在y上执行操作，<code>grad_fn</code>将跟踪变化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = y * y * <span class="number">3</span></span><br><span class="line">out = z.mean() <span class="comment"># mean(i)用于在第i个维度求平均数</span></span><br><span class="line"></span><br><span class="line">print(z, out)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">tensor([[27., 27.],</span><br><span class="line">        [27., 27.]], grad_fn&#x3D;&lt;MulBackward0&gt;) tensor(27., grad_fn&#x3D;&lt;MeanBackward1&gt;)</span><br></pre></td></tr></table></figure>

<p>一个实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">a = ((a * <span class="number">3</span>) / (a - <span class="number">1</span>))</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(<span class="literal">True</span>) <span class="comment"># 如果没有更改默认为false，之前的会自动跟踪是因为在x定义的时候就已经指定了参数为True了</span></span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b = (a * a).sum()</span><br><span class="line">print(b.grad_fn)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">&lt;SumBackward0 object at 0x000001E020B79FD0&gt;</span><br></pre></td></tr></table></figure>



<h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><h4 id="叶子张量"><a href="#叶子张量" class="headerlink" title="叶子张量"></a>叶子张量</h4><p>只能计算叶子张量的梯度</p>
<h4 id="grad和grad-fn"><a href="#grad和grad-fn" class="headerlink" title="grad和grad_fn"></a>grad和grad_fn</h4><ul>
<li>grad_fn：只在非叶子节点才有效，用于指示梯度函数是哪种类型</li>
<li>grad：该Tensor的梯度值</li>
</ul>
<h4 id="backward-函数"><a href="#backward-函数" class="headerlink" title="backward()函数"></a><code>backward()</code>函数</h4><h4 id="grad-outputs-inputs"><a href="#grad-outputs-inputs" class="headerlink" title="grad(outputs, inputs)"></a><code>grad(outputs, inputs)</code></h4><h2 id="几个库"><a href="#几个库" class="headerlink" title="几个库"></a>几个库</h2><h3 id="torch-nn库"><a href="#torch-nn库" class="headerlink" title="torch.nn库"></a><code>torch.nn</code>库</h3><h4 id="nn-Parameter"><a href="#nn-Parameter" class="headerlink" title="nn.Parameter"></a>nn.Parameter</h4><ul>
<li>定义可训练参数</li>
</ul>
<h4 id="nn-module"><a href="#nn-module" class="headerlink" title="nn.module"></a>nn.module</h4>]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之树图</title>
    <url>/2020/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91%E5%9B%BE/</url>
    <content><![CDATA[<p>有关数据结构的树和图知识，结合新学的C++知识。</p>
<a id="more"></a>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="主要算法"><a href="#主要算法" class="headerlink" title="主要算法"></a>主要算法</h3><h4 id="DFS-深度优先遍历"><a href="#DFS-深度优先遍历" class="headerlink" title="DFS(深度优先遍历)"></a>DFS(深度优先遍历)</h4><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTreeNode *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t-&gt;data;</span><br><span class="line">        PreOrder(t-&gt;left, Visit);</span><br><span class="line">        PreOrder(t-&gt;right, Visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTreeNode *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(t-&gt;left, Visit);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t-&gt;data;</span><br><span class="line">        PreOrder(t-&gt;right, Visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                ans.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><h6 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTreeNode *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(t-&gt;left, Visit);</span><br><span class="line">        PreOrder(t-&gt;right, Visit);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; mids;</span><br><span class="line">        <span class="comment">// mids的过程和先序遍历相反</span></span><br><span class="line">        <span class="comment">// 只是最后输出应该是倒序，所以设计s</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s; <span class="comment">// s自顶向下为后序序列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !mids.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mids.push(root);</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = mids.top();</span><br><span class="line">                mids.pop();</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.push_back(temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="BFS-广度优先遍历"><a href="#BFS-广度优先遍历" class="headerlink" title="BFS(广度优先遍历)"></a>BFS(广度优先遍历)</h4><p>利用队列实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTreeNode* t)</span> </span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    DataType x;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q.push(t);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123; <span class="comment">// 队列不为空时</span></span><br><span class="line">        x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x-&gt;data; <span class="comment">// 每出列一个，就访问一个</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q.push(x-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q.push(x-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SeqList Vertices;</span><br><span class="line">    <span class="keyword">int</span> edge[MaxVertices][MaxVertices]; <span class="comment">// 存放边集合的邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> numOfEdges;  <span class="comment">// 边条数</span></span><br><span class="line">&#125; AdjMGraph;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><h3 id="主要算法-1"><a href="#主要算法-1" class="headerlink" title="主要算法"></a>主要算法</h3><p><a href="https://blog.csdn.net/waectr/article/details/81161431" target="_blank" rel="noopener">遍历</a><br><a href="https://blog.csdn.net/iqRocket/article/details/8240723?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">拓扑</a></p>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>对一个有向无环图(Directed Acyclic Graph, DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若$&lt;u，v&gt; ∈E(G)$，则u在线性序列中出现在v之前。</p>
<ul>
<li>只有有向无环图才存在拓扑序列</li>
</ul>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ol>
<li>任选一个无前驱的顶点输出</li>
<li>删除该顶点，以及以其为起点的所有边</li>
<li>判断所有顶点是否已经输出？<ul>
<li>若是，不存在回路，排序结束</li>
<li>若否，判断是否还有无前驱的结点<ul>
<li>若是，返回第一步循环</li>
<li>若否，存在回路，排序结束</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="邻接表实现"><a href="#邻接表实现" class="headerlink" title="邻接表实现"></a>邻接表实现</h5><p>以Leetcode课程表这题为例，因为给的输入集就是相当于每条边，求解的问题也是是否有环。所以是一个典型的拓扑排序问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置入度表，存储每个课程的入度（先行课数量）</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建图结构，利用二维vector来存储</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(numCourses, v)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构建图(出边表)过程 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            indegree[prerequisites[i][<span class="number">0</span>]]++;  <span class="comment">// 构建入度表</span></span><br><span class="line">            graph[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]); <span class="comment">// 构建出边表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 拓扑排序过程 */</span></span><br><span class="line">        <span class="comment">// 1. 入度为0的顶点入队</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">                q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 删除结点计数器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将出队的元素的边全部删除，并将入度表和队列更新</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[temp].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                indegree[graph[temp][i]]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[graph[temp][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(graph[temp][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>​    并查集是一种维护集合的数据结构。</p>
<h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p>建立数组<code>int father[N]</code></p>
<p>其中，<code>father[i] = j</code>表示<strong>i的父亲节点为元素j</strong>。如果<code>father[i] = i</code>则说明元素i是集合的根节点。</p>
<p>对同一集合来说只存在一个根节点，且将其作为所属集合的标识。</p>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p>先初始化<code>father</code>，再根据需要进行查找或合并的操作。</p>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>起初每个元素为一个独立的集合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    father[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h6><p>由于一个集合只有一个根节点，查找操作即为<strong>对给定的节点寻找其根节点的过程</strong>。</p>
<p>方式1：递推</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// findFather函数返回元素x所在集合的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2：递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == father[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findFather(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h6><p>将两个集合合并为一个集合。实现步骤：</p>
<ol>
<li>对于给定的元素a,b，利用查找算法查到根节点后比对是否相同，以判断两个待合并元素是否属于同一集合。</li>
<li>利用1中获取的根节点faA和faB，把其中一个父节点指向另一个节点。例如：<code>father[faA] = faB</code>或者反过来。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在合并的过程中，只对不同的集合进行合并。如果两个元素在一个相同的集合中，那么就不会对它们进行操作。这就保证了在同一个集合中一定不会产生环，即并查集产生的每一个集合都是一棵树。</p>
<h6 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h6><p><strong>优化查找</strong></p>
<ol>
<li>按原先的算法获得x的根节点r。</li>
<li>重新从x开始走一遍，寻找根节点，把路径上经过的所有节点的父亲全部改为根节点r。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x; </span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="例题：好朋友"><a href="#例题：好朋友" class="headerlink" title="例题：好朋友"></a>例题：好朋友</h5><p>如果A和B是好朋友，则B和A是好朋友。</p>
<p>如果A和C是好朋友，B和C是好朋友，则A和B是好朋友。</p>
<p>现给定输入集：第一行正整数n和m，表示人数量和好朋友组数。接下来的m行每行表示一组好朋友。</p>
<p>要求：输出一组数，元素个数代表有几组好朋友，每个元素代表每组的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> father[N];</span><br><span class="line"><span class="keyword">int</span> isRoot[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        isRoot[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        Union(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        isRoot[findFather(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRoot != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; isRoot[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h4><p><a href="https://www.liuchuo.net/archives/2357" target="_blank" rel="noopener">参考文章</a></p>
<p>算法逻辑伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dijkstra() &#123;</span><br><span class="line">  初始化;</span><br><span class="line">  for(循环n次) &#123;</span><br><span class="line">    u &#x3D; 使dis[u]最小的还未被访问的顶点的编号;</span><br><span class="line">    记u为确定值;</span><br><span class="line">    for(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">      if(v未被访问 &amp;&amp; 以u为中介点使s到顶点v的最短距离更优)</span><br><span class="line">        更新dis[v];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>邻接矩阵表示法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, edge[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> dis[maxv], pre[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dis, dis + maxv, inf);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) pre[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minDis = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; minDis) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minDis = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; edge[u][v] != inf &amp;&amp; dis[u] + edge[u][v] &lt; dis[v]) &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[u][v];</span><br><span class="line">                pre[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之查找</title>
    <url>/2020/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>查找这部分是跟着郭老师学的，临近期末，又要复习这部分涉及到的内容又多，掌握的几乎为0。</p>
<a id="more"></a>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="找下限"><a href="#找下限" class="headerlink" title="找下限"></a>找下限</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLower</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        mid = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123; <span class="comment">// 这个if条件下，满足的条件一定是该if条件的真子集</span></span><br><span class="line">            <span class="built_in">end</span> = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="找上限"><a href="#找上限" class="headerlink" title="找上限"></a>找上限</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findHigher</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        mid = start + (<span class="built_in">end</span> - start + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="hash表查找"><a href="#hash表查找" class="headerlink" title="hash表查找"></a>hash表查找</h3><h4 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>目标：不需要把待查记录的关键字与查找表的某些记录进行逐个比较。而是<strong>根据待查记录的关键字值，直接找到该记录的存储地址</strong>。<br>思想：建立一个确定的函数关系H(称为散列函数，或哈希函数)：</p>
<ul>
<li>以结点关键字key作为自变量</li>
<li>以函数值H(key)作为结点的存储地址</li>
<li>通常散列表的存储空间是一个一维数组，散列地址是数组的下标。</li>
</ul>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h6 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h6><p>题目：已知一长度为14的线性表关键字集合<code>S = { and,
begin, do, end, for, go, if, repeat, then, until, while,
else, array, when }</code>。设查找表中每个关键字表示为<br><code>key[8]</code>。</p>
<p>设计：</p>
<ul>
<li>散列表表示为<code>char ht[26][8];</code></li>
<li>散列函数H(key)的值取为关键字key中的第一个字母在字母表中的序号</li>
</ul>
<p>总结：显然a、e、w开头的单词均在其地址内有冲突。</p>
<h6 id="例题改进"><a href="#例题改进" class="headerlink" title="例题改进"></a>例题改进</h6><p>在例1的基础上，修改散列函数H(key)：<strong>值为key中首尾字母在字母表中序号的平均值</strong>，此时地址不产生冲突。</p>
<h4 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p><strong>散列函数H</strong>：<br>$$Address=H(key)$$<br><strong>装载因子</strong>：<br>$$a=n/m$$<br>其中，m为散列表的空间大小，n为散列表中的记录数。</p>
<h5 id="hash函数的构造方法"><a href="#hash函数的构造方法" class="headerlink" title="hash函数的构造方法"></a>hash函数的构造方法</h5><h6 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h6><p>$$H(key)=key%p$$<br>其中p一般取&lt;=m的最大素数。</p>
<h6 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h6><ul>
<li>取关键字作为其hash地址</li>
<li>取关键字的某个线性函数：$H(key)=a*key+b$<h6 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h6>根据散列表的大小，选取其中各种符号分布均匀的若干位作为散列地址。<h6 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h6>先通过求关键字的平方值来扩大差别，<br>再取其中的几位或其组合作为散列地址。<br>具体取几位，由hash表的表长决定。<h6 id="分段叠加法"><a href="#分段叠加法" class="headerlink" title="分段叠加法"></a>分段叠加法</h6></li>
<li>将关键字分割成位数相同的几部分（最后一部分位数可不同）</li>
<li>然后取这几部分的叠加和舍去进位作为散列地址。</li>
</ul>
<h4 id="冲突解决方法"><a href="#冲突解决方法" class="headerlink" title="冲突解决方法"></a>冲突解决方法</h4><h5 id="开放地址法–找下一个空位"><a href="#开放地址法–找下一个空位" class="headerlink" title="开放地址法–找下一个空位"></a>开放地址法–找下一个空位</h5><p>当冲突发生时，使用某种方法为R的关键字key生成一个散列地址序列，其中第i次冲突散列地址：<br>$$d_i = (d_{i-1}+D)%m$$</p>
<h6 id="线性探测再散列"><a href="#线性探测再散列" class="headerlink" title="线性探测再散列"></a>线性探测再散列</h6><p>$D=i$，i表示探测次数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="二次探测再散列"><a href="#二次探测再散列" class="headerlink" title="二次探测再散列"></a>二次探测再散列</h6><p>按照$1^2, -1^2, 2^2, -2^2…$的形式构造D</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(i*i/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i+<span class="number">1</span>)*(i+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="伪随机探测再散列"><a href="#伪随机探测再散列" class="headerlink" title="伪随机探测再散列"></a>伪随机探测再散列</h6><p>按照[1:m]的随机数打乱序列开始探测</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Randomize</span><span class="params">()</span> <span class="comment">//设置随机种子</span></span></span><br><span class="line"><span class="function"></span>&#123; srand(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Random</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">// 返回一个0到i之间的随机整数值</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> rand( ) % i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">permute</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123; <span class="comment">//产生1到m的伪随机排列</span></span><br><span class="line">    <span class="keyword">int</span> i,*perm=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)* m);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m ; i++) </span><br><span class="line">        perm[i] = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        swap(perm[i<span class="number">-1</span>], perm[Random(i)]);</span><br><span class="line">    <span class="keyword">return</span> perm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>* perm)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> perm[i - <span class="number">1</span>]；&#125;</span><br></pre></td></tr></table></figure>

<h5 id="链表法–顺应冲突"><a href="#链表法–顺应冲突" class="headerlink" title="链表法–顺应冲突"></a>链表法–顺应冲突</h5><p>为每一个Hash地址建立一个链表，凡散列地址为i的记录都插入到第i个链表中。</p>
<h4 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h4>]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据科学之numpy_pandas</title>
    <url>/2020/10/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B9%8Bnumpy-pandas/</url>
    <content><![CDATA[<p><a href="https://github.com/fengdu78/Data-Science-Notes" target="_blank" rel="noopener">参考github项目地址</a></p>
<p>主要相当于复习了。</p>
<a id="more"></a>

<h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="列表转矩阵"><a href="#列表转矩阵" class="headerlink" title="列表转矩阵"></a>列表转矩阵</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.array([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><ul>
<li><code>array.ndim</code></li>
<li><code>array.shape</code></li>
<li><code>array.size</code></li>
</ul>
<h2 id="创建array"><a href="#创建array" class="headerlink" title="创建array"></a>创建array</h2><h3 id="普通创建"><a href="#普通创建" class="headerlink" title="普通创建"></a>普通创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">23</span>,<span class="number">4</span>], dtype = np.int32)</span><br></pre></td></tr></table></figure>

<h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3>]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆栈</title>
    <url>/2020/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>数据结构中的堆栈和队列知识。堆栈和队列其实就是操作受限的线性表。</p>
<a id="more"></a>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    DataType <span class="built_in">stack</span>[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; seqStack;</span><br></pre></td></tr></table></figure>
<h4 id="链表存储结构"><a href="#链表存储结构" class="headerlink" title="链表存储结构"></a>链表存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slNode</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; slNodeType;</span><br></pre></td></tr></table></figure>

<h4 id="经典问题：括号匹配"><a href="#经典问题：括号匹配" class="headerlink" title="经典问题：括号匹配"></a>经典问题：括号匹配</h4><p>思想：</p>
<ol>
<li>循环：自左向右扫描表达式串（基本框架），<ul>
<li>当遇到左括号，左括号入栈</li>
<li>当遇到右括号，比较当前栈顶元素与其是否匹配，<ul>
<li>若配对，则出栈，并继续扫描</li>
<li>若不配对，则返回不匹配</li>
<li>若栈空，则右括号多于左括号</li>
</ul>
</li>
</ul>
</li>
<li>扫描结束后，<ul>
<li>若栈非空，则左括号多于右括号</li>
<li>若栈为空，则左右括号配对<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        dic = &#123;<span class="string">'['</span>:<span class="string">']'</span>,<span class="string">'('</span>:<span class="string">')'</span>,<span class="string">'&#123;'</span>:<span class="string">'&#125;'</span>&#125;</span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span> <span class="keyword">or</span> s[i]==<span class="string">'['</span> <span class="keyword">or</span> s[i]==<span class="string">'&#123;'</span>):</span><br><span class="line">                stack.append(dic[s[i]])</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span> <span class="keyword">or</span> s[i]==<span class="string">']'</span> <span class="keyword">or</span> s[i]==<span class="string">'&#125;'</span>):</span><br><span class="line">                <span class="keyword">if</span>(stack == []):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span>(stack[<span class="number">-1</span>] != s[i]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span>(stack[<span class="number">-1</span>] == s[i]):</span><br><span class="line">                    stack = stack[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span>(stack == []):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="栈的应用：递归栈"><a href="#栈的应用：递归栈" class="headerlink" title="栈的应用：递归栈"></a>栈的应用：递归栈</h3><p>在一个函数的运行期间调用另一个函数时，<strong>在运行该被调用函数之前</strong>，需要先完成三项任务：</p>
<ul>
<li>将所有实在参数、返回地址等信息传递给被调用函数保存。</li>
<li>为被调用函数的局部变量分配存储区。</li>
<li>将控制转移到被调用函数的入口。</li>
</ul>
<p>从被调用函数返回调用函数之前，应该完成下列三项任务：</p>
<ul>
<li>保存被调函数的计算结果</li>
<li>释放被调函数的数据区</li>
<li>依照被调函数保存的返回地址将控制转移到调用函数</li>
</ul>
<p>四个概念：</p>
<ul>
<li>递归工作栈：递归过程执行过程中占用的数据区。</li>
<li>递归工作记录：每一层递归参数合成一个记录。</li>
<li>当前活动记录：栈顶记录指示当前层的执行情况。</li>
<li>当前环境指针：递归工作栈的栈顶指针。</li>
</ul>
<h3 id="栈应用：消去递归"><a href="#栈应用：消去递归" class="headerlink" title="栈应用：消去递归"></a>栈应用：消去递归</h3><p>将调用函数的过程，等效成入栈。将返回值的过程等效为出栈。</p>
<h4 id="实例：斐波那契数列的求解"><a href="#实例：斐波那契数列的求解" class="headerlink" title="实例：斐波那契数列的求解"></a>实例：斐波那契数列的求解</h4><p>解法1：堆栈消去递归（C++）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibnacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node&gt; S;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Node w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123; <span class="comment">// 向左递归，执行进栈操作</span></span><br><span class="line">            w.n = n;</span><br><span class="line">            w.tag = <span class="number">1</span>;</span><br><span class="line">            S.push(w);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum + n; <span class="comment">// 求和，因为到底已经返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!S.empty())&#123;</span><br><span class="line">            w = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="keyword">if</span>(w.tag == <span class="number">1</span>)&#123; <span class="comment">// 若左侧已经被进栈</span></span><br><span class="line">                w.tag = <span class="number">2</span>;</span><br><span class="line">                S.push(w);</span><br><span class="line">                n = w.n - <span class="number">2</span>; <span class="comment">// F(n)的右下侧为F(n-2)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!S.empty());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法2：迭代法<br>一般对于<strong>尾递归或单向递归</strong>的情形，都可以利用迭代的方法，将递归转换为非递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">longFibIter(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    longtwoback=<span class="number">0</span>,oneback=<span class="number">1</span>,Current;</span><br><span class="line">    <span class="keyword">for</span>(inti=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        Current=twoback+oneback;</span><br><span class="line">        twoback=oneback;</span><br><span class="line">        oneback=Current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h3><h4 id="顺序存储结构-1"><a href="#顺序存储结构-1" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    DataType <span class="built_in">queue</span>[MaxQueueSize];</span><br><span class="line">    <span class="keyword">int</span> front; <span class="comment">// 头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear; <span class="comment">// 尾指针</span></span><br><span class="line">&#125;SeqQueue;</span><br></pre></td></tr></table></figure>
<ul>
<li>当出队，<code>front</code>递增</li>
<li>当入队，<code>rear</code>递增</li>
<li>当队空，<code>front=rear</code></li>
</ul>
<h4 id="链表存储结构-1"><a href="#链表存储结构-1" class="headerlink" title="链表存储结构"></a>链表存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LQNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链队列定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LQNode *front;</span><br><span class="line">    LQNode *rear;</span><br><span class="line">&#125;LQueue;</span><br></pre></td></tr></table></figure>

<h3 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h3><p>操作系统的作业调度。</p>
]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之排序</title>
    <url>/2020/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>主要介绍8种排序算法：直接插入排序，直接选择排序，冒泡排序，希尔排序，堆排序，快速排序，归并排序，基数排序。</p>
<a id="more"></a>

<h1 id="排序方法一览"><a href="#排序方法一览" class="headerlink" title="排序方法一览"></a>排序方法一览</h1><ul>
<li>三种简单排序 —-$O(n^2)$<ul>
<li>直接插入排序</li>
<li>直接选择排序</li>
<li>冒泡排序</li>
</ul>
</li>
<li>希尔排序 —-$O(n^{\frac{3}{2}})$</li>
<li>堆排序 —-$O(nlogn)$</li>
<li>快速排序 —-$O(nlogn)$</li>
<li>归并排序 —-$O(nlogn)$</li>
<li>基数排序 —-$O(nlogn)$</li>
</ul>
<h1 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[j] &gt; v[j + <span class="number">1</span>])</span><br><span class="line">            	swap(v[i], v[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><p><strong>一个关键字序列${K_0, K_1, …, K_{n-1}}$</strong>，满足条件：</p>
<ul>
<li>$K_i \le K_{2i+1}，K_i \le K_{2i+2}$（或$\ge$）</li>
</ul>
<p>即每层所有元素大于（小于）下一层，其实质是一个<strong>完全二叉树的层次序列</strong>，可以用数组表示。堆中的序列是部分有序的。</p>
<p><strong>大顶堆</strong></p>
<p><img src="https://pic.leetcode-cn.com/f660d0d7b248ba51e6b39ef1a7bdf18f22a1b56fef07043bde9fd53019c3db26-image.png" alt="image.png"></p>
<p><strong>小顶堆</strong></p>
<p><img src="https://pic.leetcode-cn.com/b303b6b280c2a78d37789a35bf7e74335415298c2b48f0b5aa1d443370995c4a-image.png" alt="image.png"></p>
<h2 id="代码实现（以大顶堆为例）"><a href="#代码实现（以大顶堆为例）" class="headerlink" title="代码实现（以大顶堆为例）"></a>代码实现（以大顶堆为例）</h2><h3 id="向下调整函数"><a href="#向下调整函数" class="headerlink" title="向下调整函数"></a>向下调整函数</h3><p>从<strong>堆顶向堆底</strong>计算，依次计算有后续孩子节点的节点将其与孩子比较，并进行移动，直到整个堆完成排序。</p>
<p>时间复杂度 —-$O(logn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对堆heap进行[low, high]范围内向下调整</span></span><br><span class="line"><span class="comment">// 其中low为调整节点的下标，high为堆的最后一个元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = i * <span class="number">2</span>; <span class="comment">// i为欲调整的节点，j为其左孩子</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123; <span class="comment">// 存在孩子</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果存在右孩子，且右孩子较大</span></span><br><span class="line">            j = j + <span class="number">1</span>; <span class="comment">// j变为右孩子下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap[j] &gt; heap[i]) &#123;</span><br><span class="line">            swap(heap[j], heap[i]);</span><br><span class="line">            <span class="comment">// 更新i和j为调整好后的节点</span></span><br><span class="line">            i = j;</span><br><span class="line">            j = i * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向上调整函数"><a href="#向上调整函数" class="headerlink" title="向上调整函数"></a>向上调整函数</h3><p>时间复杂度 —-$O(logn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = high, j = i / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= low) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[j] &lt; heap[i]) &#123;</span><br><span class="line">            swap(heap[j], heap[i]);</span><br><span class="line">            i = j;</span><br><span class="line">            j = i / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="建堆函数"><a href="#建堆函数" class="headerlink" title="建堆函数"></a>建堆函数</h3><p>假设序列中的元素个数为n，由于完全二叉树的叶子节点数量为$\frac{n}{2}$，因此数组下标在$[1, \frac{n}{2}]$范围内的节点都是非叶子节点。于是从$\frac{n}{2}$号位向上倒着向下进行调整即可。</p>
<p>时间复杂度 —-$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        downAdjust(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h3><p>如果要删除堆中的最大元素（即堆顶元素），<strong>并让其仍然保持堆的结构</strong>，那么只需要最后一个元素覆盖堆顶元素，然后对根节点进行向下调整即可。</p>
<p>时间复杂度 —-$O(logn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">    downAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>如果想要往堆中添加一个元素。</p>
<ul>
<li>将想要添加的元素放在数组末尾</li>
<li>然后进行<strong>向上调整</strong>操作：向上调整就是把欲调整节点与父亲节点比较，如果权值较大就与父节点进行交换</li>
</ul>
<p>时间复杂度 —-$O(logn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++n] = x;</span><br><span class="line">    upAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>思路：</p>
<ol>
<li>取出堆顶元素</li>
<li>将堆的最后一个元素替换到堆顶</li>
<li>进行一次针对堆顶元素的向下调整</li>
<li>重复1-3，直到堆中仅剩一个元素</li>
</ol>
<p>具体实现：</p>
<p>倒序遍历数组</p>
<ol>
<li>假设当前访问到第$i$位，将堆顶元素与$i$号位交换</li>
<li>在$[1, i - 1]$范围内对堆顶元素进行一次向下调整。</li>
</ol>
<p>时间复杂度 —-$O(nlogn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createHeap();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; --i) &#123;</span><br><span class="line">        swap(heap[i], heap[<span class="number">1</span>]);</span><br><span class="line">        downAdjust(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="算法思想-分治"><a href="#算法思想-分治" class="headerlink" title="算法思想(分治)"></a>算法思想(分治)</h2><ol>
<li>选择轴值$pivot$</li>
<li>将待排序列分为两个子序列$L$和$R$，使$L$中所有值都小于或等于$pivot$，$R$中所有值都大于等于$pivot$（这一步需要利用$l$和$r$指针来实现）。</li>
<li>对子序列$L$和$R$进行快速排序。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="轴值选择函数"><a href="#轴值选择函数" class="headerlink" title="轴值选择函数"></a>轴值选择函数</h3><p>选择轴值，<strong>并将轴值与最左元素进行交换。</strong></p>
<p>也可以直接选定最左侧的元素。</p>
<h3 id="分割函数"><a href="#分割函数" class="headerlink" title="分割函数"></a>分割函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high;</span><br><span class="line">    temp = x[i]; <span class="comment">// temp存放pivot</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">/*两侧的数各自寻找两侧的"异类"，并进行互换*/</span></span><br><span class="line">        <span class="keyword">while</span> (x[j] &gt; temp &amp;&amp; (i &lt; j)) &#123;</span><br><span class="line">            <span class="comment">/*右指针寻找一个小于等于pivot的元素*/</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            x[i] = x[j];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x[i] &lt; temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            <span class="comment">/*左指针寻找一个大于等于pivot的元素*/</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            x[j] = x[i];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    x[i] = temp; <span class="comment">// 轴值赋给相遇点，形成闭环</span></span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 返回pivot下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序函数"><a href="#快速排序函数" class="headerlink" title="快速排序函数"></a>快速排序函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(x, low, high);</span><br><span class="line">    qs(x, low, pivot - <span class="number">1</span>);</span><br><span class="line">    qs(x, pivot + <span class="number">1</span>, high);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>快速排序是一种不稳定排序（相同数值的元素的相对位置可能改变）算法。</p>
<p>最差情况：</p>
<ul>
<li><p>时间—-$O(n^2)$</p>
</li>
<li><p>空间—-$O(n)$</p>
</li>
</ul>
<p>最佳情况：</p>
<ul>
<li>时间—-$O(nlogn)$</li>
<li>空间—-$O(logn)$</li>
</ul>
<p>平均情况：</p>
<ul>
<li>时间—-$O(nlogn)$</li>
<li>空间—-$O(logn)$</li>
</ul>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="算法思想-分治-1"><a href="#算法思想-分治-1" class="headerlink" title="算法思想(分治)"></a>算法思想(分治)</h2><ul>
<li>简单的将原始序列二分为两个子序列</li>
<li>继续对两子序列递归划分，将排好序的两个子序列合并为一个新的有序序列并向下归并。</li>
</ul>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="合并函数"><a href="#合并函数" class="headerlink" title="合并函数"></a>合并函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> mid)</span> </span>&#123; <span class="comment">// 存放了(low, mid)和(mid + 1, high)的已排序集合</span></span><br><span class="line">    <span class="comment">// h和j分别为两集合的遍历指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(high - low + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x[i] &lt;= x[j]) &#123;</span><br><span class="line">            helper[k] = x[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helper[k] = x[j];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*处理残留元素*/</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; mid) &#123; <span class="comment">// 如果后一个集合有剩余</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = j; p &lt;= high; ++p) &#123;</span><br><span class="line">            helper[k] = x[p];</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前一个集合有剩余</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = i; p &lt;= mid; ++p) &#123;</span><br><span class="line">            helper[k] = x[p];</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将辅助数组覆盖原数组*/</span></span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = low; p &lt;= high; ++p) &#123;</span><br><span class="line">        x[p] = helper[q++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序函数"><a href="#归并排序函数" class="headerlink" title="归并排序函数"></a>归并排序函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(x, low, mid);</span><br><span class="line">        mergeSort(x, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(x, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><p>归并排序是一种稳定的排序算法。最大、最小、平均时间代价基本相同。</p>
<ul>
<li><p>时间—-$O(nlogn)$</p>
</li>
<li><p>空间—-$O(n+logn) = O(n)$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之链表</title>
    <url>/2020/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表的内容非常非常的基础，快速回顾~</p>
<a id="more"></a>
<h2 id="绕不开的malloc和free"><a href="#绕不开的malloc和free" class="headerlink" title="绕不开的malloc和free"></a>绕不开的malloc和free</h2><p>C没有虚浮的<code>new</code>关键字，只能用使用起来不是很直观的<code>malloc</code>关键字进行内存分配。</p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>声明：<code>malloc</code>向系统申请分配指定<code>size</code>个字节的内存空间。返回类型是 <code>void*</code> 类型。<code>void*</code> 表示未确定类型的指针。C,C++规定，<code>void*</code> 类型可以强制转换为<strong>任何其它类型的指针</strong>。</p>
<h4 id="malloc函数标准用法"><a href="#malloc函数标准用法" class="headerlink" title="malloc函数标准用法"></a>malloc函数标准用法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以申请一个链表SLNode数据为例，此处head已经声明过，为SLNode的二级指针</span></span><br><span class="line"><span class="keyword">if</span> ((*head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请一段连续的内存空间</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">100</span> );</span><br></pre></td></tr></table></figure>

<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h4 id="函数声明-1"><a href="#函数声明-1" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *block)</span></span>;</span><br><span class="line"><span class="comment">// 即 void free(指针变量)</span></span><br></pre></td></tr></table></figure>

<h2 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h2><h3 id="链表vs顺序表"><a href="#链表vs顺序表" class="headerlink" title="链表vs顺序表"></a>链表vs顺序表</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">顺序表</th>
<th align="center">链表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">增删改</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center">访问</td>
<td align="center">$O(1)$</td>
<td align="center">$O(n)$</td>
</tr>
</tbody></table>
<h3 id="单链表操作"><a href="#单链表操作" class="headerlink" title="单链表操作"></a>单链表操作</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SLNode **head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    (*head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="统计元素个数-核心思想"><a href="#统计元素个数-核心思想" class="headerlink" title="统计元素个数(核心思想)"></a>统计元素个数(核心思想)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;next!=null)&#123;</span><br><span class="line">    <span class="built_in">size</span>++;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找算法-略"><a href="#查找算法-略" class="headerlink" title="查找算法(略)"></a>查找算法(略)</h4><h4 id="添加算法"><a href="#添加算法" class="headerlink" title="添加算法"></a>添加算法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = q;</span><br></pre></td></tr></table></figure>
<h4 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q)</span><br></pre></td></tr></table></figure>

<h4 id="头插法建表（反向）"><a href="#头插法建表（反向）" class="headerlink" title="头插法建表（反向）"></a>头插法建表（反向）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creatlist1</span><span class="params">(SLNode **head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 从键盘输入n个整数，建立以head为头指针的带头结点的单链表*/</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    SLNode *p;</span><br><span class="line">    <span class="keyword">if</span> ((*head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    (*head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((p=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p-&gt;data);</span><br><span class="line">        p-&gt;next=(*head)-&gt;next;</span><br><span class="line">        (*head)-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="尾插法建表（正向）"><a href="#尾插法建表（正向）" class="headerlink" title="尾插法建表（正向）"></a>尾插法建表（正向）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SLNode * <span class="title">createlist2</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch; </span><br><span class="line">    SLNode * head,*s,*r;</span><br><span class="line">    <span class="keyword">if</span> ((head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    (head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r=head;</span><br><span class="line">    <span class="keyword">while</span>((ch=getchar( ))!=‘\n’)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((s=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        s–&gt;data=ch;</span><br><span class="line">        r–&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">    &#125;</span><br><span class="line">    r–&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表操作"><a href="#双向链表操作" class="headerlink" title="双向链表操作"></a>双向链表操作</h3><p>略</p>
<h3 id="实例：多项式加法-amp-多项式乘法"><a href="#实例：多项式加法-amp-多项式乘法" class="headerlink" title="实例：多项式加法&amp;多项式乘法"></a>实例：多项式加法&amp;多项式乘法</h3><p>具体思想：</p>
<ul>
<li>设<code>p</code>和<code>q</code>分别指示多项式A和B中某一结点，</li>
<li>当<code>p</code>和<code>q</code>均非空时，比较<code>p-&gt;exp</code>与<code>q-&gt;exp</code>：<ul>
<li>若<code>p-&gt;exp</code> &lt; <code>q-&gt;exp</code>，则<code>p</code>所指结点是“和多项式”中的一项，令指针<code>p</code>后移；</li>
<li>若<code>p-&gt;exp</code> &gt; <code>q-&gt;exp</code>，则q所指结点是“和多项式”中的一项，将结点<code>q</code>插入在结点<code>p</code>之前，且令指针<code>q</code>在原来的链表上后移；</li>
<li>若<code>p-&gt;exp</code> == <code>q-&gt;exp</code>，则将两个结点中的系数相加，当和不为零时修改结点<code>p</code>的系数域，释放<code>q</code>结点；若和为零，则和多项式中无此项，从A中删去<code>p</code>结点，同时释放<code>p</code>和<code>q</code>结点。</li>
</ul>
</li>
<li>if (<code>q</code> == null) A即为“和多项式”结果</li>
<li>if (<code>p</code> == null) 将剩余的<code>q</code>表全部链接至原A最后一个结点的后继</li>
</ul>
]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/09/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>从<a href="https://www.acwing.com/problem/" target="_blank" rel="noopener">AcWing</a>官网上找到的一系列背包问题，做一个专题。</p>
<p><a href="https://www.kancloud.cn/kancloud/pack/70125" target="_blank" rel="noopener">参考题解</a></p>
<a id="more"></a>

<h1 id="背包九讲题目"><a href="#背包九讲题目" class="headerlink" title="背包九讲题目"></a>背包九讲题目</h1><h2 id="一、01背包问题"><a href="#一、01背包问题" class="headerlink" title="一、01背包问题"></a>一、01背包问题</h2><p><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">题目链接</a></p>
<p>直观dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">int</span> w[n + <span class="number">1</span>], v[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i]; <span class="comment">// weight and value</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dp[i][j]定义为前i个样品中背包容量为j时的最优解</span></span><br><span class="line">    <span class="comment">// dp[i][j] = dp[i - 1][j - w[i]] + v[i] or dp[i - 1][j]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[n + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间优化，注意此时第二层循环应该为倒序，如果继续按正序遍历的话，<strong>相当于计算的是<code>f[i][j - w[i]]</code>而不是<code>f[i - 1][j - w[i]]</code></strong>，因为在未优化的二维数组在计算当层时上一层已经全部计算完毕，所以要保证的是<code>dp[j - w[i]]</code>是一个计算完且不会再次改变的值，倒序遍历满足这个要求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">int</span> w[n + <span class="number">1</span>], v[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、完全背包问题"><a href="#二、完全背包问题" class="headerlink" title="二、完全背包问题"></a>二、完全背包问题</h2><p><a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">题目链接</a></p>
<p>暴力dp 复杂度接近3次方</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">int</span> w[n + <span class="number">1</span>], v[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">int</span> dp[n + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fill</span>(dp[<span class="number">0</span>], dp[<span class="number">0</span>] + (n + <span class="number">1</span>) * (V + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">int</span> maxK = j / w[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= maxK; ++k) &#123;</span><br><span class="line">                <span class="comment">// 将01背包变成0(1|2|3..|k|..)背包</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - k * w[i]] + k * v[i], dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如何优化上述代码的复杂度呢？我们考虑是否可以直接利用不算此次背包的结果（利用<code>dp[i - 1][j]</code>的结果），借助一个两层之间的递推公式来优化不必要的计算。</p>
<p>拜读了闫总的分析之后豁然开朗：</p>
<p>两层状态的展开如下:</p>
<p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i], dp[i - 1][j - 2 * w[i]] + 2 * v[i], ..)</code></p>
<p><code>dp[i][j - w[i]] = max(dp[i - 1][j - w[i]], dp[i - 1][j - 2 * w[i]] + v[i], ..)</code></p>
<p>即状态转移方程为：<code>dp[i][j] = dp[i][j - w[i]] + v[i]</code></p>
<p>优化后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">int</span> w[n + <span class="number">1</span>], v[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">int</span> dp[n + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fill</span>(dp[<span class="number">0</span>], dp[<span class="number">0</span>] + (n + <span class="number">1</span>) * (V + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[i]) dp[i][j] = <span class="built_in">max</span>(dp[i][j - w[i]] + v[i], dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间优化后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">int</span> w[n + <span class="number">1</span>], v[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= V; ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、多重背包问题I​"><a href="#三、多重背包问题I​" class="headerlink" title="三、多重背包问题I​"></a>三、多重背包问题I​</h2><p><a href="https://www.acwing.com/problem/content/description/4/" target="_blank" rel="noopener">题目链接</a></p>
<p>01背包问题的扩展，将枚举0、1扩展到枚举0、1、2……s[i]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">int</span> w[n + <span class="number">1</span>], v[n + <span class="number">1</span>], s[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; ++j) &#123; <span class="comment">// 注意这里j从0开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= s[i]; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= k * w[i]) dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - k * w[i]] + k * v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化为一维数组，第二层循环反向以利用上一层的结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">int</span> w[n + <span class="number">1</span>], v[n + <span class="number">1</span>], s[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i]; --j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s[i]; ++k) &#123;</span><br><span class="line">                <span class="comment">// 依次枚举选[0,s[i]]的情况下</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= k * w[i])</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - k * w[i]] + k * v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、多重背包问题II​"><a href="#四、多重背包问题II​" class="headerlink" title="四、多重背包问题II​"></a>四、多重背包问题II​</h2><p>与I问题一样，只不过是数据量翻倍，需要用等价转换的思想。</p>
<ul>
<li><p>首先想到将原问题转换为，将限制数量为s[i]的物品依次拆分成s[i]份个物品将其重新放入物品集合里，从而将原问题转换为01背包问题，但是这样的话复杂度将是$10^9$数量级的，依然会超时。</p>
<ul>
<li>$T(n) = 1000 * 2000 * 2000$</li>
</ul>
</li>
<li><p>为了优化上一过程，试图<strong>以更好的拆分方法使得拆分后的数据的组合可以表示原来的s[i]的物品的物理意义且分的份数最少</strong>。</p>
<p>举例说明当<code>s[i] == 10</code>的情况下：</p>
<ul>
<li>先以2的幂次形式向下分，依次分成<code>num == 1</code>，<code>num == 2</code>，<code>num == 4</code>，达到了极限。此时再将剩余的<code>num == 10 - 1 - 2 - 4</code>也就是3个物品的量级放入即可利用<code>{1,2,4,3}</code>的集合的部分和表示<code>s[i] &lt;= 10</code>的情况。</li>
<li>证明：<code>{1，2，4}</code>的组合有$2^3$种取值，可以表示到$[0,7]$的数据集范围，再在原基础上加上一个大小为3的偏移量即可达到10。</li>
<li>注意：当把这些新物品放入背包时，<strong>它们的weight和value也会等效的成倍增加</strong>。</li>
</ul>
</li>
</ul>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; goods; <span class="comment">// &#123;w, v&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w, v, s; <span class="comment">// &#123;weight, value, s&#125;</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; v &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= s; j *= <span class="number">2</span>) &#123;</span><br><span class="line">            s -= j;</span><br><span class="line">            goods.emplace_back(make_pair(j * w, j * v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) goods.emplace_back(make_pair(s * w, s * v));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 套用01背包模板</span></span><br><span class="line">    n = goods.<span class="built_in">size</span>(); <span class="comment">// 修正货品数</span></span><br><span class="line">    <span class="keyword">int</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= goods[i].first; --j)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - goods[i].first] + goods[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、多重背包问题III"><a href="#五、多重背包问题III" class="headerlink" title="五、多重背包问题III"></a>五、多重背包问题III</h2><h3 id="算法引入：单调队列"><a href="#算法引入：单调队列" class="headerlink" title="算法引入：单调队列"></a>算法引入：单调队列</h3><p><a href="https://www.acwing.com/solution/content/13624/" target="_blank" rel="noopener">154滑动窗口</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, q[N], nums[N]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>; <span class="comment">// hh为队列头，tt为队列尾</span></span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 分别构造非降序和非增序的队列，并实时更新每个滑动窗口对应的队列*/</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">/* 维持窗口的大小 */</span></span><br><span class="line">        <span class="comment">// 当队列不为空 且 滑动窗口的大小(i - q[hh] + 1)大于k时，弹出头元素</span></span><br><span class="line">        <span class="comment">// 滑动窗口的大小始终为k，队列弹出队列头元素以维持滑动窗口的大小</span></span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; k &lt; i - q[hh] + <span class="number">1</span>) ++hh;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 构造单调递增队列 */</span></span><br><span class="line">        <span class="comment">// 当队列不为空 且 队尾元素大于等于当前元素时，队尾不断弹出（中间部分元素没有用，相当于一个路径压缩）</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; nums[q[tt]] &gt;= nums[i]) --tt;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">"%d "</span>, nums[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>); <span class="comment">// 换行</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; k &lt; i - q[hh] + <span class="number">1</span>) ++hh;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; nums[q[tt]] &lt;= nums[i]) --tt;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">"%d "</span>, nums[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="利用单调队列求解"><a href="#利用单调队列求解" class="headerlink" title="利用单调队列求解"></a>利用单调队列求解</h3><p><a href="https://www.acwing.com/solution/content/1537/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxV = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">int</span> dp[maxV], pre[maxV], q[maxV];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 枚举每一类物品</span></span><br><span class="line">        <span class="built_in">memcpy</span>(pre, dp, <span class="keyword">sizeof</span>(dp)); <span class="comment">// pre为当层循环的拷贝dp</span></span><br><span class="line">        <span class="keyword">int</span> v, w, s; <span class="comment">// v体积 w价值 s最大数量</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123; <span class="comment">// 枚举重量的余数，从而涉及到所有的数据</span></span><br><span class="line">            <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= V; k += v) &#123; <span class="comment">// 枚举以该余数为起点的一串方案</span></span><br><span class="line">                <span class="comment">// 到这里 k是体积-&gt;方案 j是当前枚举的起始余数 q[head]表示的是最优方案</span></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail &amp;&amp; k - s*v &gt; q[head]) </span><br><span class="line">                    <span class="comment">// 当队列合法 且 当前窗口内存储的数量大于s，队头出列</span></span><br><span class="line">                    ++head;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 注意 v个数 = (q[head] - j) / v = （下标-余数）/ v</span></span><br><span class="line">                <span class="comment">//      价值  = ((k - j) / v) * w </span></span><br><span class="line">                <span class="keyword">while</span> (head &lt;= tail &amp;&amp; pre[q[tail]] - (q[tail] - j)/v * w &lt;= pre[k] - (k - j)/v * w)</span><br><span class="line">                    <span class="comment">// 当队列合法 且 队尾元素得到的收益要小于当前k，队尾出列</span></span><br><span class="line">                    --tail;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail)</span><br><span class="line">                    <span class="comment">// 转移方程，如果之前的最大+当前组总价值要更大，则更新</span></span><br><span class="line">                    dp[k] = <span class="built_in">max</span>(dp[k], pre[q[head]] + (k - q[head])/v * w);</span><br><span class="line"></span><br><span class="line">                q[++tail] = k; <span class="comment">// 尾部放置当前的方案（体积）</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯突击</title>
    <url>/2021/03/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<p>记蓝桥杯那些稀奇古怪的题。</p>
<a id="more"></a>

<h1 id="S11"><a href="#S11" class="headerlink" title="S11"></a>S11</h1><h2 id="回文日期"><a href="#回文日期" class="headerlink" title="回文日期"></a>回文日期</h2><ol>
<li><p>回文日期</p>
<p>每年的月份：天数组合是固定的（除非闰年的时候会多一个0229，注意9220…的年份不在数据范围内，所以不需要考虑闰年）。用一个日期模拟器做一个365空间大小的(month, day)字符串列表，并根据这个列表做一个reverse版本当作可以备选的年份。再实现一个排序算法，让年份从小到大排列即可。</p>
</li>
<li><p>ABABBABA日期</p>
<p>与1相同，排序后从头向后遍历，逐个判断是否是ABAB。(其实还可以取巧，只有1月1日，2月2日…10月10日..这些日期才满足，直接做一个O(12)循环也可)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Global year, mon, data</span><br><span class="line">def data</span><br><span class="line">cin data</span><br><span class="line">decoding data -&gt; y, m, d</span><br></pre></td></tr></table></figure>



<h2 id="子串分值和"><a href="#子串分值和" class="headerlink" title="子串分值和"></a>子串分值和</h2><p>维护$nex[i][j]$表示在$k &gt; i$空间下右侧字母$s[j] + ‘a’$第一次出现的位置$k$，每个字母的贡献就为$n - k + 1$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn]; <span class="keyword">int</span> n, nxt[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j++)</span><br><span class="line">            nxt[i<span class="number">-1</span>][j] = nxt[i][j];</span><br><span class="line">        nxt[i<span class="number">-1</span>][s[i]-<span class="string">'a'</span>+<span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    init();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p = nxt[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans += (n - p + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="S10"><a href="#S10" class="headerlink" title="S10"></a>S10</h1><h2 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h2><p>30*50的迷宫，用BFS算法找到步骤最少，字典序最小的上下左右步骤。</p>
<p><a href="https://my.oschina.net/u/4387790/blog/3599939" target="_blank" rel="noopener"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maze[<span class="number">35</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> dir[][<span class="number">2</span>] = &#123; &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">char</span> d[<span class="number">4</span>] = &#123; <span class="string">'D'</span>, <span class="string">'L'</span>, <span class="string">'R'</span>, <span class="string">'U'</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">35</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="built_in">string</span> rode;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">step</span>;</span><br><span class="line">	node(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy, <span class="built_in">string</span> ss, <span class="keyword">int</span> tt)</span><br><span class="line">	&#123;</span><br><span class="line">		x = xx;</span><br><span class="line">		y = yy;</span><br><span class="line">		rode = ss;</span><br><span class="line">		<span class="built_in">step</span> = tt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= <span class="number">30</span> &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &lt;= <span class="number">50</span> &amp;&amp; y &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">string</span> s, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(node(x, y, s, num));</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		node now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line"></span><br><span class="line">		vis[now.x][now.y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (now.x == <span class="number">30</span> &amp;&amp; now.y == <span class="number">50</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (now.<span class="built_in">step</span> &lt; cnt)&#123;</span><br><span class="line">				cnt = now.<span class="built_in">step</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; now.<span class="built_in">step</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt; now.rode &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				vis[now.x][now.y] = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> tx = now.x + dir[i][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> ty = now.y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (maze[tx][ty] == <span class="number">0</span> &amp;&amp; !vis[tx][ty] &amp;&amp; check(tx, ty))&#123;</span><br><span class="line">				q.push(node(tx, ty, now.rode + d[i], now.<span class="built_in">step</span> + <span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++)&#123;</span><br><span class="line">			maze[i][j] = getchar()-<span class="string">'0'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bfs(<span class="number">1</span>, <span class="number">1</span>, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h2><p>从前向后遍历数组，如果当前元素在前面出现过了，则将其自增，直到其第一次出现为止，根据以上规则返回一个新的数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxA = <span class="number">110005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[maxA], vis[maxA], N, a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != father[x]) father[x] = Find(father[x]);</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> arr[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxA; ++i) father[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;N; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;a;</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (vis[a] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = Find(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">        vis[ans] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 判断是否与前面的集合有重合部分</span></span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="number">1</span> &amp;&amp; vis[ans - <span class="number">1</span>]) &#123;</span><br><span class="line">            father[ans - <span class="number">1</span>] = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否和后面的集合有重合部分</span></span><br><span class="line">        <span class="keyword">if</span> (vis[ans + <span class="number">1</span>]) &#123;</span><br><span class="line">            father[ans] = ans + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="糖果"><a href="#糖果" class="headerlink" title="糖果"></a>糖果</h2><p>糖果店的老板一共有M种口味的糖果出售，为了方便描述，我们将其编号成1-M。</p>
<p>小明希望能够品尝到所有味道的糖果。但老板并不单独出售，只是以K颗为一整包进行出售。不过在买之前，小明就知道每包糖果内的味道。</p>
<p>给定N包糖果，请你计算小明最少买几包就能够品尝到所有味道的糖果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span> &lt;&lt; <span class="number">20</span>]; <span class="comment">// 总状态数最多有1&lt;&lt;20个</span></span><br><span class="line"><span class="keyword">int</span> a[maxN];</span><br><span class="line"><span class="keyword">int</span> n, m, k, tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="comment">// 获取每一袋candy的状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            a[i] |= (<span class="number">1</span> &lt;&lt; tmp - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">127</span>, <span class="keyword">sizeof</span> dp); <span class="comment">// 初始化dp数组为最大值</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 枚举每一袋糖果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt; (<span class="number">1</span> &lt;&lt; m); ++state) &#123;</span><br><span class="line">            <span class="comment">// 枚举每一个状态</span></span><br><span class="line">            dp[state | a[i]] = <span class="built_in">min</span>(dp[state | a[i]], dp[state] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> finalState = <span class="number">1</span> &lt;&lt; m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[finalState] &gt; maxN) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dp[finalState];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="S09"><a href="#S09" class="headerlink" title="S09"></a>S09</h1><p><a href="https://blog.csdn.net/krypton12138/article/details/79801924" target="_blank" rel="noopener">参考题解</a></p>
<h2 id="第几个幸运数"><a href="#第几个幸运数" class="headerlink" title="第几个幸运数"></a>第几个幸运数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：第几个幸运数</span><br><span class="line"></span><br><span class="line">到x星球旅行的游客都被发给一个整数，作为游客编号。</span><br><span class="line">x星的国王有个怪癖，他只喜欢数字3,5和7。</span><br><span class="line">国王规定，游客的编号如果只含有因子：3,5,7,就可以获得一份奖品。</span><br><span class="line"></span><br><span class="line">我们来看前10个幸运数字是：</span><br><span class="line">3 5 7 9 15 21 25 27 35 45</span><br><span class="line">因而第11个幸运数字是：49</span><br><span class="line"></span><br><span class="line">小明领到了一个幸运数字 59084709587505，他去领奖的时候，人家要求他准确地说出这是第几个幸运数字，否则领不到奖品。</span><br><span class="line"></span><br><span class="line">请你帮小明计算一下，59084709587505是第几个幸运数字。</span><br><span class="line"></span><br><span class="line">需要提交的是一个整数，请不要填写任何多余内容。</span><br></pre></td></tr></table></figure>

<p>set进行去重，优先队列进行排序，计算方法为尝试构造幸运数（以3，5，7为基数向上累乘），而不是证明幸运数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> maxn = <span class="number">59084709587505</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;,greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt;p;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;s;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)p.push(a[i]);</span><br><span class="line">	<span class="keyword">while</span>((n = p.top())&lt;=maxn)&#123;</span><br><span class="line">		p.pop();</span><br><span class="line">		res++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">			m = n*a[i];</span><br><span class="line">			<span class="keyword">if</span>(!s.count(m))&#123;</span><br><span class="line">				s.insert(m);</span><br><span class="line">				p.push(m);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="全球变暖"><a href="#全球变暖" class="headerlink" title="全球变暖"></a>全球变暖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">标题：全球变暖</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【题目描述】</span><br><span class="line">你有一张某海域NxN像素的照片，&quot;.&quot;表示海洋、&quot;#&quot;表示陆地，如下所示：</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">.##....</span><br><span class="line">.##....</span><br><span class="line">....##.</span><br><span class="line">..####.</span><br><span class="line">...###.</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">其中&quot;上下左右&quot;四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。  </span><br><span class="line"></span><br><span class="line">由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。  </span><br><span class="line"></span><br><span class="line">例如上图中的海域未来会变成如下样子：</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">....#..</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。  </span><br><span class="line"></span><br><span class="line">【输入格式】</span><br><span class="line">第一行包含一个整数N。  (1 &lt;&#x3D; N &lt;&#x3D; 1000)  </span><br><span class="line">以下N行N列代表一张海域照片。  </span><br><span class="line"></span><br><span class="line">照片保证第1行、第1列、第N行、第N列的像素都是海洋。  </span><br><span class="line"></span><br><span class="line">【输出格式】</span><br><span class="line">一个整数表示答案。</span><br><span class="line"></span><br><span class="line">【样例输入】</span><br><span class="line">7 </span><br><span class="line">.......</span><br><span class="line">.##....</span><br><span class="line">.##....</span><br><span class="line">....##.</span><br><span class="line">..####.</span><br><span class="line">...###.</span><br><span class="line">.......  </span><br><span class="line"></span><br><span class="line">【样例输出】</span><br><span class="line">1  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">资源约定：</span><br><span class="line">峰值内存消耗（含虚拟机） &lt; 256M</span><br><span class="line">CPU消耗  &lt; 1000ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">main函数需要返回0;</span><br><span class="line">只使用ANSI C&#x2F;ANSI C++ 标准;</span><br><span class="line">不要调用依赖于编译环境或操作系统的特殊函数。</span><br><span class="line">所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;</span><br><span class="line">不能通过工程设置而省略常用头文件。</span><br><span class="line"></span><br><span class="line">提交程序时，注意选择所期望的语言类型和编译器类型。</span><br></pre></td></tr></table></figure>

<ol>
<li>先dfs染色问题进行编号</li>
<li>再逐一check，并标记消失的岛屿部分，更新每个标号的id对应的数组里岛屿的piece数量</li>
<li>最后统计cnt数组看看哪些全部消失了</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> board[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">1005</span>][<span class="number">1005</span>]; <span class="comment">// flag为-1证明该位置消失</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> numOfPart[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i + dx[k];</span><br><span class="line">        <span class="keyword">int</span> y = j + dy[k];</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || board[x][y] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="comment">// 边缘和临海的岛屿都将消失</span></span><br><span class="line">            flag[i][j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floodFill</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    board[i][j] = id + <span class="string">'0'</span>; <span class="comment">// 岛屿标号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i + dx[k];</span><br><span class="line">        <span class="keyword">int</span> y = j + dy[k];</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            floodFill(x, y, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; board[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                <span class="comment">// 染色，岛屿的每个部分标号</span></span><br><span class="line">                floodFill(i, j, id++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                check(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i][j] == <span class="number">0</span> &amp;&amp; board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果编号有效的岛屿未消失，则该id对应的部分数量+1</span></span><br><span class="line">                numOfPart[board[i][j] - <span class="string">'0'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;board[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; id; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numOfPart[i] == <span class="number">0</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="重要经验"><a href="#重要经验" class="headerlink" title="重要经验"></a>重要经验</h1><ol>
<li>一般问题都能得到复杂度达到$O(N^2)$的时候的暴力解法。优化时可以外层循环枚举，内层用算法进行解决（二分、哈希表、滑窗等）。</li>
<li>将每个子串中有多少个这种问题转换成每个位置对最后整体的answer产生的贡献有多少。</li>
</ol>
<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">MAX</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line">    ll c = b;</span><br><span class="line">    <span class="keyword">while</span> (a % b != <span class="number">0</span>) &#123;</span><br><span class="line">        c = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">MIN</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 求最小公倍数</span></span><br><span class="line">    <span class="keyword">return</span> a * b / MAX(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="图论复习"><a href="#图论复习" class="headerlink" title="图论复习"></a>图论复习</h1><h2 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a><a href="https://leetcode-cn.com/problems/network-delay-time/" target="_blank" rel="noopener">743. 网络延迟时间</a></h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dis;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; e;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        dis.assign(n + <span class="number">1</span>, INT_MAX);</span><br><span class="line">        e.assign(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n + <span class="number">1</span>, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = times[i][<span class="number">0</span>], v = times[i][<span class="number">1</span>], t = times[i][<span class="number">2</span>];</span><br><span class="line">            e[u][v] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(k);</span><br><span class="line">        dis[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; <span class="built_in">size</span>; ++cnt) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> nex = <span class="number">1</span>; nex &lt;= n; ++nex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e[cur][nex] != INT_MAX &amp;&amp; dis[nex] &gt; dis[cur] + e[cur][nex]) &#123;</span><br><span class="line">                        dis[nex] = dis[cur] + e[cur][nex];</span><br><span class="line">                        q.push(nex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dis[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt; vector&lt; pair&lt;int, int&gt; &gt; &gt; graph;</span><br><span class="line">    vector&lt;int&gt; dis;</span><br><span class="line">    void dfs(int start) &#123;</span><br><span class="line">        <span class="keyword">for</span> (const auto &amp;tmp : graph[start]) &#123;</span><br><span class="line">            int nex = tmp.first, t = tmp.second;</span><br><span class="line">            <span class="keyword">if</span> (dis[nex] &gt; dis[start] + t) &#123;</span><br><span class="line">                dis[nex] = dis[start] + t;</span><br><span class="line">                dfs(nex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) &#123;</span><br><span class="line">        graph.resize(n + <span class="number">1</span>);</span><br><span class="line">        dis.assign(n + <span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">        <span class="keyword">for</span> (const auto &amp;t : times) graph[t[<span class="number">0</span>]].push_back(make_pair(t[<span class="number">1</span>], t[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        dis[k] = <span class="number">0</span>;</span><br><span class="line">        dfs(k);</span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] == <span class="number">101</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            ans = max(ans, dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; graph;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ismin;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxWeight = INT_MAX;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        graph.resize(n + <span class="number">1</span>);</span><br><span class="line">        ismin.resize(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        dis.assign(n + <span class="number">1</span>, INT_MAX);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;t : times) graph[t[<span class="number">0</span>]].push_back(make_pair(t[<span class="number">1</span>], t[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        dis[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minDis = maxWeight, idx = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ismin[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; minDis) &#123;</span><br><span class="line">                    idx = j;</span><br><span class="line">                    minDis = dis[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minDis == maxWeight) <span class="keyword">break</span>;</span><br><span class="line">            ismin[idx] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : graph[idx]) &#123;</span><br><span class="line">                <span class="keyword">int</span> nex = e.first, t = e.second;</span><br><span class="line">                <span class="keyword">if</span> (ismin[nex] == <span class="number">0</span> &amp;&amp; dis[idx] + t &lt; dis[nex]) &#123;</span><br><span class="line">                    dis[nex] = dis[idx] + t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>应试</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶算法笔记</title>
    <url>/2020/08/05/%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>​    主要包括数据结构和算法课中没有提及到的结构和算法。</p>
<a id="more"></a>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><p>​    <strong>字符串hash是指将一个字符串S映射为一个整数，使得该整数可以尽可能唯一地代表S</strong>。如果转换的整数相同，则代表的S也相同。</p>
<p>​    下面为hash值的递推公式，其中$str[i]$表示字符串的第$i$位，<code>index</code>函数将A-Z分别转换为数值0-25，$H[i]$表示字符串的前$i$个字符串的hash值。</p>
<p>$$H[i] = H[i - 1] * 26 + index(str[i])$$</p>
<p>​    以上公式，虽然字符串与整数是一一对应的，但由于没有适当处理，因此当长度较长，产生的整数过大，没法保存。为了应对，放弃“唯一性”，进行取模运算。</p>
<p>$$H[i] = (H[i - 1] * 26 + index(str[i])) % mod$$</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><a href="https://www.cnblogs.com/miachel-zheng/p/6965172.html" target="_blank" rel="noopener">可参考blog</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/108982607" target="_blank" rel="noopener">可参考解释</a></p>
<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>求主串中与模式串匹配的字符串的首次匹配位置。</p>
<h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute-force"></a>brute-force</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n1 = s.length(), i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> n2 = t.length(), j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i -= (j - <span class="number">1</span>);</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    i - j &gt;  n2 - n1时匹配失败</span></span><br><span class="line"><span class="comment">    i - j &lt;= n2 - n1时匹配成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kmp算法思想"><a href="#kmp算法思想" class="headerlink" title="kmp算法思想"></a>kmp算法思想</h3><p>利用好每次匹配中的信息，使得$i$的后移更加“快速”。减少每次重复冗余的匹配，使得$i$每次能向后移动最大的距离。</p>
<p>设立next数组，next[i]的值表达的意义为<strong>[0,i)位置中的最长相等前后缀长度</strong>。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*求解next数组*/</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buildNext</span><span class="params">(<span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = T.length(), j = <span class="number">0</span>; <span class="comment">// "主"串指针</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">-1</span>; <span class="comment">// 模式串指针</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span> || T[j] == T[t]) &#123;</span><br><span class="line">            <span class="comment">/*如果碰到了哨兵或是正确匹配*/</span></span><br><span class="line">            ++t; ++j;</span><br><span class="line">            next[j] = (T[j] == T[t]) ? next[t] : t; <span class="comment">// 防止以卵击石的"幼稚"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = next[t]; <span class="comment">// 赋值为next(相当于移动模式串)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;   	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*kmp主算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = buildNext(T);</span><br><span class="line">    <span class="keyword">int</span> n1 = S.length(), i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = T.length(), j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span> || S[i] == T[j]) &#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>brute-force —-$O(n1 * n2)$ –&gt;实际情况下$\approx O(n1 + n2)$</p>
<p>kmp —-$O(n1 + n2)$ —-最差$O(2 * n1 + 2 * n2)$</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口的本质是一个双指针，它并不局限于字符串类问题，主要用于解<strong>最优解问题</strong>。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>设置<code>l = 0</code>和<code>r = 0</code>两个指针，<code>[l, r]</code>的区间看作一个窗口。</li>
<li>通过<code>++r</code>逐步将指针右移，查看是否有匹配原题的答案（例如字符串匹配，或者是加和相等），直到有匹配的答案时停止右移。</li>
<li>然后通过<code>++l</code>的方式缩短区间<code>[l, r]</code>，直到该区间内的答案不再匹配。更新当前的<code>ans</code>（可以是窗口大小）</li>
<li>重复2、3步，直到<code>l == n - 1</code>，此时的<code>ans</code>即为结果。</li>
</ol>
<p>本质上来看，第2步在<strong>寻找可行解</strong>，第三步在<strong>优化可行解</strong>。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">长度最小的子数组</a></p>
<hr>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p><a href="https://blog.csdn.net/qq_39553725/article/details/76696168" target="_blank" rel="noopener">树状数组应用汇总</a></p>
<h3 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h3><p><code>lowbit(x)</code>返回<strong>能整除x的最大2的幂次</strong>(转换为二进制后，右侧第一个1和右边所有的0)。</p>
<h3 id="BIT"><a href="#BIT" class="headerlink" title="BIT"></a>BIT</h3><p>定义：树状数组（Binary Indexed Tree）依然是一个数组，并且与sum数组相似，是一个用来记录和的数组，只不过它存放的不是前$i$个整数之和，而是在<strong>$i$号位之前（含$i$）$lowbit(i)$个整数之和</strong>。</p>
<p><img src="https://img2018.cnblogs.com/blog/1727888/201907/1727888-20190715193025175-355675081.png" alt="树状数组图"></p>
<h4 id="设计函数getSum-x"><a href="#设计函数getSum-x" class="headerlink" title="设计函数getSum(x)"></a>设计函数<code>getSum(x)</code></h4><p>功能：返回前x个数之和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C[x] &#x3D; A[x - lowbit(x) + 1] + ...A[x] </span><br><span class="line">SUM(1,x) &#x3D; A[1] + ... A[x]</span><br><span class="line">         &#x3D; A[1] + ... A[x - lowbit(x)] + A[x - lowbit(x) + 1] + ... + A[x]</span><br><span class="line">         &#x3D; SUM(1, x - lowbit(x)) + C[x]</span><br></pre></td></tr></table></figure>

<p>依据上述推导过程写出<code>getSum</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 时间复杂度O(logn)</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样下来，<strong>求解[x,y]区间和的问题转换为求 <code>getSum(y) - getSum(x - 1)</code></strong>。</p>
<h4 id="设计函数update-x-v"><a href="#设计函数update-x-v" class="headerlink" title="设计函数update(x, v)"></a>设计函数<code>update(x, v)</code></h4><p>功能：实现将第x个数加上一个数v的功能，即<code>A[x] += v</code></p>
<p>与getSum函数相对应的，以对A[6]加上v为例，需要寻找树状数组C中覆盖了A[6]的元素，将其加上v。也就是对C[6]、C[8]、C[16]分别加上v。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// 时间复杂度O(logn)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">        c[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>​    给定一个有N个正整数的序列A(N &lt;= 1e5, A[i] &lt;= 1e5)，对序列中每一个数，求出序列中左边比它小的数的个数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i) &amp; (-i))</span></span><br><span class="line"><span class="keyword">int</span> c[maxn]; <span class="comment">// 树状数组，存储每个数的出现次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; maxn; i += lowbit(i)) &#123;</span><br><span class="line">        c[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="comment">// 输入序列元素</span></span><br><span class="line">        update(x, <span class="number">1</span>); <span class="comment">// x的出现次数加1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getSum(x - <span class="number">1</span>)); <span class="comment">// 输出当前小于x的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拓展（离散化）"><a href="#拓展（离散化）" class="headerlink" title="拓展（离散化）"></a>拓展（离散化）</h3><p>假设：A[i] &lt;= N这个条件不成立。那数组不能开的太大了。</p>
<p>应对类似情况需要将<code>[520, 9999999999, 18, 666, 88888]</code>转换成类似于<code>[2,5,1,3,4]</code>这样的等价序列。一般来说，设置一个临时的结构体数组，用以存放输入的序列元素的值以及原始序号，而在输入完毕后将数组按val大小从小到大进行排序，排序后再按照计算排名的方式将排名根据原始序号pos存入一个新的数组。这个过程称为<strong>离散化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i) &amp; (-i))</span></span><br><span class="line"><span class="keyword">int</span> c[maxn]; <span class="comment">// 树状数组，存储每个数的出现次数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Node &#123;</span></span><br><span class="line"><span class="comment">    int val; // 元素值</span></span><br><span class="line"><span class="comment">    int pos; // 原始序号</span></span><br><span class="line"><span class="comment">&#125; temp[maxn];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt; pair&lt;int, int&gt; &gt; temp(maxn); // &#123;元素值，原始序号&#125;</span><br><span class="line"><span class="keyword">int</span> A[maxn]; <span class="comment">// 离散化后的原始数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; maxn; i += lowbit(i)) &#123;</span><br><span class="line">        c[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp[i].first); <span class="comment">// 输入序列元素</span></span><br><span class="line">        temp[i].second = i; <span class="comment">// 原始序号</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 离散化</span></span><br><span class="line">    sort(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 与前一个元素不同，赋值为元素个数</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || temp[i].first != temp[i - <span class="number">1</span>].first) &#123;</span><br><span class="line">            A[temp[i].second] = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，直接继承</span></span><br><span class="line">            A[temp[i].second] = A[temp[i - <span class="number">1</span>].second];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 离散化后，每个位存储的是前方比它大的元素的个数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新求和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        update(A[i], <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getSum(A[i] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>V -&gt; A 的过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V [520, 9999999999, 18, 666, 88888]</span><br><span class="line">temp [&#123;520,0&#125;, &#123;9999999999,1&#125;, &#123;18,2&#125;, &#123;666,3&#125;, &#123;88888,4&#125;] ---排序前</span><br><span class="line">temp [&#123;18,2&#125;, &#123;520,0&#125;, &#123;666,3&#125;, &#123;88888,4&#125;, &#123;9999999999,1&#125;] ---排序后</span><br><span class="line">A [2,5,1,3,4]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(nlogn)$</p>
<p>空间复杂度：$O(n)$</p>
<h4 id="计算右侧小于当前元素个数"><a href="#计算右侧小于当前元素个数" class="headerlink" title="计算右侧小于当前元素个数"></a>计算右侧小于当前元素个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c; <span class="comment">// 树状数组c</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A; <span class="comment">// 离散化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; temp; <span class="comment">// &#123;元素值，原始序号&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//#define lowbit(i) ((i) &amp; (-i))</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i) &amp; (-i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">            c[i] += v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 获取x的前i项和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">            sum += c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        c.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        A.assign(n, <span class="number">0</span>);</span><br><span class="line">        temp.resize(n);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            temp[i].first = nums[i];</span><br><span class="line">            temp[i].second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 离散化</span></span><br><span class="line">        sort(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 与前一个元素不同，赋值为元素个数</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || temp[i].first != temp[i - <span class="number">1</span>].first) &#123;</span><br><span class="line">                A[temp[i].second] = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，直接继承</span></span><br><span class="line">                A[temp[i].second] = A[temp[i - <span class="number">1</span>].second];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            update(A[i], <span class="number">1</span>);</span><br><span class="line">            ans[i] = getSum(A[i] - <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​    又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常<strong>被搜索引擎系统用于文本词频统计</strong>。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<p><img src="https://pic.leetcode-cn.com/e3c98484881bd654daa8419bcb0791a2b6f8288b58ef50df70ddaeefc4084f48-file_1575215107950" alt="来自算法4"></p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="抽象结构"><a href="#抽象结构" class="headerlink" title="抽象结构"></a>抽象结构</h4><p>例如以下的trie树，存储了一组字符串<code>[&quot;cat&quot;, &quot;can&quot;, &quot;cs&quot;, &quot;cstring&quot;]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    r</span><br><span class="line">    |</span><br><span class="line">    c</span><br><span class="line">   &#x2F; \</span><br><span class="line">  a   s*</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">t*  n*  t</span><br><span class="line">         \</span><br><span class="line">          r</span><br><span class="line">           \</span><br><span class="line">            i</span><br><span class="line">             \</span><br><span class="line">              n</span><br><span class="line">               \</span><br><span class="line">                g*</span><br></pre></td></tr></table></figure>

<h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p>法1 ：空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    trieNode** son; <span class="comment">// 二维指针指向一个trieNode指针数组</span></span><br><span class="line">    <span class="keyword">int</span> cnt; <span class="comment">// 标记</span></span><br><span class="line">    trieNode(<span class="keyword">char</span> c) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">        val = c;</span><br><span class="line">        son = <span class="keyword">new</span> trieNode*[<span class="number">26</span>];</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            son[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或参考例题中的写法</span></span><br></pre></td></tr></table></figure>

<p>法2：数组模拟空间</p>
<p>开辟一个二维数组<code>tree[m][26]</code>。</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>root(0,25)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[…’c’:1…]</td>
<td>[‘a’:2…’s’:2…]</td>
<td>[…’n’:3…’t’:3…]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    trieNode* p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;son[c])	p-&gt;son[c] = <span class="keyword">new</span> trieNode(c);</span><br><span class="line">        p = p-&gt;son[c];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    trieNode* p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;son[c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = p-&gt;son[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h3><p>给定一组 <strong>互不相同</strong> 的单词， 找出所有<strong>不同</strong> 的索引对<code>(i, j)</code>，使得列表中的两个单词， <code>words[i] + words[j]</code> ，可拼接成回文串。</p>
<p>实现：数组模拟空间结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ch[<span class="number">26</span>]; <span class="comment">// 节点存储的字母</span></span><br><span class="line">        <span class="keyword">int</span> flag; <span class="comment">// 标记字符串结束节点</span></span><br><span class="line">        node() &#123; <span class="comment">// node的初始化</span></span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; tree; <span class="comment">// 建立字典树</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 遍历字符串</span></span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'a'</span>; <span class="comment">// 获取字母</span></span><br><span class="line">            <span class="keyword">if</span> (!tree[add].ch[x]) &#123; <span class="comment">// 如果树中不存在这样的节点</span></span><br><span class="line">                tree.emplace_back(); <span class="comment">// 给树添加新的节点</span></span><br><span class="line">                tree[add].ch[x] = tree.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 前驱节点指向下一个节点(此处用数组的结构表示)</span></span><br><span class="line">            &#125;</span><br><span class="line">            add = tree[add].ch[x]; <span class="comment">// 指向下一个节点，继续向后添加</span></span><br><span class="line">        &#125;</span><br><span class="line">        tree[add].flag = id; <span class="comment">// 遍历完字符串，将尾字符做标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findWord</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; i--) &#123; <span class="comment">// 倒序遍历指定区间的字符串</span></span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'a'</span>; <span class="comment">// 获取字母</span></span><br><span class="line">            <span class="keyword">if</span> (!tree[add].ch[x]) &#123; <span class="comment">// 如果不存在，返回-1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            add = tree[add].ch[x]; <span class="comment">// 否则继续向下遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree[add].flag; <span class="comment">// 返回是否尾结点有标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; <span class="comment">// 左右指针逼近遍历判断是否是回文串</span></span><br><span class="line">        <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left + i] != s[right - i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">palindromePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造字典树</span></span><br><span class="line">        tree.emplace_back(node());</span><br><span class="line">        <span class="keyword">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            insert(words[i], i); <span class="comment">// 单词在words中的序号即为其id</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断回文对</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 遍历words容器</span></span><br><span class="line">            <span class="keyword">int</span> m = words[i].<span class="built_in">size</span>(); <span class="comment">// 获取当前遍历元素的长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123; <span class="comment">// 遍历该单词</span></span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(words[i], j, m - <span class="number">1</span>)) &#123; <span class="comment">// 如果(j:m-1)的部分是回文串</span></span><br><span class="line">                    <span class="comment">// 先用left_id保存(0:j-1)区间字符串是否在字典树中的返回值</span></span><br><span class="line">                    <span class="keyword">int</span> left_id = findWord(words[i], <span class="number">0</span>, j - <span class="number">1</span>); </span><br><span class="line">                    <span class="keyword">if</span> (left_id != <span class="number">-1</span> &amp;&amp; left_id != i) &#123; <span class="comment">// 如果找得到这样的字符串，且该字符串不是本身</span></span><br><span class="line">                        ret.push_back(&#123;i, left_id&#125;); <span class="comment">// 则证明(i, j)是一个合法的二元组</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &amp;&amp; isPalindrome(words[i], <span class="number">0</span>, j - <span class="number">1</span>)) &#123; <span class="comment">// 由于上界是j-1，应该保持j合法</span></span><br><span class="line">                    <span class="keyword">int</span> right_id = findWord(words[i], j, m - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (right_id != <span class="number">-1</span> &amp;&amp; right_id != i) &#123;</span><br><span class="line">                        ret.push_back(&#123;right_id, i&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><p><a href="https://leetcode-cn.com/problems/re-space-lcci/" target="_blank" rel="noopener">恢复空格</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    Trie* son[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span>(son));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">// 倒序插入</span></span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;son[x]) node-&gt;son[x] = <span class="keyword">new</span> Trie();</span><br><span class="line">            node = node-&gt;son[x];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;flag++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dictionary, <span class="built_in">string</span> sentence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = dictionary.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len = sentence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n || !len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Trie* tree = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            tree-&gt;insert(dictionary[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>, INT_MAX)</span></span>; <span class="comment">// dp[i]代表前i个字符中未识别的个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// 出现次数默认为前一个+1</span></span><br><span class="line">            Trie* cur = tree;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; --j) &#123; <span class="comment">// 从第i位开始向前匹配单词</span></span><br><span class="line">                <span class="keyword">int</span> c = sentence[j - <span class="number">1</span>] - <span class="string">'a'</span>; <span class="comment">// 获取字母</span></span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;son[c]) &#123; <span class="comment">// 如果未识别到</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果识别到该单词了，则i位置的dp应取为识别该单词和不识别该单词中的最小值</span></span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;son[c]-&gt;flag) dp[i] = <span class="built_in">min</span>(dp[i], dp[j - <span class="number">1</span>]); </span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;son[c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他应用：寻找某字符串在另一个字符串数组中的前缀出现次数。</p>
<h2 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h2><p>与三种经典DFS的时间相同，却只消耗常数级别的空间。</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ol>
<li>如果当前节点的左孩子为空，则输出当前节点</li>
</ol>
<h1 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h1><h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><p><strong>将状态压缩成二进制进行保存。</strong></p>
<h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p>旅行商问题，acwing第91题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span> &lt;&lt; <span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; weight[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp); <span class="comment">// 0x3f代表无穷大初始化</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sta = <span class="number">1</span>; sta &lt; (<span class="number">1</span> &lt;&lt; n); ++sta) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sta &amp; (<span class="number">1</span> &lt;&lt; i)) &#123; <span class="comment">// 遍历到第i个点，第i点状态为1时，枚举j为上一个到达的点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sta &amp; (<span class="number">1</span> &lt;&lt; j)) <span class="comment">// 第j个点状态为1</span></span><br><span class="line">                        dp[sta][i] = <span class="built_in">min</span>(dp[sta][i], dp[sta ^ (<span class="number">1</span> &lt;&lt; i)][j] + weight[j][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>]; <span class="comment">// 终点为19且所有地方均走过一遍的最短距离</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="前缀和思想"><a href="#前缀和思想" class="headerlink" title="前缀和思想"></a>前缀和思想</h2><h3 id="两要素"><a href="#两要素" class="headerlink" title="两要素"></a>两要素</h3><ol>
<li>pre或pre[i]存储前缀和</li>
<li>hash表保存 个数/前缀和出现下标 等信息。(hash表的初值很重要)</li>
</ol>
<h3 id="例1-和为K的子数组"><a href="#例1-和为K的子数组" class="headerlink" title="例1 和为K的子数组"></a>例1 和为K的子数组</h3><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>hash表用来存储遍历到当前获取的合法子数组数目。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// pre : cnt</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>; <span class="comment">// 前n项的和</span></span><br><span class="line">        <span class="comment">// (j:i)中pre[j - 1]个数 == pre[i] - target个数</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pre += nums[i]; <span class="comment">// 前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(pre - target) != m.<span class="built_in">end</span>()) <span class="comment">// 如果前侧有</span></span><br><span class="line">                ans += m[pre - target];</span><br><span class="line">            m[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="例2-和为目标值的最大数目不重叠非空子数组数目"><a href="#例2-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="例2 和为目标值的最大数目不重叠非空子数组数目"></a>例2 和为目标值的最大数目不重叠非空子数组数目</h3><p>请你返回 <strong>非空不重叠</strong> 子数组的最大数目，且每个子数组中数字和都为 <code>target</code> 。</p>
<h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><p>hash表用来存储遍历到当前$i$，满足$target$的下标$j$出现的最新位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">-1</span>; <span class="comment">// pre表示前缀和，end表示已经保存的子数组中的最大下标</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pre_idx; <span class="comment">// pre:idx</span></span><br><span class="line">        pre_idx[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 访问到pre刚好为target时，此时的pre_idx == 0为错误值，应为下标-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            pre += nums[i - <span class="number">1</span>]; <span class="comment">// 求得前缀和</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 寻找[j, i]区间内和满足要求的最近的j(pre[i] - pre[j] = target)</span></span><br><span class="line">            <span class="keyword">if</span> (pre_idx.<span class="built_in">find</span>(pre - target) != pre_idx.<span class="built_in">end</span>()) &#123; <span class="comment">/// 如果这样的前缀存在</span></span><br><span class="line">                <span class="keyword">int</span> j = pre_idx[pre - target]; <span class="comment">// 获取区间上界j</span></span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &gt; <span class="built_in">end</span>) &#123; <span class="comment">// 如果j在end之后</span></span><br><span class="line">                    ++ans;</span><br><span class="line">                    <span class="built_in">end</span> = i - <span class="number">1</span>; <span class="comment">// 将当前已纳入结果中的子数组的最大下标更新为end</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre_idx[pre] = i - <span class="number">1</span>; <span class="comment">// 更新前缀和出现的下标 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><a href="https://blog.csdn.net/morewindows/article/details/7354571" target="_blank" rel="noopener">参考原文</a></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>位运算其实就是直接对内存中的二进制数据进行操作</strong>，因此速度非常快。</p>
<h3 id="基础位操作符"><a href="#基础位操作符" class="headerlink" title="基础位操作符"></a>基础位操作符</h3><table>
<thead>
<tr>
<th>符号</th>
<th align="left">描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td align="left">与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr>
<td>`</td>
<td align="left">`</td>
<td>或</td>
</tr>
<tr>
<td><code>^</code></td>
<td align="left">异或</td>
<td>两个位相同为0，相异为1</td>
</tr>
<tr>
<td><code>~</code></td>
<td align="left">取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td align="left">左移</td>
<td>各二进位全部左移若干位，<strong>高位丢弃，低位补0</strong></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td align="left">右移</td>
<td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>只有<code>~</code>是单目运算符</li>
<li>位操作只作用于int</li>
<li>VC6.0和VS2008的编译器会将<code>&gt;&gt;</code>按算术右移处理</li>
<li>位运算符的运算级比较低</li>
<li>除以上还有复合操作符，<code>&amp;=</code>、<code>|=</code>、 <code>^=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>。</li>
</ul>
<h3 id="常用位操作"><a href="#常用位操作" class="headerlink" title="常用位操作"></a>常用位操作</h3><h4 id="简单运算"><a href="#简单运算" class="headerlink" title="简单运算"></a>简单运算</h4><table>
<thead>
<tr>
<th>操作</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>原数除以2</td>
<td><code>i &gt;&gt; 1</code></td>
</tr>
<tr>
<td>取原数符号位</td>
<td><code>i &gt;&gt; 31</code></td>
</tr>
<tr>
<td>获取奇偶性(1奇0偶)</td>
<td><code>i &amp; 1</code></td>
</tr>
<tr>
<td>将第k - 1位，置为1</td>
<td><code>i &amp; (1 &lt;&lt; k)</code></td>
</tr>
<tr>
<td>二进制取反</td>
<td><code>i ^ -1</code></td>
</tr>
<tr>
<td>返回二进制数最低位1的权值(计算lowbit(i))</td>
<td><code>i &amp; (-i)</code></td>
</tr>
<tr>
<td>判断是否是2的幂</td>
<td><code>i &amp; (i - 1) == 0 &amp;&amp; n &gt; 0</code></td>
</tr>
<tr>
<td>不断删除最低位的1</td>
<td><code>i &amp;= (i - 1)</code></td>
</tr>
<tr>
<td>判断二进制数中是否有相邻的1</td>
<td>`i &amp; (i &lt;&lt; 1)</td>
</tr>
<tr>
<td>将数组转成二进制数([1,0,0] -&gt; 100)</td>
<td>`for (..) state = (a[i] == 0) ? state &lt;&lt; 1</td>
</tr>
</tbody></table>
<h4 id="交换两数"><a href="#交换两数" class="headerlink" title="交换两数"></a>交换两数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="逆转符号"><a href="#逆转符号" class="headerlink" title="逆转符号"></a>逆转符号</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">signRev</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据逆转符号的原理设计的绝对值函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = (a &gt;&gt; <span class="number">31</span>); <span class="comment">// 通过移位求得符号位(int为32位)i为0/-1</span></span><br><span class="line">    <span class="keyword">return</span> i == <span class="number">0</span> ? a : (~a + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = (a &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="comment">// 与0异或保持不变，与-1异或相当于取反</span></span><br><span class="line">    <span class="keyword">return</span> ((a ^ i) - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="位操作与空间压缩"><a href="#位操作与空间压缩" class="headerlink" title="位操作与空间压缩"></a>位操作与空间压缩</h3><h4 id="二进制逆序"><a href="#二进制逆序" class="headerlink" title="二进制逆序"></a>二进制逆序</h4>]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目cJson</title>
    <url>/2020/09/07/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEcJson/</url>
    <content><![CDATA[<p>cJson是一个可以自动整理Json格式文件的脚本。</p>
<p><a href="https://sourceforge.net/projects/cjson/" target="_blank" rel="noopener">项目地址</a></p>
<a id="more"></a>

<h1 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h1><ul>
<li>cJSON.c</li>
<li>cJSON.h</li>
<li>test.c</li>
</ul>
<h1 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h1><h2 id="cJSON-h"><a href="#cJSON-h" class="headerlink" title="cJSON.h"></a>cJSON.h</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>定义了9个宏，表示JSON格式中的全部7个数据类型加上两个额外项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_False 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_True 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_NULL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_Number 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_String 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_Array 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_Object 6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_IsReference 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_StringIsConst 512</span></span><br></pre></td></tr></table></figure>

<p><img src="http://img.blog.csdn.net/20161119144432000" alt="数据类型示意图"></p>
<h3 id="数据结构和其构造函数"><a href="#数据结构和其构造函数" class="headerlink" title="数据结构和其构造函数"></a>数据结构和其构造函数</h3><p>声明了JSON格式的数据结构。</p>
<ul>
<li>对于array，item-&gt;child是其本体，其中以双向链表的形式存储各个链表节点（array中的元素）</li>
<li>对于object，item-&gt;child是其存储的第一级元素（即第一个逗号前的元素）。以下类推，每个键值对可由child向下递推，其中的键是item-&gt;string。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*cJSON格式的数据结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> type; <span class="comment">// 对应上面的宏定义，即数据类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *valuestring;</span><br><span class="line">    <span class="keyword">int</span> valueint;</span><br><span class="line">    <span class="keyword">double</span> valuedouble;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">string</span>; <span class="comment">// 对象的名称字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON_Hooks</span> &#123;</span></span><br><span class="line">	<span class="comment">/*malloc_fn是一个函数指针，它所指向的函数有一个size_t类型的参数，返回一个void类型的指针*/</span></span><br><span class="line">    <span class="keyword">void</span> *(*malloc_fn)(<span class="keyword">size_t</span> sz);</span><br><span class="line">    <span class="comment">/*free_fn是一个函数指针，它所指向的函数具有一个void*类型的指针参数，无返回值*/</span></span><br><span class="line">    <span class="keyword">void</span> (*free_fn)(<span class="keyword">void</span> *ptr);</span><br><span class="line">&#125; cJSON_Hooks;</span><br></pre></td></tr></table></figure>

<p>将以上代码段与cJSON.c文件中的内容结合来看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在全局声明了两个静态函数指针，分别把json_malloc和json_free指向malloc和free函数*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *(*json_malloc)(<span class="keyword">size_t</span> sz) = <span class="built_in">malloc</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*json_free)</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>= <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">json_init_hooks</span><span class="params">(json_hooks *hooks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hooks)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 如果hook未声明，就对两个函数指针重置</span></span><br><span class="line">        json_malloc = <span class="built_in">malloc</span>;</span><br><span class="line">        json_free = <span class="built_in">free</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果已声明</span></span><br><span class="line">    json_malloc = (hooks-&gt;malloc_fn)?hooks-&gt;malloc_fn:<span class="built_in">malloc</span>;</span><br><span class="line">    json_free = (hooks-&gt;free_fn)?hooks-&gt;free_fn:<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的hook整体来看是提供了一个接口，允许开发者自定义一组<code>malloc</code>和<code>free</code>函数，如果开发者未定义，默认采用stdlib.h头文件中的<code>malloc</code>和<code>free</code>。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><h4 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_Parse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *value)</span></span>; <span class="comment">// 返回一个可读的JSON对象，完成时调用cJSON_Delete</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">char</span> *<span class="title">cJSON_Print</span><span class="params">(cJSON *item)</span></span>; <span class="comment">// 将cJSON输出，完成时释放char*</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">char</span> *<span class="title">cJSON_PrintUnformatted</span><span class="params">(cJSON *item)</span></span>; <span class="comment">// 输出没有经过整理的对象，完成时释放char*</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">char</span> *<span class="title">cJSON_PrintBuffered</span><span class="params">(cJSON *item, <span class="keyword">int</span> prebuffer, <span class="keyword">int</span> fmt)</span></span>; <span class="comment">// 使用缓冲策略将cJSON实体呈现给文本。预缓冲是对最终大小的猜测。猜测得好可以减少重新分配。fmt=0表示未格式化，=1表示格式化</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">cJSON_Delete</span><span class="params">(cJSON *c)</span></span>; <span class="comment">// 删除一个cJSON实体和其子体</span></span><br></pre></td></tr></table></figure>

<h4 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">cJSON_GetArraySize</span><span class="params">(cJSON *<span class="built_in">array</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_GetArrayItem</span><span class="params">(cJSON *<span class="built_in">array</span>, <span class="keyword">int</span> item)</span></span>; <span class="comment">// 取出数组中的元素，如果不成功返回空</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_GetObjectItem</span><span class="params">(cJSON* object, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>; <span class="comment">// 从对象中获取字符串，不区分大小写</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">cJSON_GetErrorItem</span><span class="params">(cJSON *object, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>; <span class="comment">// 对于错误解析，返回一个指向这个错误解析的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*create函数簇*/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateNull</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateTrue</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateFalse</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateBool</span><span class="params">(<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateNumber</span><span class="params">(<span class="keyword">double</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateArray</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateObject</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateIntArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *numbers,<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateFloatArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> *numbers,<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateDoubleArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *numbers,<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_CreateStringArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **strings,<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*add函数簇*/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">cJSON_AddItemToArray</span><span class="params">(cJSON *<span class="built_in">array</span>, cJSON *item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>	<span class="title">cJSON_AddItemToObject</span><span class="params">(cJSON *object,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>,cJSON *item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>	<span class="title">cJSON_AddItemToObjectCS</span><span class="params">(cJSON *object,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>,cJSON *item)</span></span>;	<span class="comment">//当字符串必定是常量(例如，一个文字，或者和常量一样好)，并且肯定能在cJSON对象中保留</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将对项目的引用附加到指定的数组/对象。 当您要将现有的cJSON添加到新的cJSON，但又不想破坏现有的cJSON时，请使用此选项。 */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">cJSON_AddItemReferenceToArray</span><span class="params">(cJSON *<span class="built_in">array</span>, cJSON *item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>	<span class="title">cJSON_AddItemReferenceToObject</span><span class="params">(cJSON *object,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>, cJSON *item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_Duplicate</span><span class="params">(cJSON *item,<span class="keyword">int</span> recurse)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许您要求(并检查)JSON是否以null结尾，并检索到最终解析的字节的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> cJSON *<span class="title">cJSON_ParseWithOpts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *value,<span class="keyword">const</span> <span class="keyword">char</span> **return_parse_end,<span class="keyword">int</span> require_null_terminated)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">cJSON_Minify</span><span class="params">(<span class="keyword">char</span> *json)</span></span>;</span><br></pre></td></tr></table></figure>

<p>过程是调用<code>cJSON_AddItemToObject()</code>并结合不同的对象类型增加节点名称和子节点。然后在其中调用<code>cJSON_AddItemToArray()</code>函数来添加信息，此函数中判断对象孩子结点是否为<code>NULL</code>，如果是<code>NULL</code>，则直接插入，否则找到最后一个孩子，调用<code>suffix_object()</code>函数添加到双向链表的尾部。</p>
<h3 id="宏声明"><a href="#宏声明" class="headerlink" title="宏声明"></a>宏声明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创造对象直接用添加函数来替代，提高效率*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_AddNullToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateNull())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_AddTrueToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateTrue())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_AddFalseToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateFalse())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_AddBoolToObject(object,name,b)	cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_AddNumberToObject(object,name,n)	cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_AddStringToObject(object,name,s)	cJSON_AddItemToObject(object, name, cJSON_CreateString(s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创造整数数据时，也要将其拷贝到valdouble上*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_SetIntValue(object,val)			((object)?(object)-&gt;valueint=(object)-&gt;valuedouble=(val):(val))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_SetNumberValue(object,val)		((object)?(object)-&gt;valueint=(object)-&gt;valuedouble=(val):(val))</span></span><br></pre></td></tr></table></figure>



<h2 id="cJSON-c"><a href="#cJSON-c" class="headerlink" title="cJSON.c"></a>cJSON.c</h2><h3 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h3><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">cJSON *<span class="title">cJSON_Parse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cJSON_ParseWithOpts(value, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_ParseWithOpts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">const</span> <span class="keyword">char</span> **return_parse_end, <span class="keyword">int</span> require_null_terminated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">    cJSON *c = cJSON_New_Item();</span><br><span class="line">    ep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">end</span> = parse_value(c, skip(value));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">end</span>) &#123;</span><br><span class="line">        cJSON_Delete(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (require_null_terminated) &#123;</span><br><span class="line">        <span class="built_in">end</span> = skip(<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span> (*<span class="built_in">end</span>) &#123;</span><br><span class="line">            cJSON_Delete(c);</span><br><span class="line">            ep = <span class="built_in">end</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (return_parse_end) *return_parse_end = <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析字符串value，并将其填充到item对象中*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">parse_value</span><span class="params">(cJSON *item, <span class="keyword">const</span> <span class="keyword">char</span> *value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!value)						<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strncmp</span>(value,<span class="string">"null"</span>,<span class="number">4</span>))	&#123; item-&gt;type = cJSON_NULL;  <span class="keyword">return</span> value + <span class="number">4</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strncmp</span>(value,<span class="string">"false"</span>,<span class="number">5</span>))	&#123; item-&gt;type = cJSON_False; <span class="keyword">return</span> value + <span class="number">5</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strncmp</span>(value,<span class="string">"true"</span>,<span class="number">4</span>))	&#123; item-&gt;type = cJSON_True; item-&gt;valueint = <span class="number">1</span>;	<span class="keyword">return</span> value + <span class="number">4</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> (*value == <span class="string">'\"'</span>)				&#123; <span class="keyword">return</span> parse_string(item,value); &#125;</span><br><span class="line">	<span class="keyword">if</span> (*value == <span class="string">'-'</span> || (*value &gt;= <span class="string">'0'</span> &amp;&amp; *value &lt;= <span class="string">'9'</span>))	&#123; <span class="keyword">return</span> parse_number(item,value); &#125;</span><br><span class="line">	<span class="keyword">if</span> (*value == <span class="string">'['</span>)				&#123; <span class="keyword">return</span> parse_array(item,value); &#125;</span><br><span class="line">	<span class="keyword">if</span> (*value == <span class="string">'&#123;'</span>)				&#123; <span class="keyword">return</span> parse_object(item,value); &#125;</span><br><span class="line"></span><br><span class="line">	ep = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 失败，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意其中的<code>skip()</code>函数（跳过空格等）为自定义的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">skip</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// in != NULL &amp;&amp; *in != \0 &amp;&amp; 不是控制字符</span></span><br><span class="line">    <span class="keyword">while</span> (in &amp;&amp; *in &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">char</span>)*in &lt;= <span class="number">32</span>)</span><br><span class="line">        in++;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分函数"><a href="#分函数" class="headerlink" title="分函数"></a>分函数</h4><h5 id="parse-hex4-函数"><a href="#parse-hex4-函数" class="headerlink" title="parse_hex4()函数"></a><code>parse_hex4()</code>函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 从str开始截取4位十六进制转换成数字返回 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">parse_hex4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str &gt;= <span class="string">'0'</span> &amp;&amp; *str &lt;= <span class="string">'9'</span>) h += (*str) - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'A'</span> &amp;&amp; *str &lt;= <span class="string">'F'</span>) h += <span class="number">10</span> + (*str) - <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'a'</span> &amp;&amp; *str &lt;= <span class="string">'f'</span>) h += <span class="number">10</span> + (*str) - <span class="string">'a'</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    h &lt;&lt;= <span class="number">4</span>; str++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*str &gt;= <span class="string">'0'</span> &amp;&amp; *str &lt;= <span class="string">'9'</span>) h += (*str) - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'A'</span> &amp;&amp; *str &lt;= <span class="string">'F'</span>) h += <span class="number">10</span> + (*str) - <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'a'</span> &amp;&amp; *str &lt;= <span class="string">'f'</span>) h += <span class="number">10</span> + (*str) - <span class="string">'a'</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    h &lt;&lt;= <span class="number">4</span>; str++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*str &gt;= <span class="string">'0'</span> &amp;&amp; *str &lt;= <span class="string">'9'</span>) h += (*str) - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'A'</span> &amp;&amp; *str &lt;= <span class="string">'F'</span>) h += <span class="number">10</span> + (*str) - <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'a'</span> &amp;&amp; *str &lt;= <span class="string">'f'</span>) h += <span class="number">10</span> + (*str) - <span class="string">'a'</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    h &lt;&lt;= <span class="number">4</span>; str++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*str &gt;= <span class="string">'0'</span> &amp;&amp; *str &lt;= <span class="string">'9'</span>) h += (*str) - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'A'</span> &amp;&amp; *str &lt;= <span class="string">'F'</span>) h += <span class="number">10</span> + (*str) - <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'a'</span> &amp;&amp; *str &lt;= <span class="string">'f'</span>) h += <span class="number">10</span> + (*str) - <span class="string">'a'</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="parse-number"><a href="#parse-number" class="headerlink" title="parse_number()"></a><code>parse_number()</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将输入文本解析成数字，并把解析的结果填充到对象中 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">parse_number</span><span class="params">(cJSON *item, <span class="keyword">const</span> <span class="keyword">char</span> *num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sign标记了数字符号</span></span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">0</span>, sign = <span class="number">1</span>, scale = <span class="number">0</span>; <span class="comment">// 底数部分</span></span><br><span class="line">    <span class="keyword">int</span> subscale = <span class="number">0</span>, signsubscale = <span class="number">1</span>; <span class="comment">// 指数部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*num == <span class="string">'-'</span>) sign = <span class="number">-1</span>, num++;</span><br><span class="line">    <span class="keyword">if</span> (*num == <span class="string">'0'</span>) num++;</span><br><span class="line">    <span class="keyword">if</span> (*num &gt;= <span class="string">'1'</span> &amp;&amp; *num &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="comment">// 字符串转数字</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            n = (n * <span class="number">10.0</span>) + (*num++ - <span class="string">'0'</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (*num &gt;= <span class="string">'0'</span> &amp;&amp; *num &lt;= <span class="string">'9'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*num == <span class="string">'e'</span> || *num == <span class="string">'E'</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (*num == <span class="string">'+'</span>) num++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*num == <span class="string">'-'</span>) signsubscale = <span class="number">-1</span>, num++;</span><br><span class="line">        <span class="keyword">while</span> (*num &gt;= <span class="string">'0'</span> &amp;&amp; *num &lt;= <span class="string">'9'</span>)</span><br><span class="line">            subscale = (subscale * <span class="number">10</span>) + (*num++ - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n = sign * n * <span class="built_in">pow</span>(<span class="number">10.0</span>, (scale + subscale * signsubscale));</span><br><span class="line">    </span><br><span class="line">    item-&gt;valuedouble = n;</span><br><span class="line">    item-&gt;valueint = (<span class="keyword">int</span>)n;</span><br><span class="line">    item-&gt;type = cJSON_Number; <span class="comment">// 数字类型</span></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="parse-string-函数"><a href="#parse-string-函数" class="headerlink" title="parse_string()函数"></a><code>parse_string()</code>函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将输入的文本解析为一个不含转义字符的string格式，并将其填充到item的valuestring中 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">parse_string</span><span class="params">(cJSON* item, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ptr = str + <span class="number">1</span>; <span class="comment">// ptr为string的指针</span></span><br><span class="line">    <span class="keyword">char</span>* ptr2, *out; <span class="comment">// ptr2为out的cur指针</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> uc, uc2;</span><br><span class="line">    <span class="keyword">if</span> (*str != <span class="string">'\"'</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先判断起始字符是否为" 若否则不是字符串</span></span><br><span class="line">        ep = str;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取中间的长度"xxxx" --- 长度不算\*/</span></span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="string">'\"'</span> &amp;&amp; *ptr &amp;&amp; ++len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*ptr++ == <span class="string">'\\'</span>) ptr++; <span class="comment">// 跳过一个\</span></span><br><span class="line">    &#125;</span><br><span class="line">    out = (<span class="keyword">char</span>*)cJSON_malloc(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!out) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ptr = str + <span class="number">1</span>;</span><br><span class="line">    ptr2 = out;</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="string">'\"'</span> &amp;&amp; *ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*ptr != <span class="string">'\\'</span>) *ptr2++ = *ptr++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 额外处理转义字符</span></span><br><span class="line">            ptr++;</span><br><span class="line">            <span class="keyword">switch</span> (*ptr) &#123;</span><br><span class="line">            	<span class="keyword">case</span> <span class="string">'b'</span> : *ptr2++ = <span class="string">'\b'</span>; <span class="keyword">break</span>;</span><br><span class="line">            	<span class="keyword">case</span> <span class="string">'f'</span> : *ptr2++ = <span class="string">'\f'</span>; <span class="keyword">break</span>;</span><br><span class="line">            	<span class="keyword">case</span> <span class="string">'n'</span> : *ptr2++ = <span class="string">'\n'</span>; <span class="keyword">break</span>;</span><br><span class="line">            	<span class="keyword">case</span> <span class="string">'r'</span> : *ptr2++ = <span class="string">'\r'</span>; <span class="keyword">break</span>;</span><br><span class="line">            	<span class="keyword">case</span> <span class="string">'t'</span> : *ptr2++ = <span class="string">'\t'</span>; <span class="keyword">break</span>;</span><br><span class="line">            	<span class="keyword">case</span> <span class="string">'u'</span> : <span class="comment">/*utf16 - utf8*/</span></span><br><span class="line">                    uc = parse_hex4(ptr + <span class="number">1</span>);</span><br><span class="line">                    ptr += <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((uc &gt;= <span class="number">0xDC00</span> &amp;&amp; uc &lt;= <span class="number">0xDFFF</span>) || uc == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 不合法的utf编码</span></span><br><span class="line">                    <span class="keyword">if</span> (uc &gt;= <span class="number">0xD800</span> &amp;&amp; uc &lt;= <span class="number">0xDBFF</span>) &#123;</span><br><span class="line">                        <span class="comment">// 采用四个字节(两个UTF-16编码)来表示一个字符</span></span><br><span class="line">                        <span class="keyword">if</span> (ptr[<span class="number">1</span>] != <span class="string">'\\'</span> || ptr[<span class="number">2</span>] != <span class="string">'u'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        uc2 = parse_hex4(ptr + <span class="number">3</span>);</span><br><span class="line">                        ptr += <span class="number">6</span>;</span><br><span class="line">                        <span class="keyword">if</span> (uc2 &lt; <span class="number">0xDC00</span> || uc2 &gt; <span class="number">0xDFFF</span>) <span class="keyword">break</span>;</span><br><span class="line">                        uc = <span class="number">0x10000</span> + (((uc&amp;<span class="number">0x3FF</span>)&lt;&lt;<span class="number">10</span>) | (uc2&amp;<span class="number">0x3FF</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    len = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (uc &lt; <span class="number">0x80</span>) len = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (uc &lt; <span class="number">0x800</span>) len = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (uc &lt; <span class="number">0x10000</span>) len = <span class="number">3</span>; </span><br><span class="line">                    ptr2 += len;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">switch</span> (len) &#123;</span><br><span class="line">						<span class="keyword">case</span> <span class="number">4</span>: *--ptr2 =((uc | <span class="number">0x80</span>) &amp; <span class="number">0xBF</span>); uc &gt;&gt;= <span class="number">6</span>;</span><br><span class="line">						<span class="keyword">case</span> <span class="number">3</span>: *--ptr2 =((uc | <span class="number">0x80</span>) &amp; <span class="number">0xBF</span>); uc &gt;&gt;= <span class="number">6</span>;</span><br><span class="line">						<span class="keyword">case</span> <span class="number">2</span>: *--ptr2 =((uc | <span class="number">0x80</span>) &amp; <span class="number">0xBF</span>); uc &gt;&gt;= <span class="number">6</span>;</span><br><span class="line">						<span class="keyword">case</span> <span class="number">1</span>: *--ptr2 =(uc | firstByteMark[len]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ptr2 += len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: *ptr2++ = *ptr; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*ptr == <span class="string">'\"'</span>) ptr++;</span><br><span class="line">    item-&gt;valuestring = out;</span><br><span class="line">    item-&gt;type = cJSON_String;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="parse-object-函数"><a href="#parse-object-函数" class="headerlink" title="parse_object()函数"></a><code>parse_object()</code>函数</h5><p>解析时，只关注元素的值，所以要反复调用<code>skip()</code>函数来跳过spacing.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">parse_object</span><span class="params">(cJson *item, <span class="keyword">const</span> <span class="keyword">char</span> *value)</span> </span>&#123;</span><br><span class="line">	cJSON* child;</span><br><span class="line">    <span class="keyword">if</span> (*value != <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">        <span class="comment">// 不是一个对象</span></span><br><span class="line">        ep = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    item-&gt;type = cJSON_Object;</span><br><span class="line">    value = skip(value + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (*value == <span class="string">'&#125;'</span>) <span class="keyword">return</span> value + <span class="number">1</span>; <span class="comment">// 空对象</span></span><br><span class="line">    </span><br><span class="line">    item-&gt;child = child = cJSON_New_Item();</span><br><span class="line">    <span class="keyword">if</span> (!item-&gt;child) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    value = skip(parse_string(child, skip(value)));</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    child-&gt;<span class="built_in">string</span> = child-&gt;valuestring;</span><br><span class="line">    child-&gt;valuestring = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*value != <span class="string">':'</span>) &#123; <span class="comment">// 解析失败</span></span><br><span class="line">        ep = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    value = skip(parse_value(child, skip(value + <span class="number">1</span>) <span class="comment">/*跳过:*/</span>));</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*value == <span class="string">','</span>) &#123;</span><br><span class="line">        cJSON *new_item;</span><br><span class="line">        <span class="keyword">if</span> (!(new_item = cJSON_New_Item())) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 内存申请失败</span></span><br><span class="line">        child-&gt;next = new_item;</span><br><span class="line">        new_item-&gt;prev = child;</span><br><span class="line">        child = new_item;</span><br><span class="line">        </span><br><span class="line">        value = skip(parse_string(child, skip(value + <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        child-&gt;<span class="built_in">string</span> = child-&gt;valuestring;</span><br><span class="line">        child-&gt;valuestring = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (*value != <span class="string">':'</span>) &#123;</span><br><span class="line">            ep = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = skip(parse_value(child, skip(value + <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*value == <span class="string">'&#125;'</span>) <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">    ep = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><h4 id="总函数"><a href="#总函数" class="headerlink" title="总函数"></a>总函数</h4><p>二次封装函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cJSON_Print</span><span class="params">(cJSOn *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> print_value(item, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cJSON_PrintUnformatted</span><span class="params">(cJSON *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> print_value(item, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cJSON_PrintBuffered</span><span class="params">(cJSON *item, <span class="keyword">int</span> prebuffer, <span class="keyword">int</span> fmt)</span> </span>&#123;</span><br><span class="line">    printbuffer p;</span><br><span class="line">    p.<span class="built_in">buffer</span> = (<span class="keyword">char</span>*)cJSON_malloc(prebuffer);</span><br><span class="line">    p.length = prebuffer;</span><br><span class="line">    p.offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> print_value(item, <span class="number">0</span>, fmt, &amp;p);</span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">buffer</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内层函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">print_value</span><span class="params">(cJSON *item, <span class="keyword">int</span> depth, <span class="keyword">int</span> fmt, printbuffer *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!item) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="keyword">switch</span> ((item-&gt;type) &amp; <span class="number">255</span>) &#123; <span class="comment">// 与255相与运算得到类型</span></span><br><span class="line">            <span class="comment">// 前三种情况直接输出对应的字符串</span></span><br><span class="line">			<span class="keyword">case</span> cJSON_NULL:	&#123;out=ensure(p,<span class="number">5</span>);	<span class="keyword">if</span> (out) <span class="built_in">strcpy</span>(out,<span class="string">"null"</span>);	<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">case</span> cJSON_False:	&#123;out=ensure(p,<span class="number">6</span>);	<span class="keyword">if</span> (out) <span class="built_in">strcpy</span>(out,<span class="string">"false"</span>);	<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">case</span> cJSON_True:	&#123;out=ensure(p,<span class="number">5</span>);	<span class="keyword">if</span> (out) <span class="built_in">strcpy</span>(out,<span class="string">"true"</span>);	<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="comment">// 以下不同的输出分类讨论</span></span><br><span class="line">			<span class="keyword">case</span> cJSON_Number:	out=print_number(item,p);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> cJSON_String:	out=print_string(item,p);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> cJSON_Array:	out=print_array(item,depth,fmt,p);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> cJSON_Object:	out=print_object(item,depth,fmt,p);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与缓冲区内没有数据时的区别仅为传参的起始指针由p-&gt;0</span></span><br><span class="line">        <span class="keyword">switch</span> ((item-&gt;type) &amp; <span class="number">255</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> cJSON_NULL:	out=cJSON_strdup(<span class="string">"null"</span>);	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> cJSON_False:	out=cJSON_strdup(<span class="string">"false"</span>);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> cJSON_True:	out=cJSON_strdup(<span class="string">"true"</span>); <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> cJSON_Number:	out=print_number(item,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> cJSON_String:	out=print_string(item,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> cJSON_Array:	out=print_array(item,depth,fmt,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> cJSON_Object:	out=print_object(item,depth,fmt,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="分函数-1"><a href="#分函数-1" class="headerlink" title="分函数"></a>分函数</h4><h5 id="print-number-函数"><a href="#print-number-函数" class="headerlink" title="print_number()函数"></a><code>print_number()</code>函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">print_number</span><span class="params">(cJSON *item, printbuffer *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> d = item-&gt;valuedouble; <span class="comment">// d承接对象的valuedouble</span></span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) str = ensure(p, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> str = (<span class="keyword">char</span>*)cJSON_malloc(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (str) <span class="built_in">strcpy</span>(str, <span class="string">"0"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">fabs</span>(((<span class="keyword">double</span>)item-&gt;valuedouble) &lt;= DBL_EPSILON) &amp;&amp; d &lt;= INT_MAX &amp;&amp; d &gt;= INT_MIN) &#123;</span><br><span class="line">        <span class="comment">// DBL_EPSILON可以理解为一个极小量</span></span><br><span class="line">        <span class="keyword">if</span> (p) str = ensure(p, <span class="number">21</span>); <span class="comment">// 2^64+1（64bit计算机的极限数）可以用21个字符表示</span></span><br><span class="line">        <span class="keyword">else</span> str = (<span class="keyword">char</span>*)cJSON_malloc(<span class="number">21</span>);</span><br><span class="line">        <span class="keyword">if</span> (str) <span class="built_in">sprintf</span>(str, <span class="string">"%d"</span>, item-&gt;valueint);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) str = ensure(p, <span class="number">64</span>);</span><br><span class="line">        <span class="keyword">else</span> str = (<span class="keyword">char</span>*)cJSON_malloc(<span class="number">64</span>);</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            <span class="comment">// floor(d)求解不大于d的最大整数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="built_in">floor</span>(d) - d) &lt;= DBL_EPSILON &amp;&amp; <span class="built_in">fabs</span>(d) &lt; <span class="number">1.0e60</span>)</span><br><span class="line">                <span class="built_in">sprintf</span>(str, <span class="string">"%.0f"</span>, d); <span class="comment">// 小数位过多，保留整数位输出即可</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">fabs</span>(d) &lt; <span class="number">1.0e-6</span> || <span class="built_in">fabs</span>(d) &gt; <span class="number">1.0e9</span>)			</span><br><span class="line">                <span class="built_in">sprintf</span>(str, <span class="string">"%e"</span>, d); <span class="comment">// 如果数据过小或过大，以指数形式输出</span></span><br><span class="line">			<span class="keyword">else</span>												</span><br><span class="line">                <span class="built_in">sprintf</span>(str, <span class="string">"%f"</span>, d); <span class="comment">// 正常输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="print-string-函数"><a href="#print-string-函数" class="headerlink" title="print_string()函数"></a><code>print_string()</code>函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">print_string</span><span class="params">(cJSON *item, printbuffer *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向缓冲区中添加item-&gt;valuestring</span></span><br><span class="line">    <span class="keyword">return</span> print_string_ptr(item-&gt;valuestring, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">print_string_ptr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, printbuffer *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">char</span> *ptr2, *out;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> token;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (ptr = str; *ptr; ptr++) &#123;</span><br><span class="line">        flag |= ((*ptr &gt; <span class="number">0</span> &amp;&amp; *ptr &lt; <span class="number">32</span>) || (*ptr == <span class="string">'\"'</span>) || (*ptr == <span class="string">'\\'</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="comment">/* 如果str不含0-32的特殊指令字符 或 " 或 \ 则直接处理 */</span></span><br><span class="line">        len = ptr - str; <span class="comment">// 截取这一段"合法"的字符串[str, ptr]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*如果缓冲区有数据，在后面预设len + 3("xxxx"\0)的缓冲区大小，并且out为指向缓冲区的末尾待添加处的指针*/</span></span><br><span class="line">        <span class="keyword">if</span> (p) out = ensure(p, len + <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*否则直接申请空间*/</span></span><br><span class="line">        <span class="keyword">else</span> out = (<span class="keyword">char</span>*)cJSON_malloc(len + <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (!out) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 申请失败，返回0</span></span><br><span class="line">        ptr2 = out; </span><br><span class="line">        <span class="comment">// 在该指针位置添加字符串，格式为"xxx"</span></span><br><span class="line">        *ptr2++ = <span class="string">'\"'</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr2, str);</span><br><span class="line">        ptr2[len] = <span class="string">'\"'</span>;</span><br><span class="line">        ptr2[len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> out; <span class="comment">// 返回了添加字符串的头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!str) &#123;</span><br><span class="line">        <span class="comment">// 如果字符串为空</span></span><br><span class="line">        <span class="keyword">if</span> (p) out = ensure(p, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">else</span> out = (<span class="keyword">char</span>*)cJSON_malloc(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (!out) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(out, <span class="string">"\"\""</span>); <span class="comment">// out为""</span></span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*开始处理含转义字符的接下来部分*/</span></span><br><span class="line">    ptr = str; <span class="comment">// ptr重定位到str的开头处</span></span><br><span class="line">    <span class="comment">/* 遍历该段字符串到结尾*/</span></span><br><span class="line">    <span class="keyword">while</span> ((token = *ptr) &amp;&amp; ++len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strchr</span>(<span class="string">"\"\\\b\f\n\r\t"</span>, token))</span><br><span class="line">            <span class="comment">// 如果遍历到的字符token中包含有" \ \b \f \n \r \t，则len自增1</span></span><br><span class="line">            len++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token &lt; <span class="number">32</span>)</span><br><span class="line">            <span class="comment">// 如果不包含有转义字符，且token为一控制字符（ascii为1-32），len自增5</span></span><br><span class="line">            len += <span class="number">5</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// len + 3表示字符串两侧套上"并加入\0</span></span><br><span class="line">	<span class="keyword">if</span> (p)	out = ensure(p, len + <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">else</span>	out = (<span class="keyword">char</span>*)cJSON_malloc(len + <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (!out) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ptr2为输出内容的头指针</span></span><br><span class="line">    <span class="comment">// ptr为str的头指针</span></span><br><span class="line">    ptr2 = out; ptr = str;</span><br><span class="line">    *ptr2++ = <span class="string">'\"'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*ptr) &#123;</span><br><span class="line">        <span class="comment">// 再次遍历这段字符串内容</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)*ptr &gt; <span class="number">31</span> &amp;&amp; *ptr != <span class="string">'\"'</span> &amp;&amp; *ptr != <span class="string">'\\'</span>)</span><br><span class="line">        	<span class="comment">// 如果该字符不涉及转义和操作字符等内容，直接粘贴</span></span><br><span class="line">            *ptr2++ = *ptr++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *ptr2++ = <span class="string">'\\'</span>;</span><br><span class="line">        <span class="keyword">switch</span>(token = *ptr++) &#123;</span><br><span class="line">        	<span class="comment">// 分类讨论转义字符的情况</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\\'</span>:  *ptr2++ = <span class="string">'\\'</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\"'</span>:	*ptr2++ = <span class="string">'\"'</span>;	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\b'</span>:	*ptr2++ = <span class="string">'b'</span>;	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\f'</span>:	*ptr2++ = <span class="string">'f'</span>;	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>:	*ptr2++ = <span class="string">'n'</span>;	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\r'</span>:	*ptr2++ = <span class="string">'r'</span>;	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\t'</span>:	*ptr2++ = <span class="string">'t'</span>;	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr2++ = <span class="string">'\"'</span>;</span><br><span class="line">    *ptr2++ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="print-array-函数"><a href="#print-array-函数" class="headerlink" title="print_array()函数"></a><code>print_array()</code>函数</h5><p><code>array</code>是由一个一个的<code>item</code>组成的，故对于其每一个<code>item</code>都需要在<code>printbuffer</code>中预留额外的空间。</p>
<p><code>fmt</code>很可能是指示了元素和逗号之间是否有空格。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*输出序列，顺序输出即可（中间添加逗号，根据格式添加space）*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">print_array</span><span class="params">(cJSON* item, <span class="keyword">int</span> depth, <span class="keyword">int</span> fmt, printbuffer *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> **entries;</span><br><span class="line">    <span class="keyword">char</span> *out = <span class="number">0</span>, *ptr, *ret;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">5</span>; <span class="comment">/*len最小为5 [\"\"]\0*/</span></span><br><span class="line">    cJSON *child = item-&gt;child; <span class="comment">// 由于输出的是array需要child</span></span><br><span class="line">    <span class="keyword">int</span> numentries = <span class="number">0</span>, i = <span class="number">0</span>, fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> tmplen = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// child个数对应了序列中元素个数多少</span></span><br><span class="line">    <span class="keyword">while</span> (child) &#123;</span><br><span class="line">        numentries++;</span><br><span class="line">        child = child-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!numentries) &#123;</span><br><span class="line">        <span class="comment">// 若序列为空</span></span><br><span class="line">        <span class="keyword">if</span> (p) out = ensure(p, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">else</span> out = (<span class="keyword">char</span>*)cJSON_malloc(c);</span><br><span class="line">        <span class="keyword">if</span> (out) <span class="built_in">strcpy</span>(out, <span class="string">"[]"</span>);</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="comment">/* 组成输出序列 */</span></span><br><span class="line">        i = p-&gt;offset;</span><br><span class="line">        ptr = ensure(p, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        *ptr = <span class="string">'['</span>;</span><br><span class="line">        p-&gt;offset++;</span><br><span class="line">        child = item-&gt;child;</span><br><span class="line">        <span class="keyword">while</span> (child &amp;&amp; !fail) &#123;</span><br><span class="line">            print_value(child, depth + <span class="number">1</span>, fmt, p);</span><br><span class="line">            p-&gt;offset = update(p);</span><br><span class="line">            <span class="keyword">if</span> (child-&gt;next) &#123;</span><br><span class="line">                <span class="comment">// null -&gt; len = 1 !null -&gt; len = 2</span></span><br><span class="line">                len = fmt ? <span class="number">2</span> : <span class="number">1</span>; </span><br><span class="line">                ptr = ensure(p, len + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                *ptr++ = <span class="string">','</span>;</span><br><span class="line">                <span class="keyword">if</span> (fmt) *ptr++ = <span class="string">' '</span>; <span class="comment">// fmt决定了元素间是否有空格</span></span><br><span class="line">                *ptr = <span class="number">0</span>;</span><br><span class="line">                p-&gt;offset += len;</span><br><span class="line">            &#125;</span><br><span class="line">            child = child-&gt;next;</span><br><span class="line">            ptr = ensure(p, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            *ptr++ = <span class="string">']'</span>;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            out = (p-&gt;<span class="built_in">buffer</span>) + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 分配一个序列来承载每个值 */</span></span><br><span class="line">        entries = (<span class="keyword">char</span>**)cJSON_malloc(numentries * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">        <span class="keyword">if</span> (!entries) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(entries, <span class="number">0</span>, numentries * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">        <span class="comment">/* 检查所有结果 */</span></span><br><span class="line">        child = item-&gt;child;</span><br><span class="line">        <span class="keyword">while</span> (child &amp;&amp; !fail) &#123;</span><br><span class="line">            ret = print_value(child, depth + <span class="number">1</span>, fmt, <span class="number">0</span>);</span><br><span class="line">            entries[i++] = ret;</span><br><span class="line">            <span class="keyword">if</span> (ret) len += <span class="built_in">strlen</span>(ret) + <span class="number">2</span> + (fmt ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> fail = <span class="number">1</span>;</span><br><span class="line">            child = child-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!fail) out = (*<span class="keyword">char</span>)cJSON_malloc(len);</span><br><span class="line">        <span class="keyword">if</span> (!out) fail = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (fail) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numentries; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entries[i])</span><br><span class="line">                    <span class="comment">// 删除要把每个item都删掉</span></span><br><span class="line">                    cJSON_free(entries[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            cJSON_free(entries);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        *out = <span class="string">'['</span>;</span><br><span class="line">        ptr = out + <span class="number">1</span>;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numentries; ++i) &#123;</span><br><span class="line">            <span class="comment">// 边遍历entries边将其转移合并到ptr指向的内容，并在过程中free(entries)。</span></span><br><span class="line">            tmplen = <span class="built_in">strlen</span>(entries[i]);</span><br><span class="line">            <span class="built_in">memcpy</span>(ptr, entries[i], tmplen);</span><br><span class="line">            ptr += tmplen;</span><br><span class="line">            <span class="keyword">if</span> (i != numentries - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 中间加逗号</span></span><br><span class="line">                *ptr++ = <span class="string">','</span>;</span><br><span class="line">                <span class="keyword">if</span> (fmt) *ptr++ = <span class="string">' '</span>;</span><br><span class="line">                *ptr = <span class="number">0</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">            cJSON_free(entries[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cJSON_free(entries);</span><br><span class="line">        *ptr++ = <span class="string">']'</span>;</span><br><span class="line">        *ptr+= = <span class="number">0</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="print-object-函数"><a href="#print-object-函数" class="headerlink" title="print_object()函数"></a><code>print_object()</code>函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*输出对象，每个key之间要有空行*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">print_object</span><span class="params">(cJSON *item, <span class="keyword">int</span> depth, <span class="keyword">int</span> fmt, printbuffer *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*fmt代表了中间是否有换行/缩进 1有0无*/</span></span><br><span class="line">    <span class="comment">/*depth代表第几个制表符位置(行中的相对位置)*/</span></span><br><span class="line">    <span class="keyword">char</span> **entries = <span class="number">0</span>, **names = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *out = <span class="number">0</span>, *ptr, *ret, *str;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">7</span>, i = <span class="number">0</span>, j;</span><br><span class="line">    cJSON *child = item-&gt;child;</span><br><span class="line">    <span class="keyword">int</span> numentries = <span class="number">0</span>, fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> tmplen = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (child) &#123;</span><br><span class="line">        numentries++;</span><br><span class="line">        child = child-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!numentries) &#123; <span class="comment">// 如果对象为空</span></span><br><span class="line">        <span class="comment">// depth+4 ... &#123;\n(depth - 1)*(\t)&#125;\0</span></span><br><span class="line">        <span class="comment">// 3       ... &#123;&#125;\0</span></span><br><span class="line">        <span class="keyword">if</span> (p) out = ensure(p, fmt ? depth + <span class="number">4</span> : <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 如果fmt为1 说明要进行空行</span></span><br><span class="line">        <span class="keyword">else</span> out = (<span class="keyword">char</span>*)cJSON_malloc(fmt ? depth + <span class="number">4</span> : );</span><br><span class="line">        <span class="keyword">if</span> (!out) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ptr = out;</span><br><span class="line">        *ptr++ = <span class="string">'&#123;'</span>;</span><br><span class="line">        <span class="keyword">if</span> (fmt) &#123;</span><br><span class="line">            *ptr++ = <span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                *ptr++ = <span class="string">'\t'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *ptr++ = <span class="string">'&#125;'</span>;</span><br><span class="line">        *ptr++ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="comment">// 如果输出buffer不为空，组成输出</span></span><br><span class="line">        i = p-&gt;offset;</span><br><span class="line">        len = fmt ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        ptr = ensure(p, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        *ptr++ = <span class="string">'&#123;'</span>;</span><br><span class="line">        <span class="keyword">if</span> (fmt) *ptr++ = <span class="string">'\n'</span>;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        p-&gt;offset += len;</span><br><span class="line">        child = item-&gt;child;</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">while</span> (child) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fmt) &#123;</span><br><span class="line">                ptr = ensure(p, depth);</span><br><span class="line">                <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; depth; ++j) &#123;</span><br><span class="line">                    *ptr++ = <span class="string">'\t'</span>; <span class="comment">// ptr后添加depth个\t</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;offset += depth;</span><br><span class="line">            &#125;</span><br><span class="line">            print_string_ptr(child-&gt;<span class="built_in">string</span>, p); <span class="comment">// key一定是字符串格式</span></span><br><span class="line">            p-&gt;offset += update(p);</span><br><span class="line">            </span><br><span class="line">            len = fmt ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">            ptr = ensure(p, len);</span><br><span class="line">            <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            *ptr++ = <span class="string">':'</span>;</span><br><span class="line">            <span class="keyword">if</span> (fmt) *ptr++ = <span class="string">'\t'</span>;</span><br><span class="line">            p-&gt;offset += len;</span><br><span class="line">            </span><br><span class="line">            print_value(child, depth, fmt, p); <span class="comment">// val需要依据其数据类型而定</span></span><br><span class="line">            p-&gt;offset = update(p);</span><br><span class="line">            </span><br><span class="line">            len = (fmt ? <span class="number">1</span> : <span class="number">0</span>) + (child-&gt;next ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            ptr = ensure(p, len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (child-&gt;next) *ptr++ = <span class="string">','</span>;</span><br><span class="line">            <span class="keyword">if</span> (fmt) *ptr++ = <span class="string">'\n'</span>;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            p-&gt;offset += len;</span><br><span class="line">            </span><br><span class="line">            child = child-&gt;next;           </span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ensure(p, fmt ? (depth + <span class="number">1</span>) : <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fmt) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; depth - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                *ptr++ = <span class="string">'\t'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *ptr++ = <span class="string">'&#125;'</span>;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        out = (p-&gt;<span class="built_in">buffer</span>) + i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 如果输出buffer为空，为对象名和对象分配空间 */</span></span><br><span class="line">        entries = (<span class="keyword">char</span>**)cJSON_malloc(numentries * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">        <span class="keyword">if</span> (!entries) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        names = (<span class="keyword">char</span>**)cJSON_malloc(numentries * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">        <span class="keyword">if</span> (!names) &#123;cJSON_free(entries); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="built_in">memset</span>(entries, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * numentries);</span><br><span class="line">        <span class="built_in">memset</span>(names, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * numentries);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将所有结果放入数组中 */</span></span><br><span class="line">        child = item-&gt;child;</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span> (fmt) len += depth;</span><br><span class="line">        <span class="keyword">while</span> (child) &#123;</span><br><span class="line">            names[i] = str = print_string_ptr(child-&gt;<span class="built_in">string</span>, <span class="number">0</span>);</span><br><span class="line">            entries[i++] = ret = print_value(child, depth, fmt, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (str &amp;&amp; ret) len += <span class="built_in">strlen</span>(ret) + <span class="built_in">strlen</span>(str) + <span class="number">2</span> + (fmt ? <span class="number">2</span> + depth : <span class="number">0</span>); </span><br><span class="line">            <span class="comment">// name + 2("") + 2 + depth(2是:两侧的空格)</span></span><br><span class="line">            <span class="keyword">else</span> fail = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            child = child-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!fail) out = (<span class="keyword">char</span>*)cJSON_malloc(len);</span><br><span class="line">        <span class="keyword">if</span> (!out) fail = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fail) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numentries; ++i) &#123;</span><br><span class="line">                <span class="comment">// 逐个free掉names[i]和entries[i]</span></span><br><span class="line">                <span class="keyword">if</span> (names[i]) &#123;</span><br><span class="line">                    cJSON_free(names[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (entries[i]) &#123;</span><br><span class="line">                    cJSON_free(entries[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cJSON_free(names[i]); </span><br><span class="line">            cJSON_free(entries[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        *out = <span class="string">'&#123;'</span>;</span><br><span class="line">        ptr = out + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (fmt) *ptr++ = <span class="string">'\n'</span>;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numentries; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fmt) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; depth; ++j) &#123;</span><br><span class="line">                    *ptr++ = <span class="string">'\t'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tmplen = <span class="built_in">strlen</span>(names[i]);</span><br><span class="line">            <span class="comment">// 这里为啥不用strcpy</span></span><br><span class="line">            <span class="built_in">memcpy</span>(ptr, names[i], tmplen);</span><br><span class="line">            ptr += tmplen;</span><br><span class="line">            *ptr++ = <span class="string">':'</span>;</span><br><span class="line">            <span class="keyword">if</span> (fmt) *ptr++ = <span class="string">'\t'</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(ptr, entries[i]);</span><br><span class="line">            ptr += <span class="built_in">strlen</span>(entries[i]);</span><br><span class="line">            <span class="keyword">if</span> (i != numentries - <span class="number">1</span>) *ptr++ = <span class="string">','</span>;</span><br><span class="line">            <span class="keyword">if</span> (fmt) *ptr++ = <span class="string">'\n'</span>;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 边转移到输出边free</span></span><br><span class="line">            cJSON_free(names);</span><br><span class="line">            cJSON(entries[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cJSON_free(names); cJSON_free(entries);</span><br><span class="line">        <span class="keyword">if</span> (fmt) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth - <span class="number">1</span>; ++i)</span><br><span class="line">                *ptr++ = <span class="string">'\t'</span>;</span><br><span class="line">        *ptr = <span class="string">'&#125;'</span>; *ptr++ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">cJSON_GetErrorPtr</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;<span class="keyword">return</span> ep;&#125; <span class="comment">// 获取错误类型指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串比较函数</span></span><br><span class="line"><span class="comment">	如果s1 == s2，返回0</span></span><br><span class="line"><span class="comment">	如果s1 &gt; s2，返回正数</span></span><br><span class="line"><span class="comment">	如果s1 &lt; s2，返回负数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cJSON_strcasecmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!s1) <span class="keyword">return</span> (s1 == s2) ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">// s1 == s2 == nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (!s2) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// s1 != nullptr s2 == nullptr</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">tolower</span>(*s1) == <span class="built_in">tolower</span>(*s2); ++s1, ++s2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s1 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// s1与s2完全相等</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tolower</span>(*(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)s1) - <span class="built_in">tolower</span>(*(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制字符串 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">cJSON_strdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">char</span>* copy;</span><br><span class="line">    </span><br><span class="line">    len = <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(copy = (*<span class="keyword">char</span>)cJSON_malloc(len)))</span><br><span class="line">        <span class="comment">// 如果对copy申请空间失败，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(copy, str, len);</span><br><span class="line">    <span class="keyword">return</span> copy; <span class="comment">// 返回副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部构造函数(初始化) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> cJSON *<span class="title">cJSON_New_Item</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    cJSON* node = (cJSON*)cJSON_malloc(<span class="keyword">sizeof</span>(cJSON));</span><br><span class="line">    <span class="keyword">if</span> (node) <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(cJSON));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除一个cJSON结构 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_Delete</span><span class="params">(cJSON *c)</span> </span>&#123;</span><br><span class="line">    cJSON *next;</span><br><span class="line">    <span class="keyword">while</span> (c) &#123;</span><br><span class="line">        next = c-&gt;next; <span class="comment">// next承接下一个内容</span></span><br><span class="line">        <span class="comment">// cJSON_IsReference 256    100000000</span></span><br><span class="line">        <span class="comment">// cJSON_StringIsConst 512 1000000000</span></span><br><span class="line">        <span class="comment">/* c-&gt;type不能是256和512 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;type &amp; cJSON_IsReference) &amp;&amp; c-&gt;child) cJSON_Delete(c-&gt;child); <span class="comment">// 递归free掉孩子节点</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;type &amp; cJSON_IsReference) &amp;&amp; c-&gt;valuestring) cJSON_free(c-&gt;valuestring); <span class="comment">// free掉valuestring</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;type &amp; cJSON_StringIsConst) &amp;&amp; c-&gt;<span class="built_in">string</span>) cJSON_free(c-&gt;<span class="built_in">string</span>); <span class="comment">// free掉string</span></span><br><span class="line">        cJSON_free(c); <span class="comment">// free掉前一个结点</span></span><br><span class="line">        c = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回一个比x-1大的最小的2^N */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pow2gt</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    --x;</span><br><span class="line">    <span class="comment">// 10010 </span></span><br><span class="line">    <span class="comment">// 01001 1 11011</span></span><br><span class="line">    <span class="comment">// 00100 2 11111</span></span><br><span class="line">    <span class="comment">// 00001 4 11111 --&gt; 31 + 1 = 32</span></span><br><span class="line">    x |= x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x |= x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    x |= x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    x |= x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    x |= x &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于将json数据打印到缓冲区时，提供缓存空间的信息 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span>; <span class="comment">// 缓存地址指针</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 缓存当前缓存区长度</span></span><br><span class="line">    <span class="keyword">int</span> offset; <span class="comment">// 缓存当前已经使用过的位置（偏移量）</span></span><br><span class="line">&#125; printbuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 确保p所指向的缓冲区能够提供needed大小的缓冲给打印功能使用 */</span></span><br><span class="line"><span class="comment">/* 返回缓冲区可以继续使用的空间位置指针 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">ensure</span><span class="params">(printbuffer *p, <span class="keyword">int</span> needed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *newbuffer;</span><br><span class="line">    <span class="keyword">int</span> newsize;</span><br><span class="line">    <span class="keyword">if</span> (!p || !p-&gt;<span class="built_in">buffer</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    needed += p-&gt;offset; <span class="comment">// 更新needed为原使用过长度+需要长度</span></span><br><span class="line">    <span class="keyword">if</span> (needed &lt;= p-&gt;length) <span class="keyword">return</span> p-&gt;<span class="built_in">buffer</span> + p-&gt;offset; <span class="comment">// 如果缓冲区的大小足够用，直接返回</span></span><br><span class="line">    </span><br><span class="line">    newsize = pow2gt(needed); <span class="comment">// newsize为比needed大的最小的2次幂数</span></span><br><span class="line">    newbuffer = (<span class="keyword">char</span> *)cJSON_malloc(newsize);</span><br><span class="line">    <span class="keyword">if</span> (!newbuffer) &#123;</span><br><span class="line">        cJSON_free(p-&gt;<span class="built_in">buffer</span>);</span><br><span class="line">        p-&gt;length = <span class="number">0</span>, p-&gt;<span class="built_in">buffer</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newbuffer) &#123;</span><br><span class="line">        <span class="comment">// 将原缓存区中的缓存区的全部内容复制到newbuffer</span></span><br><span class="line">        <span class="built_in">memcpy</span>(newbuffer, p-&gt;<span class="built_in">buffer</span>, p-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">    cJSON_free(p-&gt;<span class="built_in">buffer</span>);</span><br><span class="line">    p-&gt;length = newsize;</span><br><span class="line">    p-&gt;<span class="built_in">buffer</span> = newbuffer;</span><br><span class="line">    <span class="keyword">return</span> newbuffer + p-&gt;offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将待缓存结构更新到缓存区，并返回已使用的内存大小 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(printbuffer *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="keyword">if</span> (!p || !p-&gt;<span class="built_in">buffer</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    str = p-&gt;<span class="built_in">buffer</span> + p-&gt;offset;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;offset + <span class="built_in">strlen</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下大部分为呼应.h文件中的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cJSON_GetArraySize</span><span class="params">(cJSON *<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    cJSON *c = <span class="built_in">array</span>-&gt;child;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        c = c-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_GetArrayItem</span><span class="params">(cJSON *<span class="built_in">array</span>, <span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get第item个元素节点</span></span><br><span class="line">    cJSON *c = <span class="built_in">array</span>-&gt;child;</span><br><span class="line">    <span class="keyword">while</span> (c &amp;&amp; item &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item--;</span><br><span class="line">        c = c-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_GetObjectItem</span><span class="params">(cJSON *object, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get值为string的元素节点</span></span><br><span class="line">    cJSON *c = object-&gt;child;</span><br><span class="line">    <span class="keyword">while</span> (c &amp;&amp; cJSON_strcasecmp(c-&gt;<span class="built_in">string</span>, <span class="built_in">string</span>)) c = c-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 双向链表的节点插入操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">suffix_object</span><span class="params">(cJSON *prev, cJSON *item)</span> </span>&#123;</span><br><span class="line">    prev-&gt;next = item;</span><br><span class="line">    item-&gt;prev = prev;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">static</span> cJSON *<span class="title">create_reference</span><span class="params">(cJSON *item)</span> </span>&#123;</span><br><span class="line">    cJSON *ref = cJSON_New_Item();</span><br><span class="line">    <span class="keyword">if</span> (!ref) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ref, item, <span class="keyword">sizeof</span>(cJSON));</span><br><span class="line">    ref-&gt;<span class="built_in">string</span> = <span class="number">0</span>;</span><br><span class="line">    ref-&gt;type |= cJSON_IsReference;</span><br><span class="line">    ref-&gt;next = ref-&gt;prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_AddItemToArray</span><span class="params">(cJSON *<span class="built_in">array</span>, cJSON *item)</span> </span>&#123;</span><br><span class="line">    cJSON *c = <span class="built_in">array</span>-&gt;child;</span><br><span class="line">    <span class="keyword">if</span> (!item) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">if</span> (!c) &#123;<span class="built_in">array</span>-&gt;child = item;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (c &amp;&amp; c-&gt;next) c = c-&gt;next; </span><br><span class="line">        suffix_object(c, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_AddItemToObject</span><span class="params">(cJSON *object, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>, cJSON *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!item) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">if</span> (item-&gt;<span class="built_in">string</span>) cJSON_free(item-&gt;<span class="built_in">string</span>);</span><br><span class="line">    item-&gt;<span class="built_in">string</span> = cJSON_strdup(<span class="built_in">string</span>);</span><br><span class="line">    cJSON_AddItemToArray(object,item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_AddItemToObjectCS</span><span class="params">(cJSON *object, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>, cJSON *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!item) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">if</span> (!(item-&gt;type &amp; cJSON_StringIsConst) &amp;&amp; item-&gt;<span class="built_in">string</span>) cJSON_free(item-&gt;<span class="built_in">string</span>);</span><br><span class="line">    item-&gt;<span class="built_in">string</span> = (<span class="keyword">char</span>*)<span class="built_in">string</span>;</span><br><span class="line">    item-&gt;type |= cJSON_StringIsConst;</span><br><span class="line">    cJSON_AddItemToArray(object, item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_AddItemReferenceToArray</span><span class="params">(cJSON *<span class="built_in">array</span>, cJSON *item)</span> </span>&#123;</span><br><span class="line">    cJSON_AddItemToArray(<span class="built_in">array</span>,create_reference(item));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_AddItemReferenceToObject</span><span class="params">(cJSON *object, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>, cJSON *item)</span> </span>&#123;</span><br><span class="line">    cJSON_AddItemToObject(object,<span class="built_in">string</span>,create_reference(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从Array中分离第which个元素，并将该元素返回 */</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_DetachItemFromArray</span><span class="params">(cJSON *<span class="built_in">array</span>, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">    cJSON *c = <span class="built_in">array</span>-&gt;child;</span><br><span class="line">    <span class="keyword">while</span> (c &amp;&amp; which &gt; <span class="number">0</span>) c = c-&gt;next, which--;</span><br><span class="line">    <span class="keyword">if</span> (!c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 调整双向链表的前驱和后驱节点的后驱和前驱指向</span></span><br><span class="line">	<span class="keyword">if</span> (c-&gt;prev) c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;next) c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="built_in">array</span>-&gt;child) <span class="built_in">array</span>-&gt;child = c-&gt;next; <span class="comment">// 如果which == 0，只需要更新array-&gt;child</span></span><br><span class="line">    c-&gt;prev = c-&gt;next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_DeleteItemFromArray</span><span class="params">(cJSON *<span class="built_in">array</span>, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">    cJSON_Delete(cJSON_DetachItemFromArray(<span class="built_in">array</span>, which));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_DetachItemFromObject</span><span class="params">(cJSON *object, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    cJSON *c = object-&gt;child;</span><br><span class="line">    <span class="keyword">while</span> (c &amp;&amp; cJSON_strcasecmp(c-&gt;<span class="built_in">string</span>, <span class="built_in">string</span>))</span><br><span class="line">        ++i, c = c-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (c) <span class="keyword">return</span> cJSON_DetachItemFromArray(object, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_DeleteItemFromObject</span><span class="params">(cJSON *object, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    cJSON_Delete(cJSON_DetachItemFromObject(object, <span class="built_in">string</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向array或object中添加或替代元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_InsertItemInArray</span><span class="params">(cJSON *<span class="built_in">array</span>, <span class="keyword">int</span> which, cJSON *newitem)</span> </span>&#123;</span><br><span class="line">    cJSON *c = <span class="built_in">array</span>-&gt;child;</span><br><span class="line">    <span class="keyword">while</span> (c &amp;&amp; which &gt; <span class="number">0</span>) c = c-&gt;next, which--;</span><br><span class="line">    <span class="keyword">if</span> (!c) &#123;cJSON_AddItemToArray(<span class="built_in">array</span>, newitem); <span class="keyword">return</span>;&#125; <span class="comment">// 如果array为空，直接添加</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    b -&gt; c</span></span><br><span class="line"><span class="comment">    变成</span></span><br><span class="line"><span class="comment">    b -&gt; newitem -&gt; c</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	newitem-&gt;next = c;</span><br><span class="line">    newitem-&gt;prev = c-&gt;prev;</span><br><span class="line">    c-&gt;prev = newitem;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="built_in">array</span>-&gt;child) <span class="built_in">array</span>-&gt;child = newitem; </span><br><span class="line">    <span class="keyword">else</span> newitem-&gt;prev-&gt;next = newitem; <span class="comment">// 如果存在前驱节点，让他指向newitem</span></span><br><span class="line">&#125;</span><br><span class="line">                                   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_ReplaceItemInArray</span><span class="params">(cJSON *<span class="built_in">array</span>,<span class="keyword">int</span> which,cJSON *newitem)</span> </span>&#123;</span><br><span class="line">    cJSON *c = <span class="built_in">array</span>-&gt;child;</span><br><span class="line">    <span class="keyword">while</span> (c &amp;&amp; which &gt; <span class="number">0</span>) c = c-&gt;next, which--;</span><br><span class="line">    <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line">	newitem-&gt;next = c-&gt;next;</span><br><span class="line">    newitem-&gt;prev = c-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (newitem-&gt;next) newitem-&gt;next-&gt;prev = newitem;</span><br><span class="line">	<span class="keyword">if</span> (c==<span class="built_in">array</span>-&gt;child) <span class="built_in">array</span>-&gt;child = newitem; </span><br><span class="line">    <span class="keyword">else</span> newitem-&gt;prev-&gt;next = newitem;</span><br><span class="line">    c-&gt;next=c-&gt;prev=<span class="number">0</span>;</span><br><span class="line">    cJSON_Delete(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_ReplaceItemInObject</span><span class="params">(cJSON *object,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>,cJSON *newitem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    cJSON *c=object-&gt;child;</span><br><span class="line">    <span class="keyword">while</span>(c &amp;&amp; cJSON_strcasecmp(c-&gt;<span class="built_in">string</span>,<span class="built_in">string</span>)) i++,c=c-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(c) &#123;</span><br><span class="line">        newitem-&gt;<span class="built_in">string</span>=cJSON_strdup(<span class="built_in">string</span>);</span><br><span class="line">        cJSON_ReplaceItemInArray(object,i,newitem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他简单函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateNull</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;cJSON *item=cJSON_New_Item();<span class="keyword">if</span>(item)item-&gt;type=cJSON_NULL;<span class="keyword">return</span> item;&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateTrue</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;cJSON *item=cJSON_New_Item();<span class="keyword">if</span>(item)item-&gt;type=cJSON_True;<span class="keyword">return</span> item;&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateFalse</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;cJSON *item=cJSON_New_Item();<span class="keyword">if</span>(item)item-&gt;type=cJSON_False;<span class="keyword">return</span> item;&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateBool</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    cJSON *item=cJSON_New_Item();</span><br><span class="line">    <span class="keyword">if</span>(item)item-&gt;type=b?cJSON_True:cJSON_False;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*createnumber需要修改valuedouble和valueint属性*/</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateNumber</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">    cJSON *item=cJSON_New_Item();</span><br><span class="line">    <span class="keyword">if</span>(item) &#123;</span><br><span class="line">        item-&gt;type=cJSON_Number;</span><br><span class="line">        item-&gt;valuedouble=num;</span><br><span class="line">        item-&gt;valueint=(<span class="keyword">int</span>)num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    cJSON *item=cJSON_New_Item();</span><br><span class="line">    <span class="keyword">if</span>(item) &#123;</span><br><span class="line">        item-&gt;type=cJSON_String;</span><br><span class="line">        item-&gt;valuestring=cJSON_strdup(<span class="built_in">string</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateArray</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;cJSON *item=cJSON_New_Item();<span class="keyword">if</span>(item)item-&gt;type=cJSON_Array;<span class="keyword">return</span> item;&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateObject</span><span class="params">(<span class="keyword">void</span>)</span>	</span>&#123;cJSON *item=cJSON_New_Item();<span class="keyword">if</span>(item)item-&gt;type=cJSON_Object;<span class="keyword">return</span> item;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数都是申请数组后，对每个元素调用create函数来生成对应类型的数据 */</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateIntArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *numbers,<span class="keyword">int</span> count)</span>		</span>&#123;<span class="keyword">int</span> i;cJSON *n=<span class="number">0</span>,*p=<span class="number">0</span>,*a=cJSON_CreateArray();<span class="keyword">for</span>(i=<span class="number">0</span>;a &amp;&amp; i&lt;count;i++)&#123;n=cJSON_CreateNumber(numbers[i]);<span class="keyword">if</span>(!i)a-&gt;child=n;<span class="keyword">else</span> suffix_object(p,n);p=n;&#125;<span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateFloatArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> *numbers,<span class="keyword">int</span> count)</span>	</span>&#123;<span class="keyword">int</span> i;cJSON *n=<span class="number">0</span>,*p=<span class="number">0</span>,*a=cJSON_CreateArray();<span class="keyword">for</span>(i=<span class="number">0</span>;a &amp;&amp; i&lt;count;i++)&#123;n=cJSON_CreateNumber(numbers[i]);<span class="keyword">if</span>(!i)a-&gt;child=n;<span class="keyword">else</span> suffix_object(p,n);p=n;&#125;<span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateDoubleArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *numbers,<span class="keyword">int</span> count)</span>	</span>&#123;<span class="keyword">int</span> i;cJSON *n=<span class="number">0</span>,*p=<span class="number">0</span>,*a=cJSON_CreateArray();<span class="keyword">for</span>(i=<span class="number">0</span>;a &amp;&amp; i&lt;count;i++)&#123;n=cJSON_CreateNumber(numbers[i]);<span class="keyword">if</span>(!i)a-&gt;child=n;<span class="keyword">else</span> suffix_object(p,n);p=n;&#125;<span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateStringArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **strings,<span class="keyword">int</span> count)</span>	</span>&#123;<span class="keyword">int</span> i;cJSON *n=<span class="number">0</span>,*p=<span class="number">0</span>,*a=cJSON_CreateArray();<span class="keyword">for</span>(i=<span class="number">0</span>;a &amp;&amp; i&lt;count;i++)&#123;n=cJSON_CreateString(strings[i]);<span class="keyword">if</span>(!i)a-&gt;child=n;<span class="keyword">else</span> suffix_object(p,n);p=n;&#125;<span class="keyword">return</span> a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_Duplicate</span><span class="params">(cJSON *item,<span class="keyword">int</span> recurse)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cJSON *newitem,*cptr,*nptr=<span class="number">0</span>,*newchild;</span><br><span class="line">	<span class="keyword">if</span> (!item) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	newitem = cJSON_New_Item();</span><br><span class="line">	<span class="keyword">if</span> (!newitem) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ~cJSON_IsReference 011111111</span></span><br><span class="line">    <span class="comment">// newitem-&gt;type      100000000</span></span><br><span class="line">	newitem-&gt;type = item-&gt;type &amp; (~cJSON_IsReference);</span><br><span class="line">    newitem-&gt;valueint = item-&gt;valueint;</span><br><span class="line">    newitem-&gt;valuedouble = item-&gt;valuedouble;</span><br><span class="line">	<span class="keyword">if</span> (item-&gt;valuestring) &#123;</span><br><span class="line">        newitem-&gt;valuestring = cJSON_strdup(item-&gt;valuestring);</span><br><span class="line">        <span class="keyword">if</span> (!newitem-&gt;valuestring) &#123;cJSON_Delete(newitem);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (item-&gt;<span class="built_in">string</span>) &#123; </span><br><span class="line">        newitem-&gt;<span class="built_in">string</span> = cJSON_strdup(item-&gt;<span class="built_in">string</span>);</span><br><span class="line">        <span class="keyword">if</span> (!newitem-&gt;<span class="built_in">string</span>) &#123;cJSON_Delete(newitem);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (!recurse) <span class="keyword">return</span> newitem; <span class="comment">// 没有递归的duplicate到这里就可以直接返回</span></span><br><span class="line">	cptr = item-&gt;child; <span class="comment">// 指向child节点</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (cptr)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 如果item-&gt;child是array类型，需要向下next迭代执行操作</span></span><br><span class="line">		newchild=cJSON_Duplicate(cptr,<span class="number">1</span>);		<span class="comment">/* 递归向下复制 */</span></span><br><span class="line">		<span class="keyword">if</span> (!newchild) &#123;cJSON_Delete(newitem);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="comment">// nptr &lt;--&gt; newchild</span></span><br><span class="line">		<span class="keyword">if</span> (nptr)	&#123;nptr-&gt;next=newchild,newchild-&gt;prev=nptr;nptr=newchild;&#125;	<span class="comment">/* If newitem-&gt;child already set, then crosswire -&gt;prev and -&gt;next and move on */</span></span><br><span class="line">		<span class="keyword">else</span>		&#123;newitem-&gt;child=newchild;nptr=newchild;&#125;					<span class="comment">/* Set newitem-&gt;child and move to it */</span></span><br><span class="line">		cptr=cptr-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    以item-&gt;child-&gt;next-&gt;next的结构为例，构建完新的newitem结构如图</span></span><br><span class="line"><span class="comment">    1. newitem-&gt;newchild(nptr)</span></span><br><span class="line"><span class="comment">    2. newitem-&gt;nptr1-&gt;newchild(nptr2)</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    也就是向后尾插节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">return</span> newitem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*跳过了几个转义字符串和注释后内容，用于将获取信息量压缩*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_Minify</span><span class="params">(<span class="keyword">char</span> *json)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *into = json;</span><br><span class="line">	<span class="keyword">while</span> (*json)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*json == <span class="string">' '</span>) json++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*json == <span class="string">'\t'</span>) json++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*json == <span class="string">'\r'</span>) json++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*json == <span class="string">'\n'</span>) json++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*json == <span class="string">'/'</span> &amp;&amp; json[<span class="number">1</span>] == <span class="string">'/'</span>)  <span class="keyword">while</span> (*json &amp;&amp; *json != <span class="string">'\n'</span>) json++; <span class="comment">/* 双斜杠注释 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*json==<span class="string">'/'</span> &amp;&amp; json[<span class="number">1</span>]==<span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="comment">/* 多行注释 */</span></span><br><span class="line">            <span class="keyword">while</span> (*json &amp;&amp; !(*json==<span class="string">'*'</span> &amp;&amp; json[<span class="number">1</span>]==<span class="string">'/'</span>)) json++; </span><br><span class="line">            json += <span class="number">2</span>; <span class="comment">// 跳过 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*json==<span class="string">'\"'</span>) &#123;</span><br><span class="line">            *into++ = *json++;</span><br><span class="line">            <span class="keyword">while</span> (*json &amp;&amp; *json != <span class="string">'\"'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (*json == <span class="string">'\\'</span>) *into++ = *json++;</span><br><span class="line">                *into++ = *json++;</span><br><span class="line">            &#125;</span><br><span class="line">            *into++ = *json++;</span><br><span class="line">        &#125; <span class="comment">/* 字符串 */</span></span><br><span class="line">		<span class="keyword">else</span> *into++ = *json++;	 <span class="comment">// 剩下的所有字符</span></span><br><span class="line">	&#125;</span><br><span class="line">	*into = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="项目疑惑"><a href="#项目疑惑" class="headerlink" title="项目疑惑"></a>项目疑惑</h1><h2 id="9-10"><a href="#9-10" class="headerlink" title="9.10"></a>9.10</h2><ul>
<li><p><code>print_number</code>函数，if语句的前两种情况不明白为什么要开2和21的空间大小。</p>
</li>
<li><p>类型的宏定义应该定义的是右移的位数？</p>
</li>
</ul>
<h2 id="9-12"><a href="#9-12" class="headerlink" title="9.12"></a>9.12</h2><ul>
<li><p><code>pow2gt()</code>求比needed大的最小2次幂数有什么用</p>
</li>
<li><p><code>print_string</code>函数，转义字符那段没看懂，为什么将<code>\b</code>-&gt;<code>b</code>？</p>
</li>
<li><p><code>depth</code>和<code>fmt</code>这两个参数没有搞懂</p>
<ul>
<li><strong>答：depth是在行中的相对位置，fmt是是否格式化的标志</strong></li>
</ul>
</li>
<li><p><code>update()</code>中，为什么不直接在原地<code>p-&gt;buffer+p-&gt;offset</code>位置之后申请<code>newsize - length</code>的空间</p>
</li>
<li><p>606行那个<code>i</code>好像有点问题（<code>fmt == 1</code>时被锁定为<code>i = depth</code>）感觉上面的for循环的循环变量不应该是i</p>
</li>
<li><p>调试的时候发现转义字符直接以”\n”类似的格式输出了，这明显是有问题的！</p>
<ul>
<li><strong>答：可能JSON格式输出的时候要求保留转义字符？</strong></li>
</ul>
</li>
</ul>
<h2 id="9-13"><a href="#9-13" class="headerlink" title="9.13"></a>9.13</h2><ul>
<li><p><code>ep</code>这个变量不知道是干啥的</p>
<ul>
<li><strong>答：错误类型的指针</strong></li>
</ul>
</li>
<li><p>utf16-&gt;utf8的原理不懂</p>
</li>
<li><p><code>PrintBuffered()</code>函数有两个return</p>
</li>
</ul>
<h2 id="9-15"><a href="#9-15" class="headerlink" title="9.15"></a>9.15</h2><ul>
<li><p>不知道<code>cJSON-&gt;valuestring</code>是干啥用的。</p>
</li>
<li><p>不知道cJSON_IsReference的具体定义到底是什么。</p>
<ul>
<li><strong>答：成员child指针或者valuestring指向的节点并不属于自己，自己仅仅是一个引用。因此，cJSON_Delete和其他相关的函数只会释放这个引用本身，而不会去释放child或者valuestring</strong></li>
</ul>
</li>
</ul>
<h2 id="9-17"><a href="#9-17" class="headerlink" title="9.17"></a>9.17</h2><ul>
<li><code>newitem-&gt;type=item-&gt;type&amp;(~cJSON_IsReference)</code>这句话不知道有什么用</li>
<li>知道<code>Minify</code>原理，不知道干啥用的</li>
</ul>
<h1 id="其他笔记"><a href="#其他笔记" class="headerlink" title="其他笔记"></a>其他笔记</h1><h2 id="大多数项目中的格式化写法"><a href="#大多数项目中的格式化写法" class="headerlink" title="大多数项目中的格式化写法"></a>大多数项目中的格式化写法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> cJSON_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>ifndef cJSON_h</code>这一系列是为了防止头文件被重复引用。</li>
<li><code>extern &quot;C&quot;</code>可以令这部分代码按C语言的方式进行编译。</li>
</ol>
<h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><p><a href="https://blog.csdn.net/gaojing303504/article/details/80346341" target="_blank" rel="noopener">参考文章</a></p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量 -&gt; 全局<strong>静态</strong>变量</p>
<ol>
<li>内存中位置：静态存储区（在整个程序的运行期间都存在）</li>
<li>初始化：自动初始化为0</li>
<li>作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。</li>
</ol>
<p>特点：</p>
<ol>
<li>不会被其他文件所访问和修改</li>
<li>其他文件可以使用相同名字的变量， 不会发生冲突</li>
</ol>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量 -&gt; 局部<strong>静态</strong>变量</p>
<ul>
<li>作用域：局部作用域</li>
</ul>
<p>概括来说，局部静态变量只是改变了变量在内存中的存储位置，从原来的栈存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，<strong>只不过我们不能再对他进行访问</strong>。</p>
<h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><p><strong>函数定义和声明默认情况下是extern</strong>，静态函数只是在声明他的文件中可见，不能被其他文件所用。</p>
<p>特点：其他文件可以定义相同名字的函数，无冲突</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>统计函数调用次数（设置一个static类型的局部静态变量）<ul>
<li>静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。</li>
</ul>
</li>
</ul>
<h2 id="strchr"><a href="#strchr" class="headerlink" title="strchr"></a>strchr</h2><p><code>char *strchr(const char *str, int c)</code>在参数<code>str</code>所指向的字符串中搜索第一次出现字符<code>c</code>的位置。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> str[] = <span class="string">"http://www.runoob.com"</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> ch = <span class="string">'.'</span>;</span><br><span class="line">   <span class="keyword">char</span> *ret;</span><br><span class="line"></span><br><span class="line">   ret = <span class="built_in">strchr</span>(str, ch);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"|%c| 之后的字符串是 - |%s|\n"</span>, ch, ret);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回以下结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|.| 之后的字符串是 - |.runoob.com|</span><br></pre></td></tr></table></figure>



<h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p><code>void *memcpy(void *str1, const void *str2, size_t n)</code> 从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 <strong>str1</strong></p>
<h2 id="free的模板"><a href="#free的模板" class="headerlink" title="free的模板"></a>free的模板</h2><p><a href="https://stackoverflow.com/questions/33170802/c-does-freeing-an-array-of-pointers-also-free-what-theyre-pointing-to/33170941" target="_blank" rel="noopener">参考解答</a></p>
<p>This all depends on how the array was allocated. I’ll give examples:</p>
<p>Example 1:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);     <span class="comment">// nope!</span></span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">array</span>= <span class="built_in">malloc</span>(<span class="number">10</span>);   <span class="comment">// request heap for memory</span></span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);         <span class="comment">// return to heap when no longer needed</span></span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> **<span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">array</span>= <span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">array</span>[i]= <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);        <span class="comment">// nope. You should do:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure>

<p>Ad. Example 1: <code>array</code> is allocated on the stack (“automatic variable”) and cannot be released by <code>free</code>. Its stack space will be released when the function returns.</p>
<p>Ad. Example 2: you request storage from the heap using <code>malloc</code>. When no longer needed, return it to the heap using <code>free</code>.</p>
<p>Ad. Example 3: you declare an array of pointers to characters. You first allocate storage for the array, then you allocate storage for each array element to place strings in. When no longer needed, you must first release the strings (with <code>free</code>) and then release the array itself (with <code>free</code>).</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cnblogs.com/skullboyer/p/8152157.html" target="_blank" rel="noopener">参考1</a></p>
<p><a href="https://www.cnblogs.com/cfzhang/p/99da02ab2f02520d458c415a5314f83d.html" target="_blank" rel="noopener">参考2</a></p>
<p><a href="https://blog.csdn.net/qq_36291381/article/details/83059629" target="_blank" rel="noopener">参考3</a></p>
<p><a href="https://blog.csdn.net/zengshunyao/article/details/42461241" target="_blank" rel="noopener">DBL_EPSILON和FLT_EPSILON</a></p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
