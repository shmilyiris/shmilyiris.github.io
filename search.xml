<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>9月散记</title>
    <url>/2020/09/06/9%E6%9C%88%E6%95%A3%E8%AE%B0/</url>
    <content><![CDATA[<p>开学了，学习计算机的时间不多了。</p>
<a id="more"></a>

<h1 id="9-6"><a href="#9-6" class="headerlink" title="9.6"></a>9.6</h1><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>10:30~11:00，计组–字符。</p>
<ul>
<li>字符</li>
<li>字符串</li>
<li>汉字编码</li>
</ul>
<p>11:00~12:00，开源项目Simple-Nes。</p>
<p>16:00~22:00，开源项目。</p>
<ul>
<li>安CMake和SFML，安装成功可是开源项目运行失败。</li>
<li>c/c++开源项目<ul>
<li>cJson</li>
<li>MyTinySTL</li>
<li>Tinyhttpd</li>
<li>Linux0.11</li>
<li>Redis</li>
</ul>
</li>
</ul>
<h1 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h1><h2 id="时间线-1"><a href="#时间线-1" class="headerlink" title="时间线"></a>时间线</h2><p>0:00~0:30，Leetcode每日一题，完成本周计划。</p>
<ul>
<li>前K个高频元素（哈希+二元组排序）</li>
</ul>
<p>8:30~9:30，六级听力+两篇阅读。</p>
<p>13:10~13:30，Leetcode一题。</p>
<ul>
<li>二叉树的所有路径（简单遍历）</li>
</ul>
<p>19:00~22:00，CJSON学习。第一次读开源项目，由于c知识的匮乏，确实有些晦涩难懂，不过随着时间的推移，应当能越来越熟练。</p>
<h1 id="9-8"><a href="#9-8" class="headerlink" title="9.8"></a>9.8</h1><h2 id="时间线-2"><a href="#时间线-2" class="headerlink" title="时间线"></a>时间线</h2><p>0:00~0:10，Leetcode每日一题。</p>
<ul>
<li>组合（回溯）</li>
</ul>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>2020暑假第三阶段学习</title>
    <url>/2020/08/11/2020%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>暑假的最后一段时间了，可能开学之后学业繁重就没时间弄计算机了，要抓紧最后的时间突破呀！8.12$\rightarrow$8.31.</p>
<a id="more"></a>

<h1 id="上期总结"><a href="#上期总结" class="headerlink" title="上期总结"></a>上期总结</h1><ol>
<li>计组剩余96节网课</li>
<li>汇编刚开了个头</li>
<li>Leetcode刷题已经达到177题</li>
<li>周赛已经参加4次</li>
<li>matlab基本语法已经掌握</li>
<li>操作系统已经学完了</li>
<li>学习的新算法<ol>
<li>滑动窗口（寻找局部最优解）</li>
<li>字典树（应用于对一组字符串进行快速匹配查询）</li>
<li>树状数组</li>
<li>位运算</li>
<li>前缀和思想</li>
<li>堆排序</li>
</ol>
</li>
</ol>
<p>由于这段时间执着于刷题，并没有对自己的时间表进行好好的规划，导致部分时间不知道自己要干什么了。下一段时间我要让自己每天都明确自己应该干啥，别盲目的学。</p>
<h1 id="本期任务"><a href="#本期任务" class="headerlink" title="本期任务"></a>本期任务</h1><p>以下时间表从回北京后开始实行</p>
<table>
<thead>
<tr>
<th></th>
<th>1245</th>
<th>36</th>
<th>7</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>9:00~10:00</td>
<td>晨刷</td>
<td>晨刷</td>
<td>晨刷</td>
<td>2easy or 1medium</td>
</tr>
<tr>
<td>10:30~12:00</td>
<td>汇编</td>
<td>学新算法</td>
<td>周赛</td>
<td></td>
</tr>
<tr>
<td>13:00~14:00</td>
<td>matlab</td>
<td>固体物理</td>
<td>–</td>
<td>matlab要适当完成小项目</td>
</tr>
<tr>
<td>14:30~16:00</td>
<td>Linux</td>
<td>刷新算法</td>
<td>Linux</td>
<td>多利用自己的虚拟机玩一玩</td>
</tr>
<tr>
<td>17:00~18:30</td>
<td>汇编</td>
<td>刷新算法</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>19:30~22:00</td>
<td>六级专项</td>
<td>–</td>
<td>周赛总结</td>
<td>六级专项主要是阅读、翻译和作文</td>
</tr>
<tr>
<td>22:00~24:00</td>
<td>计组</td>
<td>计组</td>
<td>计组</td>
<td>一天至少走三节课</td>
</tr>
<tr>
<td>0:30~1:30</td>
<td></td>
<td></td>
<td></td>
<td>每日一题</td>
</tr>
<tr>
<td>1:30~2:00</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>看书or听力 and 写总结</td>
</tr>
</tbody></table>
<p>剩余算法：</p>
<ol>
<li>归并排序、快速排序 √</li>
<li>KMP √</li>
<li>红黑树</li>
<li>最短路径</li>
<li>状态压缩</li>
<li>Morris遍历</li>
<li>马拉车算法</li>
</ol>
<h1 id="每日总结"><a href="#每日总结" class="headerlink" title="每日总结"></a>每日总结</h1><h2 id="8-12"><a href="#8-12" class="headerlink" title="8.12"></a>8.12</h2><p>0:30~1:30，每日一题，今天这题好非主流。</p>
<ul>
<li>克隆图</li>
</ul>
<p>10:00~12:00，三道Leetcode。</p>
<ul>
<li>奇偶链表(双指针)</li>
<li>猜数字大小(二分)</li>
<li>猜数字大小II(dp)</li>
</ul>
<p>13:30~14:30，六级阅读，错一个选词，两个阅读。</p>
<p>15:00~16:30，总结快速排序和归并排序算法。</p>
<p>17:00~17:40，matlab矩阵基本运算。</p>
<p>18:00~19:00，一道Leetcode，性能贼差，不想优化了。</p>
<ul>
<li>设计推特(hash+list)</li>
</ul>
<p>20:00~21:00，汇编语言两节。</p>
<ul>
<li><p>存储器</p>
</li>
<li><p>堆栈操作</p>
</li>
</ul>
<p>21:30~22:30，看计组，终于放弃了晦涩难懂的哈工大，转王道了。</p>
<p>22:40~23:00，找到了一个宝藏数据结构网课，讲的贼清楚。</p>
<ul>
<li>LCS问题（最长公共子序列）</li>
</ul>
<h2 id="8-13"><a href="#8-13" class="headerlink" title="8.13"></a>8.13</h2><p>0:00~1:40，Leetcode每日一题，只会用竖式做。</p>
<ul>
<li>字符串乘法</li>
</ul>
<p>10:00~14:30，全程淦kmp，反复看了25P视频，我只能说基本搞懂了。</p>
<p>15:30~16:30，两道Leetcode，与字符串匹配有关。</p>
<ul>
<li>实现strStr()</li>
<li>数组中的字符串匹配</li>
</ul>
<p>17:00~18:30，回北京，做六级阅读。</p>
<p>21:00~23:00，一道Leetcode简单题，但是很坑。</p>
<ul>
<li>重复叠加字符串匹配</li>
</ul>
<h2 id="8-14"><a href="#8-14" class="headerlink" title="8.14"></a>8.14</h2><p>0:30~0:40，Leetcode每日一题。</p>
<p>10:30~12:00，三道Leetcode。</p>
<ul>
<li>有效的完全平方数（完全平方数是奇数的和）</li>
<li>字符串中第一个唯一字符（hash）</li>
<li>数字转换为16进制数（位运算）</li>
</ul>
<p>17:00~21:00，三道Leetcode。</p>
<ul>
<li>根据身高重建队列（脑筋急转弯+插入排序）</li>
<li>二进制矩阵中的路径（BFS）</li>
<li>两数之和II</li>
</ul>
<p>21:30~23:00，冲浪，找到一个Linux的学习链接，在学完这个链接后立即上手做os实验。</p>
<p><a href="https://www.bilibili.com/video/BV12a4y1a7gQ?p=10" target="_blank" rel="noopener">Ubuntu 20.04 乌班图Linux课程_60集教学视频</a></p>
<p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_2_1_1_ex1.html" target="_blank" rel="noopener">os实验gitbook</a></p>
<h2 id="8-15"><a href="#8-15" class="headerlink" title="8.15"></a>8.15</h2><p>0:30~1:00，看了半天这个每日一题，懂了啥意思了，下次做铁定还不会。</p>
<ul>
<li>移除盒子</li>
</ul>
<p>10:30~11:30，三道Leetcode。</p>
<ul>
<li>FizzBuzz</li>
<li>找到所有数组中消失的数字</li>
<li>最长回文串</li>
</ul>
<p>17:00~19:30，三道Leetcode。</p>
<ul>
<li>四数之和</li>
<li>四数相加II</li>
<li>重复的子字符串</li>
</ul>
<p>21:30~23:00，三道Leetcode。</p>
<ul>
<li>斐波那契数</li>
<li>最长特殊序列I</li>
<li>最长特殊序列II（读不懂题我就是）</li>
</ul>
<h2 id="8-16"><a href="#8-16" class="headerlink" title="8.16"></a>8.16</h2><p>10:30~12:00，Leetcode周赛，前两道题秒速，第三题没思路，第四题4种思路都超时/溢出（bfs，dfs，递归，dp）。</p>
<ul>
<li>存在连续三个奇数的数组（暴力）</li>
<li>使数组中所有元素相等的最小操作数（数学）</li>
</ul>
<p>12:30~14:30，总结周赛，问题还是挺多的，主要是二分法的边界问题还没有彻底通透。</p>
<ul>
<li>两球之间的磁力（二分）</li>
<li>吃掉N个橘子的最小天数（bfs/贪心）</li>
</ul>
<p>15:00~16:15，我又研究了半天二分边界的问题，终于搞懂了！</p>
<p>19:30~23:00，Linux网课视频P10-P16。</p>
<ul>
<li>文件系统基本操作。</li>
</ul>
<h2 id="8-17"><a href="#8-17" class="headerlink" title="8.17"></a>8.17</h2><p>0:00~0:40，Leetcode每日一题。</p>
<ul>
<li>平衡二叉树</li>
</ul>
<p>0:40~1:40，两道Leetcode。</p>
<ul>
<li>相对名次（map）</li>
<li>最长回文子序列（dp）</li>
</ul>
<p>10:30~晚上，基本都在乱搞，罗列一下今天的Leetcode的题得了。</p>
<ul>
<li>学生出勤记录I</li>
<li>学生出勤记录II（不会）</li>
<li>回文子串（暴力/dp）</li>
<li>根据二叉树创建字符串（递归）</li>
</ul>
<h2 id="8-18"><a href="#8-18" class="headerlink" title="8.18"></a>8.18</h2><p>0:30~1:10，三道Leetcode。</p>
<ul>
<li>在二叉树中增加一行（bfs）</li>
<li>最长连续递增序列</li>
<li>寻找重复的子树（序列化，dfs）</li>
</ul>
<p>11:00~17:00，四道Leetcode。</p>
<ul>
<li>输出二叉树（bfs）</li>
<li>机器人能否返回原点</li>
<li>找到K个最接近的元素（二分+双指针）</li>
<li>分割数组为连续子序列（贪心）</li>
</ul>
<p>这两天学的有点乱啊，为了跟上学校的节奏，得开始早睡早起了。更新时间表吧，最后两周还是要坚持下去啊啊啊啊！（原则上要七点起床了）</p>
<table>
<thead>
<tr>
<th></th>
<th>1245</th>
<th>36</th>
<th>7</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>7:30~8:30</td>
<td>晨刷</td>
<td>晨刷</td>
<td>晨刷</td>
<td>2easy or 1medium</td>
</tr>
<tr>
<td>9:00~10:30</td>
<td>一套六级</td>
<td>新算法</td>
<td>回顾题解保持手感</td>
<td></td>
</tr>
<tr>
<td>10:30~12:00</td>
<td>汇编</td>
<td>新算法</td>
<td>周赛</td>
<td></td>
</tr>
<tr>
<td>13:00~14:00</td>
<td>matlab</td>
<td>固体物理</td>
<td>–</td>
<td>matlab要适当完成小项目</td>
</tr>
<tr>
<td>14:30~16:00</td>
<td>Linux</td>
<td>刷新算法</td>
<td>Linux</td>
<td>多利用自己的虚拟机玩一玩</td>
</tr>
<tr>
<td>17:00~18:30</td>
<td>汇编</td>
<td>刷新算法</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>19:30~22:00</td>
<td>六级专项</td>
<td>–</td>
<td>周赛总结</td>
<td>六级专项主要是翻译和作文</td>
</tr>
<tr>
<td>22:00~24:00</td>
<td>计组</td>
<td>计组</td>
<td>计组</td>
<td>一天至少走三节课</td>
</tr>
<tr>
<td>0:30~1:00</td>
<td>每日一题</td>
<td>每日一题</td>
<td>每日一题</td>
<td>完成就睡</td>
</tr>
</tbody></table>
<p>21:00~22:30，汇编语言。</p>
<ul>
<li>寻址方式</li>
</ul>
<p>23:00~24:00，一道Leetcode。</p>
<ul>
<li>最长上升子序列</li>
</ul>
<h2 id="8-19"><a href="#8-19" class="headerlink" title="8.19"></a>8.19</h2><p>0:45~1:20，一道Leetcode。</p>
<ul>
<li>最长递增子序列的个数</li>
</ul>
<p>11:00~24:00，全天Leetcode。</p>
<ul>
<li><p>二叉树最大宽度（bfs/递归）</p>
</li>
<li><p>验证回文字符串</p>
</li>
<li><p>二叉搜索树中的搜索</p>
</li>
<li><p>字符串解码（栈/递归）</p>
</li>
<li><p>删除字符串中所有相邻重复项（栈）</p>
</li>
</ul>
<p>我的电脑开始报警了，害怕😰</p>
<h2 id="8-20"><a href="#8-20" class="headerlink" title="8.20"></a>8.20</h2><p>0:00~2:00，两道Leetcode。</p>
<ul>
<li>链表中的下一个更大元素（单调栈）</li>
<li>扫雷游戏（dfs）</li>
</ul>
<p>11:00~17:00，一道Leetcode。</p>
<ul>
<li>冗余连接（dfs/拓扑排序/并查集）</li>
</ul>
<p>20:00~24:00，由于一个再次蓝屏影响了任务进度，考虑要不要换成Linux系统了。</p>
<ul>
<li>寻址方式</li>
</ul>
<h2 id="8-21-8-23"><a href="#8-21-8-23" class="headerlink" title="8.21-8.23"></a>8.21-8.23</h2><p>由于这两天考虑给小宝宝做视频，所以学习有点搁置了，不过还是抽空做了两次周练的题</p>
<ul>
<li>设计哈希集合（开放链表寻址法）</li>
<li>设计链表</li>
</ul>
<p>双周赛</p>
<ul>
<li>千位分隔数（模拟）</li>
<li>可以到达所有点的最少点数目（找入度为0）</li>
<li>得到目标数组的最少函数调用次数（模拟）</li>
<li>二维网格图中探测环（dfs）</li>
</ul>
<p>周赛</p>
<ul>
<li>圆形赛道上经过次数最多的扇区（模拟）</li>
<li>你可以获得的最大硬币数目（脑筋急转弯）</li>
<li>查找大小为M的最新分组（并查集/链表/倒序map）</li>
<li>石子游戏V（dp）</li>
</ul>
<h2 id="8-24-8-27"><a href="#8-24-8-27" class="headerlink" title="8.24-8.27"></a>8.24-8.27</h2><p>Leetcode刷题13道。</p>
<ul>
<li>重复的子字符串</li>
<li>将数据流变成多个不相交区间（平衡树，类似周赛203的第三题）</li>
<li>递增子序列（dfs）</li>
<li>最长重复子数组（dp）</li>
<li>电话号码的字母组合（dfs回溯，类似递增子序列的简化版？）</li>
<li>情侣牵手（分类讨论模拟）</li>
<li>二叉搜索树节点最小距离（中序遍历）</li>
<li>重新安排行程（dfs，但是不太好想）</li>
<li>在LR字符串中交换相邻字符（脑筋急转弯模拟）</li>
<li>叶子相似的树（中序遍历）</li>
<li>有序数组的平方（双指针）</li>
<li>最接近的三数之和（双指针（定一议二模型）/暴力）</li>
<li>账户合并（并查集）</li>
</ul>
<p>汇编语言，指令系统。</p>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>2020暑假第二阶段学习</title>
    <url>/2020/07/26/2020%E6%9A%91%E5%81%87%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>新的一周马上开始了，暑假也过了一半，感觉前一阶段的学习还算中规中矩，没有达到自己想要达到的目标，下一阶段继续加油！</p>
<a id="more"></a>
<p>该阶段主要任务：</p>
<ol>
<li>六级真题*8(每周至少要做两套)</li>
<li>Leetcode 70道题(一天至少要提交两道)</li>
<li>Leetcode 至少三次周赛(只能有一次缺席)</li>
<li>操作系统课</li>
<li>计组课</li>
<li>汇编课</li>
<li>固体物理课（原子链、能带理论）</li>
<li>Matlab使用方法</li>
<li>操作系统实验(在4、6学习完毕之后开展)</li>
</ol>
<p>保留任务：一个小项目（如果暑假没有时间也可以开学了完成）</p>
<h3 id="7-27"><a href="#7-27" class="headerlink" title="7.27"></a>7.27</h3><h4 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~1:10，Leetcode两道题。</p>
<ul>
<li>路径之和</li>
<li>判断子序列</li>
</ul>
<p>10:30~11:30，小刷六级，痛苦一天，13个听力，555</p>
<p>12:00~13:00，Leetcode两道树的题目，虽然DFS仍然稀烂无比，但上手题目渐渐有了自己的想法。</p>
<ul>
<li>二叉树中的链表</li>
<li>二叉树迭代器</li>
</ul>
<p>14:00~15:00，小刷六级阅读，全是马虎错，需刷题弥补。</p>
<p>16:00~18:00，操作系统第九章。</p>
<ul>
<li>死锁检测</li>
<li>死锁恢复</li>
<li>IPC（进程间通信）</li>
</ul>
<p>20:00~21:30，Leetcode两道树题目。</p>
<ul>
<li>路径总和II</li>
<li>路径总和III</li>
</ul>
<h3 id="7-28"><a href="#7-28" class="headerlink" title="7.28"></a>7.28</h3><h4 id="时间线-1"><a href="#时间线-1" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~2:00，Leetcode两道树题目。</p>
<ul>
<li>从前序与中序遍历序列构造二叉树</li>
<li>先序遍历构造二叉树</li>
</ul>
<p>11:00~13:14，二叉树的三种遍历的迭代方法，四道Leetcode。</p>
<ul>
<li>二叉树前序遍历</li>
<li>二叉树中序遍历</li>
<li>二叉树后序遍历</li>
<li>N叉树的前序遍历</li>
</ul>
<p>14:00~16:00，操作系统文件系统。</p>
<ul>
<li>文件描述符</li>
<li>文件别名</li>
<li>文件系统分类</li>
</ul>
<p>19:40~20:20，一道Leetcode。</p>
<ul>
<li>层序遍历II</li>
</ul>
<p>20:30~21:30，计组的系统总线的基础知识。</p>
<ul>
<li>总线结构</li>
<li>总线种类</li>
</ul>
<p>22:00~23:00，两道Leetcode的链表，Leetcode今天终于破百啦，庆祝撒花！！。</p>
<ul>
<li>分隔链表I</li>
<li>分隔链表II</li>
</ul>
<h4 id="算法下阶段重点"><a href="#算法下阶段重点" class="headerlink" title="算法下阶段重点"></a>算法下阶段重点</h4><ol>
<li>stl里面内置方法的复杂度总结（第六章）</li>
<li>并查集（第九章）</li>
<li>hash（四.2、十二.1）</li>
<li>最短路径算法（第十章）</li>
<li>树状数组（第十三章）</li>
<li>动态规划（第十一章）</li>
</ol>
<h3 id="7-29"><a href="#7-29" class="headerlink" title="7.29"></a>7.29</h3><h4 id="时间线-2"><a href="#时间线-2" class="headerlink" title="时间线"></a>时间线</h4><p>0:30~2:00，Typora下载，汇编语言第一章部分内容。<a href="https://www.dazhuanlan.com/2019/12/13/5df30035bec19/" target="_blank" rel="noopener">如何用typora+hexo的风格在文档中添加图片</a></p>
<p>10:30~12:30，STL库用法以及时间复杂度整理。</p>
<ul>
<li>vector</li>
<li>set</li>
<li>string</li>
</ul>
<p>12:30~13:00，Leetcode一道dp题。</p>
<ul>
<li>不同路径I</li>
<li>不同路径II</li>
</ul>
<p>14:00~16:00，Leetcode一道。</p>
<ul>
<li>迷你语法解析器</li>
</ul>
<p>18:00~19:00，STL库总结。</p>
<ul>
<li>queue</li>
<li>map</li>
<li>stack</li>
<li>priority_queue</li>
<li>pair</li>
</ul>
<p>21:30~22:20，六级听力，进步了错两道。</p>
<p>22:40~23:10，操作系统文件。</p>
<ul>
<li>虚拟文件系统</li>
<li>数据缓存</li>
</ul>
<p>23:40~24:00，不同路径II的滚动数组优化。</p>
<h3 id="7-30"><a href="#7-30" class="headerlink" title="7.30"></a>7.30</h3><h4 id="时间线-3"><a href="#时间线-3" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~1:40，两道Leetcode。</p>
<ul>
<li>不同路径III</li>
<li>整数拆分</li>
</ul>
<p>10:00~13:00，Leetcode双指针专题。</p>
<ul>
<li>删除排序数组的重复项II</li>
<li>反转字符串</li>
<li>三数之和</li>
</ul>
<p>14:00~18:00，Leetcode双指针。这题是真的恶心，吐了。</p>
<ul>
<li>和相同的二元子数组</li>
</ul>
<p>19:00~21:00，继续淦！Leetcode双指针，又吐了，简单题做了好久。</p>
<ul>
<li>划分字母区间</li>
<li>移动零</li>
<li>反转字符串中的元音字母</li>
</ul>
<h3 id="7-31-8-1"><a href="#7-31-8-1" class="headerlink" title="7.31-8.1"></a>7.31-8.1</h3><h4 id="时间线-4"><a href="#时间线-4" class="headerlink" title="时间线"></a>时间线</h4><p>23:30~24:00，三道Leetcode。</p>
<ul>
<li>验证回文串</li>
<li>魔术索引</li>
</ul>
<p>10:30~14:00，两道Leetcode。</p>
<ul>
<li>验证二叉搜索树</li>
<li>通过删除字母匹配到字典里最长单词</li>
</ul>
<p>14:30~18:30，学习并查集，一道Leetcode不过好像没用上。</p>
<ul>
<li>最长连续序列</li>
</ul>
<p>22:00~22:30，一道Leetcode。</p>
<ul>
<li>朋友圈</li>
</ul>
<p>22:40~23:30，操作系统完结。</p>
<ul>
<li>文件分配</li>
<li>空闲空间列表</li>
</ul>
<h3 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h3><h4 id="时间线-5"><a href="#时间线-5" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~1:00，两道Leetcode。</p>
<ul>
<li>杨辉三角形</li>
<li>二叉树展开为链表（缺两种方法总结）</li>
</ul>
<p>10:30~12:00，Leetcode周赛，虽然这次题目好像比较简单，但是第一次做出来三道题感觉还不错！</p>
<p>13:00~14:00，每日一题的另外两种解法。</p>
<p>14:30~23:30，MatLab基础语法，两道Leetcode。</p>
<ul>
<li>环形链表II</li>
<li>最大得分</li>
</ul>
<h3 id="8-3"><a href="#8-3" class="headerlink" title="8.3"></a>8.3</h3><h4 id="时间线-6"><a href="#时间线-6" class="headerlink" title="时间线"></a>时间线</h4><p>0:20~0:40，Leetcode每日一题。</p>
<ul>
<li>字符串相加</li>
</ul>
<p>1:00~1:30，汇编第一章。</p>
<p>11:30~15:30，学完Matlab基础语法。</p>
<p>16:50~18:30，三道Leetcode。</p>
<ul>
<li>推多米诺</li>
<li>大样本统计</li>
<li>相同的树</li>
</ul>
<p>21:30~24:00，Leetcode四道题。</p>
<ul>
<li>有序链表转换二叉搜索树（递归分治）</li>
<li>买卖股票最佳时机I（简单遍历，维护i前的最小值）</li>
<li>买卖股票最佳时机II（贪心，二维动态）</li>
<li>买卖股票最佳时机III（三维动态）</li>
</ul>
<h3 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h3><h4 id="时间线-7"><a href="#时间线-7" class="headerlink" title="时间线"></a>时间线</h4><p>0:30~2:00，计算机组成原理。</p>
<ul>
<li>总线控制</li>
</ul>
<p>11:30~13:00，两道Leetcode。</p>
<ul>
<li>二叉树的最大路径和（困难，简单递归）</li>
<li>杨辉三角II（模拟）</li>
</ul>
<p>14:30~16:00，MatLab绘图基础。</p>
<p>22:00~23:00，两道Leetcode。</p>
<ul>
<li>只出现一次的数字I</li>
<li>只出现一次的数字II<br>（hashset，位运算）</li>
</ul>
<h3 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h3><h4 id="时间线-8"><a href="#时间线-8" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~2:00，Leetcode三道题。</p>
<ul>
<li>打家劫舍I（dp）</li>
<li>打家劫舍II（分类后简化成I）</li>
<li>打家劫舍III（记忆化DFS）</li>
</ul>
<p>11:00~14:00，刷bp的reaction，就当是英语听力吧555</p>
<p>15:30~18:00，两道Leetcode。</p>
<ul>
<li>求根到叶子节点数字之和（每层递归记录当前和）</li>
<li>买卖股票的最佳时机IV（根据II推导）</li>
</ul>
<p>18:30~19:30，Matlab画图的子图、标注等知识。</p>
<p>20:00~22:30，学习树状数组，利用树状数组解计算右侧小于当前元素个数。</p>
<h4 id="今日遗留"><a href="#今日遗留" class="headerlink" title="今日遗留"></a>今日遗留</h4><ol>
<li>每日一题，回文对。</li>
<li>字典树</li>
<li>红黑树</li>
<li>sort方法没有完全掌握（排序pair结构出现问题）</li>
<li>以maxn的方式开数组，是否空间复杂度极高。</li>
</ol>
<h3 id="8-6"><a href="#8-6" class="headerlink" title="8.6"></a>8.6</h3><h4 id="时间线-9"><a href="#时间线-9" class="headerlink" title="时间线"></a>时间线</h4><p>21:00~23:00，学字典树，弄懂了昨日的每日一题。</p>
<h4 id="今日遗留-1"><a href="#今日遗留-1" class="headerlink" title="今日遗留"></a>今日遗留</h4><ul>
<li>Leetcode实现trie这题</li>
<li>整理200次周赛的2、3题</li>
</ul>
<h3 id="8-7"><a href="#8-7" class="headerlink" title="8.7"></a>8.7</h3><h4 id="时间线-10"><a href="#时间线-10" class="headerlink" title="时间线"></a>时间线</h4><p>10:30~11:30，回文串暴力解法（不要拼接字符串），一道Leetcode。</p>
<ul>
<li>实现tried树</li>
</ul>
<p>12:00~13:40，一道Leetcode。</p>
<ul>
<li>单词搜索II(trie树+dfs)</li>
</ul>
<p>14:40~15:40，一道Leetcode。</p>
<ul>
<li>恢复空格(trie树+dp)</li>
</ul>
<p>15:40~16:00，周赛的2、3题总结，我的方法居然还都不错？</p>
<p>16:30~17:30，Matlab二维图学完。</p>
<p>18:00~19:00，三种方法做Leetcode。</p>
<ul>
<li>长度最小的子数组<ul>
<li>暴力</li>
<li>前缀和</li>
<li>双指针(滑动窗口)</li>
</ul>
</li>
</ul>
<p>20:00~21:00，两道Leetcode，总结滑动数组思想。</p>
<ul>
<li>二叉树中第k小的元素(迭代中序遍历)</li>
<li>单词搜索I（dfs）<br>Leetcode 150道里程碑！</li>
</ul>
<p>22:00~23:00，计组结束总线控制。</p>
<ul>
<li>同步通信</li>
<li>异步通信</li>
<li>半同步通信</li>
<li>分离式通信</li>
</ul>
<h4 id="小笔记"><a href="#小笔记" class="headerlink" title="小笔记"></a>小笔记</h4><p>回溯避免重复访问的两种方式：</p>
<ol>
<li>设置vis数组<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">dfs();</span><br><span class="line">vis[i][j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li>
<li>访问后，修改为其他标记<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> cur = board[i][j];</span><br><span class="line">board[i][j] = <span class="string">"#"</span>;</span><br><span class="line">dfs();</span><br><span class="line">board[i][j] = cur;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="今日遗留-2"><a href="#今日遗留-2" class="headerlink" title="今日遗留"></a>今日遗留</h4><ol>
<li>莫里斯遍历</li>
<li>三种遍历的优化（原来的ifelse有点啰嗦）</li>
<li>快排、堆排序</li>
</ol>
<h3 id="8-8"><a href="#8-8" class="headerlink" title="8.8"></a>8.8</h3><h4 id="时间线-11"><a href="#时间线-11" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~1:00，Leetcode每日一题。</p>
<ul>
<li>恢复二叉搜索树（中序+迭代）</li>
</ul>
<p>1:10~1:40，一套英语听力。</p>
<p>10:00~10:30，两道Leetcode。</p>
<ul>
<li>用栈实现队列</li>
<li>数组中第k个最大元素</li>
</ul>
<p>11:30~14:30，学习堆排序，重做数组中第k个最大元素。</p>
<p>14:45~16:00，Matlab的基本三维图绘制。</p>
<ul>
<li>曲线图</li>
<li>曲面图<ul>
<li>网格图</li>
<li>网面图</li>
<li>柱、球</li>
</ul>
</li>
</ul>
<p>17:00~18:00，一道Leetcode。</p>
<ul>
<li>完全二叉树的节点个数（递归）</li>
</ul>
<p>19:00~20:00，一道Leetcode。</p>
<ul>
<li>滑动窗口最大值（滑动窗口/双端队列）</li>
</ul>
<p>22:30~24:00，Leetcode双周赛。</p>
<ul>
<li>第k个缺失的正整数（模拟）</li>
<li>k次操作转变字符串（模拟）</li>
</ul>
<h3 id="8-9"><a href="#8-9" class="headerlink" title="8.9"></a>8.9</h3><h4 id="时间线-12"><a href="#时间线-12" class="headerlink" title="时间线"></a>时间线</h4><p>0:10~0:30，双周赛第三题</p>
<ul>
<li>平衡括号字符串的最小插入次数（字符串匹配，栈）</li>
</ul>
<p>9:30~10:30，Leetcode每日一题。</p>
<ul>
<li>复原IP地址(枚举递归)</li>
</ul>
<p>10:30~12:00，Leetcode周赛，3、4真的不会（最近做了很多前缀和题目，老实说3没有往这方面想挺不应该的），1题真的倒胃。</p>
<ul>
<li><p>整理字符串（模拟）</p>
</li>
<li><p>找出第N个二进制字符串的第K位（模拟）</p>
</li>
</ul>
<p><strong>ps：深感自己算法知识不足。下一阶段要追求广度，力求先将算法的方法概况先掌握个大概，先不要求深度。</strong></p>
<ul>
<li>前缀和思想√</li>
<li>状态压缩</li>
<li>位运算√</li>
<li>字符串匹配</li>
<li>莫里斯遍历</li>
</ul>
<p>13:30~15:30，两道前缀和的题。</p>
<ul>
<li>和为K的子数组</li>
<li>和为目标值的最大不重叠非空子数组数目</li>
</ul>
<p>15:45~17:00，位运算总结。</p>
<p>19:00~21:00，磕了一道dp（我太菜了），白天的周赛压轴题</p>
<ul>
<li>切棍子的最小成本</li>
</ul>
<h3 id="8-10"><a href="#8-10" class="headerlink" title="8.10"></a>8.10</h3><h4 id="时间线-13"><a href="#时间线-13" class="headerlink" title="时间线"></a>时间线</h4><p>0:00~2:00，Leetcode两道题。</p>
<ul>
<li>找出最长的超赞子字符串（前缀和+位运算）</li>
<li>计数二进制子串</li>
</ul>
<p>11:00~14:00，Leetcode以前遗留的位运算的题目。</p>
<p>15:00~19:00，还是淦位运算的题，真的不好想，自己脑子也笨，题解还得吃半天，由于感觉学习成本有点高，打算先不继续向下拓展，要不有损信心。</p>
<ul>
<li>只出现一次的数字II</li>
<li>只出现一次的数字III</li>
<li>数字范围按位与</li>
</ul>
<p>20:00~23:00，看计组的课，不知道为啥，计组这也好难懂，最近学啥都不顺利qwq。</p>
<ul>
<li>存储器结构</li>
<li>半导体存储器简介</li>
<li>存储字长、存储单元、地址线、寻址空间……的联系</li>
</ul>
<h3 id="8-11"><a href="#8-11" class="headerlink" title="8.11"></a>8.11</h3><p>0:30~1:30，一道回文串的题目，这个递归思想看了半天才看懂。</p>
<p>1:30~2:30，三道Leetcode简单题。</p>
<ul>
<li>删除链表中的节点</li>
<li>2的幂（位运算）</li>
<li>回文链表（快慢指针+反转）</li>
</ul>
<p>10:30~15:00，四道Leetcode。</p>
<ul>
<li>3的幂</li>
<li>4的幂（位运算）</li>
<li>灯泡开关（脑筋急转弯）</li>
<li>零钱兑换（dfs/记忆化搜索/贪心）</li>
<li>零钱兑换II（dp）</li>
</ul>
<p>16:30~17:30，英语六级，听力错仨还可以。</p>
<p>18:00~19:00，写下一阶段文档。</p>
<p>21:30~23:30，汇编语言三节（相当于是计组的复习和扩展）。</p>
<ul>
<li>微机基本结构</li>
<li>寄存器</li>
<li>存储器</li>
</ul>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>Basic Javascript学习笔记</title>
    <url>/2020/06/30/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>　　昨天刚刚搭建了自己的博客，这也算是自己写的第一个blog吧（正好也是第一次markdown，顺便感受一下哈哈）。</p>
<p>　　最近刚刚学习到前端的相关知识，在<a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="noopener">FreeCodeCamp</a>上练习<a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/basic-javascript/" target="_blank" rel="noopener">Basic Javascript</a>的基础知识，知识体系有点混乱，这篇笔记也是帮助自己理清一下思路。那么就让我开始吧~（麦子式破音）</p>
<a id="more"></a>

<h2 id="Basic-javascript"><a href="#Basic-javascript" class="headerlink" title="Basic javascript"></a>Basic javascript</h2><p><em>注：不按系统知识记，只记录自己不熟的知识点</em></p>
<hr>
<h3 id="字符串不变性"><a href="#字符串不变性" class="headerlink" title="字符串不变性"></a>字符串不变性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> usedString = <span class="string">"Bob"</span>;</span><br><span class="line">usedString[<span class="number">0</span>] = <span class="string">'J'</span>;</span><br></pre></td></tr></table></figure>
<p>以上这段代码并不能修改<code>usedString</code> 为<code>&quot;Job&quot;</code>的输出，这就是字符串的不变性。要想实现替换的话，只能将字符串重新赋值。</p>
<hr>
<h3 id="push-pop-shift-unshift方法"><a href="#push-pop-shift-unshift方法" class="headerlink" title="push, pop, shift, unshift方法"></a>push, pop, shift, unshift方法</h3><ul>
<li>push()将括号中的数据追加到数组的末尾</li>
<li>pop()用来抛出数组的末尾数据，同时还可以将该数据赋给一个变量</li>
<li>shift()抛出第一个数据，其他和pop()一样</li>
<li>unshift()将该数据移到数组的开头</li>
</ul>
<p><strong>用这些方法能够很容易的实现经典的数据结构–堆栈</strong></p>
<hr>
<h3 id="对象（python的字典）"><a href="#对象（python的字典）" class="headerlink" title="对象（python的字典）"></a>对象（python的字典）</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="new详解"><a href="#new详解" class="headerlink" title="new详解"></a>new详解</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">constructor</span>[([arguments])]; //new的声明</span><br></pre></td></tr></table></figure>
<p>对两个参数的解释为</p>
<ul>
<li><code>constructor</code>一个指定对象实例的类型的<strong>类或函数</strong>。</li>
<li><code>arguments</code>一个用于被 constructor 调用的参数列表。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">&#125; <span class="comment">// 这个function其实就是个(构造)函数，ES6中改进成了类中的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car(<span class="string">'Eagle'</span>, <span class="string">'Talon TSi'</span>, <span class="number">1993</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car1.make);</span><br><span class="line"><span class="comment">// expected output: "Eagle"</span></span><br></pre></td></tr></table></figure>
<p><code>new</code>操作符做了什么？</p>
<ol>
<li>创建obj{}对象</li>
<li>将函数的作用域赋给新对象</li>
<li>执行函数（为对象初始化，添加..）</li>
<li>考察第3步返回的返回值，无返回值或者返回一个非对象值时，则将创建的新对象返回，否则会将返回值作为新对象返回。</li>
</ol>
<p>如果代码层面看的更深，当<code>new Foo(..)</code>执行时：</p>
<ol>
<li>一个继承自<code>Foo.prototype</code>的新对象被创建。（<code>prototype</code>-&gt;原型对象）</li>
<li>使用指定参数调用构造函数<code>Foo</code>，并<strong>将<code>this</code>绑定到新创建的对象，也就是没有指定参数列表，<code>Foo</code>不带任何参数调用的情况</strong>（然后开始执行函数）。</li>
<li>由构造函数返回的对象就是<code>new</code>表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li>
</ol>
<h4 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h4><h5 id="中括号访问"><a href="#中括号访问" class="headerlink" title="中括号访问"></a>中括号访问</h5><p>中括号访问可以进行多层寻找，而且中间的属性名称可以是来自于某个变量的值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> johnsonOneOfTheSportHobby;</span><br><span class="line"><span class="keyword">var</span> myInfo=&#123;</span><br><span class="line">    name: <span class="string">"Johnson"</span>,</span><br><span class="line">    sex: <span class="string">"male"</span>,</span><br><span class="line">    hobby_sport: &#123;<span class="string">"basketball"</span>, <span class="string">"swimming"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">johnsonOneOfTheSportHobby = myInfo[hobby_sport][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h5 id="点操作符访问"><a href="#点操作符访问" class="headerlink" title="点操作符访问"></a>点操作符访问</h5><p>点操作符的使用场景比较局限。只有属性名称已知的话，才可以使用点操作符，<strong>变量名+点操作符访问变量的操作不合法</strong>，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> johnsonOneOfTheSportHobby;</span><br><span class="line"><span class="keyword">var</span> property = sex;</span><br><span class="line"><span class="keyword">var</span> myInfo=&#123;</span><br><span class="line">    name: <span class="string">"Johnson"</span>,</span><br><span class="line">    sex: <span class="string">"male"</span>,</span><br><span class="line">    hobby_sport: &#123;<span class="string">"basketball"</span>, <span class="string">"swimming"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">johnsonSex = myInfo.property; <span class="comment">// 不正确</span></span><br><span class="line">johnsonSex = myInfo.sex; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="更新方式"><a href="#更新方式" class="headerlink" title="更新方式"></a>更新方式</h4><p><em>以下中括号方式修改也可</em></p>
<h5 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> myInfo.sex; <span class="comment">// 删除myInfo的sex属性</span></span><br></pre></td></tr></table></figure>
<h5 id="更改数据"><a href="#更改数据" class="headerlink" title="更改数据"></a>更改数据</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myInfo.sex = <span class="string">"female"</span>; <span class="comment">// 更改Info中的属性</span></span><br></pre></td></tr></table></figure>
<h5 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myInfo.job = <span class="string">"coder"</span>;  <span class="comment">// 添加job属性，并将数据初始化为coder</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="判断方式"><a href="#判断方式" class="headerlink" title="判断方式"></a>判断方式</h4><h5 id="判断属性是否存在"><a href="#判断属性是否存在" class="headerlink" title="判断属性是否存在"></a>判断属性是否存在</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(myInfo.hasOwnProperty(job) == <span class="literal">false</span>)&#123;</span><br><span class="line">    myInfo.job = <span class="string">"coder"</span>;  </span><br><span class="line">    <span class="comment">// 如果没有job属性，则添加该属性并初始化为coder</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="JavaScript-Object-Notation-JSON"><a href="#JavaScript-Object-Notation-JSON" class="headerlink" title="JavaScript Object Notation(JSON)"></a>JavaScript Object Notation(JSON)</h4><p><strong>JSON使用Javascript对象的格式来存储数据</strong>，JSON是灵活的，因为它允许多种数据结构的任意组合，下面来看一个JSON的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyFriend=[</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">"Iris"</span>,</span><br><span class="line">        sex: <span class="string">"female"</span>,</span><br><span class="line">        hobby_sport: [<span class="string">"basketball"</span>, <span class="string">"movie"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">"Kevin Durant"</span>,</span><br><span class="line">        sex: <span class="string">"male"</span>,</span><br><span class="line">        hobby_sport: [<span class="string">"basketball"</span>, <span class="string">"chatting"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>JSON可以按一种类似串联的方式，来访问格式中的某个数据，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">girlfriendHobby = MyFriend[<span class="number">0</span>].hobby_sport[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6学习笔记</title>
    <url>/2020/07/01/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/es6/" target="_blank" rel="noopener">这是ES 6的FCC链接</a><br><a href="https://www.runoob.com/w3cnote/es6-concise-tutorial.html" target="_blank" rel="noopener">ES 6</a>是Javascript语言的新一代标准，加入了很多新的功能和语法。</p>
<a id="more"></a>
<h2 id="ES-6"><a href="#ES-6" class="headerlink" title="ES 6"></a>ES 6</h2><h3 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h3><ul>
<li><strong>let关键字只在let命令所在的代码块里有效</strong><br>为了帮助理解这个<code>代码块</code>的概念，下面介绍一个实例：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'function scope'</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="string">'block scope'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Block scope i is: '</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Function scope i is: '</span>, i);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码最后会返回结果<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Block scope i is block scope</span><br><span class="line">Function scope is fuction scope</span><br></pre></td></tr></table></figure>
也就是i的赋值只在对应声明的function大模块和if模块里才会生效，let关键字可以连续声明两次变量而不报错，原因也是<strong>这两次let在不同的模块里</strong>。</li>
</ul>
<hr>
<h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>const声明的常量类似于一个指针，指向一个引用，而且const关键字也是在<strong>块区域内有效</strong>。另外我之前以为能够完全锁定一个变量，实则不然：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// 不合法</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">8</span>;  <span class="comment">// 合法，s被改为[5, 6, 8]</span></span><br></pre></td></tr></table></figure>
<p>也就是类似于这种对象，const只能保证无法直接更改原对象，但是像这种逐一修改的方式仍能改变原对象。<br>那么有没有更保险的方法，能够“锁住”对象呢？Javascript提供了一种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.freeze(obj);  </span><br><span class="line"><span class="comment">// Object.freeze()函数能够使得针对obj的修改全部被忽视</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在JavaScript中，通常不需要为函数命名，特别是在将一个函数作为参数传递给另一个函数时。取而代之的是，我们创建内联函数。从而不需要命名这些函数，因为我们不会在其他地方重用它们。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="string">"default name"</span>;</span><br><span class="line">    <span class="keyword">return</span> myVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段简单的函数可以被替换成下面的类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="string">"default name"</span>;</span><br><span class="line">    <span class="keyword">return</span> myVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而当函数只有返回值语句是，以上写法仍能够被简化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"default name"</span>;</span><br></pre></td></tr></table></figure>
<p>这三段代码都是等效的，显然第三种是最高效的写法。</p>
<p>若这个内联函数有参数，则应该被写成如下的样子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = <span class="function">(<span class="params">name = <span class="string">"default"</span></span>) =&gt;</span> name + <span class="string">"name"</span>;</span><br></pre></td></tr></table></figure>
<p>和其他语言一样，若传递了一个有意义的实参，参数值以传递值为准。</p>
<hr>
<h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>为了帮助我们创建更灵活的函数，ES6为函数参数引入了rest参数。使用rest参数，您可以创建具有可变数量参数的函数。这些参数存储在一个<strong>数组</strong>中，<strong>以后可以从函数内部访问该数组</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">howMany</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"You have passed "</span> + args.length + <span class="string">" arguments."</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(howMany(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)); </span><br><span class="line"><span class="comment">// You have passed 3 arguments.</span></span><br><span class="line"><span class="built_in">console</span>.log(howMany(<span class="string">"string"</span>, <span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123; &#125;)); </span><br><span class="line"><span class="comment">// You have passed 4 arguments.</span></span><br></pre></td></tr></table></figure>
<p>从这个FCC的实例中，可以看出来…args的length是与传入参数的数量有关的，而传入的参数共同构成了一个数组，数组名为<code>args</code>。</p>
<hr>
<h3 id="spread操作符"><a href="#spread操作符" class="headerlink" title="spread操作符"></a>spread操作符</h3><p>ES6引入了spread操作符，它允许我们在需要多个参数或元素的地方展开数组和其他表达式，这增强了代码的可读性和高效性。<code>···arr</code>返回一个未打包的数组。换句话说，它分散了数组。但是，spread操作符只能就地工作，比如在函数的参数或数组文字中。下面来看两个实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">6</span>, <span class="number">89</span>, <span class="number">3</span>, <span class="number">45</span>];</span><br><span class="line"><span class="keyword">const</span> maximus = <span class="built_in">Math</span>.max(...arr); <span class="comment">// returns 89</span></span><br><span class="line"><span class="keyword">const</span> spreaded = ...arr; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="析构赋值-destructing-assignment"><a href="#析构赋值-destructing-assignment" class="headerlink" title="析构赋值(destructing assignment)"></a>析构赋值(destructing assignment)</h3><p>析构赋值这部分涉及到的知识点比较多，我直接上实例：</p>
<h4 id="针对对象的赋值方式"><a href="#针对对象的赋值方式" class="headerlink" title="针对对象的赋值方式"></a>针对对象的赋值方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">name</span>:<span class="string">'John Doe'</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统的赋值方式</span></span><br><span class="line"><span class="keyword">const</span> userName = user.name;</span><br><span class="line"><span class="keyword">const</span> userAge = user.age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值方式一</span></span><br><span class="line"><span class="keyword">const</span> &#123;userName1, userAge1&#125; = user;</span><br><span class="line"><span class="comment">//赋值方式二</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>:userName2, <span class="attr">age</span>:userAge2&#125; = user;</span><br></pre></td></tr></table></figure>
<p>同理，这样的方式对嵌套的对象仍适用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  johnDoe: &#123; </span><br><span class="line">    age: <span class="number">34</span>,</span><br><span class="line">    email: <span class="string">'johnDoe@freeCodeCamp.com'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">johnDoe</span>: &#123; age, email &#125;&#125; = user;</span><br><span class="line"><span class="comment">//赋值方式一</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">johnDoe</span>: &#123; <span class="attr">age</span>: userAge, <span class="attr">email</span>: userEmail &#125;&#125; = user;</span><br><span class="line"><span class="comment">//赋值方式二</span></span><br></pre></td></tr></table></figure>

<h4 id="针对数组的赋值方式"><a href="#针对数组的赋值方式" class="headerlink" title="针对数组的赋值方式"></a>针对数组的赋值方式</h4><p>我们可以把这种方式看成是”省略”，这在python的编程思想中也比较常见（个人认为）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b,,, c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1,2,5</span></span><br></pre></td></tr></table></figure>
<p>除此以外rest参数在数组中也是适用的，如果将中间的三个逗号替换成rest：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>[a, b, ...arr] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [3,4,5,6,7]</span></span><br></pre></td></tr></table></figure>

<h4 id="针对函数参数的赋值方式"><a href="#针对函数参数的赋值方式" class="headerlink" title="针对函数参数的赋值方式"></a>针对函数参数的赋值方式</h4><p>修改前的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">profileData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age, nationality, location &#125; = profileData;</span><br><span class="line">  <span class="comment">// do something with these variables</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">&#123; name, age, nationality, location &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* do something with these fields */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这删除了一些额外的行，使我们的代码看起来整洁。这样做的另一个好处是<strong>不必在函数中操作整个对象，只需要在函数中复制所需的字段</strong>。<br>利用第二个好处我们再来修改一个实例，已知<code>stats</code>是一个<code>max</code>和<code>min</code>属性的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">stats</span>) =&gt;</span> (stats.max + stats.min) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">&#123;max, min&#125;</span>) =&gt;</span> (max + min) / <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，此处<code>max</code>和<code>min</code>并不一定是<code>stats</code>的全部属性，只要其属性名在<code>stats</code>中有同名的就可以。</p>
<hr>
<h3 id="模板语法和分隔符"><a href="#模板语法和分隔符" class="headerlink" title="模板语法和分隔符"></a>模板语法和分隔符</h3><p>这涉及到<code>$</code>和<code>`</code>两个符号，在<code>`</code>包围下的<code>$</code>符号才会生效：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Zodiac Hasbro"</span>,</span><br><span class="line">  age: <span class="number">56</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template literal with multi-line and string interpolation</span></span><br><span class="line"><span class="keyword">const</span> greeting = <span class="string">`Hello, my name is <span class="subst">$&#123;person.name&#125;</span>!</span></span><br><span class="line"><span class="string">I am <span class="subst">$&#123;person.age&#125;</span> years old.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting); <span class="comment">// prints</span></span><br><span class="line"><span class="comment">// Hello, my name is Zodiac Hasbro!</span></span><br><span class="line"><span class="comment">// I am 56 years old.</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="对象词法扩展"><a href="#对象词法扩展" class="headerlink" title="对象词法扩展"></a>对象词法扩展</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCar</span>(<span class="params">make, model, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 简写变量</span></span><br><span class="line">    make,  <span class="comment">// 等同于 make: make</span></span><br><span class="line">    model, <span class="comment">// 等同于 model: model</span></span><br><span class="line">    value, <span class="comment">// 等同于 value: value</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 属性可以使用表达式计算值</span></span><br><span class="line">    [<span class="string">'make'</span> + make]: <span class="literal">true</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 忽略 `function` 关键词简写对象函数</span></span><br><span class="line">    depreciate() &#123;</span><br><span class="line">      <span class="keyword">this</span>.value -= <span class="number">2500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car = getCar(<span class="string">'Barret'</span>, <span class="string">'Lee'</span>, <span class="number">40000</span>);</span><br><span class="line"><span class="comment">// output: &#123;</span></span><br><span class="line"><span class="comment">//     make: 'Barret',</span></span><br><span class="line"><span class="comment">//     model:'Lee',</span></span><br><span class="line"><span class="comment">//     value: 40000,</span></span><br><span class="line"><span class="comment">//     makeBarret: true,</span></span><br><span class="line"><span class="comment">//     depreciate: [Function: depreciate]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>可以达到的目的：</p>
<ol>
<li><strong>简写变量</strong></li>
<li>属性可以使用表达式计算值</li>
<li>忽略<code>function</code>关键词简写对象函数</li>
</ol>
<p>针对第三点可以参照下面的实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES 5写法</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Taylor"</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//ES 6写法</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Taylor"</span>,</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是ES 6提供的创建一个新对象的关键字。需要注意的是，类语法只是语法，而不是面向对象范式的成熟的基于类的实现，这与Java、Python、Ruby等语言不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShuttle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(targetPlanet) &#123;</span><br><span class="line">    <span class="keyword">this</span>.targetPlanet = targetPlanet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zeus = <span class="keyword">new</span> SpaceShuttle(<span class="string">'Jupiter'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>实例中的<code>constructor</code>相当于一个构造函数</li>
<li>类的命名一般采用UpperCamelCase的方式命名</li>
</ul>
<p>我们还可以从对象中获取值并设置对象中的属性值。这些通常称为getter和setter。Getter函数只是将对象私有变量的值返回(获取)给用户，而不需要用户直接访问私有变量。Setter函数用于根据传入Setter函数的值修改(设置)对象私有变量的值。这种更改可能涉及计算，甚至完全覆盖以前的值。这两种计算只要稍微熟悉C++和python的应该都不陌生。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(author) &#123;</span><br><span class="line">    <span class="keyword">this</span>._author = author;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> writer() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._author;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> writer(updatedAuthor) &#123;</span><br><span class="line">    <span class="keyword">this</span>._author = updatedAuthor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lol = <span class="keyword">new</span> Book(<span class="string">'anonymous'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lol.writer);  <span class="comment">// anonymous</span></span><br><span class="line">lol.writer = <span class="string">'wut'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(lol.writer);  <span class="comment">// wut</span></span><br></pre></td></tr></table></figure>
<p>这样就能实现对象的writer属性既可以被访问也可以被更改了。<br>下面是利用这个原理，写出的摄氏度单位转换实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thermostat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fahrenheit) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fahrenheit = fahrenheit;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> temperature() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">5</span> / <span class="number">9</span>) * (<span class="keyword">this</span>.fahrenheit - <span class="number">32</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> temperature(celsius) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fahrenheit = (celsius * <span class="number">9.0</span>) / <span class="number">5</span> + <span class="number">32</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="export-amp-import"><a href="#export-amp-import" class="headerlink" title="export&amp;import"></a><code>export</code>&amp;<code>import</code></h3><p>直接上实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math_function.js</span></span><br><span class="line"><span class="keyword">export</span>&#123;add, subtract&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;add,subtract&#125; <span class="keyword">from</span> <span class="string">'./math_functions'</span> ;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myMathModule <span class="keyword">from</span> <span class="string">'./math_functions'</span> ; <span class="comment">// import everything</span></span><br></pre></td></tr></table></figure>
<p>而当只用到该文件的一个函数时，我们有一种简单的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math_function.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">multiple</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125; <span class="comment">// 当只用从该文件中导出一个函数时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> multiple <span class="keyword">from</span> <span class="string">'./math_functions'</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Promise构造"><a href="#Promise构造" class="headerlink" title="Promise构造"></a>Promise构造</h3><p>一个promise有三种状态：<code>pending</code>,<code>fulfilled</code>和<code>rejected</code>。您在上一个挑战中创建的承诺将永远处于挂起状态，因为您没有添加完成该承诺的方法。提供给promise参数的<code>resolve</code>和<code>reject</code>参数用于执行此操作。当你希望你的承诺成功时，就用<code>resolve</code>，而当你希望它失败时，就用<code>reject</code>。<br>以下是promise的使用模板：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(condition here) &#123;</span><br><span class="line">    resolve(<span class="string">"Promise was fulfilled"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">"Promise was rejected"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>承诺在当你有一个进程在你的代码中花费了未知的时间(例如一些异步的事情，通常是一个服务器请求)是管用的。当您发出一个服务器请求时，它会花费一定的时间，在请求完成后，您通常需要对服务器的响应进行处理。这可以通过使用<code>then</code>方法来实现。<code>then</code>方法会在您的承诺被坚定地实现之后立即执行。这是它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myPromise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something with the result.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>与<code>then</code>相对应的有<code>catch</code>，<code>catch</code>是当你的承诺被拒绝时使用的方法。它在调用承诺的<code>reject</code>方法后立即执行。下面是它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myPromise.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something with the error.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>所以一个promise的完整架构为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> makeServerRequest = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// responseFromServer is set to false to represent an unsuccessful response from a server</span></span><br><span class="line">  <span class="keyword">let</span> responseFromServer = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(responseFromServer) &#123;</span><br><span class="line">    resolve(<span class="string">"We got the data"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    reject(<span class="string">"Data not received"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">makeServerRequest.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br><span class="line">makeServerRequest.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<p>到这里就是ES6课程的全部内容了，完结撒花~</p>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>30个JS小项目</title>
    <url>/2020/07/11/30%E4%B8%AAJS%E5%B0%8F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>一个对Javascript学习很有帮助的实操项目。</p>
<a id="more"></a>
<h2 id="打鼓点"><a href="#打鼓点" class="headerlink" title="打鼓点"></a>打鼓点</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li><code>querySelector()</code>方法返回文档中匹配指定CSS选择器的一个元素。<code>querySelectorAll()</code>返回全部元素。</li>
<li><code>&lt;kbd&gt;</code>标签用于指定该字符是从键盘输入的。</li>
<li><code>keyCode</code>65-90对应的是键盘上A-Z。</li>
<li><code>element.classList.add()</code>添加一个或多个类名。对应的<code>remove()</code>删除。</li>
<li>当发生<code>transitionend</code>事件时，<code>propertyName</code>属性返回<strong>与转换关联的CSS属性的名称</strong>。此属性是只读的。</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>加入对键盘按键的事件监听，每当按下一个按键时<ul>
<li>audio要play</li>
<li>加入playing类，从而使得样式改变。</li>
</ul>
</li>
<li>加入对每一个key的监听，若事件结束，则remove playing类从而返回初始状态。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTransition</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.propertyName !== <span class="string">'transform'</span>) <span class="keyword">return</span>; <span class="comment">// 只有监听到transition结束时，才remove playing</span></span><br><span class="line">  e.target.classList.remove(<span class="string">'playing'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playSound</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// audio和key承载了整个标签和标签里的内容</span></span><br><span class="line">  <span class="keyword">const</span> audio = <span class="built_in">document</span>.querySelector(<span class="string">`audio[data-key="<span class="subst">$&#123;e.keyCode&#125;</span>"]`</span>);</span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">document</span>.querySelector(<span class="string">`div[data-key="<span class="subst">$&#123;e.keyCode&#125;</span>"]`</span>);</span><br><span class="line">  <span class="keyword">if</span> (!audio) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  key.classList.add(<span class="string">'playing'</span>);</span><br><span class="line">  audio.currentTime = <span class="number">0</span>; <span class="comment">// 使时间归零，重新播放当前鼓点</span></span><br><span class="line">  audio.play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'.key'</span>));</span><br><span class="line">keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> key.addEventListener(<span class="string">'transitionend'</span>, removeTransition));</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'keydown'</span>, playSound);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="钟表"><a href="#钟表" class="headerlink" title="钟表"></a>钟表</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li><a href="https://www.runoob.com/jsref/prop-style-transform.html" target="_blank" rel="noopener">style的transform属性</a><code>object.style.transform</code></li>
<li><code>setinterval()</code>方法</li>
</ol>
<ul>
<li><code>setInterval()</code> 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式</li>
<li><code>setInterval()</code> 方法会不停地调用函数，直到 <code>clearInterval()</code> 被调用或窗口被关闭。</li>
</ul>
<h3 id="script代码"><a href="#script代码" class="headerlink" title="script代码"></a>script代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> secondHand = <span class="built_in">document</span>.querySelector(<span class="string">'.second-hand'</span>);</span><br><span class="line"><span class="keyword">const</span> minsHand = <span class="built_in">document</span>.querySelector(<span class="string">'.min-hand'</span>);</span><br><span class="line"><span class="keyword">const</span> hourHand = <span class="built_in">document</span>.querySelector(<span class="string">'.hour-hand'</span>);</span><br><span class="line"><span class="comment">// .XXX-hand都是类名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> seconds = now.getSeconds();</span><br><span class="line">  <span class="keyword">const</span> secondsDegrees = ((seconds / <span class="number">60</span>) * <span class="number">360</span>) + <span class="number">90</span>; <span class="comment">//初始角度为90°</span></span><br><span class="line">  secondHand.style.transform = <span class="string">`rotate(<span class="subst">$&#123;secondsDegrees&#125;</span>deg)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mins = now.getMinutes();</span><br><span class="line">  <span class="keyword">const</span> minsDegrees = ((mins / <span class="number">60</span>) * <span class="number">360</span>) + ((seconds/<span class="number">60</span>)*<span class="number">6</span>) + <span class="number">90</span>;</span><br><span class="line">  minsHand.style.transform = <span class="string">`rotate(<span class="subst">$&#123;minsDegrees&#125;</span>deg)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hour = now.getHours();</span><br><span class="line">  <span class="keyword">const</span> hourDegrees = ((hour / <span class="number">12</span>) * <span class="number">360</span>) + ((mins/<span class="number">60</span>)*<span class="number">30</span>) + <span class="number">90</span>;</span><br><span class="line">  hourHand.style.transform = <span class="string">`rotate(<span class="subst">$&#123;hourDegrees&#125;</span>deg)`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(setDate);</span><br><span class="line"></span><br><span class="line">setDate();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Update-CSS-Variable-With-JS"><a href="#Update-CSS-Variable-With-JS" class="headerlink" title="Update CSS Variable With JS"></a>Update CSS Variable With JS</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li><code>label</code>标签，<code>for</code>属性的值与后面的<code>input</code>的<code>id</code>相一致。 也可以直接把<code>input</code>内嵌到<code>label</code>中，此时不需要<code>for</code>属性。标签的作用就是关联。</li>
<li><code>:root</code>选择器用于匹配文档的根标签。</li>
<li>CSS variable<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="comment">/*变量用--表示*/</span></span><br><span class="line">  <span class="attribute">--base</span>: <span class="number">#ffc600</span>;</span><br><span class="line">  <span class="attribute">--spacing</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">--blur</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="comment">/*将变量赋值给属性*/</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="built_in">var</span>(--spacing);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--base);</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(var(--blur));</span><br><span class="line">  <span class="comment">/*blur用于设置高斯模糊*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>data-xxx</code>是input后面自定义的一个属性。用<code>this.dataset.sizing</code>获取<code>data-sizing</code>属性的值。</li>
</ol>
<h3 id="script代码-1"><a href="#script代码-1" class="headerlink" title="script代码"></a>script代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inputs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'input'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> suffix = <span class="keyword">this</span>.dataset.sizing || <span class="string">''</span>; </span><br><span class="line">  <span class="comment">// 设置后缀，like'px'，dataset对应了data-sizeing="px"，由于color项不含data-属性，故添加||''</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.setProperty(<span class="string">`--<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>, <span class="keyword">this</span>.value + suffix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inputs.forEach(<span class="function"><span class="params">input</span> =&gt;</span> input.addEventListener(<span class="string">'change'</span>, handleUpdate));</span><br><span class="line">inputs.forEach(<span class="function"><span class="params">input</span> =&gt;</span> input.addEventListener(<span class="string">'mousemove'</span>, handleUpdate));</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数组方法训练"><a href="#数组方法训练" class="headerlink" title="数组方法训练"></a>数组方法训练</h2><h3 id="知识点及应用"><a href="#知识点及应用" class="headerlink" title="知识点及应用"></a>知识点及应用</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>定义：<code>array.filter(function(currentValue,index,arr), thisValue)</code></p>
<ul>
<li><code>function</code>是必选参数，数组中每个元素都会执行这个函数，故其中<code>currentValue</code>是必选值，<code>index</code>和<code>arr</code>可以不指定。</li>
<li><code>thisValue</code>可选，<code>thisValue</code>赋给函数的<code>this</code>。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Filter the list of inventors for those who were born in the 1500's</span></span><br><span class="line"><span class="keyword">const</span> fifteen = inventors.filter(<span class="function"><span class="params">inventor</span> =&gt;</span> (inventor.year &gt;= <span class="number">1500</span> &amp;&amp; inventor.year &lt; <span class="number">1600</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>定义：<code>array.map(function(currentValue,index,arr), thisValue)</code></p>
<ul>
<li>与filter类似。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. Give us an array of the inventor first and last names</span></span><br><span class="line"><span class="keyword">const</span> fullNames = inventors.map(<span class="function"><span class="params">inventor</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;inventor.first&#125;</span> <span class="subst">$&#123;inventor.last&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fullNames);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>定义：<code>array.sort(sortFunction)</code>如无参数，默认按字母顺序。<br>原理：模拟前一个数<code>a</code>和后一个数<code>b</code>的比较，对数组所有元素进行sort。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. Sort the inventors by birthdate, oldest to youngest</span></span><br><span class="line"><span class="keyword">const</span> ordered = inventors.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.year &gt; b.year ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 若前大于后，则为1，交换顺序</span></span><br><span class="line"><span class="comment">// 若前小于后，则为-1，不交换</span></span><br><span class="line"><span class="comment">// 故为升序（从老到新--1400年的人老于1430年的人）</span></span><br><span class="line"><span class="built_in">console</span>.table(ordered);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. Sort the inventors by years lived</span></span><br><span class="line"><span class="keyword">const</span> oldest = inventors.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> lastInventor = a.passed - a.year;</span><br><span class="line">  <span class="keyword">const</span> nextInventor = b.passed - b.year;</span><br><span class="line">  <span class="keyword">return</span> lastInventor &gt; nextInventor ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.table(oldest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. sort Exercise</span></span><br><span class="line"><span class="comment">// Sort the people alphabetically by last name</span></span><br><span class="line"><span class="keyword">const</span> alpha = people.sort(<span class="function">(<span class="params">lastOne, nextOne</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [aLast, aFirst] = lastOne.split(<span class="string">', '</span>);</span><br><span class="line">  <span class="keyword">const</span> [bLast, bFirst] = nextOne.split(<span class="string">', '</span>);</span><br><span class="line">  <span class="keyword">return</span> aLast &gt; bLast ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(alpha);</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>定义：<code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></p>
<ul>
<li>按照function将数组从<code>initialValue</code>开始向后依次累计计算。</li>
<li><code>function</code>是必选参数，数组中每个元素都会执行这个函数。<code>currentValue</code>和<code>total</code>都是必选值，<code>total</code>相当于<code>m+=1</code>的<code>m</code>的效果</li>
<li><code>initalValue</code>是传递给函数的初始值，可选。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. How many years did all the inventors live?</span></span><br><span class="line"><span class="keyword">const</span> totalYears = inventors.reduce(<span class="function">(<span class="params">total, inventor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + (inventor.passed - inventor.year);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. Reduce Exercise</span></span><br><span class="line"><span class="comment">// Sum up the instances of each of these</span></span><br><span class="line"><span class="keyword">const</span> data = [<span class="string">'car'</span>, <span class="string">'car'</span>, <span class="string">'truck'</span>, <span class="string">'truck'</span>, <span class="string">'bike'</span>, <span class="string">'walk'</span>, <span class="string">'car'</span>, <span class="string">'van'</span>, <span class="string">'bike'</span>, <span class="string">'walk'</span>, <span class="string">'car'</span>, <span class="string">'van'</span>, <span class="string">'car'</span>, <span class="string">'truck'</span>, <span class="string">'pogostick'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transportation = data.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">obj, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj[item]) &#123;</span><br><span class="line">    obj[item] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  obj[item]++;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// 此处的obj和上边的total理解为初始化一个对象(数据)，然后开始逐一计算</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(transportation);</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="flex-panels"><a href="#flex-panels" class="headerlink" title="flex panels"></a>flex panels</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex" target="_blank" rel="noopener"><code>flex</code></a>属性</li>
<li><code>arr.includes(valueToFind[, fromIndex])</code>数组中是否包含某元素</li>
<li><code>str.includes(searchString[, position])</code>字符串中是否包含某子串</li>
<li><code>classList.toggle()</code>给某dom元素添加类</li>
</ul>
<h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> panels = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.panel'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击事件，修改为open</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleOpen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">this</span>.classList.toggle(<span class="string">'open'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件结束，修改为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleActive</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.propertyName);</span><br><span class="line">  <span class="keyword">if</span> (e.propertyName.includes(<span class="string">'flex'</span>)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.classList.toggle(<span class="string">'open-active'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">panels.forEach(<span class="function"><span class="params">panel</span> =&gt;</span> panel.addEventListener(<span class="string">'click'</span>, toggleOpen));</span><br><span class="line">panels.forEach(<span class="function"><span class="params">panel</span> =&gt;</span> panel.addEventListener(<span class="string">'transitionend'</span>, toggleActive));</span><br></pre></td></tr></table></figure>

<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p><code>.panel &gt; *{}</code>是啥意思？</p>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>2020暑假第一阶段学习</title>
    <url>/2020/07/04/2020%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>这是个大二升大三的关键暑假，下学期各类与计算机专业无关的课真的烦，必须要再这个暑假抽出时间来学习计算机。我暑期的学习目标就是<strong>完成并巩固基础课的学习</strong>并以兴趣带动学习<strong>完成一个小项目(暂定前端开发)</strong>。这个文档来规划和督促我的这个第一阶段的学习。</p>
<a id="more"></a>
<h3 id="事项交代"><a href="#事项交代" class="headerlink" title="事项交代"></a>事项交代</h3><h4 id="暑期学习表（不断更新）"><a href="#暑期学习表（不断更新）" class="headerlink" title="暑期学习表（不断更新）"></a>暑期学习表（不断更新）</h4><p>暑期待学课程以及学习时间表：</p>
<table>
<thead>
<tr>
<th align="center">课程</th>
<th align="center">学习方式</th>
<th align="center">视频时长</th>
<th align="center">学习时长</th>
<th align="center">时长明细</th>
<th align="center">阶段安排</th>
</tr>
</thead>
<tbody><tr>
<td align="center">六级刷题</td>
<td align="center">刷题</td>
<td align="center">0</td>
<td align="center">16h</td>
<td align="center">2h*8套</td>
<td align="center">各阶段</td>
</tr>
<tr>
<td align="center">爬虫</td>
<td align="center">课程+实战</td>
<td align="center">3h</td>
<td align="center">3h</td>
<td align="center">3h+3h</td>
<td align="center">1阶段</td>
</tr>
<tr>
<td align="center">Vue</td>
<td align="center">课程</td>
<td align="center">5h</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1阶段</td>
</tr>
<tr>
<td align="center">数据结构</td>
<td align="center">课件+实验回顾+blog</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">各阶段</td>
</tr>
<tr>
<td align="center">数据分析</td>
<td align="center">课程+实战</td>
<td align="center">28h</td>
<td align="center"></td>
<td align="center">28+</td>
<td align="center">1、2阶段</td>
</tr>
<tr>
<td align="center">操作系统</td>
<td align="center">课程+实验</td>
<td align="center">22h</td>
<td align="center"></td>
<td align="center">22+</td>
<td align="center">1、2阶段</td>
</tr>
<tr>
<td align="center">数据结构+算法</td>
<td align="center">课件+实验回顾</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">各阶段</td>
</tr>
<tr>
<td align="center">计算机网络</td>
<td align="center">课程</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2、3阶段</td>
</tr>
<tr>
<td align="center">计组</td>
<td align="center">课程+实验</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2、3阶段</td>
</tr>
<tr>
<td align="center">人工智能</td>
<td align="center">课件+实验回顾</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2、3阶段</td>
</tr>
</tbody></table>
<h4 id="该阶段主要目标"><a href="#该阶段主要目标" class="headerlink" title="该阶段主要目标"></a>该阶段主要目标</h4><p>第一阶段暂定日期 <strong>7.4~7.26</strong>共三周时间完成！<br>第一阶段的主要目标是至少完成：</p>
<ul>
<li>爬虫</li>
<li>Vue</li>
<li>操作系统的理论部分</li>
<li>数据分析的Excel和MySQL部分</li>
<li>Leetcode(每日一题)</li>
</ul>
<p>其余的像六级刷题、数据结构、Leetcode这几个贯穿整个暑假始终的学习项目也不能落下！</p>
<p>第一阶段要完成的大作业有：</p>
<ul>
<li>基于Vue的仿制音乐播放</li>
<li>blog部分 数据结构树图部分以前的大作业汇总</li>
<li>3套六级试题</li>
</ul>
<p>blog每天更新，记录自己一天干了什么，以及个人总结！<br>冲冲冲！！</p>
<h3 id="日志部分"><a href="#日志部分" class="headerlink" title="日志部分"></a>日志部分</h3><p>以下为这阶段的学习日记</p>
<hr>
<h4 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h4><h5 id="小笔记"><a href="#小笔记" class="headerlink" title="小笔记"></a>小笔记</h5><h6 id="HTML-DOM节点"><a href="#HTML-DOM节点" class="headerlink" title="HTML DOM节点"></a>HTML DOM节点</h6><p>在HTML DOM中，每个东西都是<strong>节点</strong>：</p>
<ul>
<li>文档本身是一个文档对象</li>
<li>所有HTML元素都是元素节点</li>
<li>所有HTML属性都是属性节点</li>
<li>插入到HTML元素文本时文本节点</li>
<li>注释是注释节点</li>
</ul>
<h5 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h5><p>今天购买了<strong>机器学习实战</strong>这本书，当作这个暑假的入门教材来读！可以在2、3阶段重点学习一下经典的代码实现。</p>
<h5 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h5><p>8:00~9:00，刷了两道Leetcode。分别是<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">求x的平方根</a>和<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a>，都比较简单。前者运用基本不等式，后者是逻辑简单的遍历链表。</p>
<p>9:00~10:30，学习了操作系统的有关内存这部分的内容。主要搞清楚了逻辑地址和物理地址的生成方法，以及os在这之中到底起到了什么样的作用。除此以外，内存分层结构也体现了计算机存储数据的一个层次关系（从CPU到物理内存到磁盘，容量正三角，速度倒三角）。最后就是有关连续内存分配的内存碎片的处理的简单知识。</p>
<p>附上7.3的重点：</p>
<ul>
<li>BIOS,bootloader,os在启动过程中的行为和作用</li>
<li>系统调用、异常和中断三个定义和大体过程</li>
<li>应用程序,os,外设之间的简单逻辑关系</li>
</ul>
<p>附上7.4重点：</p>
<ul>
<li>内存层次结构</li>
<li>逻辑地址生成</li>
<li>物理地址生成</li>
<li>内存调度三个方法</li>
<li>交换式碎片整理</li>
</ul>
<p>11:00~12:00，复习整理了数据结构单链表一块的知识，巩固了malloc和free的用法。</p>
<p>13:00~15:00，观看了<a href="https://www.bilibili.com/video/BV1xb411e7ww" target="_blank" rel="noopener">动态规划入门视频</a>，完成了一个分配钱实例，从中了解到了动态规划的精妙之处，单论这一个实例简直是完爆了递归和贪心算法。同时得知了<strong>动态规划的重要性，极其极其大！</strong>所以后期这部分的学习可以更精致一些，今天看完了前40分钟，明天继续。</p>
<p>16:00~17:00，完成了python的requests库到bs4库的全部学习，完成了大学排名爬取的小实验，直接深刻的掌握了标签树的相关关系。但是中文对齐这方面，发现pycharm的输出和idle的输出有一些偏差，表头由于全中文整体偏右。</p>
<p>20:00~21:00，观看完了<a href="https://www.bilibili.com/video/BV12J411m7MG" target="_blank" rel="noopener">vue入门视频</a>的前五节，从官方文档体会到了vue的类似字符串模板的一种理念。<code>Vue</code>是一个构造函数，该函数的参数（从语法上，我是直观上这样理解的不知道对不对）是一个包含<code>el</code>和<code>data</code>属性的对象。</p>
<ul>
<li><code>el</code>:设置挂载点，通过css选择器设置vue实例管理元素，el命中元素的内部的大括号内数据被同名的data替换</li>
<li><code>data</code>:数据对象，object、string、array……</li>
</ul>
<p>22:00~23:00，完成了Leetcode上的<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第n个节点</a>，算是一个对今天链表复习的巩固。而且又一次遇到了双指针，下次我一定能想出来双指针。</p>
<h6 id="今日感悟"><a href="#今日感悟" class="headerlink" title="今日感悟"></a>今日感悟</h6><p>以后Leetcode上刷题，要刷今天学的知识，就当是巩固啦~</p>
<hr>
<h4 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h4><p>今天比昨天懒了许多，这才第二天啊，反省！</p>
<h5 id="小笔记-1"><a href="#小笔记-1" class="headerlink" title="小笔记"></a>小笔记</h5><p>地址空间是操作系统如何跟踪分配给每个程序的内存的方式。</p>
<p>内存空间是堆中的实际物理内存。</p>
<p>地址空间映射到内存空间，当程序终止时，内存空间被释放回堆。</p>
<p>地址空间是虚拟的，也称为虚拟内存。</p>
<p>虚拟内存给人的印象是计算机内存很大，但是它一直在重复使用内存空间。</p>
<h5 id="时间线-1"><a href="#时间线-1" class="headerlink" title="时间线"></a>时间线</h5><p>9:30~11:30，学习了操作系统非连续内存分配这部分内容。将之前学过的分段和分页机制尤其是<strong>分页机制的如何将逻辑地址空间映射到物理地址空间</strong>这方面搞得很明白了。关键的几个流程图都记在了Goodnotes上，课下要经常翻阅这部分的内容。</p>
<ul>
<li>分段机制</li>
<li>分页机制</li>
<li>页寻址机制</li>
<li><a href="https://blog.csdn.net/qq_37924084/article/details/78360003" target="_blank" rel="noopener">分段与分页</a></li>
</ul>
<p>13:00~15:00, 继续动态规划，掌握了动态规划3问题中的两个：最值问题、计数问题，并完成了两个实例。</p>
<p>16:00~17:00，爬虫的正则表达式库的学习，掌握了正则表达式的语法。还未进入re库的学习。</p>
<p>19:30~20:30，继续学习了一小部分Vue的内容。还未感受到Vue的简单之处，可能是之前并未做过类似的前端大作业，对原来直接操作DOM和现在这种挂载的方式并未感受到其强大。</p>
<p>21:00~22:00，Leetcode做了一道动态规划的题，正好遇到了一个明天要学的题，按照思路做出来了，明天看完那位大神的教程之后再写这个Leetcode的总结。</p>
<hr>
<h4 id="7-6-7-7"><a href="#7-6-7-7" class="headerlink" title="7.6-7.7"></a>7.6-7.7</h4><h5 id="小笔记-2"><a href="#小笔记-2" class="headerlink" title="小笔记"></a>小笔记</h5><p>有关TLB的相关知识：</p>
<p>页表一般都很大，并且存放在内存中，所以处理器引入MMU后，读取指令、数据<strong>需要访问两次内存：首先通过查询页表得到物理地址，然后访问该物理地址读取指令、数据</strong>。为了减少因为MMU导致的处理器性能下降，引入了TLB，TLB是Translation Lookaside Buffer的简称，可翻译为“地址转换后援缓冲器”，也可简称为“快表”。简单地说，<strong>TLB就是页表的Cache</strong>，其中<strong>存储了当前最可能被访问到的页表项</strong>，其内容是<strong>部分页表项的一个<em>副本</em></strong>。只有在TLB无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。</p>
<p>TLB中的项由两部分组成：<strong>标识和数据</strong>。标识中存放的是虚地址的一部分，而数据部分中存放物理页号、存储保护信息以及其他一些辅助信息。</p>
<p>因为页大小是8KB，所以虚拟地址的0-12bit作为页内地址偏移。TLB表有64项，所以虚拟地址的13-18bit作为TLB表项的索引。假如虚拟地址的13-18bit是1，那么就会查询TLB的第1项，从中取出标识，与虚拟地址的19-31位作比较，如果相等，表示TLB命中，反之，表示TLB失靶。TLB失靶时，可以由硬件将需要的页表项加载入TLB，也可由软件加载，具体取决于处理器设计，OR1200没有提供硬件加载页表项的功能，只能由软件实现。TLB命中时，此时翻译得到的物理地址就是TLB第1项中的标识（即物理地址13-31位）与虚拟地址0-12bit的结合。在地址翻译的过程中还会结合TLB项中的辅助信息判断是否发生违反安全策略的情况，比如：要修改某一页，但该页是禁止修改的，此时就违反了安全策略，会触发异常。</p>
<h5 id="时间线-2"><a href="#时间线-2" class="headerlink" title="时间线"></a>时间线</h5><p>10:00~12:00，完成操作系统的非连续内存分配内容，虚拟内存单元开了个小头。重点学习了页表的机制。</p>
<ul>
<li>页表内容(resident bit)</li>
<li>TLB引入</li>
<li>内存覆盖技术</li>
</ul>
<p>14:00~15:30，完成了re库爬虫的理论部分，正则表达式使用起来非常方便，具体语法还需加深记忆。</p>
<p>17:00~18:00，完成了动态规划的网课学习。理论上已经知道如何解决动态规划的三类题，具体解决还需勤加练习。另外的，某些题目(跳跃游戏)更适配贪心法，并不是所有题目都适配动态规划。贪心法和动态规划法的理论部分了解不够深入，还需回溯定义。</p>
<p>19:00~21:00，磕了一道Leetcode，具体见Leetcode日记。</p>
<hr>
<h4 id="7-8"><a href="#7-8" class="headerlink" title="7.8"></a>7.8</h4><h5 id="时间线-3"><a href="#时间线-3" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~11:30，Leetcode。</p>
<p>12:30~14:00，操作系统的交换技术和虚存技术。这部分内容和前边的分配内存关系非常大，主要目的都是实现<strong>小内存运行大程序</strong>的目标，让程序用着几M的内存以为自己畅游在几G的内存空间里，这就是所谓的虚拟内存。</p>
<ul>
<li>内存交换技术</li>
<li>虚存技术的原理</li>
</ul>
<p>16:00~17:30，Python实现淘宝比价定向爬取实例，运行之后居然都没爬出来？查看了网页源代码，应该是网页格式已经更新换代了，raw_title和raw_value的键值对已经不存在了。。明天再搞吧。</p>
<p>19:00~21:00，Leetcode跳水板问题，循环居然写反了，反思反思！</p>
<p>22:30~1:00，我又愉快的做了道力扣，法克，快被气死了，为啥中级题老是写不对啊，我真垃圾。</p>
<h5 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h5><p>Leetcode的题真的很值得玩味，有的看似简单……双指针问题还需要继续练啊，我考虑边界问题的能力简直弱爆了。。</p>
<hr>
<h4 id="7-9"><a href="#7-9" class="headerlink" title="7.9"></a>7.9</h4><h5 id="时间线-4"><a href="#时间线-4" class="headerlink" title="时间线"></a>时间线</h5><p>9:30~11:00，总结Leetcode题目。</p>
<p>11:40~13:00，操作系统之虚存技术的实现。虚存技术的实现流程就是在页式的基础上增加请求调页和页面换入换出操作。精髓是，在运行的过程中不断地调入需要的页和数据，这一技术的实现，首先要求局部性原理要好(参照双循环按列遍历和按行遍历的区别)，这样在性能计算上参数<code>p</code>（缺页概率）才会尽可能小，效率才理想。</p>
<ul>
<li>缺页中断的处理</li>
<li>虚拟内存的性能</li>
</ul>
<p>15:00~17:00，听项目组会。以后每周要向老师汇报啊，哭-_-</p>
<p>18:00~20:00，一直检查那道Leetcode题目–恢复空格。<br>注意：在C语言中，要想运用<code>strcmp</code>判断字符数组和一个字符串是否相等，一定要在字符数组的结尾添加一个<code>&#39;\0&#39;</code>元素才可以！<br>另外：Hash表好🐂🍺，这周完了我再不会hash我就是🐕！</p>
<p>plus：总结的有关c语言的各种初始化：</p>
<ol>
<li><p>字符数组</p>
<ul>
<li>动态构建时，结尾必须有<code>&#39;\0&#39;</code>(还可以直接<code>scanf</code>输入)</li>
<li>静态构建时，这两个方法是等价的哦<ol>
<li><code>char sentence[] = &quot;justdoit&quot;;</code></li>
<li><code>char sentence[] = {&#39;j&#39;,&#39;u&#39;,&#39;s&#39;...&#39;t&#39;,&#39;\0&#39;}</code></li>
<li><code>char sentence[7] = {&#39;j&#39;,&#39;u&#39;,&#39;s&#39;...&#39;t&#39;,&#39;\0&#39;}</code></li>
</ol>
</li>
</ul>
</li>
<li><p>字符串数组</p>
<ul>
<li>静态构建:<code>const char* dictionary[5] = { &quot;just&quot;, &quot;do&quot;, &quot;it&quot; };</code></li>
<li><a href="https://blog.csdn.net/qq_39516859/article/details/83384880" target="_blank" rel="noopener">动态构建</a>：一般应该是用那个for循环来。</li>
</ul>
</li>
</ol>
<p>20:00~21:30，爬虫的实例完成，原来没有完成的原因是该宝变严了，具体解决方法参见python爬虫笔记-3。</p>
<p>21:30~22:30，hash表的部分学习，唤醒了之前的不少记忆，应该能很快掌握。</p>
<hr>
<h4 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h4><h5 id="时间线-5"><a href="#时间线-5" class="headerlink" title="时间线"></a>时间线</h5><p>9:00~11:00，操作系统的四个页面置换算法，这段比较好理解。</p>
<ul>
<li>OPT算法</li>
<li>FIFO算法</li>
<li>LRU算法</li>
<li>Clock置换算法</li>
</ul>
<p>12:00~13:30，Leetcode的一道dp题，这次的dp是多状态的，总结在Leetcode笔记里了。</p>
<p>16:00~17:00，Hash表的学习。<br>plus：买了一本考研机试的书，希望能提高应试能力吧。</p>
<p>19:00~20:00，一道简单的Leetcode题目，合并两个有序数组。</p>
<h5 id="今日感悟-1"><a href="#今日感悟-1" class="headerlink" title="今日感悟"></a>今日感悟</h5><p>最近真的懒了好多，最近几天说好的MySQL和Vue都没有看，接下来的阶段打算变动一部分学习计划</p>
<ol>
<li>新加入：<ul>
<li>Javascript 30天小项目</li>
<li>看人工智能的书</li>
<li>数据结构加快学习</li>
</ul>
</li>
<li>删除：<ul>
<li>Vue</li>
</ul>
</li>
</ol>
<hr>
<h4 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h4><h5 id="时间线-6"><a href="#时间线-6" class="headerlink" title="时间线"></a>时间线</h5><p>10:00~12:00，操作系统。</p>
<ul>
<li>二次机会算法（加入dirty bit判断）</li>
<li>LFU算法</li>
<li>Belady现象</li>
<li>Clock、FIFO、LRU算法对比</li>
</ul>
<p>13:00~14:00，Leetcode每日一题，今天的太难，能力它不够呀。。</p>
<p>15:00~19:00，<strong>天那我承认我没咋学，我再也不这样了</strong>。</p>
<p>19:00~21:00，JS项目1_DrumKit。</p>
<p>21:30~22:30，一道Leetcode，浪漫的相交链表。</p>
<p>23:00~24:00，一道Leetcode，环形链表。</p>
<h5 id="今日遗留"><a href="#今日遗留" class="headerlink" title="今日遗留"></a>今日遗留</h5><p>hash表的C语言实现</p>
<hr>
<h4 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h4><h5 id="时间线-7"><a href="#时间线-7" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~12:30，操作系统。终于完成了虚拟内存部分的内容。这部分重点就是学习逻辑地址转换成物理地址过程中，产生的缺页中断如何用页面置换算法加以解决。</p>
<ul>
<li>工作集页置换算法</li>
<li>缺页率置换算法</li>
<li>页面抖动问题</li>
</ul>
<p>13:00~15:00，两道Leetcode。一道SQL查询，一道每日一题，今天的这道地下城与勇士太快乐了，最后几乎是自己做出来了一道困难难度的题目。</p>
<p>15:30~16:00，看机试的书。听王道叔叔说要用C With STL的风格编程了。</p>
<p>16:30~17:30，python爬虫re库实例2，股票信息爬取。</p>
<p>19:00~20:30，JS项目2_Clock。</p>
<p>21:00~22:30，一道Leetcode，重排链表。</p>
<hr>
<h4 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h4><h5 id="时间线-8"><a href="#时间线-8" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~12:30，操作系统的进程部分所有内容。</p>
<ul>
<li>进程概念</li>
<li>进程组成</li>
<li>进程状态</li>
</ul>
<p>13:00~16:30，Leetcode每日一题，求数组的交集。<br>做题过程：<br>首先觉得好简单-&gt;开始做-&gt;不简单做不做出来-&gt;发现题目理解错了-&gt;接着做-&gt;还是做不出来-&gt;浑身难受-&gt;浑身难受中-&gt;有了思路哈希表-&gt;开始实现-&gt;踩坑1-&gt;踩坑2-&gt;踩坑3……-&gt;踩坑6-&gt;做出来了。<br>太难了8(不过确实找到了很多不足，这个坑踩得还是比较有意义的)</p>
<p>18:00~20:00，看书，王道机试和机器学习，记笔记。</p>
<p>22:00~23:20，JS项目3_Update CSS Variable With JS。</p>
<p>23:40~24:00，看数据结构。</p>
<hr>
<h4 id="7-14"><a href="#7-14" class="headerlink" title="7.14"></a>7.14</h4><h5 id="时间线-9"><a href="#时间线-9" class="headerlink" title="时间线"></a>时间线</h5><p>8:30~8:50，Leetcode每日一题，一道非常经典的路径最短dp。</p>
<p>9:00~9:30，总结二维数组申请空间问题。</p>
<p>10:00~12:00，操作系统，线程的知识和上下文切换。线程与进程的状态和生命周期等方面有很多相似之处，而线程实际上是比进程更小的可以独立运行单位，这使得进程的功能组成可以被进一步细化成管理资源+多线程的模型，线程在其中主要负责代码部分的执行。</p>
<ul>
<li>线程概念</li>
<li>线程的实现<ul>
<li>用户线程</li>
<li>内核线程</li>
<li>轻量级进程</li>
</ul>
</li>
<li>上下文切换</li>
</ul>
<p>13:00~16:30，写论文。</p>
<p>17:00~19:00，栈部分的相关总结。</p>
<p>20:00~21:30，爷哭了，简单力扣，堆栈基础，做崩了。（没有<code>dummyhead</code>，这个入栈我真的穷尽脑汁没想到咋弄）</p>
<p>22:40~24:00，JS项目_4 数组练习1，干货满满。</p>
<h5 id="今日遗留-1"><a href="#今日遗留-1" class="headerlink" title="今日遗留"></a>今日遗留</h5><ul>
<li><code>array.reduce()</code>方法是类似于C的递归吗。</li>
<li><code>memset()</code>方法总结</li>
</ul>
<hr>
<h4 id="7-15"><a href="#7-15" class="headerlink" title="7.15"></a>7.15</h4><h5 id="时间线-10"><a href="#时间线-10" class="headerlink" title="时间线"></a>时间线</h5><p>0:05~0:30，Leetcode每日一题，不同的二叉搜索树。</p>
<p>10:00~12:00，操作系统，进程控制内容。</p>
<ul>
<li><code>fork()</code>–进程的创建</li>
<li><code>exec()</code>–函数簇，加载程序替换当前进程</li>
<li><code>wait()</code>–等待子进程返回</li>
<li><code>exit()</code>–终止进程，资源回收</li>
</ul>
<p>12:50~13:30，一道Leetcode，两数之和II-输入有序数组。</p>
<p>14:00~15:00，一道Leetcode，快乐数，虚拟链表，非常有意思。</p>
<p>16:00~17:00，下载本周大创项目相应的学习资料。</p>
<p>18:30~20:00，学STL。</p>
<p>20:00~21:00，JS项目5_flex pannels，这讲被css的flex听懵了。</p>
<p>22:20~24:00，继续看数据结构堆栈。</p>
<hr>
<h4 id="7-16"><a href="#7-16" class="headerlink" title="7.16"></a>7.16</h4><h5 id="时间线-11"><a href="#时间线-11" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~1:00，看固体物理的书。</p>
<p>1:00~2:00，两道Leetcode。存在重复元素I、II，其中II还没解出来，学完STL部分的知识再去回顾。</p>
<p>11:00~13:00，操作系统，进程调度部分的内容。</p>
<ul>
<li>调度原则，调度指标</li>
<li>先来先服务算法</li>
<li>短作业优先算法</li>
<li>最高响应比算法</li>
</ul>
<p>14:10~16:00，六级卷子。TOO HARD, FUCK IT。</p>
<p>17:30~19:00，学习STL中的<code>map</code>和<code>unordered_map</code>用法，完成了凌晨一点那题的解法。</p>
<p>19:30~21:00，利用刚学的<code>unordered_map</code>解Leetcode的存在重复元素III，实现了，但超时了。明天学了<code>set</code>之后，把这道题再磕了。</p>
<p>22:30~24:00，继续看固体物理的书。</p>
<hr>
<h4 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h4><h5 id="时间线-12"><a href="#时间线-12" class="headerlink" title="时间线"></a>时间线</h5><p>10:00~13:00，操作系统的进程调度学完。</p>
<ul>
<li>轮循算法</li>
<li>多级反馈队列<ul>
<li><a href="https://www.jianshu.com/p/1f5195dcc75b" target="_blank" rel="noopener">CPU密集型和I/O密集型的分别</a></li>
</ul>
</li>
<li>公平共享制度</li>
<li>实时调度（似懂非懂）</li>
<li>多处理器调度</li>
<li>优先级反转现象及解决方案</li>
</ul>
<p>14:30~16:00，看机试书。</p>
<p>19:00~22:00，刷Leetcode，学习<code>set</code>的用法。</p>
<hr>
<h4 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h4><h5 id="时间线-13"><a href="#时间线-13" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~13:40，昨天遗留的Leetcode每日一题，交错字符串。并总结滚动数组的相关用法。</p>
<p>14:30~18:30，四道Leetcode。</p>
<ul>
<li>移除链表元素</li>
<li>交错字符串</li>
<li>计数质数</li>
<li>我能赢吗（不会做）</li>
</ul>
<p>19:30~22:00，两道Leetcode（被简单题虐死了？？）</p>
<ul>
<li>反转链表</li>
<li>同构字符串</li>
</ul>
<p>23:00~24:00，两道Leetcode（是的，今天是Leetcode Saturday）</p>
<ul>
<li>好数对的数目</li>
<li>仅含1的字符串</li>
</ul>
<hr>
<h4 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h4><h5 id="时间线-14"><a href="#时间线-14" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~11:30，操作系统的同步内容介绍。</p>
<p>12:00~13:30，Leetcode每日一题总结。</p>
<p>16:00~19:00，树的相关知识，以及Leetcode上的简单树的题。<br><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">一个GitHub上非常牛的刷题导引</a><br><a href="https://lyl0724.github.io/2020/01/25/1/" target="_blank" rel="noopener">由此引出来的递归调用理解以及相关递归树题目导航的大佬blog传送门</a></p>
<p>19:00~20:35，几个树的题目。</p>
<ul>
<li>二叉树的最大深度</li>
<li>平衡二叉树判定<ul>
<li>自顶向下递归法</li>
<li>自底向上递归法</li>
</ul>
</li>
<li>翻转二叉树</li>
<li>两两交换链表中的结点（后面还要写出来迭代法等解法）</li>
</ul>
<p>21:00~23:00，递归专题练习。</p>
<ul>
<li>删除排序链表中的重复元素</li>
<li>对称二叉树</li>
<li>二叉树的最小深度</li>
</ul>
<p>23:15~23:40，看固体物理的视频。</p>
<h5 id="今日遗留-2"><a href="#今日遗留-2" class="headerlink" title="今日遗留"></a>今日遗留</h5><ul>
<li>合并二叉树</li>
<li>最大二叉树</li>
</ul>
<hr>
<h4 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h4><h5 id="时间线-15"><a href="#时间线-15" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~2:00，python爬虫scrapy模块，Linux入坑视频。</p>
<p>10:00~10:30，Leetcode每日一题。</p>
<p>10:30~11:40，操作系统看完同步内容。</p>
<ul>
<li>临界区的实现方法<ul>
<li>基于flag[i]和turn来设计</li>
<li>基于TestAndSet操作实现</li>
<li>基于Exchange操作实现</li>
</ul>
</li>
</ul>
<p>13:00~15:30，遗留的Leetcode。</p>
<ul>
<li>合并二叉树</li>
<li>最大二叉树</li>
</ul>
<p>16:30~18:00，固体物理原子链部分。</p>
<p>19:00~20:00，爬虫scrapy。</p>
<p>20:30~22:00，总结图结构，Leetcode课程表（未解决）。</p>
<h5 id="今日遗留-3"><a href="#今日遗留-3" class="headerlink" title="今日遗留"></a>今日遗留</h5><ul>
<li><code>nullptr</code>和<code>NULL</code>的区别</li>
<li>Linux安装</li>
<li>blog建立评论区</li>
<li>记得抽时间把那个blog的出处都弄一下</li>
</ul>
<hr>
<h4 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h4><h5 id="小笔记-3"><a href="#小笔记-3" class="headerlink" title="小笔记"></a>小笔记</h5><p><a href="https://blog.csdn.net/zzq060143/article/details/96278516" target="_blank" rel="noopener">参考文章</a></p>
<ul>
<li><code>nullptr</code>在C++里代指空指针</li>
<li><code>NULL</code><ul>
<li>C中是<code>(void*)0</code></li>
<li>C++中是<code>0</code></li>
</ul>
</li>
</ul>
<h5 id="时间线-16"><a href="#时间线-16" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~1:00，Leetcode每日一题，不同的二叉搜索树II。又是一道递归，没做出来。。不过看答案之后秒懂，还是好菜</p>
<p>10:30~12:30，操作系统的信号量内容。</p>
<ul>
<li>信号量的定义<ul>
<li>二进制信号量</li>
<li>计数信号量</li>
</ul>
</li>
<li>生产者消费者模型</li>
<li>P-V操作的实现</li>
</ul>
<p>14:00~15:00，安装Centos Linux。</p>
<p>16:00~20:30，拓扑排序，和相关习题，DFS和BFS的原理。</p>
<p>22:00~24:00，坎坷得配置Linux网络和与主机的通信。</p>
<h5 id="今日遗留-4"><a href="#今日遗留-4" class="headerlink" title="今日遗留"></a>今日遗留</h5><ul>
<li>爬虫-&gt;nba数据</li>
<li>二分图</li>
<li>今天的图论的Leetcode笔记</li>
</ul>
<hr>
<h4 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h4><h5 id="时间线-17"><a href="#时间线-17" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~1:00，继续配置，，终于成功</p>
<p>1:00~1:30，Leetcode每日一题。</p>
<p>8:00~9:00，找机场。</p>
<p>11:00~13:00，操作系统管程。</p>
<p>15:00~16:30，研究清华的操作系统实验资源。</p>
<p>17:00~18:00，Linux命令行。</p>
<p>19:00~2:30，写Leetcode周练。</p>
<ul>
<li>换酒问题(40min)</li>
<li>子树中标签相同的结点数(4h+)</li>
</ul>
<p>服了。。</p>
<hr>
<h4 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a>7.23</h4><h5 id="小笔记-4"><a href="#小笔记-4" class="headerlink" title="小笔记"></a>小笔记</h5><p>BFS VS DFS</p>
<ul>
<li>空间复杂度<ul>
<li>BFS：$O(n)$</li>
<li>DFS：$O(logn)$</li>
</ul>
</li>
<li>BFS适合找最小值问题，例如迷宫最短路径</li>
<li>由于DFS需要函数调用消耗栈空间，而栈空间当层数过大时容易爆栈，所以当层数过大时尽量用BFS</li>
</ul>
<p>总结：<br>BFS</p>
<ol>
<li>空间是指数级别的</li>
<li>不会有爆栈风险（给队列开全局变量，不会存在爆堆）</li>
</ol>
<p>DFS</p>
<ol>
<li>空间与深度成正比</li>
<li>有爆栈风险</li>
</ol>
<h5 id="时间线-18"><a href="#时间线-18" class="headerlink" title="时间线"></a>时间线</h5><p>10:30~14:00，两道leetcode，最近脑子不够使啊，做啥都好难(；′⌒`)。</p>
<ul>
<li>最多的不重叠字符串</li>
<li>最小路径和</li>
</ul>
<p>15:00~19:00，混乱浏览。</p>
<ul>
<li>配置操作系统课实验环境</li>
<li>看计组课的前七节</li>
<li>汇编解释编程本质课</li>
</ul>
<p>19:30~20:15，Leetcode，二分图。</p>
<p>21:00~22:00，操作系统。</p>
<p>22:30~23:30，看DFS和BFS视频，敲完二分图。</p>
<h5 id="今日遗留-5"><a href="#今日遗留-5" class="headerlink" title="今日遗留"></a>今日遗留</h5><ul>
<li>二分查找解决前一个未打卡的题</li>
<li>操作系统看完这几节</li>
<li>看完BFS和DFS</li>
<li>flood fill</li>
</ul>
<hr>
<h4 id="7-24"><a href="#7-24" class="headerlink" title="7.24"></a>7.24</h4><h5 id="时间线-19"><a href="#时间线-19" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~1:20，Leetcode。</p>
<ul>
<li>完全平方数</li>
<li>除数博弈</li>
<li>二分图BFS</li>
</ul>
<p>11:00~14:00，BFS和DFS的几道题。</p>
<ul>
<li>flood fill</li>
<li>num of islands</li>
<li>surrounded regions</li>
</ul>
<p>17:00~20:00，做Leetcode右侧小于当前元素个数。</p>
<ul>
<li>小笔记：<code>lower_bound(first, last, value)</code>返回指向范围<code>[first, last)</code>中首个不小于（即大于或等于） <code>value</code> 的元素的迭代器，或若找不到这种元素则返回 <code>last</code> 。</li>
</ul>
<p>20:30~22:30，操作系统的读者写者问题。</p>
<hr>
<h4 id="7-25"><a href="#7-25" class="headerlink" title="7.25"></a>7.25</h4><h5 id="时间线-20"><a href="#时间线-20" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~1:30，Leetcode每日一题。</p>
<ul>
<li>分割数组的最大值</li>
</ul>
<p>10:30~12:30，操作系统哲学家就餐问题。</p>
<p>14:00~19:40，一道Leetcode，还是中等题呜呜呜5555呜呜呜</p>
<ul>
<li>检查网格中是否存在有效路径</li>
</ul>
<p>20:00~23:30，一道Leetcode，好像还是不难，哎哟。</p>
<ul>
<li>从先序遍历还原二叉树</li>
</ul>
<hr>
<h4 id="7-26"><a href="#7-26" class="headerlink" title="7.26"></a>7.26</h4><h5 id="时间线-21"><a href="#时间线-21" class="headerlink" title="时间线"></a>时间线</h5><p>0:00~2:30，Leetcode一道题。</p>
<ul>
<li>封闭的岛屿数量</li>
<li>矩阵中最长递归路径(明天需要继续总结)</li>
</ul>
<p>9:30~10:30，每日一题的拓扑排序做法。</p>
<p>10:30~12:00，比赛。。就做出一道题，第二题太笨，第三题欠考虑了。</p>
<p>14:00~15:30，总结两道竞赛题。</p>
<ul>
<li>灯泡开关IV</li>
<li>好叶子节点对数量</li>
</ul>
<p>18:00~19:00，一道Leetcode的BFS题目。</p>
<p>19:30~20:50，死锁问题的开头。</p>
<ul>
<li>死锁问题</li>
<li>死锁模型</li>
<li>死锁特点</li>
<li>死锁四条件</li>
<li>死锁预防和死锁避免</li>
</ul>
<p>22:00~23:00，计组的硬件功能和简单指令实现。</p>
<ul>
<li>存储器</li>
<li>运算器</li>
<li>控制器</li>
<li>取数指令过程</li>
<li>存数指令过程</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习日志</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode日记</title>
    <url>/2020/07/02/LeetCode%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>偶尔在力扣上刷刷题碰到些有价值的题目随手都记录到这里了。</p>
<a id="more"></a>
<p><strong><em>题目分类：</em></strong></p>
<p><strong>动态规划：</strong></p>
<ul>
<li>爬楼梯</li>
<li>恢复空格</li>
<li>地下城与勇士</li>
<li>三角形最小路径和</li>
<li>不同的二叉搜索树</li>
</ul>
<p><strong>双指针：</strong></p>
<ul>
<li>删除链表的倒数第n个结点</li>
<li>删除排序链表里的重复元素II</li>
<li>相交链表</li>
<li>环形链表</li>
<li>重排链表</li>
<li>数组交集</li>
<li>两数之和II</li>
<li>快乐数</li>
<li>戳气球</li>
</ul>
<p>贪心法：</p>
<ul>
<li>跳跃游戏</li>
</ul>
<p><strong>hash表：</strong></p>
<ul>
<li>删除排序链表里的重复元素II</li>
<li>恢复空格</li>
<li>数组交集</li>
<li>存在重复元素II</li>
<li>存在重复元素III</li>
</ul>
<p>递归：</p>
<ul>
<li>删除排序链表里的重复元素II</li>
<li>反转链表</li>
</ul>
<p>二分法</p>
<ul>
<li>排列硬币</li>
<li>旋转数组的最小值</li>
</ul>
<p>排除法</p>
<ul>
<li>计数质数</li>
</ul>
<hr>
<h4 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h4><h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><p>输入：两个二进制字符串<br>输出：加法后得到的二进制字符串</p>
<h5 id="个人解答-Python"><a href="#个人解答-Python" class="headerlink" title="个人解答(Python)"></a>个人解答(Python)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        carry = <span class="number">0</span>  <span class="comment"># 进位初始化为0</span></span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        n = max(len(a),len(b))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(i &gt; len(a)<span class="number">-1</span>):  <span class="comment"># 当b未遍历完，a遍历完</span></span><br><span class="line">                result += str((int(b[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">                carry = (int(b[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; len(b)<span class="number">-1</span>):  <span class="comment"># 当a未遍历完，b遍历完</span></span><br><span class="line">                result += str((int(a[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">                carry = (int(a[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            result += str((int(a[-i<span class="number">-1</span>])+int(b[-i<span class="number">-1</span>])+carry) % <span class="number">2</span>)</span><br><span class="line">            carry = (int(a[-i<span class="number">-1</span>])+int(b[-i<span class="number">-1</span>])+carry) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>):  <span class="comment"># 如果最后进位是1，补位</span></span><br><span class="line">            result += str(carry)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h5 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h5><p>两个数字位数较小的一个，直接用0补齐，使得两个字符串的位数相同，可以节省代码空间，减少判断次数，降低运行时间。</p>
<h5 id="法2：位运算"><a href="#法2：位运算" class="headerlink" title="法2：位运算"></a>法2：位运算</h5><p><a href="https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/" target="_blank" rel="noopener">戳我看解法</a></p>
<hr>
<h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><h5 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h5><p>人一次只能爬1个或2个楼梯<br>输入：楼梯个数<br>输出：爬楼梯共有多少种爬法</p>
<h5 id="个人解答-Python-1"><a href="#个人解答-Python-1" class="headerlink" title="个人解答(Python)"></a>个人解答(Python)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * f(n<span class="number">-1</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = (n//<span class="number">2</span>)+<span class="number">1</span>  <span class="comment"># 共有多少种不重复的已经确定的1，2个数分布</span></span><br><span class="line">        j = n  <span class="comment"># 排列组合公式的底数</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">            result += f(j)/(f(i)*f(j-i))</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h5 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结"></a>我的总结</h5><p>我的思路是先找到1，2个数的所有组合，举个例子：<br>比如n=6，那么楼梯的1，2组合只能是以下四种：</p>
<ul>
<li>111111</li>
<li>11112</li>
<li>1122</li>
<li>222</li>
</ul>
<p>那么只需要找到2的排列组合数就行：</p>
<ul>
<li>0/6 111111</li>
<li>1/5 11112</li>
<li>2/4 1122</li>
<li>3/3 222</li>
</ul>
<p>虽然找到了公式，但不得不说，我这个不论空间还是时间都垃圾的很……直接看标答吧…<br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">戳我看完整答案</a></p>
<h5 id="方法1：动态规划！"><a href="#方法1：动态规划！" class="headerlink" title="方法1：动态规划！"></a>方法1：动态规划！</h5><p>我们用 <code>f(x)</code> 表示爬到第 <code>x</code> 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：<br>$$f(x) = f(x-1) + f(x-2)$$</p>
<p>这个公式的意思是，爬到第n级台阶只能是爬到n-1级（爬到第n级用了一步）或是爬到n-2级（爬到n级用了两步）的方案的集合。看到这里就一目了然，这不就是传说中的<code>斐波那契数列</code>吗？（后话）<br>利用滚动数组的方法求解代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    q = <span class="number">0</span></span><br><span class="line">    r = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        p = q  <span class="comment"># q前移一位</span></span><br><span class="line">        q = r  <span class="comment"># r前移一位</span></span><br><span class="line">        r = p + q  <span class="comment"># 更新r</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>
<h5 id="方法2：斐波那契公式"><a href="#方法2：斐波那契公式" class="headerlink" title="方法2：斐波那契公式"></a>方法2：斐波那契公式</h5><p>$$f ( n ) = \frac { 1 } { \sqrt { 5 } } [ ( \frac { 1 + \sqrt { 5 } } { 2 } ) ^ { n } - ( \frac { 1 - \sqrt { 5 } } { 2 } ) ^ { n } ]<br>$$</p>
<hr>
<h4 id="删除链表的倒数第n个节点"><a href="#删除链表的倒数第n个节点" class="headerlink" title="删除链表的倒数第n个节点"></a>删除链表的倒数第n个节点</h4><h5 id="个人解答-C-两次遍历"><a href="#个人解答-C-两次遍历" class="headerlink" title="个人解答(C,两次遍历)"></a>个人解答(C,两次遍历)</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cur = cur -&gt; next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==n)&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 如果删除头结点，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count-n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125; <span class="comment">// 如果不删除头结点，按照结点删除法删除对应节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="我的总结-1"><a href="#我的总结-1" class="headerlink" title="我的总结"></a>我的总结</h5><p>遍历2L-n次，时间复杂度 $O(L)$<br>空间复杂度$O(1)$</p>
<h5 id="优化：一次遍历法（双指针）"><a href="#优化：一次遍历法（双指针）" class="headerlink" title="优化：一次遍历法（双指针）"></a>优化：一次遍历法（双指针）</h5><p>哎呀，想了十分钟没想出来，一说双指针一下子明白了。双指针保持间隔为n，依次向前递推，直到快指针指向空，慢指针定位成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 定位快指针到第n+1个结点</span></span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125; <span class="comment">// 如果第n+1个结点为空，直接返回head-&gt;next</span></span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>free语句是必不可少的，这里为了省空间就没用q承载再删除</strong>。正解如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>


<hr>
<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><h5 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h5><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p>
<h5 id="个人解答-C"><a href="#个人解答-C" class="headerlink" title="个人解答(C)"></a>个人解答(C)</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = numsSize<span class="number">-2</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= numsSize-i<span class="number">-1</span>)&#123; </span><br><span class="line">            <span class="comment">// 如果这个在尾元素之前的元素可以到达末尾，则以该元素为末尾</span></span><br><span class="line">            numsSize -= (numsSize-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numsSize==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<h5 id="标答-贪心法"><a href="#标答-贪心法" class="headerlink" title="标答(贪心法)"></a>标答(贪心法)</h5><p><strong>更新能跳到的最远位置</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n, rightmost = len(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &lt;= rightmost:</span><br><span class="line">                rightmost = max(rightmost, i + nums[i])</span><br><span class="line">                <span class="keyword">if</span> rightmost &gt;= n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两链表之和"><a href="#两链表之和" class="headerlink" title="两链表之和"></a>两链表之和</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>例如：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><p>本来想省一点空间，直接在L1上操作，现在导致前后两难：</p>
<ol>
<li>逻辑不清晰，可读性很差</li>
<li>时间复杂度提高的鸭子！！</li>
<li>代码冗长</li>
</ol>
<p>浪费了我俩小时，先睡了。/(ㄒoㄒ)/~~</p>
<p>2020.7.8..今天早上用c语言做出来了，直接贴代码。之前的思路（改变L1），造成了我遍历完其中一个链表，就会分类讨论出三种情况，无疑复杂化了原问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>; <span class="comment">// 进位位初始化</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>; <span class="comment">// 每位的加和</span></span><br><span class="line">    <span class="keyword">int</span> x,y; <span class="comment">// 每位的真实加法数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">L1</span>=<span class="title">l1</span>,*<span class="title">L2</span>=<span class="title">l2</span>,*<span class="title">result</span>,*<span class="title">cur</span>,*<span class="title">high</span>,*<span class="title">nextNode</span>;</span></span><br><span class="line">    result = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    cur = result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(L1!=<span class="literal">NULL</span> || L2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        x = L1!=<span class="literal">NULL</span> ? L1-&gt;val : <span class="number">0</span>;</span><br><span class="line">        y = L2!=<span class="literal">NULL</span> ? L2-&gt;val : <span class="number">0</span>;</span><br><span class="line">        nextNode = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        sum = x + y + temp;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            nextNode -&gt; val = sum%<span class="number">10</span>;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nextNode -&gt; val = sum;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            L1=L1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            L2=L2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = nextNode;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后排除多位问题</span></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">1</span>)&#123;</span><br><span class="line">        high = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        high -&gt; val = <span class="number">1</span>;</span><br><span class="line">        cur -&gt; next = high;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以以后再碰到类似的题目，要先想好自己要不要优化空间（时间），到底是先试着把题目做出来，还是就着一个优化空间的角度钻牛角尖，还是要衡量一下的。</strong>后面还看到了一个时间上比我快很多的算法，其实和我之前的思路有一点类似(当某一个链表遍历完，剩余的链接到后面，但是由于我一心只想改变L1，造成了很多不必要的麻烦，而且后面的关于进位位的处理也没人家想的好)大体讲一下思路，开阔一下视野。</p>
<ol>
<li>新建一个链表l3，用以存放l1+l2的和</li>
<li>分3种情况，在l1，l2都没到尾的前提下<ul>
<li>l1先结束，l2多出来的部分直接加入到l3</li>
<li>l2先结束，l1多出来的部分直接加到l3</li>
<li>两个一起结束，直接相加，不管结果是否大于10</li>
</ul>
</li>
<li>遍历l3，先不考虑链表最后一个数，<ul>
<li>如果l3.val&gt;10，减去10，并在下一个节点上加1</li>
<li>如果链表最后一个数大于10，则减去10，并新建一个节点存1</li>
</ul>
</li>
</ol>
<p>这个思路的<strong>对进位位的处理</strong>是很值得借鉴的，就是先不管进位位的情况下统一加完，再遍历链表实现进位位的加法，这种方法看似消耗了时间（相当于两次遍历），实际上居然比我那个要快很多，显然是因为我那个的条件判断语句有点过多了。</p>
<hr>
<h4 id="跳水板"><a href="#跳水板" class="headerlink" title="跳水板"></a>跳水板</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。<br>返回的长度需要<strong>从小到大排列</strong>。</p>
<h5 id="个人解答-1"><a href="#个人解答-1" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">divingBoard</span><span class="params">(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *newNode;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(longer==shorter)&#123;</span><br><span class="line">        newNode = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line">        *newNode = longer*k;</span><br><span class="line">        *returnSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(k+<span class="number">1</span>));</span><br><span class="line">    *returnSize = k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        newNode[k-i] = i*shorter + (k-i)*longer; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="删除排序链表里的重复元素II"><a href="#删除排序链表里的重复元素II" class="headerlink" title="删除排序链表里的重复元素II"></a>删除排序链表里的重复元素II</h4><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中<strong>没有重复出现</strong>的数字。</p>
<h5 id="个人原解答"><a href="#个人原解答" class="headerlink" title="个人原解答"></a>个人原解答</h5><p>思路：</p>
<ol>
<li>如果链表只有0/1个元素，返回head。 </li>
<li>将链表化为<strong>前两个元素一定不一样</strong>的模型。</li>
<li>设置快指针q，慢指针p。</li>
<li>p-&gt;next-&gt;val == q-&gt;val时是删除条件<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// p是慢指针，q是快指针</span></span><br><span class="line">    <span class="comment">// 如果是开头重复：label=1</span></span><br><span class="line">    <span class="comment">// 如果是中间重复：label=0</span></span><br><span class="line">    <span class="comment">// 由于头结点和后面都不一样，我觉得先摘除头结点重复的前半部分，将链表化为“前两个一定不相同的模型”</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>=<span class="title">head</span>, *<span class="title">q</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> label = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next-&gt;val == head-&gt;val)&#123;</span><br><span class="line">        label = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next-&gt;val == head-&gt;val)&#123;</span><br><span class="line">            label = <span class="number">1</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(label)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;val == q-&gt;val)&#123; <span class="comment">// 若相等</span></span><br><span class="line">            <span class="keyword">if</span>(q-&gt;next==<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123; <span class="comment">// 到达链表尾，则删除</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 否则快指针后移</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 若不等</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;next == q)&#123; <span class="comment">// 不能删，要后移p</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 否则应该删掉中间结点</span></span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我感觉我想法挺好的啊！但真的做崩了，被各种细节卡了下来，提交了5次都没成功，我是真的垃圾。都说能用递归，那我用递归试试，半小时不行就劝退吧，现在是0：49，我很困。<br>1：01，爷想不出来，气死了，睡觉。</li>
</ol>
<h5 id="标准解法"><a href="#标准解法" class="headerlink" title="标准解法"></a>标准解法</h5><h6 id="方法1：递归"><a href="#方法1：递归" class="headerlink" title="方法1：递归"></a>方法1：递归</h6><ul>
<li><code>head</code>后面有值而且和<code>head</code>的值相等，那么就找到不相等为止，然后对后面一个结点去递归，这样就把前面重复的给删除了。</li>
<li><code>head</code>后面有值但和<code>head</code>的值不等，那么就递归后面一个结点，接在<code>head</code>的后面。</li>
<li>最后返回<code>head</code>。</li>
</ul>
<p>想法和我是一样的，但是我就……没能力实现出来？？其实中间很多循环条件判断条件也是完全一样的，，这个<code>return deleteDuplicates(head-&gt;next)</code>我服了，我当时怎么都没想出来解决(1,1,2,2)这种情况，人家一句就解决了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="方法2：hash表"><a href="#方法2：hash表" class="headerlink" title="方法2：hash表"></a>方法2：hash表</h6><p>hash_map 统计出现次数，如果出现次数等于1，那么就放在新链表后面。</p>
<h6 id="方法3：双指针"><a href="#方法3：双指针" class="headerlink" title="方法3：双指针"></a>方法3：双指针</h6><p><strong>先建一个哑结点真的省事儿</strong>，当建完哑结点后，删除就会和<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表里的重复元素I</a>这道题的方法基本一样–<strong>顺序遍历，若同则删</strong>，不同的是，<code>cur-&gt;next</code>是否为空要加以判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哑结点指向head</span></span><br><span class="line">    ListNode* dummy = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode* pre = dummy;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">NULL</span> &amp;&amp; cur-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next!=<span class="literal">NULL</span> &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;                </span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h5><p>当这种情况下，可能有很多种情况，首先想能不能把这几个情况想个方法合并。比如法1的递归和法3的双指针的哑结点，都是<strong>为了排除特殊情情况而设计的</strong>。</p>
<hr>
<h4 id="恢复空格"><a href="#恢复空格" class="headerlink" title="恢复空格"></a>恢复空格</h4><h5 id="别人解答C"><a href="#别人解答C" class="headerlink" title="别人解答C"></a>别人解答C</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CMP</span><span class="params">(<span class="keyword">void</span> * a,<span class="keyword">void</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * S1 = *(<span class="keyword">char</span> **)a;</span><br><span class="line">    <span class="keyword">char</span> * S2 = *(<span class="keyword">char</span> **)b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(S1,S2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Binary</span><span class="params">(<span class="keyword">char</span> **dictionary,<span class="keyword">int</span> dictionarySize,<span class="keyword">char</span> * <span class="built_in">string</span>,<span class="keyword">int</span> lenth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = dictionarySize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>,ret2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;        <span class="comment">//mid是一个区间</span></span><br><span class="line">        ret = <span class="built_in">strncmp</span>(dictionary[mid],<span class="built_in">string</span>,lenth);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret2 = <span class="built_in">strlen</span>(dictionary[mid]);</span><br><span class="line">            <span class="keyword">if</span>(ret2 == lenth)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret2 &gt; lenth)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="keyword">char</span>** dictionary, <span class="keyword">int</span> dictionarySize, <span class="keyword">char</span>* sentence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    qsort(dictionary,dictionarySize,<span class="keyword">sizeof</span>(<span class="keyword">char</span> *),CMP);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(sentence);</span><br><span class="line">    <span class="keyword">int</span> * dp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    * dp = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *(dp + i) = *(dp + i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt;= i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Binary(dictionary,dictionarySize,sentence + j,i - j + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    *(dp + i) = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    *(dp + i) = MIN(dp[i],dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> answer = dp[len] - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(dp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我改进后的，用C语言基于动态规划的答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">substr</span><span class="params">(<span class="keyword">char</span>* sentence, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *substring = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        substring[i] = sentence[start+i];</span><br><span class="line">    &#125;</span><br><span class="line">    substring[len] = <span class="string">'\0'</span>; <span class="comment">// 这个结尾一定要赋'\0'要不比较不了</span></span><br><span class="line">    <span class="keyword">return</span> substring;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="keyword">char</span>** dictionary, <span class="keyword">int</span> dictionarySize, <span class="keyword">char</span>* sentence)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回的是字符数，不是单词数……</span></span><br><span class="line">    <span class="comment">// 这题应该能用动态规划解</span></span><br><span class="line">    <span class="comment">// 转移方程：f[i]=min&#123;f[i-word.length],f[i]&#125;</span></span><br><span class="line">    <span class="comment">// 之所以会有min函数是因为 </span></span><br><span class="line">    <span class="comment">// sentence:"looked" dictionary:["looked","oked"]这种情况，最后就会采取最小匹配</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(sentence); <span class="comment">// sentence长度</span></span><br><span class="line">    <span class="keyword">int</span> dp[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">// 单词长度</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        dp[i+<span class="number">1</span>] = dp[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; dictionarySize;j++)&#123;</span><br><span class="line">            <span class="built_in">size</span> = <span class="built_in">strlen</span>(dictionary[j]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">size</span>&lt;=i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dictionary[j], substr(sentence, i+<span class="number">1</span>-<span class="built_in">size</span>, <span class="built_in">size</span>))==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>] = dp[i+<span class="number">1</span>]&lt;dp[i+<span class="number">1</span>-<span class="built_in">size</span>] ? dp[i+<span class="number">1</span>] : dp[i+<span class="number">1</span>-<span class="built_in">size</span>];</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看别人家的题解，了解到了<strong>字典树</strong>（Trie树）这个概念，同时还有<strong>字符串hash</strong>的解法。<br><a href="https://leetcode-cn.com/problems/re-space-lcci/solution/jian-dan-dp-trieshu-bi-xu-miao-dong-by-sweetiee/" target="_blank" rel="noopener">甜姐的trie解法</a></p>
<hr>
<h4 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h4><p>编写一个程序，找到两个单链表相交的起始节点。<br>利用<strong>两个链表的总长是一样的</strong>这一看似弱智的现象，有点类似于那个前移n位的算法，就是将[0:m]的前[0:n]和后[n+1:m]分别反转，整体再反转，就能实现前移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pA</span> = <span class="title">headA</span>, *<span class="title">pB</span> = <span class="title">headB</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(pA==<span class="literal">NULL</span> || pB==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">        pA = pA == <span class="literal">NULL</span> ? headB : pA-&gt;next;</span><br><span class="line">        pB = pB == <span class="literal">NULL</span> ? headA : pB-&gt;next; </span><br><span class="line">    &#125; <span class="comment">// 当无相交现象时，最后都为NULL时会直接跳出</span></span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p>判断给定链表是否有环。<br>设置快慢指针，快指针一次两步，慢指针一次一步。设置哑结点以优雅的处理边界(后来发现设置没有什么卵用)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummyhead</span>, *<span class="title">fast</span>, *<span class="title">slow</span>;</span> </span><br><span class="line">    dummyhead = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line"></span><br><span class="line">    dummyhead-&gt;next = head;</span><br><span class="line">    slow = dummyhead;</span><br><span class="line">    fast = dummyhead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">NULL</span> || fast-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="地下城与勇士"><a href="#地下城与勇士" class="headerlink" title="地下城与勇士"></a>地下城与勇士</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<ul>
<li>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</li>
<li>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</li>
<li>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</li>
</ul>
<h5 id="初代解法（失败）"><a href="#初代解法（失败）" class="headerlink" title="初代解法（失败）"></a>初代解法（失败）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>** dungeon, <span class="keyword">int</span> dungeonSize, <span class="keyword">int</span>* dungeonColSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[dungeonSize][*dungeonColSize]; <span class="comment">// 申请一个和原二维数组相同大小的二维空间</span></span><br><span class="line">    f[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>] = <span class="number">1</span> - dungeon[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>]; <span class="comment">// 初始化f</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = dungeonSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = *dungeonColSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==dungeonSize<span class="number">-1</span> &amp;&amp; j==*dungeonColSize<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == dungeonSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = f[i][j+<span class="number">1</span>] - dungeon[i][j]; <span class="comment">// 下边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(j == *dungeonColSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = f[i+<span class="number">1</span>][j] - dungeon[i][j]; <span class="comment">// 左边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            f[i][j] = fmin(f[i+<span class="number">1</span>][j], f[i][j+<span class="number">1</span>]) - dungeon[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二代解法（成功）"><a href="#二代解法（成功）" class="headerlink" title="二代解法（成功）"></a>二代解法（成功）</h5><p>这次只修改了代码中的一个逻辑，就是在每一次赋值的时候均将该值与1（生命最小值）相比较。<br>分析原来的算法可以知道，原来的算法对于某些情况的路径是适用的，即在递推过程中，没有一条路径中出现的f值会为负数，所以我用<code>[[-2,-3,-3],[-5,-10,-1],[-10,-30,-5]]</code>这个全负测试用例来测试一代解法是百试不爽的。但错就错在，我们的主角是有生命值限制的，中间一旦生命值&lt;1就会立即死亡。<br>因此，为了改进原算法，只需修改原来的赋值等号右侧，<strong>一旦值小于0，就将该值修改为1</strong>，即我们加入了一个限制条件，我们可以这么理解：按一代解法的主角开挂路径（就如同一个主角开了生命值掉为0都死不了的挂），主角走到该点单看生命值其实已经挂了，我们现在手里没有挂，那么我们为了求出满足条件的最低开局生命值，只能不断手动尽量让这个点的主角残血。那么一直向前推，开局的主角就将是满足当前条件的血量最小值（不断地残血逼近开头，最终达到目的），有点类似于递归思想。<br>这么看的话，一代解法似乎是一种极端，那么如果所有的房间都是治愈房间（值为非负数），那么开局必为残血，<code>f[0][0]=1</code>。感觉这竟然很像高中的数学极限法……不知道这个思路会不会有点用以后。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>** dungeon, <span class="keyword">int</span> dungeonSize, <span class="keyword">int</span>* dungeonColSize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[dungeonSize][*dungeonColSize]; <span class="comment">// 申请一个和原二维数组相同大小的二维空间</span></span><br><span class="line">    f[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>] = fmax(<span class="number">1</span>, <span class="number">1</span> - dungeon[dungeonSize<span class="number">-1</span>][*dungeonColSize<span class="number">-1</span>]); <span class="comment">// 初始化f</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = dungeonSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = *dungeonColSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==dungeonSize<span class="number">-1</span> &amp;&amp; j==*dungeonColSize<span class="number">-1</span>) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == dungeonSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = fmax(<span class="number">1</span>, f[i][j+<span class="number">1</span>] - dungeon[i][j]); <span class="comment">// 下边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(j == *dungeonColSize - <span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = fmax(<span class="number">1</span>, f[i+<span class="number">1</span>][j] - dungeon[i][j]); <span class="comment">// 左边界处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            f[i][j] = fmax(<span class="number">1</span>, fmin(f[i+<span class="number">1</span>][j], f[i][j+<span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<h5 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h5><p>一开始一直超时还纳闷，我这不就是个双层循环吗，至于这么被针对？？最后发现是倒数第二个节点应该在每次循环的时候都指向空，否则链表就有环了，<code>p = p-&gt;next</code>那里肯定要超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span> || head-&gt;next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">head</span>, * <span class="title">cur</span> = <span class="title">head</span>, * <span class="title">q</span>, *<span class="title">lastTwo</span>;</span> <span class="comment">// p指向这一轮被移到前方的尾结点，cur指向当前的头结点</span></span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTwo = p; <span class="comment">// 找到倒数第二个结点</span></span><br><span class="line">        p = p-&gt;next; <span class="comment">// p现在是最后一个结点</span></span><br><span class="line">        q = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = p; <span class="comment">// 形成了这一轮的L0和Ln连接</span></span><br><span class="line">        p-&gt;next = q; <span class="comment">// 形成了L0，Ln，L1的连接</span></span><br><span class="line"></span><br><span class="line">        cur = cur-&gt;next-&gt;next; <span class="comment">// 更新cur</span></span><br><span class="line">        p = cur; <span class="comment">// 更新p</span></span><br><span class="line">        lastTwo-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 更新lastTwo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实做的时候就知道自己这个$O(n^2)$绝对性能贼差。</p>
<h5 id="别人解法"><a href="#别人解法" class="headerlink" title="别人解法"></a>别人解法</h5><ul>
<li>快慢指针定中点(慢一步，快两步，快到尾，慢到中)</li>
<li>后半部分链表反转</li>
<li>插空站队</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == null || head.next == null) <span class="keyword">return</span>;</span><br><span class="line">        ListNode s = head, f = head.next;</span><br><span class="line">        <span class="keyword">while</span> (f != null &amp;&amp; f.next != null) &#123;</span><br><span class="line">            s = s.next;</span><br><span class="line">            f = f.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出后，s指向链表中间节点</span></span><br><span class="line">        ListNode r = s.next; <span class="comment">// r保存s后面的队列</span></span><br><span class="line">        s.next = null;</span><br><span class="line">        ListNode prev = null, curr = r;</span><br><span class="line">        <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">            ListNode t = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时的prev就是反转后的头结点</span></span><br><span class="line">        ListNode c1 = head, c2 = prev, c3 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> le = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (c1 != null &amp;&amp; c2 != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (le % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                c3.next = c1;</span><br><span class="line">                c1 = c1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c3.next = c2;</span><br><span class="line">                c2 = c2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            le ++;</span><br><span class="line">            c3 = c3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c1 != null) c3.next = c1;</span><br><span class="line">        <span class="keyword">if</span> (c2 != null) c3.next = c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表反转通式(头结点为哑结点)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">r</span> = <span class="title">dummyhead</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// 保存头结点以后信息</span></span><br><span class="line">dummyhead-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头结点独立</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">curr</span> = <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">t</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// 保存当前结点后所有信息</span></span><br><span class="line">    curr-&gt;next = prev; <span class="comment">// curr结点的下一个为prev</span></span><br><span class="line">    prev = curr; <span class="comment">// prev更新为curr（前移一位）</span></span><br><span class="line">    curr = t; <span class="comment">// 当前结点更新为当前结点原来的后面信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = prev; <span class="comment">// 此时prev为头结点</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h4><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。</li>
<li>不必考虑输出顺序。</li>
</ul>
<h5 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h5><ul>
<li><code>breakLable</code>解决了p指向是空的情况。</li>
<li>遭遇死亡<code>stack-buffer-overflow</code>和<code>heap-buffer-overflow</code>，初始化<code>returnSize</code>得到结论（Leetcode这个对C的设定真的不好，非要弄<code>returnSize</code>）</li>
<li>提交发现空表出问题，修改了初始返回空数组。</li>
<li>发现一个奇怪的案例不行，本机调试发现对nums1的计数器有问题，问题出在<code>break</code>后，没有考虑中途<code>break</code>和最后<code>break</code>的差别，修改后终于成功。</li>
</ul>
<h5 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h5><p>hash表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 出现次数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span> *<span class="title">next</span>;</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">intersect</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为涉及到出现次数，用hash表</span></span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums1Size == <span class="number">0</span> || nums2Size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">0</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span> *<span class="title">head</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * fmin(nums1Size, nums2Size));</span><br><span class="line">    head = (struct hashNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct hashNode));</span><br><span class="line"></span><br><span class="line">    head-&gt;index = nums1[<span class="number">0</span>];</span><br><span class="line">    head-&gt;value = <span class="number">1</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums1Size; i++) &#123; <span class="comment">// 遍历nums1，得到hash表</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">int</span> breakLabel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] == p-&gt;index)&#123;</span><br><span class="line">                p-&gt;value++;</span><br><span class="line">                breakLabel = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] == p-&gt;index)&#123;</span><br><span class="line">                p-&gt;value++;</span><br><span class="line">                breakLabel = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(breakLabel == <span class="number">0</span>)&#123; <span class="comment">// 若hash表中没有该值，则新建</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">hashNode</span> *<span class="title">newNode</span> = (<span class="title">struct</span> <span class="title">hashNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">hashNode</span>));</span></span><br><span class="line">            newNode-&gt;index = nums1[i];</span><br><span class="line">            newNode-&gt;value = <span class="number">1</span>;</span><br><span class="line">            p-&gt;next = newNode;</span><br><span class="line">            newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2Size; j++) &#123; <span class="comment">// 检查第二个数组里面与hash表的对应情况</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2[j] == p-&gt;index &amp;&amp; p-&gt;value &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                p-&gt;value--;</span><br><span class="line">                res[(*returnSize)++] = nums2[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="双指针思路"><a href="#双指针思路" class="headerlink" title="双指针思路"></a>双指针思路</h5><ul>
<li>如果两个数组是有序的，则可以便捷地计算两个数组的交集。</li>
<li>首先对两个数组进行排序，然后使用两个指针遍历两个数组。</li>
<li>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* _a, <span class="keyword">const</span> <span class="keyword">void</span>* _b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = _a, *b = (<span class="keyword">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a == *b ? <span class="number">0</span> : *a &gt; *b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">intersect</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    qsort(nums1, nums1Size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line">    qsort(nums2, nums2Size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* intersection = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * fmin(nums1Size, nums2Size));</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index1 &lt; nums1Size &amp;&amp; index2 &lt; nums2Size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">            index1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intersection[(*returnSize)++] = nums1[index1];</span><br><span class="line">            index1++;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个思路真的很简单漂亮啊，不过老实说就算提示我排序后更简单，这个方法我也可能会想不到……</li>
</ul>
<hr>
<h4 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h4><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<h5 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>** triangle, <span class="keyword">int</span> triangleSize, <span class="keyword">int</span>* triangleColSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 相当于每行数组左对齐后，只能向右下走或向下走</span></span><br><span class="line">    <span class="comment">// f[i][j] = min&#123;f[i-1][j], f[i-1][j-1]&#125; + f[i][j]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangleSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangleColSize[i]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) &#123;</span><br><span class="line">                triangle[i][j] += triangle[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == triangleColSize[i] - <span class="number">1</span>) &#123;</span><br><span class="line">                triangle[i][j] += triangle[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                triangle[i][j] += fmin(triangle[i<span class="number">-1</span>][j], triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = triangle[triangleSize - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; triangleSize; k++) &#123; <span class="comment">// 逐一遍历最后一行输出最小值</span></span><br><span class="line">        res = triangle[triangleSize - <span class="number">1</span>][k] &lt; res ? triangle[triangleSize - <span class="number">1</span>][k] : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实答案给的一种从三角形下侧遍历到上侧的思路挺好的，因为不用考虑边界情况了（下侧结点多于上侧）。<br>转移方程：<br>$$f[i][j]=min{f[i+1][j], f[i+1][j+1]}$$</p>
<hr>
<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><p>给出n，输出[1:n]的序列能构成的不同的二叉搜索树的数量。</p>
<h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p>dp求解：<br>大体思路：将[1:n]的序列，选定其中一个数为<code>i</code>，以它为根节点，由于根节点不同，所以建出来的树具有唯一性。再具体考虑这个以<code>i</code>为根节点建造的树，左右子树分别是[1:i-1]和[i+1:n]，显然[i+1:n]可以直接转换为[1:n-i]，那么以<code>i</code>为根节点所建造的树就是[1:i-1]和[1:n-i]所建造的树的<strong>笛卡尔乘积</strong>。</p>
<p>具体分析：</p>
<ol>
<li>状态<ul>
<li>$G(n)$：长度为<code>n</code>的序列能构成的不同二叉搜索树的个数</li>
</ul>
</li>
<li>初始条件<br>$$G(0) = G(1) = 1$$</li>
<li>转移方程<br>$$G(n) = \sum_{i=1}^nG(i-1)*G(n-i)$$</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> G[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">    G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两数之和II-输入有序数组"><a href="#两数之和II-输入有序数组" class="headerlink" title="两数之和II-输入有序数组"></a>两数之和II-输入有序数组</h4><p>给定一个升序排列的数组，找到两个数的加和使它们的和为目标数。返回两个数的索引+1。</p>
<h5 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> numbersSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 双指针思路</span></span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> breakLabel = <span class="number">0</span>; <span class="comment">// 寻找到目标数的标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index2 &lt; numbersSize) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index1] + numbers[index2] &lt; target) &#123; <span class="comment">// 如果相邻加起来小于目标数，指针前移</span></span><br><span class="line">            index1++;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index1] + numbers[index2] == target) &#123; <span class="comment">// 如果等于，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果大于目标数</span></span><br><span class="line">            <span class="keyword">while</span>(index1 &gt; <span class="number">0</span>) &#123; <span class="comment">// 先试着逐步后移慢指针</span></span><br><span class="line">                index1--;</span><br><span class="line">                <span class="keyword">if</span>(numbers[index1] + numbers[index2] == target) &#123;</span><br><span class="line">                    breakLabel = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(breakLabel == <span class="number">0</span>) &#123; <span class="comment">// 如果慢指针到头了未找到，更新两个索引为此次循环开始时的位置再各前移一个位置</span></span><br><span class="line">                index2++;</span><br><span class="line">                index1 = index2<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(breakLabel == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳出循环意味着已找到答案</span></span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    res[<span class="number">0</span>] = index1 + <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">1</span>] = index2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题解解法"><a href="#题解解法" class="headerlink" title="题解解法"></a>题解解法</h5><p>双指针分别从两侧向内逼近遍历：</p>
<ul>
<li>如果加和小于<code>target</code>，慢指针前移。</li>
<li>如果加和大于<code>target</code>，慢指针后移。</li>
<li>如果相等，直接返回。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[low] + numbers[high];</span><br><span class="line">            <span class="keyword">if</span> (sum == target)</span><br><span class="line">                <span class="keyword">return</span> &#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                ++low;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</li>
</ul>
<hr>
<h4 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h4><p>给定一个整数，循环计算各位的平方和，直到和为0，输出true。若陷入死循环，输出false。</p>
<h5 id="解法（参照官方题解）"><a href="#解法（参照官方题解）" class="headerlink" title="解法（参照官方题解）"></a>解法（参照官方题解）</h5><p>思路：双指针，建造<strong>虚拟链表</strong><br>原理：当陷入死循环时，相当于之前所有的记录构成了一个含环的链表。快指针前进速率永远是慢指针的两倍，当最后行进相交时，可以证明该链表含环。并没有真的建造一个链表，而是通过累次计算的次数不一样，来逐步构建这个链表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        res += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = n, fast = getNext(n);</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="number">1</span> &amp;&amp; slow != fast) &#123;</span><br><span class="line">        slow = getNext(slow);</span><br><span class="line">        fast = getNext(getNext(fast));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="存在重复元素II"><a href="#存在重复元素II" class="headerlink" title="存在重复元素II"></a>存在重复元素II</h4><p>给定一个整数数组和一个整数 <code>k</code>，判断数组中是否存在两个不同的索引 <code>i</code> 和 <code>j</code>，使得 <code>nums [i] = nums [j]</code>，并且 <code>i</code> 和 <code>j</code>的差的绝对值至多为 <code>k</code>。</p>
<h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><p>这个解法出自于官方题解，思路很简单，但主要是它的边界处理给了我一些启发。如果是以一个搜索框进行遍历操作的时候，越界的时候，以后可以用<code>max</code>或<code>min</code>这些函数来优雅地解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.max(i - k, <span class="number">0</span>); j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Time Limit Exceeded.</span></span><br></pre></td></tr></table></figure>

<h5 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h5><h6 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h6><p>通过散列表，即创造一个长度为k的表。<br>遍历数组，对于每个元素：</p>
<ul>
<li>在散列表中进行搜索，若存在，返回<code>true</code></li>
<li>在散列表中插入当前元素</li>
<li>如果当前大小超过了k，则将所待最久的元素移除</li>
</ul>
<p>相当于一个<strong>能遍历的队列</strong>。</p>
<h6 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h6><p>通过<code>hash</code>，<code>key</code>为<code>num</code>，<code>value</code>为其<code>index</code>。<br>遍历数组，对于每个元素：</p>
<ul>
<li>若元素在表中，判断<code>i-m[nums[i]] &lt;= k</code><ul>
<li>若<code>true</code>，返回<code>true</code></li>
<li>若<code>false</code>，更新其<code>m[nums[i]]</code>为<code>i</code></li>
</ul>
</li>
<li>若元素不在表中，更新其<code>m[nums[i]]</code>为<code>i</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter != m.<span class="built_in">end</span>() &amp;&amp; i - m[nums[i]] &lt;= k) &#123;</span><br><span class="line">                <span class="comment">// 若存在表中，且下标差符合要求</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="存在重复元素III"><a href="#存在重复元素III" class="headerlink" title="存在重复元素III"></a>存在重复元素III</h4><h5 id="个人解法（超时）"><a href="#个人解法（超时）" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// key:nums[i] value:i</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(nums[j]);</span><br><span class="line">            <span class="keyword">if</span>(iter != m.<span class="built_in">end</span>() &amp;&amp; j - iter-&gt;second &lt;= k)&#123; <span class="comment">// 如果新纳入的值已经存在表中 且 index差小于等于k 则返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">// 否则更新表</span></span><br><span class="line">                m[nums[j]] = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = nums[j]; <span class="comment">// temp表示当前的纳入表的数值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = temp-t; i &lt;= temp+t; ++i) &#123; </span><br><span class="line">                <span class="comment">// 然后在哈希表的[temp-t,temp+t]范围搜索是否这样的key为i</span></span><br><span class="line">                <span class="comment">// 使得 value存在(当前表中存在满足绝对值差&lt;=t条件的数) 且 m[nums[j]]-m[i] &lt;= k(存在的数也满足下标差&lt;=k)</span></span><br><span class="line">                <span class="keyword">if</span>(m.count(i) == <span class="number">1</span> &amp;&amp; m[temp] - m[i] &lt;= k &amp;&amp; i!=temp) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要是在<code>[temp-t,temp+t]</code>范围内查找的时候，如果t过大，会很慢很慢。</p>
<h5 id="他人解法"><a href="#他人解法" class="headerlink" title="他人解法"></a>他人解法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; <span class="built_in">set</span>;  <span class="comment">// 新建集合set</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;  <span class="comment">// 遍历nums</span></span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">set</span>.lower_bound((<span class="keyword">long</span>) nums[i] - t);  <span class="comment">// 将不小于nums[i] - t的迭代器返回给it</span></span><br><span class="line">            <span class="keyword">if</span>(it != <span class="built_in">set</span>.<span class="built_in">end</span>() &amp;&amp; *it &lt;= (<span class="keyword">long</span>) nums[i] + t)</span><br><span class="line">            <span class="comment">// 如果这个数存在，且不大于nums[i] + t</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">set</span>.insert(nums[i]);  <span class="comment">// 将nums[i]加入set集合</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">size</span>() == k + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">set</span>.erase(nums[i - k]); <span class="comment">//保证滑动窗口大小为k</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h4><p>给定字符串<code>s</code>和<code>t</code>，判断<code>s</code>是否为<code>t</code>的子序列。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<h5 id="个人解答-2"><a href="#个人解答-2" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n_s = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_s ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">n_t</span> = t.length();  <span class="comment">// 更新t的长度</span></span><br><span class="line">            <span class="keyword">auto</span> pos = t.<span class="built_in">find</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(pos != t.npos) &#123; <span class="comment">// 如果找到了，将t替换成其后的子串</span></span><br><span class="line">                t = t.substr(pos + <span class="number">1</span>, <span class="keyword">n_t</span> - pos - <span class="number">1</span>); <span class="comment">// 更新t</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="排列硬币"><a href="#排列硬币" class="headerlink" title="排列硬币"></a>排列硬币</h4><p>你总共有<code>n</code>枚硬币，你需要将它们摆成一个阶梯形状，第<code>k</code>行就必须正好有<code>k</code>枚硬币。</p>
<p>给定一个数字<code>n</code>，找出可形成完整阶梯行的总行数。</p>
<p><code>n</code>是一个非负整数，并且在32位有符号整型的范围内。</p>
<h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p>时间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt;= i) &#123;</span><br><span class="line">            n -= i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h5><p>时间复杂度：$O(log_2(n/2+1))$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找[1:n/2 + 1]中的一个中间数mid，使得(mid+1)*mid/2==n</span></span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">0</span>, <span class="built_in">end</span> = (<span class="keyword">long</span>)n / <span class="number">2</span> + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span> - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid * (mid + <span class="number">1</span>) == (<span class="keyword">long</span>)n * <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">int</span>(mid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid * (mid + <span class="number">1</span>) &lt; (<span class="keyword">long</span>)n * <span class="number">2</span>) &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">end</span> = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">end</span> * (<span class="built_in">end</span> + <span class="number">1</span>) == (<span class="keyword">long</span>)n * <span class="number">2</span>) ? (<span class="keyword">int</span>)<span class="built_in">end</span> : (<span class="keyword">int</span>)start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a>计数质数</h4><p>统计所有小于非负整数<code>n</code>的质数的数量。</p>
<h5 id="个人解法（超时）-1"><a href="#个人解法（超时）-1" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= (n<span class="number">-1</span>)/<span class="number">2</span>; ++i) &#123; </span><br><span class="line">            <span class="keyword">if</span>((n<span class="number">-1</span>) % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> countPrimes(n<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countPrimes(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="题解解法-1"><a href="#题解解法-1" class="headerlink" title="题解解法"></a>题解解法</h5><p>是排除法，排除从1到n-1范围内的所有质数（将其标志位置为0）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//n = 15</span></span><br><span class="line">        <span class="keyword">int</span> a[n+<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            a[i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i)</span><br><span class="line">                    a[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>没有想到有朝一日，这题居然也成了问题，但真没写对，555</p>
<h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><p>假设列表为：<br>$$n1\rightarrow…\rightarrow n_{k-1}\rightarrow n_k\rightarrow…\rightarrow n_m \rightarrow \varnothing$$<br>若$n_{k+1}$到$n_m$已经被反转，而我们已经处于$n_k$。<br>$$n1\rightarrow…\rightarrow n_{k-1}\rightarrow n_k\leftarrow…\leftarrow n_m$$<br>则只需将$n_{k+1}$的下一个结点指向$n_k$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="仅含1的字符串"><a href="#仅含1的字符串" class="headerlink" title="仅含1的字符串"></a>仅含1的字符串</h4><p>给你一个二进制字符串<code>s</code>（仅由<code>&#39;0&#39;</code>和<code>&#39;1&#39;</code>组成的字符串）。</p>
<p>返回所有字符都为<code>1</code>的子字符串的数目。</p>
<p>由于答案可能很大，请你将它对<code>10^9 + 7</code>取模后返回。</p>
<h5 id="个人解法-2"><a href="#个人解法-2" class="headerlink" title="个人解法"></a>个人解法</h5><p>hash表记录每段连续的1出现次数以及频次。<br>例如：<code>&quot;01101110111110011&quot;</code><br>对应的hash表为<br><code>m[2] = 2;
m[3] = 1;
m[5] = 1;</code><br>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSub</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oneCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// key:连续1出现的次数 value:这个次数出现的频次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                oneCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'0'</span> &amp;&amp; oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(m.count(oneCount) == <span class="number">0</span>) <span class="comment">// hash表中没有对应的键</span></span><br><span class="line">                    m[oneCount] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    m[oneCount]++;</span><br><span class="line">            &#125; </span><br><span class="line">            oneCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m.count(oneCount) == <span class="number">0</span>) <span class="comment">// hash表中没有对应的键</span></span><br><span class="line">                    m[oneCount] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m[oneCount]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;int,int&gt;&gt; v_map(m.begin(),m.end());</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, tn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tmp:v_map)&#123;</span><br><span class="line">            tn = ((<span class="keyword">long</span>)tmp.first + <span class="number">1</span>)*(<span class="keyword">long</span>)tmp.first / <span class="number">2</span>; <span class="comment">// 计算1+2+3+...+n</span></span><br><span class="line">            sum += ((<span class="keyword">long</span>)tmp.second*tn); <span class="comment">// 加等于 tn乘对应频次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(sum%MAXN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h5 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h5><p>不需要hash表，直接就地+=运算（瞬间感觉我用hash表，简直是脱裤子放p）<br>速度快了一倍多，，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">calValue</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * (n+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSub</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oneCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> MAXN = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                oneCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'0'</span> &amp;&amp; oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += calValue(oneCount);</span><br><span class="line">            &#125; </span><br><span class="line">            oneCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(oneCount != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += calValue(oneCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(sum%MAXN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h4><p>有<code>n</code>个气球，编号为<code>0</code>到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p>
<p>现在要求你戳破所有的气球。如果你戳破气球<code>i</code>，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的<code>left</code>和<code>right</code>代表和<code>i</code>相邻的两个气球的序号。注意当你戳破了气球<code>i</code>后，气球<code>left</code>和气球<code>right</code>就变成了相邻的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>说明:</p>
<ul>
<li>你可以假设<code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li>
<li><code>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</code></li>
</ul>
<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>看了好几个大佬的题解，都是从回溯法到记忆递归向下一步步优化到动态规划的。<br><a href="https://qoogle.top/leetcode-312-burst-balloons/" target="_blank" rel="noopener">大佬1传送门</a><br><a href="https://www.cnblogs.com/niuyourou/p/11964842.html" target="_blank" rel="noopener">大佬2传送门</a></p>
<h5 id="动态规划代码"><a href="#动态规划代码" class="headerlink" title="动态规划代码"></a>动态规划代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>)); <span class="comment">// 新建一个dp二维数组</span></span><br><span class="line">        nums.push_back(<span class="number">1</span>);</span><br><span class="line">        nums.insert(nums.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k<span class="number">-1</span>] + dp[k+<span class="number">1</span>][j] + nums[k] * nums[i - <span class="number">1</span>] * nums[j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="旋转数组的最小值"><a href="#旋转数组的最小值" class="headerlink" title="旋转数组的最小值"></a>旋转数组的最小值</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 $[3,4,5,1,2]$ 为 $[1,2,3,4,5]$ 的一个旋转，该数组的最小值为1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分查找:找到该元素的左侧大于它，右侧大于等于它</span></span><br><span class="line">        <span class="keyword">int</span> n = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">end</span> &gt; start) &#123;</span><br><span class="line">            <span class="comment">//int mid = (start + end) / 2;</span></span><br><span class="line">            <span class="keyword">int</span> mid = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &lt; numbers[<span class="built_in">max</span>(<span class="number">0</span>, mid - <span class="number">1</span>)] <span class="comment">/*&amp;&amp; numbers[mid] &lt;= numbers[min(n - 1, mid + 1)]*/</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[mid];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[<span class="built_in">end</span>]) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[<span class="built_in">end</span>]) &#123;</span><br><span class="line">                <span class="built_in">end</span> = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">end</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="built_in">end</span>];       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个解法的边界处理非常值得总结一下，尤其是<code>start = mid + 1</code>和<code>end--</code>这两个地方非常容易出错。</p>
<ul>
<li><code>start = mid + 1</code>避免了形同$[3,1]$这种类型</li>
<li><code>end--</code>避免了$[1,1,1]$这样的结尾出现重复数的情形</li>
</ul>
<hr>
<p>Leetcode日记I就到这里啦，LeetcodeII日记再见~</p>
]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode周赛</title>
    <url>/2020/07/26/Leetcode%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<p>暑假的Leetcode周赛上的题目集合。</p>
<a id="more"></a>
<h2 id="第199次周赛"><a href="#第199次周赛" class="headerlink" title="第199次周赛"></a>第199次周赛</h2><h3 id="灯泡开关IV"><a href="#灯泡开关IV" class="headerlink" title="灯泡开关IV"></a>灯泡开关IV</h3><p><a href="https://leetcode-cn.com/problems/bulb-switcher-iv/" target="_blank" rel="noopener">题目链接</a></p>
<h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>从左到右遇到不同的数加一，再加上第一个数的值即可。<br>（？？什么原理）</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>参考vitamin用户。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = target.length();</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[n][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[n][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][0] 表示从第i个到末尾转换成target的次数</span></span><br><span class="line">        <span class="comment">// dp[i][1] 表示从第i个到末尾转换成target反的次数</span></span><br><span class="line">        <span class="comment">// 当target[i] = 0</span></span><br><span class="line">        <span class="comment">// dp[i][0] = dp[i + 1][0]  dp[i][1] = dp[i + 1][0] + 1</span></span><br><span class="line">        <span class="comment">// 当target[i] = 1</span></span><br><span class="line">        <span class="comment">// dp[i][0] = dp[i + 1][1] + 1  dp[i][1] = dp[i + 1][1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i + <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i + <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i + <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="好叶子节点对的数量"><a href="#好叶子节点对的数量" class="headerlink" title="好叶子节点对的数量"></a>好叶子节点对的数量</h4><p><a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/" target="_blank" rel="noopener">题目链接</a></p>
<h5 id="BFS-记录深度信息（失败）"><a href="#BFS-记录深度信息（失败）" class="headerlink" title="BFS+记录深度信息（失败）"></a>BFS+记录深度信息（失败）</h5><p>考虑欠妥，光关注了例子里的案例，单纯的想同一株子树的路径长度等于层数相减再+2，然而这只适用于源自于同一个祖宗节点的两个叶子节点。最后解答错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; leafNode;  <span class="comment">// 深度，左右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">queue</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt;&amp; q, <span class="keyword">int</span> tag)</span> </span>&#123; <span class="comment">// 0 左子树 1 右子树</span></span><br><span class="line">        <span class="keyword">if</span> (q.front().first == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//int dep = 1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="comment">//dep++;</span></span><br><span class="line">            <span class="keyword">auto</span> temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp.first-&gt;left || temp.first-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp.first-&gt;left != <span class="literal">NULL</span>) q.push(&#123;temp.first-&gt;left, temp.second + <span class="number">1</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span> (temp.first-&gt;right != <span class="literal">NULL</span>) q.push(&#123;temp.first-&gt;right, temp.second + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leafNode.push_back(&#123;temp.second, tag&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最短路径长度是（一侧的话，深度相减 + 2。异侧的话，深度相加）</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; qLeft; <span class="comment">// 结点，深度信息</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; qRight;</span><br><span class="line">        qLeft.push(&#123;root-&gt;left, <span class="number">1</span>&#125;); <span class="comment">// 纳入左根节点</span></span><br><span class="line">        qRight.push(&#123;root-&gt;right, <span class="number">1</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        helper(qLeft, <span class="number">0</span>);</span><br><span class="line">        helper(qRight, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (auto temp:leafNode) &#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; temp.first &lt;&lt; " " &lt;&lt; temp.second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leafNode.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; leafNode.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leafNode[i].second == leafNode[j].second &amp;&amp; <span class="built_in">abs</span>(leafNode[i].first - leafNode[j].first) + <span class="number">2</span> &lt;= distance)</span><br><span class="line">                    ++ans;</span><br><span class="line">                <span class="keyword">if</span> (leafNode[i].second != leafNode[j].second &amp;&amp; leafNode[i].first + leafNode[j].first &lt;= distance)</span><br><span class="line">                    ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root, distance, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 后序遍历dfs</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;; <span class="comment">// 是叶子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">auto</span> left = dfs(root-&gt;left, distance, ans);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dis:left) &#123; <span class="comment">// dis代表子节点到祖宗节点的相对路径</span></span><br><span class="line">            <span class="keyword">if</span> (++dis &gt; distance) <span class="keyword">continue</span>; <span class="comment">// 如果单侧路径已经超过distance，直接跳过</span></span><br><span class="line">            ret.push_back(dis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> right = dfs(root-&gt;right, distance, ans);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dis:right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++dis &gt; distance) <span class="keyword">continue</span>;</span><br><span class="line">            ret.push_back(dis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当完成一个完整的左子树、右子树、根节点遍历过程后，对left和right进行配对相加计算，相加后如果符合则ans++</span></span><br><span class="line">        <span class="comment">// 这样保证每一个祖宗节点的所有叶子节点都能被考虑到</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l:left) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r:right) &#123;</span><br><span class="line">                ans += (l + r &lt;= distance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第200场周赛"><a href="#第200场周赛" class="headerlink" title="第200场周赛"></a>第200场周赛</h2><h3 id="最大得分"><a href="#最大得分" class="headerlink" title="最大得分"></a>最大得分</h3><p><a href="https://leetcode-cn.com/problems/get-the-maximum-score/" target="_blank" rel="noopener">题目链接</a></p>
<p>参照LenoDeng的解法，以每个相同的通路为断点，求出每段的最大和，最后加和即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.<span class="built_in">size</span>() &amp;&amp; j &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                res += (<span class="built_in">max</span>(sum1, sum2) + nums1[i]);</span><br><span class="line">                sum1 = <span class="number">0</span>; sum2 = <span class="number">0</span>;</span><br><span class="line">                ++i; ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                sum2 += nums2[j];</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum1 += nums1[i];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sum1 += nums1[i]; </span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sum2 += nums2[j];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">max</span>(sum1, sum2);</span><br><span class="line">        <span class="keyword">return</span> res % (<span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第32场双周赛"><a href="#第32场双周赛" class="headerlink" title="第32场双周赛"></a>第32场双周赛</h2><h3 id="平衡括号字符串的最小插入次数"><a href="#平衡括号字符串的最小插入次数" class="headerlink" title="平衡括号字符串的最小插入次数"></a>平衡括号字符串的最小插入次数</h3><p><a href="https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string/" target="_blank" rel="noopener">题目链接</a></p>
<p>栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) stk.push(<span class="string">'('</span>); <span class="comment">// 左括号直接压栈</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 右括号分类讨论</span></span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123; <span class="comment">// 如果右括号在最后一位</span></span><br><span class="line">                    <span class="keyword">if</span> (stk.empty()) ans += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        ans += <span class="number">1</span>;</span><br><span class="line">                        stk.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i + <span class="number">1</span>] == <span class="string">'('</span>) &#123; <span class="comment">// 如果下一个是左括号</span></span><br><span class="line">                        <span class="keyword">if</span> (stk.empty()) &#123;</span><br><span class="line">                            ans += <span class="number">2</span>;</span><br><span class="line">                            stk.push(<span class="string">'('</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不需要出栈，因为下一次要再入栈</span></span><br><span class="line">                            ans += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果下一个是右括号</span></span><br><span class="line">                        <span class="keyword">if</span> (stk.empty()) ans += <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> stk.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    i += <span class="number">2</span>; <span class="comment">// 由于判断了后一位，所以i要后移两位</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!stk.empty()) ans += (<span class="number">2</span> * (stk.<span class="built_in">size</span>()));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="找出最长的超赞子字符串"><a href="#找出最长的超赞子字符串" class="headerlink" title="找出最长的超赞子字符串"></a>找出最长的超赞子字符串</h3><p><a href="https://leetcode-cn.com/problems/find-longest-awesome-substring/" target="_blank" rel="noopener">题目链接</a></p>
<h4 id="状态压缩-位运算"><a href="#状态压缩-位运算" class="headerlink" title="状态压缩+位运算"></a>状态压缩+位运算</h4><ul>
<li><code>1 &lt;&lt; i (0 &lt;= i &lt;= 9)</code> 表示 $2^i$</li>
</ul>
<p>状态说明：例如当出现数字$i = 2$，将其状态$status$通过$1 &lt;&lt; i$转换为$000000100$，这样<strong>从右向左数第2位</strong>就置为了1，这表示i出现了1次（奇数次）。</p>
<p>递推过程：向下递推的时候进行异或运算，即<br>$$status \land = (1 &lt;&lt; i)$$<br>就能获取截止到现在的，<strong>前i个字符的奇偶出现情况</strong>，其实也属于前缀和的思想。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestAwesome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*hash表存储了状态status（且全偶）出现的最新一次下标*/</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// status：idx</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, ans = <span class="number">1</span>;</span><br><span class="line">        m[cur] = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 00110 6</span></span><br><span class="line">        <span class="comment">// 00010 2</span></span><br><span class="line">        <span class="comment">// 00100 4</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; s.length(); ++c) &#123;</span><br><span class="line">            <span class="keyword">int</span> ch = s[c] - <span class="string">'0'</span>;</span><br><span class="line">            cur ^= (<span class="number">1</span> &lt;&lt; ch); <span class="comment">// 计算当前位的status</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = cur ^ (<span class="number">1</span> &lt;&lt; i); <span class="comment">// 试探有没有单个数出现奇数个(cur里面只有一个0)</span></span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">find</span>(next) != m.<span class="built_in">end</span>()) &#123; <span class="comment">// 如果试探出了全偶数的情况，证明这个是单奇数</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, c - m[next]); <span class="comment">// 返回该区域长度与ans相比的较大值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(cur) == m.<span class="built_in">end</span>()) &#123; <span class="comment">// 如果前面没有保存全偶状态</span></span><br><span class="line">                m[cur] = c;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则将ans更新为该区域长度与ans相比的最大值</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, c - m[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="第201场周赛"><a href="#第201场周赛" class="headerlink" title="第201场周赛"></a>第201场周赛</h2><h3 id="和为目标值的最大不重叠非空子数组数目"><a href="#和为目标值的最大不重叠非空子数组数目" class="headerlink" title="和为目标值的最大不重叠非空子数组数目"></a>和为目标值的最大不重叠非空子数组数目</h3><p>前缀和+哈希表+dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pre_idx; <span class="comment">// pre:idx</span></span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>]; <span class="comment">// dp[i]表示前i个非空不重叠子数组的最大数目</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            pre += nums[i - <span class="number">1</span>]; <span class="comment">// 求得前缀和</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>]; <span class="comment">// dp初始化</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 寻找[j, i]区间内和满足要求的最近的j(pre[i] - pre[j] = target)</span></span><br><span class="line">            <span class="keyword">int</span> j = pre_idx[pre - target];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j) &#123; <span class="comment">// 如果存在这样的j</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 注意:j==0有两种可能 1.当前前缀和就是target 2.不存在这样的元素</span></span><br><span class="line">                <span class="keyword">if</span> (pre == target) &#123; <span class="comment">// </span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(<span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre_idx[pre] = i; <span class="comment">// 更新前缀和出现的下标 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前缀和+哈希表+贪心</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">-1</span>; <span class="comment">// pre表示前缀和，end表示已经保存的子数组中的最大下标</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pre_idx; <span class="comment">// pre:idx</span></span><br><span class="line">        pre_idx[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 访问到pre刚好为target时，此时的pre_idx==0为错误值，应为下标-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            pre += nums[i - <span class="number">1</span>]; <span class="comment">// 求得前缀和</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 寻找[j, i]区间内和满足要求的最近的j(pre[i] - pre[j] = target)</span></span><br><span class="line">            <span class="keyword">if</span> (pre_idx.<span class="built_in">find</span>(pre - target) != pre_idx.<span class="built_in">end</span>()) &#123; <span class="comment">/// 如果这样的前缀存在</span></span><br><span class="line">                <span class="keyword">int</span> j = pre_idx[pre - target]; <span class="comment">// 获取区间上界j</span></span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &gt; <span class="built_in">end</span>) &#123; <span class="comment">// 如果j在end之后</span></span><br><span class="line">                    ++ans;</span><br><span class="line">                    <span class="built_in">end</span> = i - <span class="number">1</span>; <span class="comment">// 将当前已纳入结果中的子数组的最大下标更新为end</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre_idx[pre] = i - <span class="number">1</span>; <span class="comment">// 更新前缀和出现的下标 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="切棍子的最小成本"><a href="#切棍子的最小成本" class="headerlink" title="切棍子的最小成本"></a>切棍子的最小成本</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/" target="_blank" rel="noopener">题目链接</a></p>
<p><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/solution/c-dong-tai-gui-hua-si-lu-zhuan-hua-by-ming-tian-ge/" target="_blank" rel="noopener">参考题解</a><br>这题我看完题解觉得下次出现类似的题还是不会，可能这就是dp吧，太难入门了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;</span><br><span class="line">        sort(cuts.<span class="built_in">begin</span>(), cuts.<span class="built_in">end</span>());</span><br><span class="line">        cuts.insert(cuts.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        cuts.push_back(n);</span><br><span class="line">        <span class="comment">// 初始化dp各元素为极大值</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(cuts.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cuts.<span class="built_in">size</span>(),<span class="number">100000000</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cuts.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, cuts.<span class="built_in">size</span>() - <span class="number">1</span>, dp, cuts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &lt; <span class="number">100000000</span>)  <span class="keyword">return</span> dp[i][j]; <span class="comment">// 进行计算的直接返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; ++k) &#123; <span class="comment">// 对没有进行dp计算的区间[i, j]进行计算</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span> (dp[i][j], dfs(i, k, dp, cuts) + dfs(k , j, dp, cuts) + cuts[j] - cuts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>略去dfs过程，优化dp，参考随意凯的题解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = cuts.<span class="built_in">size</span>();</span><br><span class="line">        cuts.push_back(<span class="number">0</span>);</span><br><span class="line">        cuts.push_back(n);</span><br><span class="line">        sort(cuts.<span class="built_in">begin</span>(),cuts.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> dp[m + <span class="number">2</span>][m + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][i + <span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*dp思路过程----（）代表可计算的dp*/</span></span><br><span class="line">        <span class="comment">/*以 m = 6 为例*/</span></span><br><span class="line">        <span class="comment">/*每一步的dp均依靠上层计算好的dp值递推*/</span></span><br><span class="line">        <span class="comment">// 0  1  2  3  4  5  6  7  |</span></span><br><span class="line">        <span class="comment">// () () () () () () () () |k = 1 dp均赋值为0(不可分，无成本)</span></span><br><span class="line">        <span class="comment">// (   ) (   ) (   ) (   ) |k = 2</span></span><br><span class="line">        <span class="comment">//    (   ) (   ) (   )    |k = 2</span></span><br><span class="line">        <span class="comment">// (      ) (      )       |k = 3</span></span><br><span class="line">        <span class="comment">//    (      ) (      )    |k = 3</span></span><br><span class="line">        <span class="comment">//       (       ) (     ) |k = 3</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// (                     ) |k = m + 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= m + <span class="number">1</span>; k++) &#123; <span class="comment">// 每一个k代表当前循环枚举到的截断点个数为k个</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;"k"&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt;= m + <span class="number">1</span>; i++) &#123; <span class="comment">// i为木头的开头处，k</span></span><br><span class="line">                <span class="keyword">int</span> j = i + k; <span class="comment">// j为木头的最右端，与i中间相差k个截断点</span></span><br><span class="line">                <span class="keyword">int</span> t = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = i + <span class="number">1</span>; p &lt; j; p++) &#123; <span class="comment">// p为(i, j)间选定的截断点</span></span><br><span class="line">                    t = <span class="built_in">min</span>(t, dp[i][p] + dp[p][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;i+k&lt;&lt;endl;</span></span><br><span class="line">                dp[i][j] = t + cuts[j] - cuts[i];</span><br><span class="line">                <span class="comment">//cout&lt;&lt;dp[i][j]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/a2459956664/article/details/51106461" target="_blank" rel="noopener">一道类似题目的链接</a>，两道题一模一样，一模一样，一模一样。</p>
<h2 id="第202场周赛"><a href="#第202场周赛" class="headerlink" title="第202场周赛"></a>第202场周赛</h2><h3 id="两球之间的磁力"><a href="#两球之间的磁力" class="headerlink" title="两球之间的磁力"></a>两球之间的磁力</h3><p><a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/" target="_blank" rel="noopener">题目链接</a></p>
<p>这题和<a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">分割数组的最大和</a>一毛一样，题解写在Leetcode日记III里了。另外就是二分法的边界真的是个问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">position</span>, <span class="keyword">int</span> mid, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, pre = <span class="built_in">position</span>[<span class="number">0</span>]; <span class="comment">// 前一个放球点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">position</span>.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">position</span>[i] - pre &gt;= mid) &#123; <span class="comment">// 如果当前大于等于mid了，记为一个区间</span></span><br><span class="line">                ++cnt;</span><br><span class="line">                pre = <span class="built_in">position</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt; m - <span class="number">1</span>; <span class="comment">// 若这样的区间大于等于m-1个，则mid偏小了。反之区间不够m-1，则mid偏大了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">position</span>, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">position</span>.<span class="built_in">size</span>();</span><br><span class="line">        sort(<span class="built_in">position</span>.<span class="built_in">begin</span>(), <span class="built_in">position</span>.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="built_in">position</span>[n - <span class="number">1</span>] - <span class="built_in">position</span>[<span class="number">0</span>], minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = <span class="built_in">position</span>[i] - <span class="built_in">position</span>[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (sub &lt; minLen) minLen = sub;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = minLen, r = maxLen / (m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(<span class="built_in">position</span>, mid, m)) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：最大值最小和最小值最大这两种问题中，check函数的判断条件也需要进行相应的改动！！其返回为true至少要让原问题的最大这个原始条件满足！！！</strong></p>
<h3 id="吃掉-N-个橘子的最少天数"><a href="#吃掉-N-个橘子的最少天数" class="headerlink" title="吃掉 N 个橘子的最少天数"></a>吃掉 N 个橘子的最少天数</h3><p>厨房里总共有 <code>n</code> 个橘子，你决定每一天选择如下方式之一吃这些橘子：</p>
<ul>
<li>吃掉一个橘子。</li>
<li>如果剩余橘子数 <code>n</code> 能被 2 整除，那么你可以吃掉 <code>n/2</code> 个橘子。</li>
<li>如果剩余橘子数 <code>n</code> 能被 3 整除，那么你可以吃掉 <code>2*(n/3)</code> 个橘子。</li>
</ul>
<p>每天你只能从以上 3 种方案中选择一种方案。</p>
<p>请你返回吃掉所有 <code>n</code> 个橘子的最少天数。</p>
<h4 id="dfs（超时）"><a href="#dfs（超时）" class="headerlink" title="dfs（超时）"></a>dfs（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = (cur &lt; ans) ? cur : ans;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        helper(n - <span class="number">1</span>, cur + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) helper(n - n / <span class="number">2</span>, cur + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) helper(n - <span class="number">2</span> * (n / <span class="number">3</span>), cur + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        helper(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="dp（溢出）"><a href="#dp（溢出）" class="headerlink" title="dp（溢出）"></a>dp（溢出）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) dp[i] = <span class="built_in">min</span>(dp[i], dp[i - i / <span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) dp[i] = <span class="built_in">min</span>(dp[i], dp[i - <span class="number">2</span> * (i / <span class="number">3</span>)] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="bfs（超时）"><a href="#bfs（超时）" class="headerlink" title="bfs（超时）"></a>bfs（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q; <span class="comment">// left : day</span></span><br><span class="line">        q.push(&#123;n, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> left = tmp.first;</span><br><span class="line">                <span class="keyword">int</span> td = tmp.second;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> td;</span><br><span class="line">                <span class="keyword">if</span> (left % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(&#123;left /<span class="number">3</span>, td + <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="comment">//continue;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (left % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(&#123;left / <span class="number">2</span>, td + <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="comment">//continue;</span></span><br><span class="line">                &#125;</span><br><span class="line">                q.push(&#123;left - <span class="number">1</span>, td + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="贪心-hash"><a href="#贪心-hash" class="headerlink" title="贪心+hash"></a>贪心+hash</h4><p>参考ASAPIN的解答。</p>
<p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges/solution/tan-xin-dpde-shu-xue-zheng-ming-by-catnipan/" target="_blank" rel="noopener">贪心正确性证明</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp.count(n)) <span class="keyword">return</span> dp[n]; <span class="comment">// 用hash来记忆化</span></span><br><span class="line">        <span class="comment">/*每次减1为了能够将总数削减为原来的1/2或1/3，太妙了我的天*/</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">min</span>(minDays(n / <span class="number">2</span>) + n % <span class="number">2</span> + <span class="number">1</span>, minDays(n / <span class="number">3</span>) + n % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        dp[n] = res; <span class="comment">// 当前n向下递归完毕后，n的dp值唯一确定</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="bfs-hash"><a href="#bfs-hash" class="headerlink" title="bfs+hash"></a>bfs+hash</h4><p>由于没有优化对吃一个橘子的优化，速度要慢很多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> dis, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp.count(left)) <span class="keyword">return</span>;</span><br><span class="line">        dp[left] = dis + <span class="number">1</span>;</span><br><span class="line">        q.push(left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[n] = <span class="number">1</span>;</span><br><span class="line">        q.push(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="keyword">return</span> dp[t];</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (t % <span class="number">3</span> == <span class="number">0</span>) helper(dp[t], t / <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>) helper(dp[t], t / <span class="number">2</span>); </span><br><span class="line">            helper(dp[t], t - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="第33场双周赛"><a href="#第33场双周赛" class="headerlink" title="第33场双周赛"></a>第33场双周赛</h2><h3 id="得到目标数组的最少函数调用次数"><a href="#得到目标数组的最少函数调用次数" class="headerlink" title="得到目标数组的最少函数调用次数"></a>得到目标数组的最少函数调用次数</h3><p><a href="https://leetcode-cn.com/problems/minimum-numbers-of-function-calls-to-make-target-array/" target="_blank" rel="noopener">题目链接</a></p>
<p>模拟 参考Heltion的解答</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 操作1 给某数+1</span></span><br><span class="line">        <span class="comment">// 操作2 全部×2</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, m = <span class="number">0</span>; <span class="comment">// m记录了数组里的最大2的倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = num, n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    x -= <span class="number">1</span>;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x /= <span class="number">2</span>;</span><br><span class="line">                    n += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                m = <span class="built_in">max</span>(n, m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; m &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + m; <span class="comment">// 2的最大的倍数+奇数个数+n       </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二维网格图中探测环"><a href="#二维网格图中探测环" class="headerlink" title="二维网格图中探测环"></a>二维网格图中探测环</h3><p><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/" target="_blank" rel="noopener">题目链接</a></p>
<h4 id="个人解法（超时）"><a href="#个人解法（超时）" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; graph;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; start;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">char</span> target, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; r &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; grid[r][c] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "fuck   " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; grid[x][y] &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (graph[x][y] == target) &#123; <span class="comment">// 如果目标值要标记#</span></span><br><span class="line">                    graph[x][y] = <span class="string">'#'</span>;</span><br><span class="line">                    dfs(x, y, target, flag + <span class="number">1</span>);</span><br><span class="line">                    graph[x][y] = target;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graph[x][y] == <span class="string">'#'</span> &amp;&amp; x == start.first &amp;&amp; y == start.second &amp;&amp; flag &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    valid = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        graph = grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = graph[i][j];</span><br><span class="line">                <span class="keyword">if</span> (tmp == <span class="string">'#'</span>) <span class="keyword">continue</span>; </span><br><span class="line">                graph[i][j] = <span class="string">'#'</span>; <span class="comment">// 标记起点</span></span><br><span class="line">                start = &#123;i, j&#125;;</span><br><span class="line">                dfs(i, j, tmp, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (valid == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dir[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 精髓在于起点不是关键，只要在路上碰到了满足回路的解即可返回true，不一定要回溯到起点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">vis</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(i, j, <span class="number">-1</span>, <span class="number">-1</span>, g, vis))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> px, <span class="keyword">int</span> py, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;g, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dir[i], ty = y + dir[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || (tx == px &amp;&amp; ty == py) || g[tx][ty] != g[x][y])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[tx][ty]) <span class="comment">// 只要访问过并且不是一步回溯访问到的就可以</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(tx, ty, x, y, g, vis))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第203场周赛"><a href="#第203场周赛" class="headerlink" title="第203场周赛"></a>第203场周赛</h2><h3 id="查找大小为M的最新分组"><a href="#查找大小为M的最新分组" class="headerlink" title="查找大小为M的最新分组"></a>查找大小为M的最新分组</h3><p><a href="https://leetcode-cn.com/problems/find-latest-group-of-size-m/" target="_blank" rel="noopener">题目链接</a></p>
<h4 id="法1-倒序"><a href="#法1-倒序" class="headerlink" title="法1 倒序"></a>法1 倒序</h4><p>map倒序维护每一个可以分的区间，参考zerotrac2的解答。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s = &#123;&#123;<span class="number">1</span>, n&#125;&#125;; <span class="comment">// [1, n]区间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 倒序遍历arr</span></span><br><span class="line">            <span class="keyword">auto</span> it = prev(s.upper_bound(arr[i])); <span class="comment">// 获取该分割点所在的区间</span></span><br><span class="line">            <span class="keyword">auto</span> [l, r] = *it;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] - l == m || r - arr[i] == m) &#123; <span class="comment">// 如果分割后两个子长度满足，输出步骤</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            s.erase(it); <span class="comment">// 抹去重叠的原区间</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt;= arr[i] - <span class="number">1</span>) s.emplace(l, arr[i] - <span class="number">1</span>); <span class="comment">// 添加分割后的子区间</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] + <span class="number">1</span> &lt;= r) s.emplace(arr[i] + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="法2-正序"><a href="#法2-正序" class="headerlink" title="法2 正序"></a>法2 正序</h4><p>类似链表的结构，用指针来操作。</p>
<p>一段区间的定义：</p>
<ul>
<li>左端点的右指针指向右端点</li>
<li>右端点的左指针指向左端点</li>
</ul>
<p>分四种情况讨论（标记的0将变为1）</p>
<ol>
<li><p>1111<strong><em>0</em></strong>111  （左右均有全1区间）</p>
</li>
<li><p>1111<strong><em>0</em></strong>001  （左侧有全1区间）</p>
</li>
<li><p>1000<strong><em>0</em></strong>111  （右侧有全1区间）</p>
</li>
<li><p>1100<strong><em>0</em></strong>001  （两侧均无全1区间）</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l, r; <span class="comment">// left pointer || right pointer</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 求以x为左顶点的区间长度</span></span><br><span class="line">        <span class="keyword">return</span> r[x] - x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        l.resize(n + <span class="number">2</span>); r.resize(n + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = arr[i]; <span class="comment">// 获取当前change的位序号</span></span><br><span class="line">            <span class="keyword">if</span> (l[x - <span class="number">1</span>] &amp;&amp; r[x + <span class="number">1</span>]) &#123; <span class="comment">// 如果他的左区间和右区间都是全1</span></span><br><span class="line">                <span class="comment">// 左端点右指针指向右端点</span></span><br><span class="line">                <span class="comment">// 右端点左指针指向左端点</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(l[x - <span class="number">1</span>]) == m) --cnt;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(x + <span class="number">1</span>) == m) --cnt;</span><br><span class="line">                r[l[x - <span class="number">1</span>]] = r[x + <span class="number">1</span>];</span><br><span class="line">                l[r[x + <span class="number">1</span>]] = l[x - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(l[x - <span class="number">1</span>]) == m) ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l[x - <span class="number">1</span>]) &#123;<span class="comment">// 如果左区间存在全1，右区间还是0</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(l[x - <span class="number">1</span>]) == m) --cnt;</span><br><span class="line">                r[l[x - <span class="number">1</span>]] = x; <span class="comment">// 左端点的右指针指向右端点x</span></span><br><span class="line">                l[x] = l[x - <span class="number">1</span>]; <span class="comment">// 该x作为右端点，其左端点为l[x - 1]</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(l[x - <span class="number">1</span>]) == m) ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r[x + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(x + <span class="number">1</span>) == m) --cnt;</span><br><span class="line">                r[x] = r[x + <span class="number">1</span>];</span><br><span class="line">                l[r[x + <span class="number">1</span>]] = x;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(x) == m) ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l[x] = x; r[x] = x;</span><br><span class="line">                <span class="keyword">if</span> (m == <span class="number">1</span>) ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) res = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="石子游戏"><a href="#石子游戏" class="headerlink" title="石子游戏"></a>石子游戏</h4><p><a href="https://leetcode-cn.com/problems/stone-game-v/" target="_blank" rel="noopener">题目链接</a></p>
<p>区间dp，没有优化就过了，暂时这几天比较忙先不优化了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> pre[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] = stoneValue[i - <span class="number">1</span>] + pre[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> left = pre[k] - pre[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> right = pre[j] - pre[k];</span><br><span class="line">                    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], left + dp[i][k]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], right + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], left + <span class="built_in">max</span>(dp[i][k], dp[k + <span class="number">1</span>][j]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.bilibili.com/video/BV1wA411n7jz" target="_blank" rel="noopener">参考讲解</a></p>
<h2 id="第204场周赛"><a href="#第204场周赛" class="headerlink" title="第204场周赛"></a>第204场周赛</h2><h3 id="将子数组重新排序得到同一个二叉查找树的方案数"><a href="#将子数组重新排序得到同一个二叉查找树的方案数" class="headerlink" title="将子数组重新排序得到同一个二叉查找树的方案数"></a>将子数组重新排序得到同一个二叉查找树的方案数</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/" target="_blank" rel="noopener">题目链接</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; C;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        C = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化组合数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % MOD;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排除题中给出的一种</span></span><br><span class="line">        <span class="keyword">return</span> (f(nums) + MOD - <span class="number">1</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> k = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left, right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; k) left.push_back(x);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; k) right.push_back(x - k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (LL)C[n<span class="number">-1</span>][left.<span class="built_in">size</span>()] * f(left) % MOD * f(right) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/solution/c-di-gui-jing-jian-by-dawncy/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造排列组合数组的模板</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % MOD;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记II</title>
    <url>/2020/07/19/Leetcode%E6%97%A5%E8%AE%B0II/</url>
    <content><![CDATA[<p>最近Leetcode的刷题量大大增加，我一定会学有所成的！<br>本篇将按专题分类整理，主要包括树和图论两类题目。</p>
<a id="more"></a>
<h3 id="树-递归专题"><a href="#树-递归专题" class="headerlink" title="树-递归专题"></a>树-递归专题</h3><h4 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (root == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">max</span>(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><strong><em>平衡二叉树的定义：根节点的左子树是平衡二叉树，右子树是平衡二叉树，且它的左右子树的高度差不大于1。</em></strong></p>
<h5 id="自顶向下递归法"><a href="#自顶向下递归法" class="headerlink" title="自顶向下递归法"></a>自顶向下递归法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(Depth(root-&gt;left), Depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(Depth(root-&gt;left) - Depth(root-&gt;right)) &gt; <span class="number">1</span>) &#123; <span class="comment">// 查看当前根节点的左右子树是否满足，不满足直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 否则，继续递归看左右子树是否满足</span></span><br><span class="line">                <span class="keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="自底向上递归法"><a href="#自底向上递归法" class="headerlink" title="自底向上递归法"></a>自底向上递归法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 返回根节点是否平衡，并且保存树高度为一个引用变量</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalancedTreeHelper</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空树是平衡的，高度为-1</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">height</span> = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查子树是否平衡，如果平衡则通过递归调用返回的高度来判断当前结点是否平衡</span></span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="keyword">if</span> (isBalancedTreeHelper(root-&gt;left, left)  &amp;&amp;</span><br><span class="line">            isBalancedTreeHelper(root-&gt;right, right) &amp;&amp;</span><br><span class="line">            <span class="built_in">abs</span>(left - right) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 保存当前结点的高度</span></span><br><span class="line">            <span class="built_in">height</span> = <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalancedTreeHelper(root, <span class="built_in">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span> || rightHeight == <span class="number">-1</span> || <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h4><p>将一个二叉树对称翻转。</p>
<h5 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自顶向下递归</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;right = invertTree(root-&gt;right);       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="多种遍历方法求解"><a href="#多种遍历方法求解" class="headerlink" title="多种遍历方法求解"></a>多种遍历方法求解</h5><p>出自sunchunlei</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用前序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="comment">// 先序遍历--从顶向下交换</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">            <span class="comment">// 保存右子树</span></span><br><span class="line">            TreeNode rightTree = root.right;</span><br><span class="line">            <span class="comment">// 交换左右子树的位置</span></span><br><span class="line">            root.right = invertTree(root.left);</span><br><span class="line">            root.left = invertTree(rightTree);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">            invertTree(root.left); <span class="comment">// 递归找到左节点</span></span><br><span class="line">            TreeNode rightNode= root.right; <span class="comment">// 保存右节点</span></span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            <span class="comment">// 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left</span></span><br><span class="line">            invertTree(root.left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用后序遍历</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 后序遍历-- 从下向上交换</span></span><br><span class="line">            <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">            TreeNode leftNode = invertTree(root.left);</span><br><span class="line">            TreeNode rightNode = invertTree(root.right);</span><br><span class="line">            root.right = leftNode;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用层次遍历</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 层次遍历--直接左右交换即可</span></span><br><span class="line">            <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">            Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="built_in">queue</span>.offer(root);</span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span>.poll();</span><br><span class="line">                TreeNode rightTree = node.right;</span><br><span class="line">                node.right = node.left;</span><br><span class="line">                node.left = rightTree;</span><br><span class="line">                <span class="keyword">if</span> (node.left != null)&#123;</span><br><span class="line">                    <span class="built_in">queue</span>.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != null)&#123;</span><br><span class="line">                    <span class="built_in">queue</span>.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><p>设计辅助函数，将左子树和右子树作为辅助函数的参数。逐一判断：<strong>左子树的左孩子是否等于右子树的有孩子 以及 左子树的右孩子是否等于右子树的左孩子</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetricHelper</span><span class="params">(TreeNode* rootLeft, TreeNode* rootRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rootLeft == <span class="literal">NULL</span> &amp;&amp; rootRight == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootLeft != <span class="literal">NULL</span> &amp;&amp; rootRight != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rootLeft-&gt;val != rootRight-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSymmetricHelper(rootLeft-&gt;right, rootRight-&gt;left) &amp;&amp; isSymmetricHelper(rootLeft-&gt;left, rootRight-&gt;right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSymmetricHelper(root-&gt;left, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><p>这题的坑在于，最小深度在此题的定义为：<strong>从根节点到最近叶子节点的最短路径上的<em>节点数量</em></strong>。细品发现如果直接按照上题最大深度改变的话，无叶子节点的分支会被算作是更小的分支来计数，而实际上没有节点是不能计数的，这就要求我们返回的时候要分类讨论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return (root == NULL) ? 0 : max(1, min(minDepth(root-&gt;left), minDepth(root-&gt;right))) + 1;</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = minDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) &#123; <span class="comment">// 如果左右子树都不为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!left &amp;&amp; !right) &#123; <span class="comment">// 如果都为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果有一个为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h4><p>这题做了很久，最后改进的时候非常不满意，因为对NULL指针的引用这个小问题，导致必须牺牲时间在每次循环下多加两个判断语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        ans-&gt;val = ((t1 == <span class="literal">NULL</span>) ? <span class="number">0</span> : t1-&gt;val) + ((t2 == <span class="literal">NULL</span>) ? <span class="number">0</span> : t2-&gt;val); <span class="comment">// 完成当前根结点值的合并</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ans-&gt;left = mergeTrees(<span class="literal">NULL</span>, t2-&gt;left);</span><br><span class="line">            ans-&gt;right = mergeTrees(<span class="literal">NULL</span>, t2-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ans-&gt;left = mergeTrees(t1-&gt;left, <span class="literal">NULL</span>);</span><br><span class="line">            ans-&gt;right = mergeTrees(t1-&gt;right, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            ans-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看完了答案，爷悟了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        ans-&gt;val = t1-&gt;val + t2-&gt;val; <span class="comment">// 完成当前根结点值的合并</span></span><br><span class="line">        </span><br><span class="line">        ans-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        ans-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码量简直锐减。</p>
<h4 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h4><p>起初是这么做的，超时了。应该是构造子数组这步是多此一举。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOfMaxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>], maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">                <span class="built_in">max</span> = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = indexOfMaxValue(nums, n);  <span class="comment">// 获取最大元素的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建左右的子数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numsLeft</span><span class="params">(maxIndex, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numsRight</span><span class="params">(n - maxIndex, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxIndex; ++i) &#123;</span><br><span class="line">            numsLeft.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = maxIndex + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            numsRight.push_back(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        ans-&gt;val = nums[maxIndex];  <span class="comment">// 当前根结点的值</span></span><br><span class="line"></span><br><span class="line">        ans-&gt;left = constructMaximumBinaryTree(numsLeft);</span><br><span class="line">        ans-&gt;right = constructMaximumBinaryTree(numsRight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>决定构造一个新的函数，传的参数可以只是数组的下标范围。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOfMaxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = nums[start], maxIndex = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">                <span class="built_in">max</span> = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTreeHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = indexOfMaxValue(nums, start, <span class="built_in">end</span>);  <span class="comment">// 获取最大元素的索引</span></span><br><span class="line"></span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        ans-&gt;val = nums[maxIndex];  <span class="comment">// 当前根结点的值</span></span><br><span class="line"></span><br><span class="line">        ans-&gt;left = constructMaximumBinaryTreeHelper(nums, start, maxIndex - <span class="number">1</span>);</span><br><span class="line">        ans-&gt;right = constructMaximumBinaryTreeHelper(nums, maxIndex + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        ans = constructMaximumBinaryTreeHelper(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(n^2)$，辅助函数一共被调用n次。每次递归寻找根节点时，需要遍历当前索引范围内所有元素找出最大值。一般情况下，每次遍历的复杂度为 $O(logn)$，总复杂度为$O(nlogn)$。最坏的情况下，数组 <code>nums</code>有序，此时为$O(n^2)$。</p>
<p>空间复杂度：$O(n)$，递归深度为n。</p>
<h4 id="不同的二叉搜索树II"><a href="#不同的二叉搜索树II" class="headerlink" title="不同的二叉搜索树II"></a>不同的二叉搜索树II</h4><p>输入整型数n，输出由[1:n]不同的数构成的所有二叉搜索树构成的集合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateHelper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="built_in">end</span>) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 获取[start,end]范围内满足条件的左右子树集合</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees = generateHelper(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees = generateHelper(i + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分别从左子树和右子树集合中选取树合并为一个可行解，并加入到解集里</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> leftTree:leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> rightTree:rightTrees) &#123;</span><br><span class="line">                    TreeNode* curr = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    curr-&gt;left = leftTree;</span><br><span class="line">                    curr-&gt;right = rightTree;</span><br><span class="line">                    ans.push_back(curr); <span class="comment">// 这句要注意，每一层递归返回的这个ans很多层都没用，我们只是关注最后一次返回的ans即可</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> generateHelper(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkVisit</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">string</span>&amp; labels, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查看该结点label是否等于target，并查看下边是否还有后续结点，如果有check是否有相同label，并返回对应主函数中的ans[i]数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (labels[node] == labels[target]) count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postNode:graph[node]) &#123; <span class="comment">// 遍历给定node所连结点的序列</span></span><br><span class="line">            <span class="keyword">if</span> (tag[target][postNode] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"辅函数 "</span>&lt;&lt;target&lt;&lt;<span class="string">"与"</span>&lt;&lt;postNode&lt;&lt;<span class="string">"比较"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                tag[node][postNode] = <span class="number">1</span>;</span><br><span class="line">                tag[postNode][node] = <span class="number">1</span>;</span><br><span class="line">                count += checkVisit(postNode, target, graph, labels, tag);</span><br><span class="line">                tag[postNode][target] = <span class="number">1</span>; <span class="comment">// 更新tag</span></span><br><span class="line">                tag[target][postNode] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSubTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(n, v)</span></span>; <span class="comment">// 邻接表形式的图</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">tag</span><span class="params">(n, row)</span></span>; <span class="comment">// 结点访问标志，当0-1访问后，1-0也应该被置为1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构造无向图邻接表 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 其他结点对0的标志位设为1 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            tag[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从0-n逐行遍历图 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;node:graph[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tag[i][node] == <span class="number">0</span>) &#123; <span class="comment">// 当该结点未被访问过时</span></span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"主函数 "</span>&lt;&lt;i&lt;&lt;<span class="string">"与"</span>&lt;&lt;node&lt;&lt;<span class="string">"比较"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    ans[i] += checkVisit(node, i, graph, labels, tag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="从先序遍历还原二叉树"><a href="#从先序遍历还原二叉树" class="headerlink" title="从先序遍历还原二叉树"></a>从先序遍历还原二叉树</h4><p>注意：<code>dep</code>需设为全局变量，因为每一次调用到底时需要回溯，而如果把<code>dep</code>设置为局部变量，它仅在该层dfs函数内有效，并不能指向回溯后的数据。<br>以$1-2–3–4-5–6–7$为例，当<code>pos</code>指向4时，触发<code>dep != currDepth</code>（2!=3），返回了一个空指针。这样3的左右节点由于dfs参数相同，均为空，此时3结点会返回给2结点的<code>left</code>，2结点便开始进行<code>node-&gt;right</code>操作，此时的dep仍为2，这保证了在执行dfs的时候能够跳过前侧的<code>dep != currDepth</code>判断，直接将右节点的值设置为4。便实现了回溯。</p>
<p>综上来看，这个思路关键是在dep处理上要设置成全局。tql，源自于dijks大佬。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, dep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> currDepth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s[pos] == <span class="string">'-'</span> &amp;&amp; pos &lt; n) &#123; <span class="comment">// 如果遍历到'-'，记录深度信息到dep上</span></span><br><span class="line">            pos++;</span><br><span class="line">            dep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dep != currDepth) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 如果深度信息与当前树深度不一致，返回空</span></span><br><span class="line">        dep = <span class="number">0</span>; <span class="comment">// 此处dep必须赋值为0，为了下一次调用时更新获取的'-'数。</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[pos] != <span class="string">'-'</span> &amp;&amp; pos &lt; n) val = val * <span class="number">10</span> + (s[pos++] - <span class="string">'0'</span>); <span class="comment">// 获取结点值</span></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">        node-&gt;left = dfs(currDepth + <span class="number">1</span>);</span><br><span class="line">        node-&gt;right = dfs(currDepth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        s = S;</span><br><span class="line">        n = S.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="图-专题"><a href="#图-专题" class="headerlink" title="图-专题"></a>图-专题</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>==主要思路==（以邻接表的结构为基础）<br>遍历<code>nums</code>，对<code>nums[i]</code>向dfs()传参传入该节点关键字和邻接表<br>dfs()：</p>
<ul>
<li>写递归出口</li>
<li>逐个遍历传入<code>node</code>的所有邻接<code>neibor</code><ul>
<li>递归调用df</li>
</ul>
</li>
</ul>
<h5 id="子树中标签相同的节点数"><a href="#子树中标签相同的节点数" class="headerlink" title="子树中标签相同的节点数"></a>子树中标签相同的节点数</h5><p>要求：一个<strong>根节点为0</strong>的<strong>无向图</strong>，每一个序号对应着<code>string labels</code>中的该序号的字母，判断第i个结点的子树（包括自身）中与<code>labels[i]</code>相同的个数，并返回<code>ans</code>数组。<br>输入：边的集合，labels，总数n<br>输出：<code>ans</code></p>
<h6 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h6><p>这是最初的解法，并没有意识到<strong>根节点为0</strong>以及<strong>边的给定顺序可能不是由edge[0]指向edge[1]</strong>，最终失败。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkVisit</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">string</span>&amp; labels)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查看该结点label是否等于target，并查看下边是否还有后续结点，如果有check是否有相同label，并返回对应主函数中的ans[i]数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (labels[node] == labels[target]) count += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (graph[node].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[node].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                count += checkVisit(graph[node][i], target, graph, labels);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSubTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(n, v)</span></span>; <span class="comment">// 邻接表形式的图</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构造图 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> node:graph[i]) &#123;</span><br><span class="line">                ans[i] += checkVisit(node, i, graph, labels);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h6><ol>
<li>先由给定的集合<strong>递归求得树每层结点的相对ranking</strong>，例如给定边集$[(0,1),(1,2),(0,3)]$，ranking为<code>[4,3,2,3]</code>。</li>
<li>再根据ranking的相对大小，进行坑1类似的操作，即根据邻接表来依次自顶向下访问各结点信息并进行比较。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkVisit</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">string</span>&amp; labels, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查看该结点label是否等于target，并查看下边是否还有后续结点，如果有check是否ranking要更低级，并返回对应主函数中的ans[i]数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (labels[node] == labels[target]) count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postNode:graph[node]) &#123; <span class="comment">// 遍历给定node所连结点的序列</span></span><br><span class="line">            <span class="keyword">if</span> (tag[postNode] &lt; tag[node]) &#123;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;"辅函数 "&lt;&lt;target&lt;&lt;"与"&lt;&lt;postNode&lt;&lt;"比较"&lt;&lt;endl;</span></span><br><span class="line">                count += checkVisit(postNode, target, graph, labels, tag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getRanking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tag, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> currRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 从0开始向下遍历以得到结点的相对ranking */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; next:graph[currRoot]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag[next] &lt; tag[currRoot]) &#123;</span><br><span class="line">                tag[next] = tag[currRoot] - <span class="number">1</span>;</span><br><span class="line">                getRanking(tag, graph, next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSubTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(n, v)</span></span>; <span class="comment">// 邻接表形式的图</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构造无向图邻接表 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tag</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 结点ranking数组</span></span><br><span class="line">        tag[<span class="number">0</span>] = n;</span><br><span class="line">        getRanking(tag, graph, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从0-n逐行遍历图 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;node:graph[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tag[node] &lt; tag[i]) &#123; <span class="comment">// 当该结点ranking较小</span></span><br><span class="line">                    <span class="comment">//cout&lt;&lt;"主函数 "&lt;&lt;i&lt;&lt;"与"&lt;&lt;node&lt;&lt;"比较"&lt;&lt;endl;</span></span><br><span class="line">                    ans[i] += checkVisit(node, i, graph, labels, tag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
结果：超时！！！<br>计算ranking复杂度为$O(n)$，遍历图的复杂度为$O(nlogn)$，而每次还都需要进行一次checkVisit的递归，递归的开销也有$(logn)^2$左右吧。那乘起来就是$O(n*(logn)^3)$再加上$O(n)$。</li>
</ol>
<h6 id="官方答案"><a href="#官方答案" class="headerlink" title="官方答案"></a>官方答案</h6><p>直接设置了一个数组$f[n][26]$用于标记<strong>o子树中各结点代表的字母出现的次数</strong>，例如：$f[0][2]=2$代表0序号的子树中$b$出现的次数为2。</p>
<p><strong>最关键的思路：</strong><br>$o$相当于当前结点的一个层级，$pre$则是因为这次递推，已经确定的前驱结点。如果$nex==pre$那就是遍历时又向前访问了前一层。<br>更新语句：<code>o = nex</code>和<code>pre = o</code></p>
<p><strong>以$1(d)⬅2(b)⬅0(a)➡3(b)$为例的每部详细过程：</strong><br>递归前  o=0  nex=2  pre=-1<br>不递归  o=2  nex=0  pre=0<br>递归前  o=2  nex=1  pre=0<br>不递归  o=1  nex=2  pre=2<br>递归后  o=2  nex=1  pre=0<br>递归后  o=0  nex=2  pre=-1<br>递归前  o=0  nex=3  pre=-1<br>不递归  o=3  nex=0  pre=0<br>递归后  o=0  nex=3  pre=-1</p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">o</th>
<th align="center">pre</th>
<th align="center">赋值 or for加和</th>
<th align="center">nex</th>
<th align="center">continue or return or recursive</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">f[0][0]=1</td>
<td align="center">2</td>
<td align="center">recursive</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">f[2][1]=1</td>
<td align="center">0</td>
<td align="center">continue</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">无</td>
<td align="center">1</td>
<td align="center">recursive</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">f[1][3]=1</td>
<td align="center">2</td>
<td align="center">return</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">加和</td>
<td align="center">1</td>
<td align="center">return</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">加和</td>
<td align="center">2</td>
<td align="center">return</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">..</td>
<td align="center">..</td>
<td align="center">..</td>
<td align="center">..</td>
<td align="center">..</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> pre, <span class="keyword">const</span> <span class="built_in">string</span> &amp;labels)</span> </span>&#123;</span><br><span class="line">        f[o][labels[o] - <span class="string">'a'</span>] = <span class="number">1</span>; <span class="comment">// 自身预先出现一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;nex: g[o]) &#123; <span class="comment">// 遍历自己的连接结点</span></span><br><span class="line">            <span class="keyword">if</span> (nex == pre) &#123;</span><br><span class="line">                <span class="comment">// 避免了回溯</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            dfs(nex, o, labels);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                f[o][i] += f[nex][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSubTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels)</span> </span>&#123;</span><br><span class="line">        g.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;edge: edges) &#123;</span><br><span class="line">            g[edge[<span class="number">0</span>]].push_back(edge[<span class="number">1</span>]);</span><br><span class="line">            g[edge[<span class="number">1</span>]].push_back(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        f.assign(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">-1</span>, labels);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans.push_back(f[i][labels[i] - <span class="string">'a'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(nc)$，其中 n 是树中的节点数，c 是字符集大小，此处 c = 26。深度优先搜索需要对树中的每个节点访问一次，对每个节点都需要更新所有可能的标签出现的次数，由于标签都是小写字母，需要对 26 个字母都进行一次讨论。</p>
<p>空间复杂度：$O(nc)$，其中 n 是树中的节点数。空间复杂度主要取决于递归栈的调用深度，递归栈的调用深度不会超过 n。</p>
<h5 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h5><p>返回该给定邻接表的图，是否为二分图。</p>
<h6 id="DFS方法"><a href="#DFS方法" class="headerlink" title="DFS方法"></a>DFS方法</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tag; <span class="comment">// 设置标签位，未标签为-1，标签有1、0两种</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> currTag, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        tag[node] = currTag;</span><br><span class="line">        <span class="keyword">int</span> revCurrTag = (currTag == <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">// 将标签取反</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neibor:graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag[neibor] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dfs(neibor, revCurrTag, graph);</span><br><span class="line">                <span class="keyword">if</span> (valid == <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag[neibor] != revCurrTag) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// graph就是邻接表的形式</span></span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        valid = <span class="literal">true</span>;</span><br><span class="line">        tag.assign(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> currTag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dfs(i, currTag, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路：设置一个标志位，标志有三种状态：未标记，1标记，0标记。dfs遍历图：</p>
<ul>
<li>若相邻结点未被标记，标记相反标记后，继续向下遍历</li>
<li>若相邻节点已被标记，查看标记位，若不相反，则返回false</li>
</ul>
<h5 id="flood-fill"><a href="#flood-fill" class="headerlink" title="flood fill"></a>flood fill</h5><p>将给定的二维数组中的某坐标元素的颜色记为oldColor，将它的四邻方块（包括自己）中为oldColor的依次更新为newColor，并对四邻方块递归执行如上操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">image</span>, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldColor = <span class="built_in">image</span>[sr][sc];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">image</span>.empty() || newColor == oldColor) <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> rowLen = <span class="built_in">image</span>[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> colLen = <span class="built_in">image</span>.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">image</span>[sr][sc] = newColor;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = sr + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = sc + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; colLen &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; rowLen &amp;&amp; <span class="built_in">image</span>[x][y] == oldColor)</span><br><span class="line">                floodFill(<span class="built_in">image</span>, x, y, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h5><p>统计给定二维数组的连通块数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == <span class="string">'1'</span>)</span><br><span class="line">                dfs(grid, x, y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="封闭岛屿数量"><a href="#封闭岛屿数量" class="headerlink" title="封闭岛屿数量"></a>封闭岛屿数量</h5><p>和上一题基本一样，只是边界情况不算（和数组外联通不算）</p>
<p>处理方法：当将0修改为1的过程中，碰到了边界的0，此时这次count增加不算。</p>
<h6 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count, row, col;</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;; <span class="comment">//下右上左</span></span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= row - <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt;= col - <span class="number">1</span> &amp;&amp; grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">0</span> || x == row - <span class="number">1</span> || y == <span class="number">0</span> || y == col - <span class="number">1</span>) &#123; <span class="comment">// 如果联通到边缘的石块，则valid置为false</span></span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    grid[r][c] = <span class="number">0</span>; <span class="comment">// 这步骤是为了防止前一步错误更改的1，导致下一次遍历的时候封闭使得count偏大</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(grid, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row &lt;= <span class="number">2</span> || col &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="comment">//bool isEdge = i &gt; 0 &amp;&amp; i &lt; row - 1 &amp;&amp; j &gt; 0 &amp;&amp; j &lt; col - 1; </span></span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">                    dfs (grid, i, j);</span><br><span class="line">                    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    valid = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h6><p>变化主要在dfs函数上，思想是：如果按上下左右方向遍历，遍历到0的话，继续遍历直到遇到1，此时就会返回true，如果四个方向都是true那么就是正确的，否则错误。方法简单明了，值得学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(grid,i,j))&#123;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> up = dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        <span class="keyword">boolean</span> down = dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        <span class="keyword">boolean</span> left = dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> right = dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(up &amp;&amp; down &amp;&amp; left &amp;&amp; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/number-of-closed-islands/solution/dfsjie-jue-by-liuchuan1992/" target="_blank" rel="noopener">Liuchuan1992</a></p>
<h5 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h5><p>将被<code>&#39;X&#39;</code>围绕的<code>&#39;O&#39;</code>更新为<code>&#39;X&#39;</code>（二维数组的边界被<code>&#39;O&#39;</code>包围）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= row  || j &gt;= col || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'#'</span>)</span><br><span class="line">            <span class="comment">// 如果越界或者是数组被标记或者该处为X</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">'#'</span>; <span class="comment">// 将该O标记为#</span></span><br><span class="line"></span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        row = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!row) <span class="keyword">return</span>;</span><br><span class="line">        col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从边界向内深搜（在深搜内限制不能从边界向外搜索，但可以向内）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span> &amp;&amp; (i == <span class="number">0</span> || j == <span class="number">0</span> || i == row - <span class="number">1</span> || j == col - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="检查网格中是否有有效路径"><a href="#检查网格中是否有有效路径" class="headerlink" title="检查网格中是否有有效路径"></a>检查网格中是否有有效路径</h5><p><a href="https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/" target="_blank" rel="noopener">题目一览</a></p>
<h6 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h6><p>首先用<code>validNextDirection</code>和<code>validComeDirection</code>来表示该方块的合法来方向和合法去方向。然后每次dfs到一个网格时，要四方向遍历，这导致我的时间复杂度达到了$O(mn * 4)$，且占用了很多不必要的空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> blk = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> down = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> left = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> right = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下左右</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> validNextDirection[<span class="number">7</span>][<span class="number">4</span>] = </span><br><span class="line">    &#123;   &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;blk,blk,left,right&#125;,</span><br><span class="line">        &#123;up,down,blk,blk&#125;,</span><br><span class="line">        &#123;blk,down,left,blk&#125;,</span><br><span class="line">        &#123;blk,down,blk,right&#125;,</span><br><span class="line">        &#123;up,blk,left,blk&#125;,</span><br><span class="line">        &#123;up,blk,blk,right&#125;  &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> validComeDirection[<span class="number">7</span>][<span class="number">4</span>] = </span><br><span class="line">    &#123;   &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;blk,blk,left,right&#125;,</span><br><span class="line">        &#123;up,down,blk,blk&#125;,</span><br><span class="line">        &#123;up,blk,blk,right&#125;,</span><br><span class="line">        &#123;up,blk,left,blk&#125;,</span><br><span class="line">        &#123;blk,down,blk,right&#125;,</span><br><span class="line">        &#123;blk,down,left,blk&#125;  &#125;;</span><br><span class="line">    <span class="keyword">int</span> visited[<span class="number">302</span>][<span class="number">302</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (validComeDirection[grid[r][c]][dir] == blk) &#123; <span class="comment">// 如果来的方向不对，返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> edgeValid = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">            <span class="keyword">if</span> (edgeValid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (validNextDirection[grid[r][c]][i] != blk &amp;&amp; visited[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dfs(grid, x, y, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValidPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>();</span><br><span class="line">        n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line"></span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; <span class="comment">// 尝试四个方向走</span></span><br><span class="line">            <span class="keyword">bool</span> edgeValid = dx[i] &gt;= <span class="number">0</span> &amp;&amp; dx[i] &lt; m &amp;&amp; dy[i] &gt;= <span class="number">0</span> &amp;&amp; dy[i] &lt; n;</span><br><span class="line">            <span class="keyword">if</span> (validNextDirection[grid[<span class="number">0</span>][<span class="number">0</span>]][i] != blk &amp;&amp; edgeValid) &#123; <span class="comment">// 如果这个方向合法，就dfs</span></span><br><span class="line">                dfs(grid, dx[i], dy[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>插曲：我最后又check了一下，发现超时是因为我的调试语句<code>cout</code>没有删掉，我去去去去去！！！！</p>
<h6 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h6><p>参考“五行缺你”朋友改进。<br>以<code>validDirection[7][4]</code>同时显示来的方向和去的方向两层信息。</p>
<ul>
<li>index 提示来的方向</li>
<li>value 提示去的方向</li>
</ul>
<p>这样可以顺次遍历，复杂度提升到$O(mn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> blk = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> down = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> left = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> right = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下左右</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> validDirection[<span class="number">7</span>][<span class="number">4</span>] = </span><br><span class="line">    &#123;   &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;blk,blk,left,right&#125;,</span><br><span class="line">        &#123;up,down,blk,blk&#125;,</span><br><span class="line">        &#123;left,blk,blk,down&#125;,</span><br><span class="line">        &#123;right,blk,down,blk&#125;,</span><br><span class="line">        &#123;blk,left,blk,up&#125;,</span><br><span class="line">        &#123;blk,right,up,blk&#125;  &#125;;</span><br><span class="line">    <span class="keyword">int</span> visited[<span class="number">302</span>][<span class="number">302</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> dir)</span> </span>&#123;</span><br><span class="line">        visited[r][c] = <span class="number">1</span>;  <span class="comment">// 标记为已访问</span></span><br><span class="line">        <span class="keyword">int</span> nextDir = validDirection[grid[r][c]][dir];  <span class="comment">// 该方块的下一个方向是[当前块种类][下一个方向]</span></span><br><span class="line">        <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span> &amp;&amp; nextDir != blk) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nextDir != blk) &#123;  <span class="comment">// 如果下一个方向不是blk</span></span><br><span class="line">            <span class="keyword">int</span> x = r + dx[nextDir];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[nextDir];</span><br><span class="line">            <span class="keyword">bool</span> edgeValid = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">            <span class="keyword">if</span> (edgeValid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dfs(grid, x, y, nextDir);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValidPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>();</span><br><span class="line">        n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line"></span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; <span class="comment">// 尝试四个方向走 0 上 1 下 2 左 3 右</span></span><br><span class="line">            <span class="keyword">if</span> (validDirection[grid[<span class="number">0</span>][<span class="number">0</span>]][i] != blk) &#123; <span class="comment">// 如果这个方向合法，就dfs</span></span><br><span class="line">                dfs(grid, <span class="number">0</span>, <span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩阵中最长递归路径"><a href="#矩阵中最长递归路径" class="headerlink" title="矩阵中最长递归路径"></a>矩阵中最长递归路径</h5><p>给定一个整数矩阵，找出最长递增路径的长度。</p>
<p>个人解法应该是超时了，原思路是按照dfs走的，然后用一个res来存储每次的</p>
<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h6><p>记忆化深度优先搜索，当访问到一个单元格 (i,j) 时，如果${memo}[i][j] \neq 0$，说明该单元格的结果已经计算过，则直接从缓存中读取结果，如果${memo}[i][j]=0$，说明该单元格的结果尚未被计算过，则进行搜索，并将计算得到的结果存入缓存中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[r][c] != <span class="number">0</span>) <span class="keyword">return</span> memo[r][c];</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        memo[r][c]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col;</span><br><span class="line">            <span class="keyword">if</span> (notEdge &amp;&amp; matrix[x][y] &gt; matrix[r][c]) &#123;</span><br><span class="line">                memo[r][c] = <span class="built_in">max</span>(memo[r][c], dfs(matrix, x, y, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> memo = <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; (row, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; (col));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dfs(matrix, i, j, memo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="不同路径III"><a href="#不同路径III" class="headerlink" title="不同路径III"></a>不同路径III</h5><p>方格中有四种状态.</p>
<ul>
<li>1表示起点，只有1个</li>
<li>2表示终点，只有1个</li>
<li>0表示可走</li>
<li>-1表示不可走<br>要求从起点走到终点，且经过所有的可走点，并返回路径的可能总数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; start;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fixedStep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> <span class="built_in">step</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">step</span> &gt; fixedStep) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">step</span> == fixedStep) ++ans;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span> || grid[x][y] == <span class="number">0</span>)</span><br><span class="line">                    dfs(grid, x, y, <span class="built_in">step</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先找1，并返回从1到2应该走的正确步数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) start = &#123;i, j&#125;;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] != <span class="number">-1</span>) fixedStep++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再从起点开始DFS</span></span><br><span class="line">        dfs(grid, start.first, start.second, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用了所有节点都需走一遍的这个性质，提前计算出了固定的步数，如果没达到预期，则此次路径无效。</li>
<li>用修改0状态为3，来实现记忆化搜索。但需要注意的是，在四个方向遍历结束后，要将当前的状态修改回0，已更新新的方法。</li>
</ul>
<hr>
<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>==要素==：队列</p>
<h5 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h5><p>输入一个正整数n，返回其通过平方数（1，4，9，16..）等加和得到的需要最小平方数。</p>
<p>BFS解法：相当于将原问题转换为，求根节点到某叶子节点（结点的关键字值为n）的最短距离（最小深度）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>; <span class="comment">// dist代表的是当前元素所在的深度</span></span><br><span class="line">        q.push(<span class="number">0</span>);</span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 根节点深度为0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123; <span class="comment">// 当队列不为空时</span></span><br><span class="line">            <span class="keyword">int</span> temp = q.front(); <span class="comment">// 取出顶元素</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp == n) <span class="keyword">return</span> dist[temp]; <span class="comment">// 如果此时到达n，直接输出此时的层数即可</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * i + temp &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i * i + temp; <span class="comment">// 更新j为此时的平方加和数</span></span><br><span class="line">                <span class="keyword">if</span> (dist[j] &gt; dist[temp] + <span class="number">1</span>) &#123; <span class="comment">// 如果此时j的dist要大于temp的层数+1</span></span><br><span class="line">                    dist[j] = dist[temp] + <span class="number">1</span>; <span class="comment">// 更新它为temp的下一层</span></span><br><span class="line">                    q.push(j); <span class="comment">// 并将其加入队列尾部</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>附：dp解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 抽象成一个平方数加上一个数（上一步得来的数）</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h5><p>给出一个二叉树，返回一个二维数组，数组的第i行对应的是二叉树的第i深度从左到右的顺序。</p>
<p>不贴个人的BFS了，官方的这个解法没有额外的求各层的深度，而是利用了<strong>每次进入循环时队列的长度为各层的长度</strong>这个性质，在每次循环中直接处理完这层的遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/" target="_blank" rel="noopener">出自nettee大佬的BFS精华总结</a></p>
<hr>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="课程表II"><a href="#课程表II" class="headerlink" title="课程表II"></a>课程表II</h5><p>给定课程表的$[后续课，先行课]$集合，以及课程总数。输出符合先行课规则的上课顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(numCourses, v)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据边信息构造邻接表graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            indegree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">            graph[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i); <span class="comment">// 将入度为0的边入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123; <span class="comment">// 当队列非空时，循环操作</span></span><br><span class="line">            <span class="keyword">int</span> temp = q.front();  <span class="comment">// 将队列头部的元素出队</span></span><br><span class="line">            q.pop();</span><br><span class="line">            count++;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改入度表indegree，当发现有入度为0时，将其入队</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[temp].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                indegree[graph[temp][i]]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[graph[temp][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(graph[temp][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a>矩阵中的最长递增路径</h5><p>和上面的dfs一道题的题目相同，用拓扑排序的方法求解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!row) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(col, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(row, v)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算出度</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k];</span><br><span class="line">                    <span class="keyword">int</span> y = j + dy[k];</span><br><span class="line">                    <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col;</span><br><span class="line">                    <span class="keyword">if</span> (notEdge &amp;&amp; matrix[x][y] &gt; matrix[i][j]) &#123;</span><br><span class="line">                        memo[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!memo[i][j]) q.push(&#123;i, j&#125;); <span class="comment">// 如果出度为0(四周没人比他大)，入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 记录每次出队的层数</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="comment">// 如果队列非空，对队列里的所有元素依次处理</span></span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>(); <span class="comment">// 保存当前队中的数据个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> r = temp.first;</span><br><span class="line">                <span class="keyword">int</span> c = temp.second;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = r + dx[j];</span><br><span class="line">                    <span class="keyword">int</span> y = c + dy[j];</span><br><span class="line">                    <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col;</span><br><span class="line">                    <span class="keyword">if</span> (notEdge &amp;&amp; matrix[x][y] &lt; matrix[r][c]) &#123;</span><br><span class="line">                        --memo[x][y]; </span><br><span class="line">                        <span class="comment">// 四周的所有点中，较小的的出度应该减1，下一次就有希望被纳入到队列中</span></span><br><span class="line">                        <span class="keyword">if</span> (memo[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                            q.push(&#123;x, y&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记III</title>
    <url>/2020/07/24/Leetcode%E6%97%A5%E8%AE%B0III/</url>
    <content><![CDATA[<p>延续II的风格，进行题型分类。</p>
<a id="more"></a>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="计算右侧小于当前元素的个数"></a>计算右侧小于当前元素的个数</h4><h5 id="第一次提交"><a href="#第一次提交" class="headerlink" title="第一次提交"></a>第一次提交</h5><p>从头向尾遍历数组，将第i个之后的数组拷贝一份并排序，并对排序后的数组应用二分查找找到后续的小于当前元素个数，超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sortedNums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sortedNums[m] &gt;= target) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedNums</span><span class="params">(n)</span></span>;</span><br><span class="line">            copy(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), sortedNums.<span class="built_in">begin</span>()); <span class="comment">// 拷贝一份nums</span></span><br><span class="line">            sort(sortedNums.<span class="built_in">begin</span>(), sortedNums.<span class="built_in">end</span>()); <span class="comment">// 对sortedNums进行排序</span></span><br><span class="line">            <span class="keyword">int</span> temp = binarySearch(num, sortedNums, n);</span><br><span class="line">            n -= <span class="number">1</span>;</span><br><span class="line">            nums.erase(nums.<span class="built_in">begin</span>());</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="第二次提交"><a href="#第二次提交" class="headerlink" title="第二次提交"></a>第二次提交</h5><p>从后向前遍历数组，将i后续的数组直接在原数组上进行排序，并将得到的<code>temp</code>头插入到<code>ans</code>数组中，依然超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sortedNums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sortedNums[m] &gt;= target) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">end</span>()); <span class="comment">// 对sortedNums进行排序</span></span><br><span class="line">            <span class="keyword">int</span> temp = binarySearch(num, nums, i, n - <span class="number">1</span>);</span><br><span class="line">            ans.insert(ans.<span class="built_in">begin</span>(), temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="第三次提交"><a href="#第三次提交" class="headerlink" title="第三次提交"></a>第三次提交</h5><p>使用了该作者的<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/315-ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-9/" target="_blank" rel="noopener">优化解法</a>。<br>他的解法妙就妙在并不用对后续的数组进行<code>sort</code>排序，而是利用返回的这个<code>r</code>向当前的排序数组进行插入。从而避免了每次都要重排的这部分开销，完美的利用了上一步的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ordered_arr存储排序后的有序数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ordered_arr, res(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = ordered_arr.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; ordered_arr[mid])</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// r即插入ordered_arr的位置，也是在其右侧比其小的元素个数</span></span><br><span class="line">            res[i] = r; </span><br><span class="line">            <span class="comment">// 倒序逐个插入元素</span></span><br><span class="line">            ordered_arr.insert(ordered_arr.<span class="built_in">begin</span>() + r, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(nlogn)$（但是insert函数开销较大，有接近$O(n)$的复杂度）</p>
<h4 id="分割数组的最大和"><a href="#分割数组的最大和" class="headerlink" title="分割数组的最大和"></a>分割数组的最大和</h4><p>给定一个数组，和一个要求的分割数<code>m</code>。求出所有分割法中，各分成m份中的最大值中最小的那个和。</p>
<h5 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h5><p>听官方的话说”求最大值中的最小值”这种问法常用二分法来解决。<br>思路：</p>
<ul>
<li>该目标值显然位于<code>maxVal</code>和<code>sumArray</code>之间，那么我们寻求一个中间的<code>mid</code>值，然后以这个<code>mid</code>值为标准对数组依次划分。</li>
<li>将数组从头到尾进行遍历，使之分成多个不大于<code>mid</code>的部分，然后判断这个得到的分割部分<code>count</code>是否满足不大于<code>m</code>这一条件？<ul>
<li>如果满足，则可能当前的<code>mid</code>选取的有点大了，将区间划到左侧继续尝试搜索有没有更小点的<code>mid</code>。</li>
<li>如果不满足，显然当前<code>mid</code>选取小了，需要在右侧区间进行继续搜索。</li>
</ul>
</li>
<li>最终不断地逼近正确结果，也就是最后<strong>不大不小刚刚好把题目的nums分成m份，且每一部分的和都比较接近</strong>（定性描述），此时的搜到的结果显然是所求解。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkMid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> mid, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 初始化计数器</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>; <span class="comment">// 初始化加和，目标是m - 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + sum &gt; mid) &#123; <span class="comment">// 当当前元素组的加和大于目标加和，截断，计数</span></span><br><span class="line">                count++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，继续向后累加</span></span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count &lt;= m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//if (!n) return 0;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> maxVal = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxVal)</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = maxVal, right = sum, mid; <span class="comment">// 在maxVal到sum的范围内进行二分搜索</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (checkMid(nums, mid, m)) &#123; <span class="comment">// 检查当前m的值是偏大还是偏小</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
不过我却还是觉得很神奇的就是，假设<code>nums[i] + sum &lt; mid</code>在所有分割数组都发生了，而没有出现过一个分割集的数恰好等于<code>mid</code>，那么最后输出的解就不是最优解了？</li>
<li>还是说当出现这种情况的时候，会触发最后的<code>checkMid</code>的<code>false</code>导致<code>left</code>更新然后修正了？</li>
<li>还是说根本不会达到我的假设？</li>
</ul>
<hr>
<h3 id="树和图"><a href="#树和图" class="headerlink" title="树和图"></a>树和图</h3><h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><p>给定一个树，给定一个sum。返回是否有从根节点到子节点的路径val总和==sum。</p>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt; pair&lt; <span class="keyword">int</span>, TreeNode* &gt; &gt; q; <span class="comment">// 保存&lt;当前和，节点&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        q.push(&#123;root-&gt;val, root&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> node = temp.second;</span><br><span class="line">            <span class="keyword">auto</span> curSum = temp.first;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) q.push(&#123;curSum + node-&gt;left-&gt;val, node-&gt;left&#125;);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) q.push(&#123;curSum + node-&gt;right-&gt;val, node-&gt;right&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum == curSum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树中的链表"><a href="#二叉树中的链表" class="headerlink" title="二叉树中的链表"></a>二叉树中的链表</h4><p>查找二叉树中从上到下的某条路径中是否含有与链表元素排列相同的子路径。</p>
<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><p>注意<code>isSubPath</code>函数中的返回值，如果针对<code>root</code>进行DFS失败后，就要试试左子树和右子树进行<code>isSubPath</code>是否成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != head-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(head-&gt;next, root-&gt;left) || dfs(head-&gt;next, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubPath</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自顶向下dfs</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(head, root) || isSubPath(head, root-&gt;left) || isSubPath(head, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><p>只关注到每一个非叶子节点的左节点和右节点是否满足，没有关注叶子节点的左子树和右子树是否满足。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left-&gt;val &lt; root-&gt;val) &#123;</span><br><span class="line">                ans &amp;= dfs(root-&gt;left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">                ans &amp;= dfs(root-&gt;right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root) &amp;&amp; isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="递归修正"><a href="#递归修正" class="headerlink" title="递归修正"></a>递归修正</h5><p>上限值和下限值的递归</p>
<ul>
<li>遍历到左子树，更新<code>higher</code>为<code>root-&gt;val</code></li>
<li>遍历到右子树，更新<code>lower</code>为<code>root-&gt;right</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> lower, <span class="keyword">long</span> <span class="keyword">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            inorder(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (ans.empty()) ans.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[ans.<span class="built_in">size</span>() - <span class="number">1</span>] &gt;= root-&gt;val) &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.push_back(root-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h4><p>找出路径和等于给定数值的路径总数。</p>
<h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span> currSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (currSum + root-&gt;val == sum) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, sum, currSum + root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right, sum, currSum + root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, sum, <span class="number">0</span>);</span><br><span class="line">        pathSum(root-&gt;left, sum);</span><br><span class="line">        pathSum(root-&gt;right, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h4><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径，返回一个二维数组。</p>
<h5 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h5><p>这个性能比较差，传参必须要传成非引用格式的<code>row</code>，否则后续返回其他结果的时候会与前面的路径产生交集。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        row.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                ans.push_back(row);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, target, row, sum);</span><br><span class="line">        dfs(root-&gt;right, target, row, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row;</span><br><span class="line">        dfs(root, sum, row, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="DFS优化"><a href="#DFS优化" class="headerlink" title="DFS优化"></a>DFS优化</h5><ul>
<li>优化掉了一个参数：每次向下递减就不用再额外保存sum参数了</li>
<li>每次结束后弹出，就能使用地址传参了，空间优化很多<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        row.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == target &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ans.push_back(row);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, target - root-&gt;val, row);</span><br><span class="line">        dfs(root-&gt;right, target - root-&gt;val, row);</span><br><span class="line">        row.pop_back(); </span><br><span class="line">        <span class="comment">/* 弹出最后一个添加的元素，每执行完一次dfs意味着</span></span><br><span class="line"><span class="comment">        该root的左右子节点均已返回，此时应该将该路径的数弹出，</span></span><br><span class="line"><span class="comment">        以防共用一个地址空间，后面的row数组会产生重复*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row;</span><br><span class="line">        dfs(root, sum, row);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h4><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, getMax(root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, getMax(root-&gt;right));</span><br><span class="line">        res = <span class="built_in">max</span>(res, root-&gt;val + left + right); <span class="comment">// 如果当前根节点的路径最大，则更新res</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root-&gt;val; <span class="comment">// 在每个子节点中选择左右子树中路径较大的加上根节点值才能构成合法路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        getMax(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h4><p>给定一个二叉树，<strong>原地</strong>将它展开为一个单链表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br><span class="line">转换为</span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; inf;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            inf.push_back(root);</span><br><span class="line">            dfs(root-&gt;left);</span><br><span class="line">            dfs(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       dfs(root);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; inf.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">           TreeNode* curr = inf[i], *prev = inf[i - <span class="number">1</span>];</span><br><span class="line">           prev-&gt;right = curr;</span><br><span class="line">           prev-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="边前序边展开"><a href="#边前序边展开" class="headerlink" title="边前序边展开"></a>边前序边展开</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            TreeNode* curr = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                prev-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                prev-&gt;right = curr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode *left = curr-&gt;left, *right = curr-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运算流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1进栈 </span><br><span class="line">1出栈 </span><br><span class="line">5进栈 </span><br><span class="line">2进栈</span><br><span class="line">2出栈</span><br><span class="line">prev是1</span><br><span class="line">prev右是2</span><br><span class="line">4进栈</span><br><span class="line">3进栈</span><br><span class="line">3出栈</span><br><span class="line">prev是2</span><br><span class="line">prev右是3</span><br><span class="line">4出栈</span><br><span class="line">prev是3</span><br><span class="line">prev右是4</span><br><span class="line">5出栈</span><br><span class="line">prev是4</span><br><span class="line">prev右是5</span><br><span class="line">6进栈</span><br><span class="line">6出栈</span><br><span class="line">prev是5</span><br><span class="line">prev右是6</span><br></pre></td></tr></table></figure>

<h5 id="前序递归"><a href="#前序递归" class="headerlink" title="前序递归"></a>前序递归</h5><p>参考王道烩大神的题解。<br>先把左右子树分别展开，然后将左子树插入到右子树上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            TreeNode* cur = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;right) &#123; </span><br><span class="line">                <span class="comment">// 找到当前节点的左子树的右侧尾结点</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;right = root-&gt;right; <span class="comment">// 将根节点的右子树挂到当前节点右侧</span></span><br><span class="line">            root-&gt;right = root-&gt;left; <span class="comment">// 左子树替换右子树</span></span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>; <span class="comment">// 左子树置为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><h4 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h4><p>对于一个迷宫<code>obstacleGrid</code>，里面只有0、1两种，1不允许通过，求从左上角到达右下角的路径个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[m];</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>) dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) temp = <span class="number">0</span>;</span><br><span class="line">            dp[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                        temp = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[<span class="number">0</span>] = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = (obstacleGrid[i][j] == <span class="number">1</span>) ? <span class="number">0</span> : (dp[j] + dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h4><p>将整数n化为多个数的乘积，使得乘积最大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i; ++j) &#123; <span class="comment">// 最后一份为j</span></span><br><span class="line">                <span class="comment">// 当i-j部分不继续分时，为后者</span></span><br><span class="line">                <span class="comment">// 当i-j部分需要继续分，为前者</span></span><br><span class="line">                <span class="keyword">int</span> max1 = <span class="built_in">max</span>(dp[i - j] * j, (i - j) * j);</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], max1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="和相同的二元子数组"><a href="#和相同的二元子数组" class="headerlink" title="和相同的二元子数组"></a>和相同的二元子数组</h4><p>在由若干<code>0</code>和<code>1</code> 组成的数组<code>A</code>中，有多少个和为<code>S</code>的非空子数组。</p>
<h5 id="个人解法（空间太大）"><a href="#个人解法（空间太大）" class="headerlink" title="个人解法（空间太大）"></a>个人解法（空间太大）</h5><p>数组开的过大，栈溢出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n][n];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// f[i][j] 表示从i到j构成的加和</span></span><br><span class="line">        <span class="comment">// f[i][j] = f[i][j - 1] + A[j] = f[i - 1][j] - A[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            dp[k][k] = A[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + A[j];</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == S) ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[k] == S) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="优化dp（超时）"><a href="#优化dp（超时）" class="headerlink" title="优化dp（超时）"></a>优化dp（超时）</h5><p>优化成滚动数组，超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// f[i][j] 表示从i到j构成的加和</span></span><br><span class="line">        <span class="comment">// f[i][j] = f[i][j - 1] + A[j] = f[i - 1][j] - A[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[k] == S) ++ans;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = A[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] + A[j];</span><br><span class="line">                <span class="keyword">if</span> (dp[j] == S) ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先求得前缀和<code>s[i]表示前i-1项和</code>，问题转换成：<br>遍历到第s[j]，求得有多少个S满足<code>S = s[j] - s[i]</code> </p>
<ol>
<li>如果前缀和大于等于S，则前侧存在满足条件的子数组</li>
<li>S = s[i] - s[j] (i &gt; j) –&gt; <strong>存在多少个s[j]使得，<code>s[j] = s[i] - S</code></strong></li>
<li>s[j]个数 = (s[i] - S)的个数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;int&gt; s(n + 1, 0), f(n + 1, 0);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="number">1</span>] + A[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = s[i]; <span class="comment">// 第i位置的前缀和</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= S) ans += f[sum - S]; </span><br><span class="line">            f[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="删除排序链表的重复项II"><a href="#删除排序链表的重复项II" class="headerlink" title="删除排序链表的重复项II"></a>删除排序链表的重复项II</h4><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[idx - <span class="number">2</span>]) &#123; <span class="comment">// 新序列的倒数第二个元素不等于当前遍历的元素</span></span><br><span class="line">                <span class="comment">// 则将新序列的下一个元素变为当前遍历的元素，并后移新序列的尾指针</span></span><br><span class="line">                nums[idx++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则i指针继续向前遍历</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 $a + b + c = 0$ ? 请你找出所有满足条件且不重复的三元组。</p>
<p>注意：<strong>答案中不可以包含重复的三元组</strong>。</p>
<h5 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h5><p>固定前一个元素，后续元素双指针优化，失败。（没有处理好重复元素限定）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 固定一个数，另外两个数为双指针寻值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> i = k + <span class="number">1</span>, j = n - <span class="number">1</span>; <span class="comment">// 快慢指针</span></span><br><span class="line">            <span class="keyword">int</span> target = -nums[k];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">                    v.push_back(nums[k]);</span><br><span class="line">                    v.push_back(nums[i]);</span><br><span class="line">                    v.push_back(nums[j]);</span><br><span class="line">                    ans.push_back(v);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] &gt; target) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考starfly的题解之后，修改细节如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 固定一个数，另外两个数为双指针寻值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果第一个值大于零，后续将不存在解，直接跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 排除固定元素造成的重复</span></span><br><span class="line">            <span class="keyword">int</span> i = k + <span class="number">1</span>, j = n - <span class="number">1</span>; <span class="comment">// 快慢指针</span></span><br><span class="line">            <span class="keyword">int</span> target = -nums[k];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">                    v.push_back(nums[k]);</span><br><span class="line">                    v.push_back(nums[i]);</span><br><span class="line">                    v.push_back(nums[j]);</span><br><span class="line">                    ans.push_back(v);</span><br><span class="line"></span><br><span class="line">                    ++i; --j;</span><br><span class="line">                    <span class="comment">// 排除快慢指针指向的元素造成的重复</span></span><br><span class="line">                    <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) --j;</span><br><span class="line">                    <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) ++i;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &gt; target) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<h5 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h5><p>固定前两个元素+双指针+set去重</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans; <span class="comment">// set去重</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">4</span>; ++i) &#123; <span class="comment">// 固定首元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n - <span class="number">3</span>; ++j) &#123; <span class="comment">// 固定次元素</span></span><br><span class="line">                <span class="keyword">int</span> k = j + <span class="number">1</span>, l = n - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "下标 " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; k &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "数值 " &lt;&lt; nums[i] &lt;&lt; " " &lt;&lt; nums[j] &lt;&lt; " " &lt;&lt; nums[k] &lt;&lt; " " &lt;&lt; nums[l] &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">while</span> (k &lt; l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[l];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        ans.insert(&#123;nums[i] ,nums[j] ,nums[k] ,nums[l]&#125;);</span><br><span class="line">                        ++k; --l;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        ++k;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        --l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h5><p>固定元素+双指针+边界条件去重</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">4</span>; ++i) &#123; <span class="comment">// 固定首元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n - <span class="number">3</span>; ++j) &#123; <span class="comment">// 固定次元素</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> k = j + <span class="number">1</span>, l = n - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "下标 " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; k &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "数值 " &lt;&lt; nums[i] &lt;&lt; " " &lt;&lt; nums[j] &lt;&lt; " " &lt;&lt; nums[k] &lt;&lt; " " &lt;&lt; nums[l] &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">while</span> (k &lt; l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[l];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        ans.push_back(&#123;nums[i] ,nums[j] ,nums[k] ,nums[l]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; l &amp;&amp; nums[k + <span class="number">1</span>] == nums[k])</span><br><span class="line">                            ++k; </span><br><span class="line">                        <span class="keyword">while</span> (k &lt; l &amp;&amp; nums[l - <span class="number">1</span>] == nums[l])</span><br><span class="line">                            --l;</span><br><span class="line">                        ++k; --l;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        ++k;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        --l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h4><p>字符串<code>S</code>由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
<p>看完这题完全没有思路。</p>
<p>hash表+双指针思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每个片段蕴含的字母尽量少，含有的字母种类尽量少</span></span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ends</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span></span>; <span class="comment">// 建立26个字母的hash表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ends[S[i] - <span class="string">'a'</span>] = i; <span class="comment">// 更新ends[c]为每一个字符c出现的最后一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = ends[S[i] - <span class="string">'a'</span>]; <span class="comment">// 获取当前分段的开头元素在数组中最后一次出现的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= r; ++j) &#123;</span><br><span class="line">                <span class="comment">// 更新r为区间(i,r]内的字符出现位置的最大值</span></span><br><span class="line">                r = <span class="built_in">max</span>(r, ends[S[j] - <span class="string">'a'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(r - i + <span class="number">1</span>);</span><br><span class="line">            i = r + <span class="number">1</span>; <span class="comment">// 更新i</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h4><ul>
<li><code>tolower()</code></li>
<li><code>isalsum(char c)</code>返回c是否为大写字母或小写字母或数字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="通过删除字母匹配到字典里最长单词"><a href="#通过删除字母匹配到字典里最长单词" class="headerlink" title="通过删除字母匹配到字典里最长单词"></a>通过删除字母匹配到字典里最长单词</h4><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p>
<p>思路：</p>
<ul>
<li>先将d容器按照优先长度升序，再按字典序倒序排列。</li>
<li>遍历时倒序遍历d检查即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a.length() == b.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> a &gt; b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.length() &lt; b.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; cmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span> || d.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        sort(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = d.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; <span class="comment">// i是s的指针，k是d[j]的指针</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.length()) &#123; <span class="comment">// 如果没遍历完s继续遍历</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == d[j][k]) ++k; <span class="comment">// 如果对应元素相同，子串的指针后移</span></span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span> (k == d[j].<span class="built_in">size</span>()) <span class="keyword">return</span> d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h4><p>根据给定的链表返回环形的入口节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设前半部分节点为x，后半部分节点为y</span></span><br><span class="line">        <span class="comment">// f = s + ny = 2s</span></span><br><span class="line">        <span class="comment">// s = ny (相遇时)</span></span><br><span class="line">        <span class="comment">// s' = x + ny (到入口时)</span></span><br><span class="line">        <span class="comment">// t = x</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">bool</span> tag = <span class="literal">false</span>; <span class="comment">// 判断是否有环</span></span><br><span class="line">        ListNode *f, *s, *dummyHead;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        f = dummyHead; s = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (f != <span class="literal">NULL</span> &amp;&amp; f-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            f = f-&gt;next-&gt;next;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (s == f) &#123;</span><br><span class="line">                tag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tag) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* t = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (t != s) &#123;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="迷你语法解析器"><a href="#迷你语法解析器" class="headerlink" title="迷你语法解析器"></a>迷你语法解析器</h4><p><a href="https://leetcode-cn.com/problems/mini-parser/" target="_blank" rel="noopener">题目链接</a></p>
<h5 id="个人解法-失败"><a href="#个人解法-失败" class="headerlink" title="个人解法(失败)"></a>个人解法(失败)</h5><p>失败原因：没理解题意，以为每个列表内只能是一个列表和一个整数，没想到还可以是两个整数，或者两个列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// key：级数 val：数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 代表当前遍历到的数值的级数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">NestedInteger <span class="title">helper</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        NestedInteger ans;</span><br><span class="line">        ans.add(m[k]);</span><br><span class="line">        <span class="keyword">if</span> (k == m.<span class="built_in">size</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        ans.add(helper(k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retValue</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123; <span class="comment">// 根据当前字符串获取值</span></span><br><span class="line">        <span class="keyword">int</span> negLabel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            negLabel = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            value = value * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        m[cnt] = (!negLabel) ? value : (-value); <span class="comment">// 向map对应级数添加元素</span></span><br><span class="line">        <span class="keyword">return</span> m[cnt];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">NestedInteger <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] != <span class="string">'['</span>) <span class="keyword">return</span> NestedInteger(retValue(s));</span><br><span class="line">        <span class="keyword">if</span> (!n || s == <span class="string">"[]"</span>) <span class="keyword">return</span> NestedInteger();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">','</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                --cnt;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'-'</span> || <span class="built_in">isdigit</span>(s[i])) </span><br><span class="line">                retValue(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            NestedInteger ans;</span><br><span class="line">            ans.add(NestedInteger());</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="答案解法"><a href="#答案解法" class="headerlink" title="答案解法"></a>答案解法</h5><p>将解析的过程以<code>&#39;[&#39;</code>的出现为标志，分为两类：解析数字或者解析列表。解析数字时直接返回新建的对象给上一级，而解析列表则是一一将该列表里的List或Num传入<code>parse()</code>中识别出它为列表还是数字，再掉用对应函数添加到结果里面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">NestedInteger <span class="title">parse</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前位置是个"["则已更改返回list</span></span><br><span class="line">        <span class="keyword">if</span> (s[pos] == <span class="string">'['</span>) <span class="keyword">return</span> parseList(s);</span><br><span class="line">        <span class="comment">// 否则解析一个数</span></span><br><span class="line">        <span class="keyword">return</span> parseNum(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析一个数字</span></span><br><span class="line">    <span class="function">NestedInteger <span class="title">parseNum</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断正负</span></span><br><span class="line">        <span class="keyword">int</span> sign = s[pos] == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[pos] == <span class="string">'-'</span> || s[pos] == <span class="string">'+'</span>) pos++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; pos &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[pos]); pos++)</span><br><span class="line">            num = num * <span class="number">10</span> + s[pos] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="comment">// 返回该数字</span></span><br><span class="line">        <span class="keyword">return</span> NestedInteger(sign * num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析一个List</span></span><br><span class="line">    <span class="function">NestedInteger <span class="title">parseList</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        NestedInteger ni;</span><br><span class="line">        <span class="keyword">while</span> (s[pos] != <span class="string">']'</span>) &#123;</span><br><span class="line">            pos++;                    <span class="comment">// 跳过[和,</span></span><br><span class="line">            <span class="keyword">if</span> (s[pos] == <span class="string">']'</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 对List中的每个元素进行解析，可能存在数字或者嵌套的List</span></span><br><span class="line">            ni.add(parse(s));</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;                        <span class="comment">// 跳过]</span></span><br><span class="line">        <span class="comment">// 返回解析的List</span></span><br><span class="line">        <span class="keyword">return</span> ni;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">NestedInteger <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parse(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="最小区间"><a href="#最小区间" class="headerlink" title="最小区间"></a>最小区间</h4><p>你有<code>k</code>个升序排列的整数数组。找到一个最小区间，使得<code>k</code>个列表中的每个列表至少有一个数包含在其中。</p>
<p>我们定义如果 <code>b-a &lt; d-c</code> 或者在 <code>b-a == d-c</code> 时 <code>a &lt; c</code>，则区间 <code>[a,b]</code> 比 <code>[c,d]</code> 小。</p>
<p>示例 1:</p>
<p>输入:<code>[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</code><br>输出: <code>[20,24]</code><br>解释:<br>列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。<br>列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。<br>列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。<br>注意:</p>
<p>给定的列表可能包含重复元素，所以在这里升序表示 &gt;= 。<br>1 &lt;= k &lt;= 3500<br>-105 &lt;= 元素的值 &lt;= 105</p>
<p>解法：hash表+滑动窗口<br><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/solution/pai-xu-hua-chuang-by-netcan/" target="_blank" rel="noopener">参考Netcan加的注释</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallestRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; ordered;</span><br><span class="line">        <span class="comment">// 将&#123;数值, 列表索引&#125;信息保存到ordered，并依照数值排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> item: nums[i]) &#123;</span><br><span class="line">                ordered.push_back(&#123;item, i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ordered.<span class="built_in">begin</span>(), ordered.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ordered.<span class="built_in">size</span>(); ++j) &#123; <span class="comment">// 遍历ordered</span></span><br><span class="line">            <span class="comment">// 以nums.size()为3举例</span></span><br><span class="line">            <span class="comment">// 如果遍历到的索引出现过，次数+1</span></span><br><span class="line">            <span class="comment">// 如果遍历到的索引没出现过，次数+1，指针后移（后移三次意味着0，1，2均出现过）</span></span><br><span class="line">            <span class="keyword">if</span> (!count[ordered[j].second]++) ++k;</span><br><span class="line">            <span class="keyword">if</span> (k == nums.<span class="built_in">size</span>()) &#123; <span class="comment">// 直到遍历三个长度的索引均出现过 </span></span><br><span class="line">                <span class="comment">// 当出现类似于滑动窗口为(2,21), (2,22), (2,23), (1,24), (0,25)这种情况</span></span><br><span class="line">                <span class="comment">// 不能单纯的取(2,21)而是要将i更新到(2,23)为真正的首窗口</span></span><br><span class="line">                <span class="keyword">while</span> (count[ordered[i].second] &gt; <span class="number">1</span>) --count[ordered[i++].second];</span><br><span class="line">                <span class="keyword">if</span> (ans.empty() || ans[<span class="number">1</span>] - ans[<span class="number">0</span>] &gt; ordered[j].first - ordered[i].first) &#123;</span><br><span class="line">                    <span class="comment">// 如果ans为空（第一次修正ans）</span></span><br><span class="line">                    <span class="comment">// 或者滑动窗口首尾值差小于之前ans中的存储的首尾差</span></span><br><span class="line">                    <span class="comment">// 则更新ans为新的首尾区间</span></span><br><span class="line">                    ans = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;ordered[i].first, ordered[j].first&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令行</title>
    <url>/2020/07/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<p>Linux命令行的工具手册。</p>
<a id="more"></a>
<h1 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h1><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ls</code></td>
<td align="center">查看该级文件</td>
</tr>
<tr>
<td align="center"><code>ls -a</code></td>
<td align="center">查看该级隐藏文件</td>
</tr>
<tr>
<td align="center"><code>ls /</code></td>
<td align="center">查看该级所有文件</td>
</tr>
<tr>
<td align="center"><code>ls -l</code></td>
<td align="center">查看长文件信息</td>
</tr>
<tr>
<td align="center"><code>ls -lh</code></td>
<td align="center">大小用k、M、G显示</td>
</tr>
<tr>
<td align="center"><code>ls -d</code></td>
<td align="center">查看当前目录信息</td>
</tr>
<tr>
<td align="center"><code>ls -i</code></td>
<td align="center">查看文件id</td>
</tr>
<tr>
<td align="center"><code>ls xx</code>+<code>tab</code></td>
<td align="center">补齐文件开头为<code>xx</code>的文件</td>
</tr>
</tbody></table>
<h2 id="pwd-print-working-directory"><a href="#pwd-print-working-directory" class="headerlink" title="pwd(print working directory)"></a>pwd(print working directory)</h2><p>输出当前路径</p>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>cd /home/test</code></td>
<td align="center">访问xx目录</td>
</tr>
<tr>
<td align="center"><code>cd ..</code></td>
<td align="center">访问上一级</td>
</tr>
<tr>
<td align="center"><code>cd .</code></td>
<td align="center">访问当前目录</td>
</tr>
<tr>
<td align="center"><code>cd ~</code></td>
<td align="center">访问主目录</td>
</tr>
</tbody></table>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>mkdir test</code></td>
<td align="center">新建test文件夹</td>
</tr>
<tr>
<td align="center"><code>mkdir -p /test/123</code></td>
<td align="center">递归创建目录</td>
</tr>
<tr>
<td align="center"><code>mkdir t1 t2 t3</code></td>
<td align="center">同时创建多个目录</td>
</tr>
</tbody></table>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>rmdir test</code></td>
<td align="center">删除一个空目录</td>
</tr>
<tr>
<td align="center"><code>rm -rf abc</code></td>
<td align="center">将当前目录中所有内容强制删除</td>
</tr>
</tbody></table>
<h2 id="cp-amp-mv"><a href="#cp-amp-mv" class="headerlink" title="cp &amp; mv"></a>cp &amp; mv</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>cp-rf e1 e2</code></td>
<td align="center">复制文件或目录</td>
</tr>
<tr>
<td align="center"><code>move hi hello</code></td>
<td align="center">重命名文件或目录</td>
</tr>
</tbody></table>
<h2 id="归档压缩"><a href="#归档压缩" class="headerlink" title="归档压缩"></a>归档压缩</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>tar -cvf f.tar f1 f2 f3</code></td>
<td align="center">将文件归档成档案包</td>
</tr>
<tr>
<td align="center"><code>tar -xvf f.tar</code></td>
<td align="center">还原档案包到当前路径</td>
</tr>
<tr>
<td align="center"><code>tar -xvf f.tar -C xxx/</code></td>
<td align="center">还原档案包到指定路径</td>
</tr>
<tr>
<td align="center"><code>tar -zcvf f.tar.gz f1 f2 f3</code></td>
<td align="center">归档并压缩</td>
</tr>
<tr>
<td align="center"><code>tar -zxvf f.tar.gz</code></td>
<td align="center">解压缩到当前路径</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>STL整理</title>
    <url>/2020/07/29/STL%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>是一个标准模板库的使用字典。</p>
<a id="more"></a>

<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;vector&gt;</code></p>
<h2 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h2><h3 id="单个访问"><a href="#单个访问" class="headerlink" title="单个访问"></a>单个访问</h3><ol>
<li>下标访问</li>
<li>begin()函数(<code>*(v.begin + i)</code>)  <strong>只有string和vector支持这种访问方法</strong></li>
</ol>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li>for循环利用下标<code>i</code></li>
<li>for循环利用迭代器<ul>
<li><code>for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)</code></li>
<li><code>for(auto temp:v)</code></li>
</ul>
</li>
</ol>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul>
<li><code>push_back(x)</code> —-$O(1)$</li>
<li><code>pop_back()</code> —-$O(1)$</li>
<li><code>size()</code> —-$O(1)$</li>
<li><code>clear()</code> —-$O(n)$</li>
<li><code>insert(it, x)</code> —-$O(n)$</li>
<li><code>erase(it)</code>/ <code>erase(first, last)</code> —-$O(n)$</li>
</ul>
<h2 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h2><ol>
<li>存储数据</li>
<li>充当数组</li>
<li>邻接表存储图</li>
</ol>
<hr>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p><strong>内部有序</strong>且不含<strong>重复元素</strong>的容器。</p>
<h2 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;set&gt;</code></p>
<h2 id="访问方式-1"><a href="#访问方式-1" class="headerlink" title="访问方式"></a>访问方式</h2><p>只能通过迭代器访问</p>
<h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><p><code>insert(x)</code> —-$O(logn)$</p>
</li>
<li><p><code>find(value)</code> —-$O(logn) $ </p>
<p><strong>返回的是对应值为value的迭代器</strong></p>
</li>
<li><p><code>erase()</code></p>
<ul>
<li><p>通过迭代器删除单个元素 <code>st.erase(it)</code> —-$O(1)$</p>
<p>配合<code>find()</code>使用场景：<code>st.erase(st.find(100))</code></p>
</li>
<li><p>通过值删除单个元素<code>st.erase(value)</code> —-$O(logn)$</p>
</li>
<li><p>通过迭代器删除区间元素 <code>st.erase(first, last)</code> —- $O(last - first)$</p>
</li>
</ul>
</li>
<li><p><code>size()</code> —-$O(1)$</p>
</li>
<li><p><code>clear()</code> —-$O(n)$</p>
</li>
</ol>
<h2 id="常见用途-1"><a href="#常见用途-1" class="headerlink" title="常见用途"></a>常见用途</h2><ol>
<li>自动去重并按升序排列</li>
<li>扩展容器<strong>unordered_set</strong>，只去重，不排序。</li>
</ol>
<hr>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="头文件-2"><a href="#头文件-2" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;string&gt;</code></p>
<h2 id="访问方式-2"><a href="#访问方式-2" class="headerlink" title="访问方式"></a>访问方式</h2><ol>
<li>下标访问</li>
<li>迭代器访问</li>
</ol>
<h2 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><p><code>+=</code></p>
</li>
<li><p><code>&gt;</code>、<code>&lt;</code>、<code>==</code>(比较字典序)</p>
</li>
<li><p><code>length()</code> / <code>size()</code> —-$O(1)$</p>
</li>
<li><p><code>insert()</code> —-$O(n)$</p>
<ul>
<li><code>str.insert(pos, string)</code> 向<code>str[3]</code>的位置插入字符串<code>string</code></li>
<li><code>str.insert(it, it2, it3)</code>向<code>str</code>字符串中插入另一字符串的首尾迭代器<code>it2</code>和<code>it3</code>之间</li>
</ul>
</li>
<li><p><code>erase()</code> —-$O(n)$</p>
<ul>
<li><code>erase(it)</code></li>
<li><code>erase(first, last)</code></li>
<li><code>erase(pos, length)</code></li>
</ul>
</li>
<li><p><code>clear()</code> —-$O(1)$</p>
</li>
<li><p><code>substr(pos, len)</code> —-$O(len)$</p>
</li>
<li><p><code>find()</code> —-$O(nm)$ </p>
<ul>
<li><p><code>str.find(str2)</code> </p>
<p>当<code>str2</code>是<code>str</code>的子串，返回其在<code>str</code>中第一次出现的位置。否则返回<code>npos</code>。</p>
</li>
<li><p><code>str.find(str2, pos)</code></p>
<p>以<code>pos</code>（int）位为起点，开始向后匹配。</p>
</li>
</ul>
</li>
<li><p><code>string::npos</code> 当作<code>find()</code>函数失配的返回值</p>
</li>
<li><p><code>replace()</code> —-$O(str.length())$</p>
<ul>
<li><p><code>str.replace(pos, len, str2)</code></p>
<p>把<code>str</code>从<code>pos</code>位开始，长度为<code>len</code>的子串替换为<code>str2</code></p>
</li>
<li><p><code>str.replace(it1, it2, str2)</code></p>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map可以建立键值对的映射，且会以<strong>键从小到大的顺序自动排序</strong>。</p>
<h2 id="头文件-3"><a href="#头文件-3" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;map&gt;</code></p>
<h2 id="访问方式-3"><a href="#访问方式-3" class="headerlink" title="访问方式"></a>访问方式</h2><ol>
<li>下标访问</li>
<li>迭代器访问<ul>
<li>key：<code>it-&gt;first</code></li>
<li>val：<code>it-&gt;second</code></li>
</ul>
</li>
</ol>
<h2 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><code>find(key)</code> —-$O(logn)$</li>
<li><code>erase()</code><ul>
<li><code>erase(it)</code> —-$O(1)$</li>
<li><code>erase(key)</code> —-$O(logn)$</li>
<li><code>erase(first, last)</code> —-$O(last - first)$</li>
</ul>
</li>
<li><code>size()</code> —-$O(1)$</li>
<li><code>clear()</code> —-$O(1)$</li>
</ol>
<h2 id="常见用途-2"><a href="#常见用途-2" class="headerlink" title="常见用途"></a>常见用途</h2><ol>
<li>建立字符(字符串)到整数的映射</li>
<li>判断大整数或者其他数据是否存在</li>
<li>字符串映射</li>
<li><code>unordered_map</code>建立哈希表</li>
</ol>
<hr>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><h2 id="头文件-4"><a href="#头文件-4" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;queue&gt;</code></p>
<h2 id="访问方式-4"><a href="#访问方式-4" class="headerlink" title="访问方式"></a>访问方式</h2><p><code>q.front()</code> / <code>q.back()</code></p>
<h2 id="常用函数-4"><a href="#常用函数-4" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><code>front()</code>,<code>back()</code> —-$O(1)$</li>
<li><code>pop()</code> —-$O(1)$</li>
<li><code>empty()</code> —-$O(1)$</li>
<li><code>size()</code> —-$O(1)$</li>
</ol>
<h2 id="常见用途-3"><a href="#常见用途-3" class="headerlink" title="常见用途"></a>常见用途</h2><p>广度优先搜索</p>
<hr>
<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>双端队列</strong>，允许在首尾两端快速插入以及删除。</p>
<h2 id="头文件-5"><a href="#头文件-5" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;deque&gt;</code></p>
<h2 id="访问方式-5"><a href="#访问方式-5" class="headerlink" title="访问方式"></a>访问方式</h2><p><code>q.front()</code> —-$O(1)$</p>
<p><code>q.back()</code> —-$O(1)$</p>
<p><code>q.at(int pos)</code> —-$O(1)$</p>
<h2 id="常用函数-5"><a href="#常用函数-5" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><code>empty()</code> —-$O(1)$</li>
<li><code>size()</code>  —-$O(1)$</li>
<li><code>insert(it, val)</code> —-$O(n)$</li>
<li><code>push_back()</code> —-$O(1)$</li>
<li><code>push_front()</code> —-$O(1)$</li>
<li><code>front()</code> —-$O(1)$</li>
<li><code>back()</code> —-$O(1)$</li>
<li><code>pop_front()</code> —-$O(1)$</li>
<li><code>pop_back()</code> —-$O(1)$</li>
</ol>
<hr>
<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><strong>优先队列</strong>，底层用堆进行实现。队列中，队首元素一定是<strong>当前队列中优先级最高的元素</strong>。</p>
<h2 id="头文件-6"><a href="#头文件-6" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;queue&gt;</code></p>
<h2 id="访问方式-6"><a href="#访问方式-6" class="headerlink" title="访问方式"></a>访问方式</h2><p><code>q.top()</code>访问队首元素</p>
<h2 id="常用函数-6"><a href="#常用函数-6" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><code>push()</code> —-$O(logn)$</li>
<li><code>top()</code> —-$O(1)$</li>
<li><code>pop()</code> —-$O(logn)$</li>
<li><code>empty()</code> —-$O(1)$</li>
<li><code>size()</code> —-$O(1)$</li>
</ol>
<h2 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h2><h3 id="基本数据类型设置"><a href="#基本数据类型设置" class="headerlink" title="基本数据类型设置"></a>基本数据类型设置</h3><p><code>priority_queue&lt;int&gt; q</code></p>
<p>优先级按照元素<strong>从大到小</strong>降序排列</p>
<p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code></p>
<p>优先级按照元素<strong>从小到大</strong>降序排列</p>
<h3 id="结构体的优先级设置"><a href="#结构体的优先级设置" class="headerlink" title="结构体的优先级设置"></a>结构体的优先级设置</h3><p>以水果为例，根据水果的名称和价格建立一个结构体。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在希望按照其<strong>价格从高到低获取水果名称</strong>，需要重载运算符，重载运算符函数加入到结构体的定义中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> fruit &amp;f1, <span class="keyword">const</span> fruit &amp;f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，可以直接定义<code>fruit</code>类型的优先队列<code>priority_queue&lt;fruit&gt; q;</code>，其内部以价格高的水果为高优先级。</p>
<p>如想以低价格为优先级高，只需将return语句中的<code>&lt;</code>改成<code>&gt;</code>即可。</p>
<p><strong>另外，如果想将重载写在结构体之外，声明方式和队列的定义方式也需要发生一定的改变。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> fruit &amp;f1, <span class="keyword">const</span> fruit &amp;f2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;fruit, <span class="built_in">vector</span>&lt;fruit&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure>

<p>其他的STL容器也可以用类似的方法来定义优先级。</p>
<hr>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><h2 id="头文件-7"><a href="#头文件-7" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;stack&gt;</code></p>
<h2 id="访问方式-7"><a href="#访问方式-7" class="headerlink" title="访问方式"></a>访问方式</h2><p><code>s.top()</code></p>
<h2 id="常用函数-7"><a href="#常用函数-7" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><code>push()</code> —-$O(1)$</li>
<li><code>top()</code> —-$O(1)$</li>
<li><code>pop()</code> —-$O(1)$</li>
<li><code>empty()</code> —-$O(1)$</li>
<li><code>size()</code> —-$O(1)$</li>
</ol>
<h2 id="常见用途模拟递归"><a href="#常见用途模拟递归" class="headerlink" title="常见用途模拟递归"></a>常见用途模拟递归</h2><p>模拟递归，防止递归层数过多。</p>
<hr>
<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><h2 id="头文件-8"><a href="#头文件-8" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;utility&gt;</code> / <code>#include &lt;map&gt;</code></p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p><code>p.first</code></p>
<p><code>p.second</code></p>
<h2 id="常用函数-8"><a href="#常用函数-8" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li><p>赋值函数：<code>p = make_pair(&quot;666&quot;, 666);</code></p>
</li>
<li><p>比较操作数：直接用操作数比较</p>
<p>标准：<strong>先以first的大小作为标准，当first相等时再去判定second的大小</strong></p>
</li>
</ol>
<h2 id="常见用途-4"><a href="#常见用途-4" class="headerlink" title="常见用途"></a>常见用途</h2><ol>
<li><p>代替二元结构体，节省代码</p>
</li>
<li><p>作为map值进行插入(其实用{}的方式插入应该也可以)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">m.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">"haha"</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>将一个元素的相关信息与其绑定（例如&lt;节点，深度&gt;）</p>
</li>
</ol>
<hr>
<h1 id="algorithm头文件下的其他常用函数"><a href="#algorithm头文件下的其他常用函数" class="headerlink" title="algorithm头文件下的其他常用函数"></a>algorithm头文件下的其他常用函数</h1><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><p><code>fill(a, a+4, 0)</code> </p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">int</span> r; <span class="comment">// 排名</span></span><br><span class="line">&#125; stu[<span class="number">10010</span>];</span><br></pre></td></tr></table></figure>

<p>对所有学生的成绩按从高到低排列，分数相同的按照姓名的字典序从小到大排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score != b.score) <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.name, b.name) &lt; <span class="number">0</span>; <span class="comment">// 比较两个char型数组的字典序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lower-bound-amp-upper-bound"><a href="#lower-bound-amp-upper-bound" class="headerlink" title="lower_bound() &amp; upper_bound()"></a>lower_bound() &amp; upper_bound()</h2><p>这两个函数需要用在一个有序数组或容器中。</p>
<p>复杂度 —-$O(log(last-first))$</p>
<p><code>lower_bound(first, last, val)</code>用来寻找在数组或容器的$[first, last)$范围内第一个值大于等于<code>val</code>的元素的位置。</p>
<ul>
<li>如果是数组，则返回该位置指针。</li>
<li>如果是容器，则返回该位置迭代器。</li>
</ul>
<p><code>upperbound(frist, last, val)</code>用于寻找在数组或容器的$[first, last)$范围内第一个大于<code>val</code>的元素的位置。</p>
<ul>
<li>如果是数组，则返回该位置指针。</li>
<li>如果是容器，则返回该位置迭代器。</li>
</ul>
<p><strong>如果数组或容器中，没有需要寻找的元素，则返回可以插入该元素位置的指针或迭代器。</strong></p>
<p><strong>如果只想获取其下标，则将返回值减去首地址/首迭代器。</strong></p>
<h2 id="advance"><a href="#advance" class="headerlink" title="advance()"></a>advance()</h2><p>将迭代器前移或后退指定距离。</p>
<p><code>advance(it, dis)</code></p>
<h2 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate()"></a>accumulate()</h2><p><code>accumulate(it_begin, it_end, beginSum, lambda)</code></p>
<p><strong>int, string均可加</strong></p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*数组求和*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val = &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> sum = accumulate(val.<span class="built_in">begin</span>(), val.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*应用lambda表达式*/</span></span><br><span class="line"><span class="comment">// 以The numbers are 为初始值，向后依次以": x"为模板向后累加</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> s = accumulate(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="string">"The numbers are"</span>,[](strings str, <span class="keyword">int</span> n)&#123; <span class="keyword">return</span> str + <span class="string">" : "</span> + <span class="built_in">std</span>::to_string(n);&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//Output: The numbers are: 1: 2: 3: 10: 11: 12</span></span><br></pre></td></tr></table></figure>



<h2 id="max-element和min-element"><a href="#max-element和min-element" class="headerlink" title="max_element和min_element"></a>max_element和min_element</h2><p><code>int maxValue = *max_element(nums.begin(), nums.end())</code></p>
]]></content>
      <categories>
        <category>应试</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记-4</title>
    <url>/2020/07/20/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-4/</url>
    <content><![CDATA[<p>主要介绍模块库scrapy。</p>
<a id="more"></a>
<h3 id="scrapy库"><a href="#scrapy库" class="headerlink" title="scrapy库"></a>scrapy库</h3><h4 id="scrapy爬虫框架"><a href="#scrapy爬虫框架" class="headerlink" title="scrapy爬虫框架"></a>scrapy爬虫框架</h4><p><img src="https://www.runoob.com/wp-content/uploads/2018/10/8c591d54457bb033812a2b0364011e9c_articlex.png" alt="框架图"><br>Scrapy Engine(引擎): 负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。</p>
<ul>
<li><strong>Scheduler(调度器)</strong>: 它负责接受引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。</li>
<li><strong>Downloader（下载器）</strong>：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理，</li>
<li><strong>Spider（爬虫）</strong>：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器).</li>
<li><strong>Item Pipeline(管道)</strong>：它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方。</li>
<li><strong>Downloader Middlewares（下载中间件）</strong>：你可以当作是一个可以自定义扩展下载功能的组件。</li>
<li><strong>Spider Middlewares（Spider中间件）</strong>：你可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses;和从Spider出去的Requests）</li>
</ul>
<h4 id="scrapy常用命令"><a href="#scrapy常用命令" class="headerlink" title="scrapy常用命令"></a>scrapy常用命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
<th align="center">格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong><code>startproject</code></strong></td>
<td align="center">创建一个工程</td>
<td align="center"><code>scrapy startproject &lt;name&gt; [dir]</code></td>
</tr>
<tr>
<td align="center"><strong><code>genspider</code></strong></td>
<td align="center">创建一个爬虫</td>
<td align="center"><code>scrapy genspider [options] &lt;name&gt; &lt;domain&gt;</code></td>
</tr>
<tr>
<td align="center"><code>settings</code></td>
<td align="center">获得爬虫配置信息</td>
<td align="center"><code>scrapy settings [options]</code></td>
</tr>
<tr>
<td align="center"><strong><code>crawl</code></strong></td>
<td align="center">运行一个爬虫</td>
<td align="center"><code>scrapy crawl &lt;spider&gt;</code></td>
</tr>
<tr>
<td align="center"><code>list</code></td>
<td align="center">列出工程中所有爬虫</td>
<td align="center"><code>scrapy list</code></td>
</tr>
<tr>
<td align="center"><code>shell</code></td>
<td align="center">启用URL调试命令行</td>
<td align="center"><code>scrapy shell [url]</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记V</title>
    <url>/2020/08/17/Leetcode%E6%97%A5%E8%AE%B0V/</url>
    <content><![CDATA[<p>Leetcode日记V，最后一波，冲！</p>
<a id="more"></a>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="根据二叉树创建字符串"><a href="#根据二叉树创建字符串" class="headerlink" title="根据二叉树创建字符串"></a>根据二叉树创建字符串</h2><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>
<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    2     3</span><br><span class="line">   &#x2F;    </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">解释: 原本将是“1(2(4)())(3())”，</span><br><span class="line">在你省略所有不必要的空括号对之后，</span><br><span class="line">它将是“1(2(4))(3)”。</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    2     3</span><br><span class="line">     \  </span><br><span class="line">      4 </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2()(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">解释: 和第一个示例相似，</span><br><span class="line">除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</span><br></pre></td></tr></table></figure>

<p>递归+前序遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">            ans.append(to_string(t-&gt;val));</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) &#123; <span class="comment">// 左右均存在 或 左不存在右存在</span></span><br><span class="line">                ans += (<span class="string">"("</span> + tree2str(t-&gt;left) + <span class="string">")("</span> + tree2str(t-&gt;right) + <span class="string">")"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;left) &#123; <span class="comment">// 左存在右不存在</span></span><br><span class="line">                ans += (<span class="string">"("</span> + tree2str(t-&gt;left) + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h2><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*序列化+dfs*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// 序列 ：出现次数</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二叉树序列化</span></span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        <span class="comment">// 当前根节点的先序序列，由于空格的位数偏差，该序列是唯一的</span></span><br><span class="line">        str = to_string(r-&gt;val) + <span class="string">" "</span> + helper(r-&gt;left) + <span class="string">" "</span> + helper(r-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (m[str] == <span class="number">1</span>) ans.push_back(r); <span class="comment">// 如果已经出现了一次，则存在重复</span></span><br><span class="line">        m[str]++;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="输出二叉树"><a href="#输出二叉树" class="headerlink" title="输出二叉树"></a>输出二叉树</h2><p><a href="https://leetcode-cn.com/problems/print-binary-tree/" target="_blank" rel="noopener">题目链接</a></p>
<p>根据深度bfs，逐层修改结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (r == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">max</span>(getDepth(r-&gt;left), getDepth(r-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">printTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#123;<span class="string">""</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> d = getDepth(root); <span class="comment">// 树的深度等于行数</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">pow</span>(<span class="number">2</span>, d) - <span class="number">1</span>; <span class="comment">// 宽度为2 ^ d - 1</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">ans</span><span class="params">(d, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(c, <span class="string">""</span>))</span></span>; <span class="comment">// 初始化为全空</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">-1</span>; <span class="comment">// 当前树的高度</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; cur &lt; d - <span class="number">1</span>) &#123; <span class="comment">// bfs，跳出循环条件为层数达到d</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            cur++;</span><br><span class="line">            <span class="comment">// 该层第一个输出位的当前列下标为 (2^cur-1)/(2^(cur+1))</span></span><br><span class="line">            <span class="comment">// 每两个节点相隔2^(d-cur)</span></span><br><span class="line">            <span class="keyword">int</span> start = c / <span class="built_in">pow</span>(<span class="number">2</span>, cur + <span class="number">1</span>), len = <span class="built_in">pow</span>(<span class="number">2</span>, d - cur);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                ans[cur][start + len * i] = (tmp == <span class="literal">NULL</span>) ? <span class="string">""</span> : to_string(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">                    q.push(tmp-&gt;left);</span><br><span class="line">                    q.push(tmp-&gt;right);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 空节点也要占位</span></span><br><span class="line">                    q.push(<span class="literal">NULL</span>); q.push(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h2><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p>
<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p>
<h3 id="个人解法（超时）"><a href="#个人解法（超时）" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h3><p>bfs+层节点序列化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用一个字符串记录每层的非空节点</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>(); <span class="comment">// cnt为该层非空节点数量，若为0则break</span></span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">                    q.push(tmp-&gt;left);</span><br><span class="line">                    q.push(tmp-&gt;right);</span><br><span class="line">                    str.push_back(<span class="string">'*'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                    q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                    str.push_back(<span class="string">'#'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cnt = str.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = str.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 从后向前遍历层序列</span></span><br><span class="line">                <span class="keyword">if</span> (str[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; ans) &#123;</span><br><span class="line">                ans = cnt; <span class="comment">// 更新ans</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>存储每个非空节点的对应下标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.push(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            ans = <span class="built_in">max</span>(<span class="keyword">int</span>(q.back().second - q.front().second + <span class="number">1</span>), ans);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (tmp.first-&gt;left) q.push(&#123;tmp.first-&gt;left, tmp.second * <span class="number">2</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span> (tmp.first-&gt;right) q.push(&#123;tmp.first-&gt;right, tmp.second * <span class="number">2</span> + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt; m; <span class="comment">// depth : left 存储最左节点的下标</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* r, <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pos)</span> </span>&#123; <span class="comment">// 前序dfs 每当第一次访问每层，一定先访问到最左节点</span></span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">find</span>(d) == m.<span class="built_in">end</span>()) m[d] = pos;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (<span class="keyword">int</span>)(pos - m[d] + <span class="number">1</span>));</span><br><span class="line">        dfs(r-&gt;left, d + <span class="number">1</span>, pos * <span class="number">2</span>);</span><br><span class="line">        dfs(r-&gt;right, d + <span class="number">1</span>, pos * <span class="number">2</span> + <span class="number">1</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h2><p>将<code>val</code>插入二叉搜索树中。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) &#123;</span><br><span class="line">            root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *parent = root, *p = root;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            parent = p;</span><br><span class="line">            p = p-&gt;val &lt; val ? p-&gt;right : p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;val &lt; val) &#123;</span><br><span class="line">            parent-&gt;right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树中所有距离为K的结点"><a href="#二叉树中所有距离为K的结点" class="headerlink" title="二叉树中所有距离为K的结点"></a>二叉树中所有距离为K的结点</h2><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。</p>
<p>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。</p>
<h3 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h3><p>树-&gt;图，dfs</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(TreeNode* pre, TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            graph[r-&gt;val].push_back(pre-&gt;val); <span class="comment">// 前驱也是它的相邻节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;left) graph[r-&gt;val].push_back(r-&gt;left-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;right) graph[r-&gt;val].push_back(r-&gt;right-&gt;val);</span><br><span class="line"></span><br><span class="line">        createGraph(r, r-&gt;left); <span class="comment">// r变为前驱，左节点变为根</span></span><br><span class="line">        createGraph(r, r-&gt;right); <span class="comment">// r变为前驱，右节点变为根</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) ans.push_back(cur);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[cur].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nex = graph[cur][i];</span><br><span class="line">                <span class="keyword">if</span> (graph.<span class="built_in">find</span>(nex) != graph.<span class="built_in">end</span>() &amp;&amp; vis[nex] == <span class="number">0</span>) &#123;</span><br><span class="line">                    vis[nex] = <span class="number">1</span>;</span><br><span class="line">                    dfs(k - <span class="number">1</span>, nex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* r, TreeNode* target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将树转换成图</span></span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> &#123;target-&gt;val&#125;;</span><br><span class="line">        createGraph(<span class="literal">nullptr</span>, r);</span><br><span class="line">        <span class="comment">// 处理当图仅一个结点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (graph.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> &#123;r-&gt;val&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vis.resize(graph.<span class="built_in">size</span>(), <span class="number">0</span>); <span class="comment">// 构建vis数组</span></span><br><span class="line">        vis[target-&gt;val] = <span class="number">1</span>;</span><br><span class="line">        dfs(k, target-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>参考steven</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findDistK</span><span class="params">(TreeNode* r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!r || k &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 如果根节点为空或k不合法返回</span></span><br><span class="line">        <span class="keyword">if</span> (!k) ans.push_back(r-&gt;val);</span><br><span class="line">        findDistK(r-&gt;left, k - <span class="number">1</span>);</span><br><span class="line">        findDistK(r-&gt;right, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetParent</span><span class="params">(TreeNode* r, TreeNode* target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (r == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = findTargetParent(r-&gt;left, target, k);</span><br><span class="line">        <span class="keyword">int</span> right = findTargetParent(r-&gt;right, target, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果target在左分支</span></span><br><span class="line">            <span class="keyword">if</span> (left == k) &#123;</span><br><span class="line">                ans.push_back(r-&gt;val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; k) &#123;</span><br><span class="line">                findDistK(r-&gt;right, k - left - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果target在右分支</span></span><br><span class="line">            <span class="keyword">if</span> (right == k) &#123;</span><br><span class="line">                ans.push_back(r-&gt;val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &lt; k) &#123;</span><br><span class="line">                findDistK(r-&gt;left, k - right - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* r, TreeNode* target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> &#123;target-&gt;val&#125;;</span><br><span class="line">        findTargetParent(r, target, k);</span><br><span class="line">        findDistK(target, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="dfs-1"><a href="#dfs-1" class="headerlink" title="dfs"></a>dfs</h1><h2 id="扫雷游戏"><a href="#扫雷游戏" class="headerlink" title="扫雷游戏"></a>扫雷游戏</h2><p><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">题目链接</a></p>
<p>无脑dfs即可，注意当访问到的位修改后变成了数字（即其为炸弹的相邻位）修改原位直接返回即可，否则递归向下修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = board[r][c]; <span class="comment">// 保存元字符</span></span><br><span class="line">        board[r][c] = <span class="string">'#'</span>; <span class="comment">// 标志访问</span></span><br><span class="line">        <span class="keyword">int</span> cntM = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123; <span class="comment">// 首先探炸弹</span></span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge &amp;&amp; board[x][y] == <span class="string">'M'</span>) &#123;</span><br><span class="line">                cntM++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cntM) &#123; <span class="comment">// 如果四周没炸弹，递归向下继续dfs</span></span><br><span class="line">            board[r][c] = <span class="string">'B'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">                <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">                <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">                <span class="keyword">if</span> (notEdge &amp;&amp; board[x][y] == <span class="string">'E'</span>) &#123;</span><br><span class="line">                    dfs(board, x, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则修改后直接返回</span></span><br><span class="line">            board[r][c] = <span class="string">'0'</span> + cntM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; <span class="title">updateBoard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">click</span>)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>(); m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="built_in">click</span>[<span class="number">0</span>]][<span class="built_in">click</span>[<span class="number">1</span>]] == <span class="string">'M'</span>) &#123;</span><br><span class="line">            board[<span class="built_in">click</span>[<span class="number">0</span>]][<span class="built_in">click</span>[<span class="number">1</span>]] = <span class="string">'X'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(board, <span class="built_in">click</span>[<span class="number">0</span>], <span class="built_in">click</span>[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h2><p><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="dfs-2"><a href="#dfs-2" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查看graph[start]是否有end，若无继续dfs</span></span><br><span class="line">        vis[start] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[start].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[start][i] == <span class="built_in">end</span> &amp;&amp; vis[graph[start][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果遍历到了目标节点，返回true</span></span><br><span class="line">                vis[start] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graph[start][i] != <span class="built_in">end</span> &amp;&amp; vis[graph[start][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果遍历到的不是end，且当前未被访问过，继续dfs</span></span><br><span class="line">                <span class="keyword">if</span> (dfs(graph[start][i], <span class="built_in">end</span>)) &#123;</span><br><span class="line">                    vis[start] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[start] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLoop</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; edge)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向边(u,v)，是否存在另一条(u,v)的通路</span></span><br><span class="line"></span><br><span class="line">        vis[edge[<span class="number">0</span>]] = <span class="number">1</span>; <span class="comment">// 标记成已访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[edge[<span class="number">0</span>]].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[edge[<span class="number">0</span>]][i] == edge[<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// u-&gt;v跳过</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(graph[edge[<span class="number">0</span>]][i], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                vis[edge[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[edge[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先根据edges转换成邻接表结构</span></span><br><span class="line">        N = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        graph.resize(N + <span class="number">1</span>);</span><br><span class="line">        vis.assign(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 倒序访问边集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (isLoop(edges[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> edges[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 先根据edges转换成邻接表结构，并构建入度表 */</span></span><br><span class="line">        N = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        graph.resize(N + <span class="number">1</span>);</span><br><span class="line">        indegree.resize(N + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            indegree[edges[i][<span class="number">0</span>]]++;</span><br><span class="line">            indegree[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">1</span>) <span class="comment">// 入度为1的节点入队</span></span><br><span class="line">                q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123; <span class="comment">// 依次删除图中的入度为1的节点，并更新队列</span></span><br><span class="line">            <span class="keyword">int</span> temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[temp].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                indegree[graph[temp][i]]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[graph[temp][i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.push(graph[temp][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*经过拓扑排序之后，indegree中的所有入度大于1的节点的任意组合都是可删的边*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 倒序遍历边</span></span><br><span class="line">            <span class="keyword">if</span> (indegree[edges[i][<span class="number">0</span>]] &gt; <span class="number">1</span> &amp;&amp; indegree[edges[i][<span class="number">1</span>]] &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> edges[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 路径压缩，寻找根节点</span></span><br><span class="line">        <span class="keyword">int</span> a = x;</span><br><span class="line">        <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">            x = father[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (a != father[a]) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = a;</span><br><span class="line">            a = father[a];</span><br><span class="line">            father[z] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = edges.<span class="built_in">size</span>();</span><br><span class="line">        father.resize(N + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123; <span class="comment">// 初始化</span></span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123; <span class="comment">// 遍历边集合</span></span><br><span class="line">            <span class="keyword">int</span> res1 = findFather(edges[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> res2 = findFather(edges[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (res2 == res1) <span class="keyword">return</span> edges[i];</span><br><span class="line">            <span class="keyword">else</span> father[res1] = res2; <span class="comment">// 独立集合合并</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="个人解法（失败）"><a href="#个人解法（失败）" class="headerlink" title="个人解法（失败）"></a>个人解法（失败）</h3><p>hash表存储，在一条龙遍历。</p>
<p>当纯按字典序走的时候，会出现死胡同情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findItinerary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; ticket : tickets) &#123;</span><br><span class="line">            m[ticket[<span class="number">0</span>]].push_back(ticket[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : m) &#123;</span><br><span class="line">            sort(item.second.<span class="built_in">begin</span>(), item.second.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(<span class="string">"JFK"</span>);</span><br><span class="line">        <span class="built_in">string</span> cur = <span class="string">"JFK"</span>, nex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tickets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = m[cur].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m[cur].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">find</span>(m[cur][j]) != m.<span class="built_in">end</span>() || i == tickets.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                    nex = m[cur][j];</span><br><span class="line">                    ans.push_back(nex);</span><br><span class="line">                    m[cur].erase(it);</span><br><span class="line">                    cur = nex;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, priority_queue&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt;&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (vec.count(curr) &amp;&amp; vec[curr].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = vec[curr].top();</span><br><span class="line">            vec[curr].pop();</span><br><span class="line">            dfs(<span class="built_in">move</span>(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        stk.emplace_back(curr); <span class="comment">// 死胡同会先于活胡同入栈（死胡同必为最后一个节点）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findItinerary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : tickets) &#123;</span><br><span class="line">            vec[it[<span class="number">0</span>]].emplace(it[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">"JFK"</span>);</span><br><span class="line"></span><br><span class="line">        reverse(stk.<span class="built_in">begin</span>(), stk.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="喧闹和富有"><a href="#喧闹和富有" class="headerlink" title="喧闹和富有"></a>喧闹和富有</h2><p><a href="https://leetcode-cn.com/problems/loud-and-rich/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h3><p>dfs超时（这题不会记忆化，67/86个就超时了。。。）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; richerTable;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> poor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (richerTable[poor].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; richerTable[poor].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nexBig = richerTable[poor][i];</span><br><span class="line">            <span class="keyword">if</span> (nexBig &lt; root) &#123;</span><br><span class="line">                <span class="comment">// 如若下一个更大的已经计算出所有比它大的了，那就直接添加全部结点</span></span><br><span class="line">                <span class="keyword">if</span> (richerTable[nexBig].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; richerTable[nexBig].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    richerTable[root].push_back(richerTable[nexBig][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (richerTable[nexBig].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item : richerTable[nexBig]) &#123;</span><br><span class="line">                    richerTable[root].push_back(item);</span><br><span class="line">                    dfs(root, item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">loudAndRich</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = quiet.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        richerTable.assign(N, v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item : richer) &#123;</span><br><span class="line">            richerTable[item[<span class="number">1</span>]].push_back(item[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            dfs(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            richerTable[i].push_back(i); <span class="comment">// 添加自己</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = INT_MAX;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;rich : richerTable[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (quiet[rich] &lt; cur) &#123;</span><br><span class="line">                    cur = quiet[rich];</span><br><span class="line">                    ret = rich;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h3><p>参考wpn-zju的思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">loudAndRich</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(quiet.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec : richer)</span><br><span class="line">            graph[vec[<span class="number">1</span>]].push_back(vec[<span class="number">0</span>]);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(quiet.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            result[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; quiet.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            dfsFindRich(graph, quiet, result, i, i);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfsFindRich</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result, <span class="keyword">int</span> t, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*t为当前所求的结点，cur为当前与t比较的结点*/</span></span><br><span class="line">        <span class="keyword">if</span> (quiet[result[t]] &gt; quiet[cur])</span><br><span class="line">            result[t] = cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i : graph[cur]) &#123; <span class="comment">// 寻求当前比cur更rich的结点i</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; t) &#123; <span class="comment">// 如果i&lt;t，证明i已经得到了比他更小的结果result[i]，直接根据这个结果更新就好了</span></span><br><span class="line">                <span class="keyword">if</span> (quiet[result[t]] &gt; quiet[result[i]])</span><br><span class="line">                    result[t] = result[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则还得继续dfs</span></span><br><span class="line">                dfsFindRich(graph, quiet, result, t, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="使陆地分离的最少天数"><a href="#使陆地分离的最少天数" class="headerlink" title="使陆地分离的最少天数"></a>使陆地分离的最少天数</h2><p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的二维网格 <code>grid</code> ，其中 <code>0</code> 表示水，而 <code>1</code> 表示陆地。岛屿由水平方向或竖直方向上相邻的 <code>1</code> （陆地）连接形成。</p>
<p>如果 <strong>恰好只有一座岛屿</strong> ，则认为陆地是 <strong>连通的</strong> ；否则，陆地就是 <strong>分离的</strong> 。</p>
<p>一天内，可以将任何单个陆地单元（<code>1</code>）更改为水单元（<code>0</code>）。</p>
<p>返回使陆地分离的最少天数。</p>
<h3 id="个人解法（超时）-1"><a href="#个人解法（超时）-1" class="headerlink" title="个人解法（超时）"></a>个人解法（超时）</h3><p>dfs</p>
<ol>
<li>首先判断是否是多个岛屿，如果是，返回0.</li>
<li>否则判断是否答案为1<ul>
<li>逐一将1改为0，再全局dfs判断是否多个岛屿。如果是，直接返回1</li>
<li>否则返回2</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; vis, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        vis[r][c] = <span class="number">1</span>; <span class="comment">// 标记1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[k];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[k];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge &amp;&amp; grid[x][y] == <span class="number">1</span> &amp;&amp; vis[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(grid, vis, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123; <span class="comment">// 返回是否有多个岛屿</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">vis</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>))</span></span>; <span class="comment">// dfs遍历时的vis数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; vis[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    dfs(grid, vis, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (check(grid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (check(grid)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法优化"><a href="#解法优化" class="headerlink" title="解法优化"></a>解法优化</h3><p>直接修改原<code>grid</code>(注意传参不能传引用了)，空间复杂度优化到$O(1)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[k];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[k];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(grid, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; grid)</span> </span>&#123; <span class="comment">// 返回是否有多个岛屿</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (check(grid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (check(grid)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果想多次dfs同一个图，切记</p>
<p><strong>不能先将该结点标记，再dfs后修改回原值！！</strong>如果想多次dfs同一个原图的话就采用传引用的方式或者vis数组。</p>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="找到K个最接近的元素"><a href="#找到K个最接近的元素" class="headerlink" title="找到K个最接近的元素"></a>找到K个最接近的元素</h2><p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。</p>
<h3 id="个人解法-2"><a href="#个人解法-2" class="headerlink" title="个人解法"></a>个人解法</h3><p>二分+双指针，由于insert性能糟糕</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 二分找下限</span></span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[m] &lt; x) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[l] != x &amp;&amp; l &gt;= <span class="number">1</span>) &#123; <span class="comment">// l修正为离x最近的元素</span></span><br><span class="line">            <span class="keyword">int</span> r1 = <span class="built_in">abs</span>(arr[l] - x);</span><br><span class="line">            <span class="keyword">int</span> r2 = <span class="built_in">abs</span>(arr[l - <span class="number">1</span>] - x);</span><br><span class="line">            l = (r1 &lt; r2) ? l : l - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r = l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= n - <span class="number">1</span> &amp;&amp; ans.<span class="built_in">size</span>() &lt; k) &#123; <span class="comment">// 从最近元素向两侧延申找结果</span></span><br><span class="line">            <span class="keyword">int</span> r1 = <span class="built_in">abs</span>(arr[l] - x);</span><br><span class="line">            <span class="keyword">int</span> r2 = <span class="built_in">abs</span>(arr[r] - x);</span><br><span class="line">            <span class="keyword">if</span> (r1 &lt;= r2) &#123;</span><br><span class="line">                ans.insert(ans.<span class="built_in">begin</span>(), arr[l]);</span><br><span class="line">                --l;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(arr[r]);</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &lt; k) &#123; <span class="comment">// 如果找到的元素还不够k</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果左侧达到上限，右侧全部纳入结果</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                    ans.push_back(arr[r]);</span><br><span class="line">                    ++r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r &gt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                    ans.insert(ans.<span class="built_in">begin</span>(), arr[l]);</span><br><span class="line">                    --l;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法优化-1"><a href="#解法优化-1" class="headerlink" title="解法优化"></a>解法优化</h3><p>解一定是原数组的一个子区间，直接二分法找到区间的起始下标即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x - arr[mid] &gt; arr[mid + k] - x)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(arr.<span class="built_in">begin</span>() + left, arr.<span class="built_in">begin</span>() + k + left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h1><h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>

<p>思路：依次选定一个由[2, n]的区间<code>len</code>，由中间向两侧递推dp得到该区间下的子串数。</p>
<p><a href="https://leetcode-cn.com/problems/palindromic-substrings/solution/c-dpjie-fa-by-hou-yong-sheng/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> dp[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == s[i]) dp[i - <span class="number">1</span>][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; v : dp) &#123;</span><br><span class="line">            ans = accumulate(v, v + n, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>

<p>顺向dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n]; <span class="comment">// 以nums[i]为结尾的最长升序长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;t : dp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &gt; ans) ans = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="最长递增子序列的个数"><a href="#最长递增子序列的个数" class="headerlink" title="最长递增子序列的个数"></a>最长递增子序列的个数</h2><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<p>与上一题结合，设置cnt数组进行逐个计数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n], cnt[n]; <span class="comment">// cnt[i]表示该处最长递增子序列的个数</span></span><br><span class="line">        <span class="keyword">int</span> tmp[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123; <span class="comment">// 更新一次序列，cnt与更新位相等</span></span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        cnt[i] = cnt[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i]) &#123; <span class="comment">// 找到了新的组合，cnt加上更新位</span></span><br><span class="line">                        cnt[i] += cnt[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; mLen) mLen = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == mLen) ans += cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a>预测赢家</h2><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p>
<p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
<h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>用到了<strong>相对分数</strong>的概念。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> <span class="built_in">turn</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">turn</span> * nums[l];</span><br><span class="line">        <span class="keyword">int</span> s1 = nums[l] * <span class="built_in">turn</span> + getScore(nums, l + <span class="number">1</span>, r, -<span class="built_in">turn</span>);</span><br><span class="line">        <span class="keyword">int</span> s2 = nums[r] * <span class="built_in">turn</span> + getScore(nums, l, r - <span class="number">1</span>, -<span class="built_in">turn</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(s1 * <span class="built_in">turn</span>, s2 * <span class="built_in">turn</span>) * <span class="built_in">turn</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScore(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="dp-1"><a href="#dp-1" class="headerlink" title="dp"></a>dp</h3><p><a href="https://leetcode-cn.com/problems/predict-the-winner/solution/bo-yi-dpmo-ban-san-chong-dpsi-lu-you-hua-kong-jian/" target="_blank" rel="noopener">参考题解</a></p>
<h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<h3 id="递归（官方题解）"><a href="#递归（官方题解）" class="headerlink" title="递归（官方题解）"></a>递归（官方题解）</h3><p>这个<code>string()</code>函数挺好的，直接把一串字母转换成字符串了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> src; </span><br><span class="line">    <span class="keyword">size_t</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDigits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; src.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(src[ptr])) &#123;</span><br><span class="line">            ret = ret * <span class="number">10</span> + src[ptr++] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr == src.<span class="built_in">size</span>() || src[ptr] == <span class="string">']'</span>) &#123;</span><br><span class="line">            <span class="comment">// String -&gt; EPS</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> cur = src[ptr]; <span class="keyword">int</span> repTime = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(cur)) &#123;</span><br><span class="line">            <span class="comment">// String -&gt; Digits [ String ] String</span></span><br><span class="line">            <span class="comment">// 解析 Digits</span></span><br><span class="line">            repTime = getDigits(); </span><br><span class="line">            <span class="comment">// 过滤左括号</span></span><br><span class="line">            ++ptr;</span><br><span class="line">            <span class="comment">// 解析 String</span></span><br><span class="line">            <span class="built_in">string</span> str = getString(); </span><br><span class="line">            <span class="comment">// 过滤右括号</span></span><br><span class="line">            ++ptr;</span><br><span class="line">            <span class="comment">// 构造字符串</span></span><br><span class="line">            <span class="keyword">while</span> (repTime--) ret += str; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(cur)) &#123;</span><br><span class="line">            <span class="comment">// String -&gt; Char String</span></span><br><span class="line">            <span class="comment">// 解析 Char</span></span><br><span class="line">            ret = <span class="built_in">string</span>(<span class="number">1</span>, src[ptr++]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret + getString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        src = s; <span class="comment">// 拷贝一份s</span></span><br><span class="line">        ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//string ans = "";</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; data; <span class="comment">// 存放括号内的数据</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rep; <span class="comment">// 存放repeat次数</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> cur = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                value = value * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">                rep.push(value);</span><br><span class="line">                data.push(cur);</span><br><span class="line">                value = <span class="number">0</span>;</span><br><span class="line">                cur = <span class="string">""</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &lt;= <span class="string">'z'</span> &amp;&amp; s[i] &gt;= <span class="string">'a'</span> || s[i] &lt;= <span class="string">'Z'</span> &amp;&amp; s[i] &gt;= <span class="string">'A'</span>) &#123;</span><br><span class="line">                cur += s[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> repeat = rep.top(); rep.pop(); <span class="comment">// 重复次数弹栈</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; repeat; ++i) &#123; <span class="comment">// 重复repeat次</span></span><br><span class="line">                    data.top() += cur;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = data.top();</span><br><span class="line">                data.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>字符串模拟栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.empty() &amp;&amp; s.back() == c) &#123;</span><br><span class="line">                s.pop_back();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.push_back(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="链表中的下一个更大节点"><a href="#链表中的下一个更大节点" class="headerlink" title="链表中的下一个更大节点"></a>链表中的下一个更大节点</h2><p><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="个人解法-3"><a href="#个人解法-3" class="headerlink" title="个人解法"></a>个人解法</h3><p>拷贝成数组，然后用单调递减栈原理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head-&gt;next) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            v.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(len)</span></span>;</span><br><span class="line">        ans[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mstk; <span class="comment">// 单调递减栈</span></span><br><span class="line">        mstk.push(v[len - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (mstk.empty()) &#123;</span><br><span class="line">                mstk.push(v[i]);</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[i] &lt; mstk.top()) &#123;</span><br><span class="line">                ans[i] = mstk.top();</span><br><span class="line">                mstk.push(v[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[i] &gt;= mstk.top()) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!mstk.empty() &amp;&amp; v[i] &gt;= mstk.top()) &#123;</span><br><span class="line">                    mstk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i] = (mstk.empty()) ? <span class="number">0</span> : mstk.top();</span><br><span class="line">                mstk.push(v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; ans[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="相对名次"><a href="#相对名次" class="headerlink" title="相对名次"></a>相对名次</h2><p>给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（”Gold Medal”, “Silver Medal”, “Bronze Medal”）。</p>
<p>(注：分数越高的选手，排名越靠前。)</p>
<h3 id="个人解法-4"><a href="#个人解法-4" class="headerlink" title="个人解法"></a>个人解法</h3><p>排序+hash</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRelativeRanks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums_ = nums;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [] (<span class="keyword">const</span> <span class="keyword">int</span> &amp;n1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n2) &#123;<span class="keyword">return</span> n1 &gt; n2;&#125;);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            m[nums[i]] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; nums[i] &lt;&lt; " " &lt;&lt; m[nums[i]] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> rank = m[nums_[i]];</span><br><span class="line">            <span class="keyword">if</span> (rank &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                ans.push_back(to_string(rank));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">3</span>) &#123;</span><br><span class="line">                ans.push_back(<span class="string">"Bronze Medal"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">2</span>) &#123;</span><br><span class="line">                ans.push_back(<span class="string">"Silver Medal"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(<span class="string">"Gold Medal"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h3><p>map自动排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">3</span>) <span class="keyword">return</span> to_string(n);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"Gold Medal"</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"Silver Medal"</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="string">"Bronze Medal"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRelativeRanks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;it : m) &#123;</span><br><span class="line">            ans[it.second] = getString(n--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分割数组为连续子序列"><a href="#分割数组为连续子序列" class="headerlink" title="分割数组为连续子序列"></a>分割数组为连续子序列</h2><p>给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。</p>
<p>如果可以完成上述分割，则返回 true ；否则，返回 false 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">你可以分割出这样两个连续子序列 : </span><br><span class="line">1, 2, 3</span><br><span class="line">3, 4, 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,4,5]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/solution/tan-xin-suan-fa-jian-cha-shu-zu-neng-fou-bei-fen-w/" target="_blank" rel="noopener">参考题解</a></p>
<p>贪心</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tail, cnt; <span class="comment">// tail表示以该元素为序列尾的序列个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            cnt[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[num] == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 没出现的不管</span></span><br><span class="line">            <span class="keyword">if</span> (cnt[num] &gt; <span class="number">0</span> &amp;&amp; tail[num - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果当前cnt不为0，且存在以前一个元素为尾的序列</span></span><br><span class="line">                cnt[num]--;</span><br><span class="line">                tail[num]++;</span><br><span class="line">                tail[num - <span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[num] &gt; <span class="number">0</span> &amp;&amp; cnt[num + <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[num + <span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 组成三连序列，优先级低于上侧的if</span></span><br><span class="line">                cnt[num]--;</span><br><span class="line">                cnt[num + <span class="number">1</span>]--;</span><br><span class="line">                cnt[num + <span class="number">2</span>]--;</span><br><span class="line">                tail[num + <span class="number">2</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="24点游戏"><a href="#24点游戏" class="headerlink" title="24点游戏"></a>24点游戏</h2><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 <code>*</code>，<code>/</code>，<code>+</code>，<code>-</code>，<code>(</code>，<code>)</code> 的运算得到 24。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4, 1, 8, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: (8-4) * (7-1) &#x3D; 24</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 1, 2]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<p>除法运算符 <code>/</code> 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p><a href="https://leetcode-cn.com/problems/24-game/solution/24-dian-you-xi-by-leetcode-solution/" target="_blank" rel="noopener">参考官方题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> TARGET = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> EPSLON = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> ADD = <span class="number">0</span>, MULTIPLY = <span class="number">1</span>, SUBTRACT = <span class="number">2</span>, DIVIDE = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgePoint24</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">            v.emplace_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fabs</span>(v[<span class="number">0</span>] - TARGET) &lt; EPSLON;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) &#123; <span class="comment">// 挑选两操作数</span></span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; lis = <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">size</span>; ++k) &#123; <span class="comment">// 剩余的操作数</span></span><br><span class="line">                        <span class="keyword">if</span> (k != j &amp;&amp; k != i) &#123;</span><br><span class="line">                            lis.emplace_back(v[k]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123; <span class="comment">// 被选召的操作数进行运算</span></span><br><span class="line">                        <span class="keyword">if</span> (k &lt; <span class="number">2</span> &amp;&amp; i &gt; j) &#123; <span class="comment">// 加乘可以交换律</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (k == ADD) &#123;</span><br><span class="line">                            lis.emplace_back(v[i] + v[j]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == MULTIPLY) &#123;</span><br><span class="line">                            lis.emplace_back(v[i] * v[j]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == SUBTRACT) &#123;</span><br><span class="line">                            lis.emplace_back(v[i] - v[j]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == DIVIDE) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[j]) &lt; EPSLON) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>; <span class="comment">// 跳过除0运算</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            lis.emplace_back(v[i] / v[j]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (solve(lis)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        lis.pop_back(); <span class="comment">// 如果这样不能解决，弹出回溯</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="将数据流变为多个不相交区间"><a href="#将数据流变为多个不相交区间" class="headerlink" title="将数据流变为多个不相交区间"></a>将数据流变为多个不相交区间</h2><p><a href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummaryRanges</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; intervals;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    SummaryRanges() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">newItv</span><span class="params">(&#123;val, val&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = intervals.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (it != intervals.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newItv[<span class="number">1</span>] + <span class="number">1</span> &lt; (*it)[<span class="number">0</span>]) &#123;</span><br><span class="line">                intervals.insert(it, newItv);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*it)[<span class="number">1</span>] + <span class="number">1</span> &lt; newItv[<span class="number">0</span>]) &#123;</span><br><span class="line">                it++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newItv[<span class="number">0</span>] = <span class="built_in">min</span>((*it)[<span class="number">0</span>], newItv[<span class="number">0</span>]); <span class="comment">// 更新左</span></span><br><span class="line">                newItv[<span class="number">1</span>] = <span class="built_in">max</span>((*it)[<span class="number">1</span>], newItv[<span class="number">1</span>]); <span class="comment">// 更新右</span></span><br><span class="line">                it = intervals.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        intervals.push_back(newItv);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getIntervals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法2（类似203次周赛题III）"><a href="#法2（类似203次周赛题III）" class="headerlink" title="法2（类似203次周赛题III）"></a>法2（类似203次周赛题III）</h3><p>平衡树</p>
<p><a href="https://www.acwing.com/solution/content/373/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummaryRanges</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; l, r;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    SummaryRanges() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 判断新添加的元素是否已经在某个区间内了</span></span><br><span class="line">            <span class="keyword">auto</span> it = r.upper_bound(val);</span><br><span class="line">            <span class="keyword">if</span> (it != r.<span class="built_in">begin</span>()) &#123; </span><br><span class="line">                it--; <span class="comment">// it为小于等于r的元素最后一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (val &lt;= it-&gt;second) &#123;</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 已经存在于区间中直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = l.count(val - <span class="number">1</span>), right = r.count(val + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 分三种情况讨论</span></span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="comment">// 左右均存在区间，此时将区间合并</span></span><br><span class="line">            <span class="comment">// 左端点右指针指向右端点 右端点左指针指向左端点</span></span><br><span class="line">            r[l[val - <span class="number">1</span>]] = r[val + <span class="number">1</span>];</span><br><span class="line">            l[r[val + <span class="number">1</span>]] = l[val - <span class="number">1</span>];</span><br><span class="line">            l.erase(val - <span class="number">1</span>); r.erase(val + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left) &#123;</span><br><span class="line">            <span class="comment">// 左存在 右不存在</span></span><br><span class="line">            r[l[val - <span class="number">1</span>]] = val;</span><br><span class="line">            l[val] = l[val - <span class="number">1</span>];</span><br><span class="line">            l.erase(val - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right) &#123;</span><br><span class="line">            <span class="comment">// 右存在 左不存在</span></span><br><span class="line">            l[r[val + <span class="number">1</span>]] = val;</span><br><span class="line">            r[val] = r[val + <span class="number">1</span>];</span><br><span class="line">            r.erase(val + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左右均不存在</span></span><br><span class="line">            l[val] = val;</span><br><span class="line">            r[val] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getIntervals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; tmp : r) &#123;</span><br><span class="line">            res.push_back(&#123;tmp.first, tmp.second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="在LR字符串中交换相邻字符"><a href="#在LR字符串中交换相邻字符" class="headerlink" title="在LR字符串中交换相邻字符"></a>在LR字符串中交换相邻字符</h2><p>在一个由 <code>&#39;L&#39;</code> , <code>&#39;R&#39;</code> 和 <code>&#39;X&#39;</code> 三个字符组成的字符串（例如<code>&quot;RXXLRXRXL&quot;</code>）中进行移动操作。一次移动操作指用一个<code>&quot;LX&quot;</code>替换一个<code>&quot;XL&quot;</code>，或者用一个<code>&quot;XR&quot;</code>替换一个<code>&quot;RX&quot;</code>。现给定起始字符串<code>start</code>和结束字符串<code>end</code>，请编写代码，当且仅当存在一系列移动操作使得<code>start</code>可以转换成<code>end</code>时， 返回<code>True</code>。</p>
<h3 id="个人解法（失败）-1"><a href="#个人解法（失败）-1" class="headerlink" title="个人解法（失败）"></a>个人解法（失败）</h3><p>企图模拟过程，没有抓住主要矛盾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canTransform</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">string</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = start.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; j &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start[i] == <span class="built_in">end</span>[j]) &#123;</span><br><span class="line">                ++i; ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">end</span>[j] == <span class="string">'L'</span> &amp;&amp; start[i] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; len &amp;&amp; start[i] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                        ++i;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">end</span>[i] != <span class="string">'X'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; len &amp;&amp; start[i] == <span class="string">'L'</span>) &#123;</span><br><span class="line">                        j = i + <span class="number">1</span>;</span><br><span class="line">                        i = j;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span>[j] == <span class="string">'X'</span> &amp;&amp; start[i] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; len &amp;&amp; <span class="built_in">end</span>[j] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                        ++j;</span><br><span class="line">                        <span class="keyword">if</span> (start[j] != <span class="string">'X'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; len &amp;&amp; <span class="built_in">end</span>[j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                        i = j + <span class="number">1</span>;</span><br><span class="line">                        j = i;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="答案解法"><a href="#答案解法" class="headerlink" title="答案解法"></a>答案解法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路分析： 题目的意思是说 ‘R’只能向右移动，并且只能移向’X’，‘L’只能向左移动，并且只能移向’X’。</span><br><span class="line"></span><br><span class="line">第一：如果将start、end中的‘X’全部去掉得到的newStart 和 newEnd相等才有可能转换成功。</span><br><span class="line">第二：如果start中&#39;R&#39;的左边&#39;X&#39;的个数超过在end中对应位置的&#39;R&#39;的左边&#39;X&#39;的个数，则不能转换成功，因为start中的&#39;R&#39;只能向右移动，右边的&#39;X&#39;只能增加不能减少</span><br><span class="line">第三：如果end中&#39;L&#39;的左边&#39;X&#39;的个数超过在start中对应位置的&#39;L&#39;的左边&#39;X&#39;的个数，则不能转换成功，因为start中的&#39;L&#39;只能向左移动，左边的&#39;X&#39;只能减少不能增加</span><br></pre></td></tr></table></figure>

<p>原来只需考虑个数即可，将三种不满足的情况排除就是<code>true</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canTransform</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">string</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = start.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; j &lt; len) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len &amp;&amp; start[i] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len &amp;&amp; <span class="built_in">end</span>[j] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (start[i] != <span class="built_in">end</span>[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> ((start[i] == <span class="string">'L'</span> &amp;&amp; i &lt; j) || (<span class="built_in">end</span>[j] == <span class="string">'R'</span> &amp;&amp; i &gt; j)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ++i; </span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; i == <span class="string">'X'</span>) ++i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len &amp;&amp; j == <span class="string">'X'</span>) ++j;</span><br><span class="line">        <span class="keyword">if</span> (i != j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="合并账户"><a href="#合并账户" class="headerlink" title="合并账户"></a>合并账户</h2><p><a href="https://leetcode-cn.com/problems/accounts-merge/" target="_blank" rel="noopener">题目链接</a></p>
<p>并查集解法 <a href="https://leetcode-cn.com/problems/accounts-merge/solution/zhi-nan-shen-mei-de-cbing-cha-ji-shi-xian-fang-fa-/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father; <span class="comment">// key:name val:father</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; emFather; <span class="comment">// key:email val:father</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">            x = father[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = findFather(a), fb = findFather(b);</span><br><span class="line">        <span class="keyword">if</span> (fa != fb) &#123;</span><br><span class="line">            father[fa] = fb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">accountsMerge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> len = accounts.<span class="built_in">size</span>();</span><br><span class="line">        father.resize(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) father[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; accounts[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 逐行遍历accounts数据</span></span><br><span class="line">                <span class="keyword">if</span> (emFather.count(accounts[i][j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果之前还没遍历到这个email</span></span><br><span class="line">                    emFather[accounts[i][j]] = i; <span class="comment">// 将其father修改成第一个遇到的人名</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果之前遍历到过这个email，证明它的父亲已经出现过了，并查集合并两个父亲</span></span><br><span class="line">                    merge(i, emFather[accounts[i][j]]); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; nameToEm; <span class="comment">// key:name val:emails</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = findFather(i); <span class="comment">// 获取现在这个人名的真实父亲</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; accounts[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 遍历这个人名的所有email数据，将其加入到自带查重的hash表中</span></span><br><span class="line">                nameToEm[t].insert(accounts[i][j]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 遍历nameToEm，得到结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item : nameToEm) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">            v.push_back(accounts[item.first][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;em : item.second) &#123;</span><br><span class="line">                v.push_back(em);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="乘积为正数的最长子数组长度"><a href="#乘积为正数的最长子数组长度" class="headerlink" title="乘积为正数的最长子数组长度"></a>乘积为正数的最长子数组长度</h2><p>给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。</p>
<p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p>
<p>请你返回乘积为正数的最长子数组长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历一遍之后得到0的位置</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">// 指示正负数，默认为正</span></span><br><span class="line">        <span class="keyword">int</span> first_neg = <span class="number">-1</span>; <span class="comment">// 区间第一个负数下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) flag *= (<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果区间积为正，更新ans</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果区间积为负</span></span><br><span class="line">                    <span class="keyword">if</span> (first_neg &gt;= <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, i - first_neg);</span><br><span class="line">                    <span class="keyword">else</span> first_neg = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                first_neg = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="第k个排列"><a href="#第k个排列" class="headerlink" title="第k个排列"></a>第k个排列</h2><p>给出集合 <code>[1,2,3,…,*n*]</code>，其所有元素共有 <em>n</em>! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记。</p>
<p>给定n和k，返回第k个排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求n!</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ans *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> to_string(nums[<span class="number">0</span>]); <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">int</span> grLen = f(len - <span class="number">1</span>); <span class="comment">// 求组长度</span></span><br><span class="line">        <span class="keyword">int</span> gr = k / grLen + <span class="number">1</span>; <span class="comment">// 当前元素在第几组</span></span><br><span class="line">        <span class="keyword">if</span> (k % grLen == <span class="number">0</span>) gr--; <span class="comment">// 组末位修正</span></span><br><span class="line">        <span class="keyword">int</span> tmp = nums[gr - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>();</span><br><span class="line">        advance(it, gr - <span class="number">1</span>); </span><br><span class="line">        nums.erase(it);</span><br><span class="line">        <span class="keyword">int</span> nexOrder = k % grLen; <span class="comment">// 下一个相对位置</span></span><br><span class="line">        <span class="keyword">if</span> (!nexOrder) nexOrder = grLen;</span><br><span class="line">        <span class="keyword">return</span> to_string(tmp) + helper(nums, nexOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cur</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cur[i - <span class="number">1</span>] = i;</span><br><span class="line">        <span class="keyword">return</span> helper(cur, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记_1</title>
    <url>/2020/07/01/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>主要介绍python的第三方库Requests库的应用场景。</p>
<a id="more"></a>
<h3 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h3><p>requests是使用Apache2 licensed 许可证的HTTP库，用python编写，比urllib2模块更简洁。主要用于<strong>自动爬取HTML页面&amp;自动网络请求提交</strong>。Requests一般掌握<code>get()</code>和<code>head()</code>两个方法就足够使用。</p>
<p>请看Requests库的主要七个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.request()  <span class="comment">#构造一个请求，支撑以下各方法的基础方法</span></span><br><span class="line">requests.get()  <span class="comment"># 获取HTML网页的主要方法，对应于HTTP的GET</span></span><br><span class="line">requests.head()  <span class="comment"># 获取HTML网页头信息的方法，对应于HTTP的HEAD</span></span><br><span class="line">requests.post()  <span class="comment"># 向HTML网页提交POST请求的方法，对应于HTTP的POST</span></span><br><span class="line">requests.put()  <span class="comment"># 向HTML网页提交PUT请求的方法，对应于HTTP的PUT</span></span><br><span class="line">requstes.patch()  <span class="comment"># 向HTML网页提交局部修改请求，对应于HTTP的PATCH</span></span><br><span class="line">requests.delete()  <span class="comment">#向HTML页面提交删除请求，对应于HTTP的DELETE</span></span><br></pre></td></tr></table></figure>
<p>上图七种方法所对应的HTTP协议对资源的操作其实与Requests库的方法是一致的，不必深究。<br>值得一提的是，<code>patch()</code>相对于<code>put()</code>的好处就是，只用修改局部字段即可。</p>
<hr>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(url)</span><br><span class="line"><span class="comment"># r是爬虫返回的内容，称为Response对象</span></span><br></pre></td></tr></table></figure>

<p>Response对象具有很多有用的属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>r.status_code</code></td>
<td align="center">HTTP请求的返回状态，200表示成功</td>
</tr>
<tr>
<td align="center"><code>r.text</code></td>
<td align="center">HTTP响应内容的字符串形式–url对应的页面内容</td>
</tr>
<tr>
<td align="center"><code>r.encoding</code></td>
<td align="center">从HTTP header中猜测的响应内容编码方式</td>
</tr>
<tr>
<td align="center"><code>r.apparent_encoding</code></td>
<td align="center">从内容中分析出响应内容编码方式（备选内容编码方式）</td>
</tr>
<tr>
<td align="center"><code>r.content</code></td>
<td align="center">HTTP响应内容的二进制形式</td>
</tr>
<tr>
<td align="center"><code>r.raise_for_status()</code></td>
<td align="center">如果不是200，产生异常（类型为requests.HTTPError）</td>
</tr>
</tbody></table>
<p>基于以上介绍的Response对象的属性，利用try-except方法爬取页面的的通用代码的框架基本形成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout = <span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="head-方法"><a href="#head-方法" class="headerlink" title="head()方法"></a>head()方法</h4><p><code>head()</code>方法适合只访问头部信息的这种场景，此时调用<code>r.text</code>返回的内容为空：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://www.baidu.com"</span></span><br><span class="line">r = requests.head(url)</span><br><span class="line">print(r.headers)  <span class="comment"># 返回头部信息内容</span></span><br><span class="line">print(r.text)  <span class="comment"># 空</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="post-方法"><a href="#post-方法" class="headerlink" title="post()方法"></a>post()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/put'</span>,data = payload)</span><br><span class="line">print(r.text)</span><br><span class="line"><span class="comment"># 此时的r.text将是原内容加上payload的内容</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="request-方法"><a href="#request-方法" class="headerlink" title="request()方法"></a>request()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.request(method, url, **kwargs)</span><br><span class="line"><span class="comment"># method:请求方式，对应get,post...</span></span><br><span class="line"><span class="comment"># **kwargs:控制访问的参数，共13个</span></span><br></pre></td></tr></table></figure>
<p>以下是可选的参数（只列出9个）：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>params</code></td>
<td align="center">字典或字节序列，作为参数<strong>增加到url中</strong></td>
</tr>
<tr>
<td align="center"><code>data</code></td>
<td align="center">字典、字节序列或文件对象，作为<strong>Request的内容</strong></td>
</tr>
<tr>
<td align="center"><code>json</code></td>
<td align="center">JSON格式数据，作为<strong>Request的内容</strong></td>
</tr>
<tr>
<td align="center"><code>headers</code></td>
<td align="center">字典，HTTP定制头</td>
</tr>
<tr>
<td align="center"><code>cookies</code></td>
<td align="center">字典或CookieJar，Request中的cookie</td>
</tr>
<tr>
<td align="center"><code>auth</code></td>
<td align="center">元组，支持HTTP认证功能</td>
</tr>
<tr>
<td align="center"><code>files</code></td>
<td align="center">字典类型，传输文件</td>
</tr>
<tr>
<td align="center"><code>timeout</code></td>
<td align="center">设定超时时间，秒为单位</td>
</tr>
<tr>
<td align="center"><code>proxies</code></td>
<td align="center">字典类型，设定访问代理服务器，可增加登录认证</td>
</tr>
</tbody></table>
<hr>
<h4 id="爬虫实例"><a href="#爬虫实例" class="headerlink" title="爬虫实例"></a>爬虫实例</h4><h5 id="爬取亚马逊商品页面（更改用户代理）"><a href="#爬取亚马逊商品页面（更改用户代理）" class="headerlink" title="爬取亚马逊商品页面（更改用户代理）"></a>爬取亚马逊商品页面（更改用户代理）</h5><p><code>User-Agent</code>会告诉网站服务器，访问者是通过什么工具来请求的，如果是爬虫请求，一般会拒绝，如果是用户浏览器，就会应答。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://www.amazon.cn/gp/product/B01M8L5Z3Y"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">    r = requests.get(url, headers=kv)  <span class="comment"># 将User-Agent由python请求修改为用户请求</span></span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[<span class="number">1000</span>:<span class="number">2000</span>])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="百度搜索关键词提交"><a href="#百度搜索关键词提交" class="headerlink" title="百度搜索关键词提交"></a>百度搜索关键词提交</h5><p><em>注意：不同的搜索引擎关键词接口(wd)不一样</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">keyword = <span class="string">"Python"</span></span><br><span class="line">url = <span class="string">"https://www.baidu.com"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'Wd'</span>:keyword&#125;</span><br><span class="line">    r = requests.get(url, params = kv)</span><br><span class="line">    print(r.request.url)</span><br><span class="line">    <span class="comment"># 'https://www.baidu.com/s?wd=Python'</span></span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    print(len(r.text))</span><br><span class="line">    <span class="comment"># 302829</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="网络图片爬取"><a href="#网络图片爬取" class="headerlink" title="网络图片爬取"></a>网络图片爬取</h5><ul>
<li>os库用于判断路径是否存在</li>
<li>保存的文件名为网站源文件的名称</li>
<li>将图片以二进制的形式<code>r.content</code>写入<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://image.nationalgeographic.com.cn/2017/0211/20170211061910157.jpg"</span></span><br><span class="line">root = <span class="string">"D://pic//"</span></span><br><span class="line">path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">        os.mkdir(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">            f.close()</span><br><span class="line">            print(<span class="string">"文件保存成功"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"文件已存在"</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="IP地址查询代码"><a href="#IP地址查询代码" class="headerlink" title="IP地址查询代码"></a>IP地址查询代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://m.ip138.com/ip.asp?ip="</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url + <span class="string">'202.204.80.112'</span>)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[<span class="number">-500</span>:])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode日记IV</title>
    <url>/2020/08/03/Leetcode%E6%97%A5%E8%AE%B0IV/</url>
    <content><![CDATA[<p>Leetcode日记IV，淦！</p>
<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="推多米诺"><a href="#推多米诺" class="headerlink" title="推多米诺"></a>推多米诺</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = dominoes.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> dominoes; </span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (f &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[f] == <span class="string">'L'</span> &amp;&amp; s == <span class="number">0</span> &amp;&amp; dominoes[s] == <span class="string">'.'</span>) &#123; <span class="comment">// &lt;-</span></span><br><span class="line">                <span class="keyword">while</span> (s &lt; f) &#123;</span><br><span class="line">                    dominoes[s++] = <span class="string">'L'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[f] == <span class="string">'R'</span> &amp;&amp; dominoes[s] == <span class="string">'L'</span>) &#123; <span class="comment">// &lt;- -&gt;</span></span><br><span class="line">                s = f;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[f] == <span class="string">'L'</span> &amp;&amp; dominoes[s] == <span class="string">'R'</span>) &#123; <span class="comment">// -&gt; &lt;-</span></span><br><span class="line">                <span class="comment">// 左右指针向右挤压</span></span><br><span class="line">                <span class="keyword">int</span> l = s, r = f;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    dominoes[r--] = <span class="string">'L'</span>;</span><br><span class="line">                    dominoes[l++] = <span class="string">'R'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l == r) dominoes[l] = <span class="string">'.'</span>;</span><br><span class="line">                s = f;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == n - <span class="number">1</span> &amp;&amp; dominoes[s] == <span class="string">'R'</span> &amp;&amp; dominoes[f] == <span class="string">'.'</span>) &#123; <span class="comment">// -&gt;</span></span><br><span class="line">                <span class="keyword">while</span> (s &lt;= f) &#123;</span><br><span class="line">                    dominoes[s++] = <span class="string">'R'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[f] == <span class="string">'L'</span> &amp;&amp; dominoes[s] == <span class="string">'L'</span>) &#123; <span class="comment">// &lt;- &lt;-</span></span><br><span class="line">                <span class="keyword">while</span> (s &lt; f) &#123;</span><br><span class="line">                    dominoes[s++] = <span class="string">'L'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[f] == <span class="string">'R'</span> &amp;&amp; dominoes[s] == <span class="string">'R'</span>) &#123; <span class="comment">// -&gt; -&gt;</span></span><br><span class="line">                <span class="keyword">while</span> (s &lt; f) &#123;</span><br><span class="line">                    dominoes[s++] = <span class="string">'R'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[s] == <span class="string">'.'</span> &amp;&amp; dominoes[f] != <span class="string">'.'</span>) &#123; <span class="comment">// . .</span></span><br><span class="line">                s = f;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dominoes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<h4 id="暴力法-滑动窗口优化"><a href="#暴力法-滑动窗口优化" class="headerlink" title="暴力法+滑动窗口优化"></a>暴力法+滑动窗口优化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="前缀和-二分查找"><a href="#前缀和-二分查找" class="headerlink" title="前缀和+二分查找"></a>前缀和+二分查找</h4><p>只适用于元素全正的情况下！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 2 3 1 2 4 3</span></span><br><span class="line">        <span class="comment">// 2 5 6 8 12 15</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = s + sum[i - <span class="number">1</span>]; <span class="comment">// 获取当前在sum数组中的目标数</span></span><br><span class="line">            <span class="keyword">auto</span> bound = lower_bound(sum.<span class="built_in">begin</span>(), sum.<span class="built_in">end</span>(), target);</span><br><span class="line">            <span class="keyword">if</span> (bound != sum.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, ((<span class="keyword">int</span>)(bound - sum.<span class="built_in">begin</span>()) - i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == (n + <span class="number">1</span>) ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="双指针（滑动窗口）"><a href="#双指针（滑动窗口）" class="headerlink" title="双指针（滑动窗口）"></a>双指针（滑动窗口）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">end</span> &lt; n) &#123;</span><br><span class="line">            sum += nums[<span class="built_in">end</span>];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">end</span> - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">end</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><p>判断链表是否回文。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *f = head, *s = head, *pre = <span class="literal">nullptr</span>, *p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 完成前序反转和寻找中间结点</span></span><br><span class="line">        <span class="keyword">while</span> (f != <span class="literal">nullptr</span> &amp;&amp; f-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = s;</span><br><span class="line">            f = f-&gt;next-&gt;next;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line"></span><br><span class="line">            p-&gt;next = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 证明有奇数个节点</span></span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != s-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// dp[i]表示amount=i时的硬币组合数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; ++i) &#123;</span><br><span class="line">                dp[i] += dp[i - coin]; <span class="comment">// 每一步i的组合数等于其最后一步之前的dp值加上当前值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外还有记忆化搜索的方法，就不再多说。</p>
<h3 id="猜数字大小II"><a href="#猜数字大小II" class="headerlink" title="猜数字大小II"></a>猜数字大小II</h3><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/" target="_blank" rel="noopener">题目链接</a></p>
<p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/dong-tai-gui-hua-c-you-tu-jie-by-zhang-xiao-tong-2/" target="_blank" rel="noopener">参考题解</a>写的是真的好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j] = min(k + max(dp[i][k - 1] + dp[k + 1][j]), dp[i][j])</span></span><br><span class="line">        <span class="comment">// 计算顺序：由于每一个(i, j)需要矩阵中偏左和偏下的元素值，所以按固定列（从左向右）行按从下向上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= j - <span class="number">1</span>; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(k + <span class="built_in">max</span>(dp[i][k - <span class="number">1</span>], dp[k + <span class="number">1</span>][j]), dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], i + dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], j + dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最长公共子序列LCS"><a href="#最长公共子序列LCS" class="headerlink" title="最长公共子序列LCS"></a>最长公共子序列LCS</h3><p>对于给定的text1和text2，返回其最长公共子序列的长度。</p>
<h4 id="递归（超时）"><a href="#递归（超时）" class="headerlink" title="递归（超时）"></a>递归（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// recursive</span></span><br><span class="line">        <span class="keyword">int</span> n1 = text1.<span class="built_in">size</span>(), n2 = text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n1 || !n2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (text1[n1 - <span class="number">1</span>] == text2[n2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> longestCommonSubsequence(text1.substr(<span class="number">0</span>, n1 - <span class="number">1</span>), text2.substr(<span class="number">0</span>, n2 - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s1 = longestCommonSubsequence(text1.substr(<span class="number">0</span>, n1 - <span class="number">1</span>), text2);</span><br><span class="line">        <span class="keyword">int</span> s2 = longestCommonSubsequence(text1, text2.substr(<span class="number">0</span>, n2 - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="dp-1"><a href="#dp-1" class="headerlink" title="dp"></a>dp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">int</span> n1 = text1.<span class="built_in">size</span>(), n2 = text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n1 || !n2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n2 + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="comment">/*dp[i][j]表示text1[0,i]和text2[0,j]范围内的最小公公序列个数*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">o o o o -&gt; 1 o o o -&gt; 1 8 9 √</span><br><span class="line">o o o o -&gt; o 2 o o -&gt; o 2 6 7</span><br><span class="line">o o o o -&gt; o o 3 o -&gt; o o 3 5</span><br><span class="line">o o o o -&gt; o o o 4 -&gt; o o o 4</span><br></pre></td></tr></table></figure>

<p>计算顺序图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n][n]; <span class="comment">// i ~ j范围内的最长子序列</span></span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == s[i]) dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><h3 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h3><p><a href="https://leetcode-cn.com/problems/house-robber-iii/comments/" target="_blank" rel="noopener">题目链接</a></p>
<p>起初以为简单的层序遍历+dp（打家劫舍I）就能做出来，最后发现有特例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; valSet; <span class="comment">// 每层的金额总和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123; <span class="comment">// BFS获取每层的金额总和</span></span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123; <span class="comment">// 将本层的全部出队</span></span><br><span class="line">                <span class="keyword">auto</span> temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                res += temp-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left) q.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right) q.push(temp-&gt;right); </span><br><span class="line">            &#125;</span><br><span class="line">            valSet.push_back(res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 问题转换为在数组中寻找一群不相邻的节点使得和最大，同打家劫舍I</span></span><br><span class="line">        <span class="keyword">int</span> n = valSet.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> valSet[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> first = valSet[<span class="number">0</span>], second = <span class="built_in">max</span>(valSet[<span class="number">0</span>], valSet[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = <span class="built_in">max</span>(first + valSet[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改为dfs递归求解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 情况1：偷根节点</span></span><br><span class="line">        <span class="keyword">int</span> res1 = r-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;left) res1 += (dfs(r-&gt;left-&gt;left) + dfs(r-&gt;left-&gt;right));</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;right) res1 += (dfs(r-&gt;right-&gt;left) + dfs(r-&gt;right-&gt;right));</span><br><span class="line">        <span class="comment">// 情况2：不偷根节点</span></span><br><span class="line">        <span class="keyword">int</span> res2 = dfs(r-&gt;left) + dfs(r-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1, res2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>超时。<br>参考coderYQ在评论区的解法后，改成记忆化dfs，过了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 情况1：偷根节点</span></span><br><span class="line">        <span class="keyword">if</span> (m.count(r) != <span class="number">0</span>) <span class="keyword">return</span> m[r];</span><br><span class="line">        <span class="keyword">int</span> res1 = r-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;left) res1 += (dfs(r-&gt;left-&gt;left) + dfs(r-&gt;left-&gt;right));</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;right) res1 += (dfs(r-&gt;right-&gt;left) + dfs(r-&gt;right-&gt;right));</span><br><span class="line">        <span class="comment">// 情况2：不偷根节点</span></span><br><span class="line">        <span class="keyword">int</span> res2 = dfs(r-&gt;left) + dfs(r-&gt;right);</span><br><span class="line">        m[r] = <span class="built_in">max</span>(res1, res2);</span><br><span class="line">        <span class="keyword">return</span> m[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="求根到叶子节点数字之和"><a href="#求根到叶子节点数字之和" class="headerlink" title="求根到叶子节点数字之和"></a>求根到叶子节点数字之和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">输出：495 + 491 + 40 &#x3D; 1026</span><br></pre></td></tr></table></figure>

<p>法1<br>每次dfs自带该层value</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* r, <span class="keyword">int</span> value)</span> </span>&#123; <span class="comment">// value储存了当前节点的和</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            value = value * <span class="number">10</span> + r-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (r-&gt;left) dfs(r-&gt;left, value);</span><br><span class="line">            <span class="keyword">if</span> (r-&gt;right) dfs(r-&gt;right, value);</span><br><span class="line">            <span class="keyword">if</span> (!r-&gt;left &amp;&amp; !r-&gt;right) &#123; <span class="comment">// 如果当前节点为叶子节点，纳入结果</span></span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法2<br>每次dfs的value共享一个变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        value = value * <span class="number">10</span> + r-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!r-&gt;left &amp;&amp; !r-&gt;right) &#123;</span><br><span class="line">            ans += value;</span><br><span class="line">            value /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;left) dfs(r-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;right) dfs(r-&gt;right);</span><br><span class="line">        value /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h3><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n, m, <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; B, <span class="keyword">const</span> <span class="built_in">string</span>&amp; WORD)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="built_in">size</span>) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">            <span class="keyword">if</span> (notEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (B[x][y] == WORD[k] &amp;&amp; B[x][y] != <span class="string">'#'</span>) &#123;</span><br><span class="line">                    <span class="keyword">char</span> cur = B[x][y];</span><br><span class="line">                    B[x][y] = <span class="string">'#'</span>;</span><br><span class="line">                    dfs(x, y, k + <span class="number">1</span>, B, WORD);</span><br><span class="line">                    B[x][y] = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">size</span> = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="keyword">word</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">                    dfs(i, j, <span class="number">1</span>, board, <span class="keyword">word</span>);</span><br><span class="line">                    board[i][j] = <span class="keyword">word</span>[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (valid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="单词搜索II"><a href="#单词搜索II" class="headerlink" title="单词搜索II"></a>单词搜索II</h3><p>给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<h4 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h4><p><strong>trie树 + dfs</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    Trie* son[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span>(son));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;son[x]) node-&gt;son[x] = <span class="keyword">new</span> Trie();</span><br><span class="line">            node = node-&gt;son[x];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;flag++;</span><br><span class="line">        node-&gt;<span class="keyword">word</span> = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">// 网格的长宽</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">// words大小</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    Trie* tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vis; <span class="comment">// vis数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, Trie* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;flag) &#123;</span><br><span class="line">            ans.push_back(cur-&gt;<span class="keyword">word</span>);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; cur-&gt;word &lt;&lt; endl;</span></span><br><span class="line">            cur-&gt;flag--; <span class="comment">// 避免重复</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">            <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">            <span class="keyword">if</span> (notEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;son[data[x][y] - <span class="string">'a'</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "dfs " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">                dfs(x, y, cur-&gt;son[data[x][y] - <span class="string">'a'</span>]);</span><br><span class="line">                vis[x][y] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        len = words.<span class="built_in">size</span>();</span><br><span class="line">        data = board;</span><br><span class="line">        m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!len || !m) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 构建trie树</span></span><br><span class="line"></span><br><span class="line">        tree = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            tree-&gt;insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vis.assign(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dfs过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                Trie* cur = tree; <span class="comment">// 指向根节点</span></span><br><span class="line">                <span class="keyword">int</span> x = board[i][j] - <span class="string">'a'</span>; <span class="comment">// 获取字母</span></span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;son[x]) <span class="keyword">continue</span>; <span class="comment">// 如果字典树中不存在以该字母开头的路径，跳过</span></span><br><span class="line">                vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "dfs " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl &lt;&lt; endl;</span></span><br><span class="line">                dfs(i, j, cur-&gt;son[x]); <span class="comment">// 进行dfs过程</span></span><br><span class="line">                vis[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h4><p><strong>回溯剪枝 + trie树</strong><br>出自bond用户的评论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;     <span class="comment">//记录该node是否为某个单词的结尾字符</span></span><br><span class="line">    <span class="keyword">int</span> cnt;    <span class="comment">//记录有几个单词经过该node</span></span><br><span class="line">    node* children[<span class="number">26</span>];</span><br><span class="line">    node()&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        id = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="keyword">sizeof</span>(children));</span><br><span class="line">    &#125;</span><br><span class="line">    ~node()&#123;</span><br><span class="line">        <span class="keyword">for</span>(node* child : children)</span><br><span class="line">            <span class="keyword">delete</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, node* cur, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    node* child = cur-&gt;children[board[i][j]-<span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">if</span>(!child) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;    <span class="comment">//计算经过该node匹配到的单词数量</span></span><br><span class="line">    <span class="keyword">if</span>(child-&gt;id != <span class="number">-1</span>)&#123;</span><br><span class="line">        res.push_back(words[child-&gt;id]);</span><br><span class="line">        child-&gt;id = <span class="number">-1</span>;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">    board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = i + dirs[k][<span class="number">0</span>], y = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; board[x][y] != <span class="string">'#'</span>)&#123;</span><br><span class="line">            ans += backtrace(board, words, child, x, y, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    board[i][j] = c;</span><br><span class="line">    child-&gt;cnt -= ans;</span><br><span class="line">    <span class="keyword">if</span>(child-&gt;cnt == <span class="number">0</span>)&#123;  <span class="comment">//经过该节点的所有单词都匹配到了，回溯回来的路上将其删除</span></span><br><span class="line">        <span class="keyword">delete</span> child;</span><br><span class="line">        cur-&gt;children[board[i][j]-<span class="string">'a'</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    node* root = <span class="keyword">new</span> node();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        node* cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : words[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;children[c - <span class="string">'a'</span>]) cur-&gt;children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> node();</span><br><span class="line">            cur = cur-&gt;children[c - <span class="string">'a'</span>];</span><br><span class="line">            cur-&gt;cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            backtrace(board, words, root, i, j, res); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h3><p>二叉搜索树中的两个节点值被交换了，要求你在不改变原树的前提下恢复树木。</p>
<h4 id="个人解法-1"><a href="#个人解法-1" class="headerlink" title="个人解法"></a>个人解法</h4><p>中序遍历+前后指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个出现后边的小于前边的的前边的那个节点一定有问题</span></span><br><span class="line">        <span class="comment">// 第二个出现后边的小于前边的的后边的那个节点一定有问题 或者 s1的后续节点有问题</span></span><br><span class="line">        <span class="comment">// 小 大(3) 2 (1) 4 5</span></span><br><span class="line">        <span class="comment">// (5) 2 3 4 (1)</span></span><br><span class="line">        <span class="comment">// 大 小1 2 (4) 3 5</span></span><br><span class="line">        <span class="comment">// 小 小1 2 (5) 4 (3)</span></span><br><span class="line">        <span class="comment">// 1 (3) (2) 4 5 6</span></span><br><span class="line">        <span class="comment">// 1 2 (4) (3) 5 6</span></span><br><span class="line">        <span class="comment">// 1 2 (5) 4 (3) 6</span></span><br><span class="line">        <span class="comment">// 1 (5) 3 4 (2) 6</span></span><br><span class="line">        <span class="comment">// 1 (6) 3 4 5 (2)</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *s1, *s2, *temp;</span><br><span class="line">        <span class="keyword">int</span> past = INT_MIN, curr; <span class="comment">// 分别指向当前中序的前一个元素和后一个元素</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                curr = root-&gt;val; <span class="comment">// 获取当前元素的值</span></span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">0</span> &amp;&amp; curr &gt;= past) s1 = root; <span class="comment">// s1总是指向中序遍历中前驱元素</span></span><br><span class="line">                <span class="keyword">if</span> (curr &lt; past &amp;&amp; cnt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123; <span class="comment">// 如果是第一次出现这种情况</span></span><br><span class="line">                        <span class="comment">// s1指向前驱节点</span></span><br><span class="line">                        temp = root; <span class="comment">// temp保存当前的后驱备用</span></span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">                        s2 = root; <span class="comment">// s2指向后驱节点</span></span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">1</span> &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="comment">// 遍历完，且只找到s1</span></span><br><span class="line">                    s2 = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                past = curr; <span class="comment">// 滚动</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(s1-&gt;val, s2-&gt;val);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="官方题解优化"><a href="#官方题解优化" class="headerlink" title="官方题解优化"></a>官方题解优化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* x = <span class="literal">nullptr</span>; <span class="comment">// 第一个出错节点</span></span><br><span class="line">        TreeNode* y = <span class="literal">nullptr</span>; <span class="comment">// 第二个出错节点</span></span><br><span class="line">        TreeNode* pred = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pred-&gt;val) &#123;</span><br><span class="line">                <span class="comment">// 如果再出现前驱 &lt; 后驱，只需更新y即可</span></span><br><span class="line">                y = root; <span class="comment">// y指向当前节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果x还没赋值，则它为前驱且固定</span></span><br><span class="line">                    x = pred;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = root; <span class="comment">// pred永远指向当前中序序列节点的前驱</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(x-&gt;val, y-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<h4 id="贪心（思路出错）"><a href="#贪心（思路出错）" class="headerlink" title="贪心（思路出错）"></a>贪心（思路出错）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        sort(coins.<span class="built_in">begin</span>(), coins.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">int</span> n = coins.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;coin : coins) &#123;</span><br><span class="line">            <span class="keyword">while</span> (amount &gt;= coin) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                amount -= coin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (amount != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="递归（超时）-1"><a href="#递归（超时）-1" class="headerlink" title="递归（超时）"></a>递归（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            ans = <span class="built_in">min</span>(cur, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt;= coin)</span><br><span class="line">                helper(coins, amount - coin, cur + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        helper(coins, amount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (valid) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="记忆化搜索（自顶向下）"><a href="#记忆化搜索（自顶向下）" class="headerlink" title="记忆化搜索（自顶向下）"></a>记忆化搜索（自顶向下）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> amount)</span> </span>&#123; <span class="comment">// 返回amount对应的最小步数</span></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[amount] != <span class="number">0</span>) <span class="keyword">return</span> memo[amount];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;coin : coins) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; coin &lt;&lt; " " &lt;&lt; amount &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> res = helper(coins, amount - coin);</span><br><span class="line">            <span class="keyword">if</span> (amount &gt;= coin &amp;&amp; res != <span class="number">-1</span>) &#123;</span><br><span class="line">             </span><br><span class="line">                ans = <span class="built_in">min</span>(res + <span class="number">1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[amount] = (ans == INT_MAX) ? <span class="number">-1</span> : ans;</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        memo.resize(amount + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="dp（自底向上）"><a href="#dp（自底向上）" class="headerlink" title="dp（自底向上）"></a>dp（自底向上）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;coin : coins)</span><br><span class="line">                <span class="keyword">if</span> (i - coin &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i - coin] + <span class="number">1</span>, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="贪心思想-dfs"><a href="#贪心思想-dfs" class="headerlink" title="贪心思想+dfs"></a>贪心思想+dfs</h4><p><a href="https://leetcode-cn.com/problems/coin-change/solution/322-by-ikaruga/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> c_idx, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c_idx == coins.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = amount / coins[c_idx]; k &gt;= <span class="number">0</span> &amp;&amp; k + cnt &lt; ans; k--) &#123; <span class="comment">// k为贪心扔最大，最多能扔多少个</span></span><br><span class="line">            helper(coins, amount - k * coins[c_idx], c_idx + <span class="number">1</span>, cnt + k);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(coins.rbegin(), coins.rend()); <span class="comment">// 从大到小进行排列</span></span><br><span class="line">        helper(coins, amount, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (ans == INT_MAX) ? <span class="number">-1</span> : ans;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="只出现一次的数字II"><a href="#只出现一次的数字II" class="headerlink" title="只出现一次的数字II"></a>只出现一次的数字II</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了<strong>三次</strong>。找出那个只出现了一次的元素。</p>
<p><a href="https://leetcode-cn.com/problems/single-number-ii/solution/luo-ji-dian-lu-jiao-du-xiang-xi-fen-xi-gai-ti-si-l/" target="_blank" rel="noopener">参考题解1</a></p>
<p><a href="https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/" target="_blank" rel="noopener">参考题解2</a></p>
<h4 id="状态分析"><a href="#状态分析" class="headerlink" title="状态分析"></a>状态分析</h4><ul>
<li>根据题意，我们需要记录三种状态：0次，1次，2次。<strong>之后次数都是这三种状态的循环</strong>。</li>
<li>记录三个状态需要两位二进制，我们选定<strong>00，01，10分别代表0次1次2次</strong>。</li>
<li>新输入数字（每一位的二进制数）导致状态发生改变的映射方程为：<ul>
<li><code>i = 0</code>(即00)，状态不变</li>
<li><code>i = 1</code>(即01)，$00 \rarr 01, 01 \rarr 10,10 \rarr 00$</li>
</ul>
</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/0a7ea5bca055b095673620d8bb4c98ef6c610a22f999294ed11ae35d43621e93-Picture3.png" alt="Picture3.png"></p>
<p>u1s1，对于只有一位的二进制数我是看懂了，但是数组中的数基本都是多位二进制数，怎么证明每位二进制数分别进行这波位运算操作，最后组合得到的Y就是所求解呢。我写了一个例子，发现确实是这么回事。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例：[33,33,33,8,5,5,5]</span><br><span class="line">显然输出应当为8。</span><br><span class="line">将这些数按二进制数顺序排开，纵向来看，每一位的运算结果都是通过&quot;数数&quot;得来的，即每一位的我们也能看到最后答案就是每一位按照逻辑运算的简单叠加，获取的就是一个唯一的数。</span><br><span class="line">10010 -&gt;33</span><br><span class="line">10010 -&gt;33</span><br><span class="line">10010 -&gt;33</span><br><span class="line">01000 -&gt;8</span><br><span class="line">00110 -&gt;5</span><br><span class="line">00110 -&gt;5</span><br><span class="line">00110 -&gt;5</span><br><span class="line">每位出现0个数:</span><br><span class="line">46417</span><br><span class="line">每位出现1个数:</span><br><span class="line">31360</span><br><span class="line">保留非3的倍数的位:</span><br><span class="line">01000 ---&gt; 8</span><br></pre></td></tr></table></figure>

<h3 id="只出现一次的数字III"><a href="#只出现一次的数字III" class="headerlink" title="只出现一次的数字III"></a>只出现一次的数字III</h3><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitmask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            bitmask ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bitmask = i ^ j</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> diff = bitmask &amp; (-bitmask); <span class="comment">// diff保存最右边的1的权值（这个1只可能来自i或j）</span></span><br><span class="line">        <span class="comment">// i : 011 -&gt; 3</span></span><br><span class="line">        <span class="comment">// j : 101 -&gt; 5</span></span><br><span class="line">        <span class="comment">// b : 110 -&gt; 6</span></span><br><span class="line">        <span class="comment">// d : 010 -&gt; 2</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; diff) != <span class="number">0</span>) &#123; <span class="comment">// 只要num在diff位为0（那么它要么是i、j其中一个要么是剩余的数中的几个）</span></span><br><span class="line">                x ^= num; <span class="comment">// x经过异或运算筛选出i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;x, bitmask ^ x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="逻辑表达式推导"><a href="#逻辑表达式推导" class="headerlink" title="逻辑表达式推导"></a>逻辑表达式推导</h4><p>法1：卡诺图</p>
<p>法2：根据真值表列表达式后化简</p>
<p><img src="https://pic.leetcode-cn.com/f75d89219ad93c69757b187c64784b4c7a57dce7911884fe82f14073d654d32f-Picture4.png" alt="Picture4.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> X = <span class="number">0</span>, Y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> Z : nums) &#123;</span><br><span class="line">            Y = Y ^ Z &amp; ~X;</span><br><span class="line">            X = X ^ Z &amp; ~Y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数字范围按位与"><a href="#数字范围按位与" class="headerlink" title="数字范围按位与"></a>数字范围按位与</h3><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 某一位上的m~n全部相同则该位为1，否则0</span></span><br><span class="line">        <span class="comment">// 由于是一段区间的二进制数，只要有一个位全为1，那么它以后的位一定不全为1</span></span><br><span class="line">        <span class="comment">// 这体现在该位为其最靠左的位置</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// m和n同为1的最靠左位置</span></span><br><span class="line">        <span class="keyword">while</span> (m != n) &#123; <span class="comment">// </span></span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            cnt++; <span class="comment">// 右移操作的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="两整数之和"><a href="#两整数之和" class="headerlink" title="两整数之和"></a>两整数之和</h3><p>不能够使用<code>+</code>或<code>-</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> lower, carrier;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lower = a ^ b;</span><br><span class="line">            carrier = a &amp; b;</span><br><span class="line">            <span class="keyword">if</span> (carrier == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            a = lower;</span><br><span class="line">            <span class="comment">// 当测试用例含-1时，其左移会发生溢出(符号位截断)，所以要先转换成无符号数再左移</span></span><br><span class="line">            b = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(carrier) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lower;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_35661481/article/details/78991712" target="_blank" rel="noopener">溢出说明</a></p>
<h3 id="数字转换为16进制"><a href="#数字转换为16进制" class="headerlink" title="数字转换为16进制"></a>数字转换为16进制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> hex = <span class="string">"0123456789abcdef"</span>, ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &amp;&amp; ans.<span class="built_in">size</span>() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="comment">/*0xf = 00...01111*/</span></span><br><span class="line">            ans = hex[num &amp; <span class="number">0xf</span>] + ans; <span class="comment">// 获取其低4位并转换为16进制</span></span><br><span class="line">            num &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="计数二进制子串"><a href="#计数二进制子串" class="headerlink" title="计数二进制子串"></a>计数二进制子串</h3><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p>
<p>重复出现的子串要计算它们出现的次数。</p>
<h4 id="个人解法-2"><a href="#个人解法-2" class="headerlink" title="个人解法"></a>个人解法</h4><p>将0、1按连续分组。<br>比如”00111001”-&gt;[2,3,2,1]再进行计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curCnt, pasCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            curCnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; s[i] == s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                curCnt++; i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">min</span>(pasCnt, curCnt);</span><br><span class="line">            i++;</span><br><span class="line">            pasCnt = curCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h4><p>官方这种在遍历过程中不涉及<code>i - 1</code>和<code>i</code>的比对，而是用c保存<code>i - 1</code>的结果挺好的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>, n = s.<span class="built_in">size</span>(), last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[ptr];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (ptr &lt; n &amp;&amp; s[ptr] == c) &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">min</span>(count, last);</span><br><span class="line">            last = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最短回文串"><a href="#最短回文串" class="headerlink" title="最短回文串"></a>最短回文串</h3><p>给定一个字符串 <strong><em>s</em></strong>，你可以通过在字符串<strong>前面</strong>添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<p><a href="https://leetcode-cn.com/problems/shortest-palindrome/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--44/" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// if (n &lt;= 1) return s;</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// a b c d e c b e a</span></span><br><span class="line">        <span class="comment">// a e b c e (a b c d) e c b e a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> rev = s.substr(i, n);</span><br><span class="line">        reverse(rev.<span class="built_in">begin</span>(), rev.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// [0, i)之间的字符串保证里面存在最长回文串</span></span><br><span class="line">        <span class="keyword">return</span> rev + shortestPalindrome(s.substr(<span class="number">0</span>, i)) + s.substr(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h3><p>返回两个字符串相乘得到的字符串。</p>
<h4 id="个人解法-3"><a href="#个人解法-3" class="headerlink" title="个人解法"></a>个人解法</h4><p>模拟竖式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mulHelper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*返回一位数乘多位数字符串结果*/</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "在计算" &lt;&lt; s &lt;&lt; "*" &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = s[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "cur " &lt;&lt; cur &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> res = cur * c + carry; <span class="comment">// 当前位的计算结果加上carry</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "res " &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">string</span> lower = to_string(res % <span class="number">10</span>); <span class="comment">// 当前位应记下的值</span></span><br><span class="line">            ret.insert(<span class="number">0</span>, lower);</span><br><span class="line">            carry = res / <span class="number">10</span>; <span class="comment">// 当前的carry</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">            ret.insert(<span class="number">0</span>, to_string(carry)); <span class="comment">// 将carry补到前侧</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addHelper</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*返回两个字符串相加的字符串*/</span></span><br><span class="line">        <span class="keyword">int</span> n1 = s1.<span class="built_in">size</span>(), n2 = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "在计算" &lt;&lt; s1 &lt;&lt; "+" &lt;&lt; s2 &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">0</span>) <span class="keyword">return</span> s2;</span><br><span class="line">        <span class="keyword">if</span> (n2 == <span class="number">0</span>) <span class="keyword">return</span> s1;</span><br><span class="line">        <span class="keyword">int</span> i = n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = (s1[i] - <span class="string">'0'</span>) + (s2[j] - <span class="string">'0'</span>) + carry;</span><br><span class="line">            ret.insert(<span class="number">0</span>, to_string(cur % <span class="number">10</span>));</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            --i; --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "ret= " &lt;&lt; ret &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = (s1[i] - <span class="string">'0'</span>) + carry;</span><br><span class="line">            ret.insert(<span class="number">0</span>, to_string(cur % <span class="number">10</span>));</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = (s2[j] - <span class="string">'0'</span>) + carry;</span><br><span class="line">            ret.insert(<span class="number">0</span>, to_string(cur % <span class="number">10</span>));</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) ret.insert(<span class="number">0</span>, to_string(carry));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = num1.<span class="built_in">size</span>(), n2 = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span> (n1 &lt; n2) &#123;</span><br><span class="line">            swap(num1, num2);</span><br><span class="line">            swap(n2, n1);</span><br><span class="line">            <span class="comment">// 使位数偏多的数留在竖式的上侧简化乘法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*字符串一阶乘法*/</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = (num2[i] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="built_in">string</span> temp = mulHelper(num1, cur);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; ++j) &#123;</span><br><span class="line">                temp += <span class="string">"0"</span>; <span class="comment">// 后侧补0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "此次temp " &lt;&lt; temp;</span></span><br><span class="line">            res = addHelper(res, temp);</span><br><span class="line">            cnt++; <span class="comment">// cnt为当前后侧补0数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="官方优化"><a href="#官方优化" class="headerlink" title="官方优化"></a>官方优化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.<span class="built_in">size</span>(), n = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">            swap(m, n); swap(num1, num2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                curr.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> y = num2.at(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = num1.at(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> product = x * y + add;</span><br><span class="line">                curr.push_back(product % <span class="number">10</span>);</span><br><span class="line">                add = product / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (add != <span class="number">0</span>) &#123;</span><br><span class="line">                curr.push_back(add % <span class="number">10</span>);</span><br><span class="line">                add /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(curr.<span class="built_in">begin</span>(), curr.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : curr) &#123;</span><br><span class="line">                c += <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = addStrings(ans, curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> &amp;num1, <span class="built_in">string</span> &amp;num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>, j = num2.<span class="built_in">size</span>() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.at(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.at(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.push_back(result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c: ans) &#123;</span><br><span class="line">            c += <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="重复叠加字符串匹配"><a href="#重复叠加字符串匹配" class="headerlink" title="重复叠加字符串匹配"></a>重复叠加字符串匹配</h3><p>给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。</p>
<p>举个例子，A = “abcd”，B = “cdabcdab”。</p>
<p>答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”，此时 B 是其子串；A 重复叠加两遍后为”abcdabcd”，B 并不是其子串。</p>
<h4 id="个人解法-kmp"><a href="#个人解法-kmp" class="headerlink" title="个人解法(kmp)"></a>个人解法(kmp)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buildNext</span><span class="params">(<span class="built_in">string</span> &amp;T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> n = T.length(), j = <span class="number">0</span>; <span class="comment">// "主"串指针</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>; <span class="comment">// 模式串指针</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">0</span> || T[j] == T[t]) &#123;</span><br><span class="line">                <span class="comment">/*如果碰到了哨兵或是正确匹配*/</span></span><br><span class="line">                ++t; ++j;</span><br><span class="line">                next[j] = (T[j] == T[t]) ? next[t] : t; <span class="comment">// 防止以卵击石的"幼稚"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = next[t]; <span class="comment">// 赋值为next(相当于移动模式串)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;   	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> &amp;S, <span class="built_in">string</span> &amp;T, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 2 3 | 1 2 3</span></span><br><span class="line">        <span class="comment">// 0 1 2 | 0 1 2            </span></span><br><span class="line">        <span class="comment">// 0 1 2   3 4 5</span></span><br><span class="line">        <span class="comment">// 3 1 2 3</span></span><br><span class="line">        <span class="comment">// 2 - 3 &lt;= 9 - 4</span></span><br><span class="line">        <span class="comment">// -1 &lt;= 5</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; S &lt;&lt; " " &lt;&lt; T &lt;&lt; " " &lt;&lt; lim &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> n1 = S.length(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = T.length(), j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = lim;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span> || S[i] == T[j]) &#123;</span><br><span class="line">                ++i; ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == n1 &amp;&amp; lim &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                --lim;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + (<span class="built_in">size</span> - lim) * n1; <span class="comment">// 计算i的真实下标</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i - j &lt;= <span class="built_in">size</span> * n1 - n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n2 = B.<span class="built_in">size</span>(), j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = A.<span class="built_in">size</span>(), i = <span class="number">0</span>;</span><br><span class="line">        next = buildNext(B);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n1 * cnt &lt; n2) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="comment">// 算出&gt;=B.length()的最小长度A</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lim = n2 / n1 + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (!kmp(A, B, cnt)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; lim) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h4><p><a href="https://blog.csdn.net/qq_41855420/article/details/89459140" target="_blank" rel="noopener">参考题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> tempA = A;</span><br><span class="line">        <span class="comment">//cnt代表的A重复的次数,midRepCnt代表的B串中间A重复的次数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>, Asize = A.<span class="built_in">size</span>(), Bsize = B.<span class="built_in">size</span>(), midRepCnt = Bsize / Asize;</span><br><span class="line">        <span class="comment">//midRepCnt代表的B串中间A重复的次数,2是首位各添加一个A串</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= midRepCnt + <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tempA.<span class="built_in">find</span>(B) != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            tempA += A;<span class="comment">//重复次数自增</span></span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="数组中第k个最大元素"><a href="#数组中第k个最大元素" class="headerlink" title="数组中第k个最大元素"></a>数组中第k个最大元素</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>建堆 + 删除取栈顶</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low, j = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap[j] &gt; heap[i]) &#123;</span><br><span class="line">                swap(heap[i], heap[j]);</span><br><span class="line">                i = j;</span><br><span class="line">                j = i * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            downAdjust(i, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">        downAdjust(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据原序列建立堆，删除k - 1次的堆顶元素即为所求</span></span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.insert(nums.<span class="built_in">begin</span>(), <span class="number">-1</span>); <span class="comment">// 顶部插入占位元素</span></span><br><span class="line">        heap = nums;</span><br><span class="line">        createHeap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            deleteTop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<h4 id="个人解法-4"><a href="#个人解法-4" class="headerlink" title="个人解法"></a>个人解法</h4><p>滑动窗口维护最大值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;int, int&gt; getMax(vector&lt;int&gt;&amp; nums, int l, int r) &#123; // idx, val</span><br><span class="line">        <span class="keyword">int</span> mmax = INT_MIN, idx = l;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &gt; mmax) &#123;</span><br><span class="line">                idx = l;</span><br><span class="line">                mmax = nums[l];</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;idx, mmax&#125;;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最大值如果在滑动窗口之间，只需比较当前最大值和下一个进窗口的值</span></span><br><span class="line">        <span class="comment">// 如果最大值在最左侧，要记录其次大值，与下一个进窗口的值进行比较（直接调用最大值函数得了）</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums; <span class="comment">// 如果以1为区间，直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先获取第一个窗口的最大值</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> res = getMax(nums, l, r);</span><br><span class="line">        <span class="keyword">int</span> maxVal = res.second;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = res.first;</span><br><span class="line">        ans.push_back(maxVal);</span><br><span class="line">        <span class="keyword">if</span> (maxIdx == <span class="number">0</span> &amp;&amp; k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res = getMax(nums, l + <span class="number">1</span>, r);</span><br><span class="line">            maxIdx = res.first;</span><br><span class="line">            maxVal = res.second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - k; ++i) &#123;</span><br><span class="line">            <span class="comment">// i ~ k + i - 1</span></span><br><span class="line">            l = i, r = k + i - <span class="number">1</span>; <span class="comment">// 滑动窗口的左右边界</span></span><br><span class="line">            <span class="keyword">if</span> (nums[r] &gt; maxVal) &#123; <span class="comment">// 如果当前新纳入窗口的元素大于当前窗口的最大元素，更新最大值</span></span><br><span class="line">                maxIdx = r;</span><br><span class="line">                maxVal = nums[r];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(maxVal); <span class="comment">// 纳入结果数组</span></span><br><span class="line">            <span class="keyword">if</span> (maxIdx == l &amp;&amp; k &gt; <span class="number">1</span>) &#123; <span class="comment">// 如果当前最大元素位于最左边</span></span><br><span class="line">                res = getMax(nums, l + <span class="number">1</span>, r); <span class="comment">// 获取当前窗口除了左边界元素的最大值，并更新idx和val</span></span><br><span class="line">                maxVal = res.second;</span><br><span class="line">                maxIdx = res.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="其他解法-1"><a href="#其他解法-1" class="headerlink" title="其他解法"></a>其他解法</h4><p>双端队列<br>出自用户icloud</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; window;   <span class="comment">//双端队列，从队头到队尾 依次存 窗口内最大元素的index ~ 最小元素的index</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;   <span class="comment">//后续，窗口每右移一次，都会产生一个最大值[队列头位置的元素]</span></span><br><span class="line">            <span class="keyword">if</span>(!window.empty() &amp;&amp; window.front() &lt;= right - k)&#123;   <span class="comment">//队头不在窗口范围内</span></span><br><span class="line">                window.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!window.empty() &amp;&amp; nums[right] &gt; nums[window.back()])&#123;   <span class="comment">//待入队元素比队尾元素大</span></span><br><span class="line">                window.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            window.push_back(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(right &gt;= k) res.push_back(nums[window.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二进制矩阵中的最短路径"><a href="#二进制矩阵中的最短路径" class="headerlink" title="二进制矩阵中的最短路径"></a>二进制矩阵中的最短路径</h3><p><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">题目链接</a></p>
<p>图论BFS模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span> || grid[n - <span class="number">1</span>][n - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> r = tmp.first;</span><br><span class="line">                <span class="keyword">int</span> c = tmp.second;</span><br><span class="line">                <span class="keyword">if</span> (r == n - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = r + dx[i];</span><br><span class="line">                    <span class="keyword">int</span> y = c + dy[i];</span><br><span class="line">                    <span class="keyword">bool</span> notEdge = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">                    <span class="keyword">if</span> (notEdge) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                            q.push(&#123;x, y&#125;);</span><br><span class="line">                            grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">step</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记_2</title>
    <url>/2020/07/03/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>主要介绍python的第三方库BS4库的应用场景。</p>
<a id="more"></a>
<h3 id="BS4库"><a href="#BS4库" class="headerlink" title="BS4库"></a>BS4库</h3><p>BS4库主要用于<strong>HTML页面的解析</strong>。是解析、遍历、维护“标签树”的功能库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">demo = requests.get(url).text</span><br><span class="line">soup = BeautifulSoup(demo, <span class="string">"html.parser"</span>)</span><br></pre></td></tr></table></figure>
<p><code>soup</code>便承载了解析后的<code>标签树</code>。</p>
<table>
<thead>
<tr>
<th align="center">基本元素</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Tag</td>
<td align="center">标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾</td>
</tr>
<tr>
<td align="center">Name</td>
<td align="center">标签的名字，格式：<code>&lt;tag&gt;.name</code></td>
</tr>
<tr>
<td align="center">Attributes</td>
<td align="center">标签的属性，字典形式组织，格式：<code>&lt;tag&gt;.attrs</code></td>
</tr>
<tr>
<td align="center">NavigableString</td>
<td align="center">标签内非属性字符串，格式：<code>&lt;tag&gt;.string</code></td>
</tr>
<tr>
<td align="center">Comment</td>
<td align="center">标签内字符串的注释部分，一种特殊的Comment类型</td>
</tr>
</tbody></table>
<h4 id="标签树的遍历"><a href="#标签树的遍历" class="headerlink" title="标签树的遍历"></a>标签树的遍历</h4><h5 id="下行遍历"><a href="#下行遍历" class="headerlink" title="下行遍历"></a>下行遍历</h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.contents</code></td>
<td align="center">子节点的列表，将<code>&lt;tag&gt;</code>所有儿子节点存入列表</td>
</tr>
<tr>
<td align="center"><code>.children</code></td>
<td align="center">子节点的迭代类型，与<code>contents</code>类似，用于循环遍历儿子节点</td>
</tr>
<tr>
<td align="center"><code>.descendants</code></td>
<td align="center">子孙节点的迭代类型，包含所有子孙节点</td>
</tr>
</tbody></table>
<p>迭代类型的下行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> demoSoup.body.children: <span class="comment"># descendants是子孙结点</span></span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure>

<h5 id="上行遍历"><a href="#上行遍历" class="headerlink" title="上行遍历"></a>上行遍历</h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.parent</code></td>
<td align="center">节点的父亲标签</td>
</tr>
<tr>
<td align="center"><code>.parents</code></td>
<td align="center">节点先辈标签的迭代类型，用于循环遍历先辈节点</td>
</tr>
</tbody></table>
<p>迭代类型的上行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> demoSoup.a.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(parent.name)</span><br></pre></td></tr></table></figure>

<h5 id="平行遍历"><a href="#平行遍历" class="headerlink" title="平行遍历"></a>平行遍历</h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.next_sibling</code></td>
<td align="center">返回按照HTML文本顺序的下一个平行节点标签</td>
</tr>
<tr>
<td align="center"><code>.previous_sibling</code></td>
<td align="center">返回按照HTML文本顺序的上一个平行节点标签</td>
</tr>
<tr>
<td align="center"><code>.next_siblings</code></td>
<td align="center">迭代类型，返回按照HTML文本顺序的后续所有平行节点标签</td>
</tr>
<tr>
<td align="center"><code>.previous_siblings</code></td>
<td align="center">迭代类型，返回按照HTML文本顺序的前续所有平行节点标签</td>
</tr>
</tbody></table>
<p>迭代类型的上行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> demoSoup.a.next_siblings:  <span class="comment"># or previous_siblings</span></span><br><span class="line">    print(sibling)</span><br></pre></td></tr></table></figure>

<h4 id="美化标签"><a href="#美化标签" class="headerlink" title="美化标签"></a>美化标签</h4><p><code>soup.prettify()</code></p>
<h4 id="信息提取方法"><a href="#信息提取方法" class="headerlink" title="信息提取方法"></a>信息提取方法</h4><p>信息标记的三种形式XML,JSON和YAML<br><code>.find_all</code>方法，返回一个列表类型，存储查找的结果。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>name</code></td>
<td align="center">对标签名称的检索字符串</td>
</tr>
<tr>
<td align="center"><code>attrs</code></td>
<td align="center">对标签属性值的检索字符串，可标注属性检索</td>
</tr>
<tr>
<td align="center"><code>recursive</code></td>
<td align="center">是否对子孙全部检索，默认True</td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td align="center">&lt;&gt;…&lt;/&gt;中字符串区域的检索字符串</td>
</tr>
</tbody></table>
<h3 id="实例：全球大学学术排名"><a href="#实例：全球大学学术排名" class="headerlink" title="实例：全球大学学术排名"></a>实例：全球大学学术排名</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"爬取失败"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):  <span class="comment"># Tag是bs4定义的标签类型</span></span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">4</span>].string])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt1 = <span class="string">"&#123;0:^10&#125;\t&#123;1:^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    tplt2 = <span class="string">"&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(<span class="string">"全球大学学术排名情况\n"</span>)</span><br><span class="line">    ls = [<span class="string">"排名"</span>,<span class="string">"学校名称"</span>,<span class="string">"得分"</span>]</span><br><span class="line">    print(tplt1.format(ls[<span class="number">0</span>], ls[<span class="number">1</span>], ls[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(tplt2.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">"http://www.zuihaodaxue.cn/ARWU2019.html"</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>涉及知识点：</p>
<ul>
<li>下行遍历<ol>
<li>遍历tsbody中的tr，并依次输出每个tr下的td</li>
<li>遍历时不只有td这样的标签，还会有像<code>navigablestring</code>..所以要先check是否是bs4定义的标签类型</li>
</ol>
</li>
<li>中文对齐–char(12288)来控制中文对齐</li>
</ul>
]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>上机模板</title>
    <url>/2020/07/13/%E4%B8%8A%E6%9C%BA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>上机必掌握模板！</p>
<a id="more"></a>

<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="二维数组空间申请-C语言"><a href="#二维数组空间申请-C语言" class="headerlink" title="二维数组空间申请(C语言)"></a>二维数组空间申请(C语言)</h4><h5 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h5><ul>
<li>适用于每行元素数不同的情况。</li>
<li>同一行中元素地址是连续的，不同行中元素地址不一定是连续的。</li>
<li>释放空间时，每行都需<code>free(p[i])</code>，最后要<code>free(p)</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> **p = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *) * arrSize);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrSize; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * colSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h5><ul>
<li>整个数组地址都是连续的。</li>
<li>不适用于每行元素数量不同的情况<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(*p)[colSize] = (<span class="keyword">int</span>(*)[colSize])<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * arrSize * colSize);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="一维数组模拟二维数组"><a href="#一维数组模拟二维数组" class="headerlink" title="一维数组模拟二维数组"></a>一维数组模拟二维数组</h5><h4 id="二维数组空间申请-C"><a href="#二维数组空间申请-C" class="headerlink" title="二维数组空间申请(C++)"></a>二维数组空间申请(C++)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请空间为n*n的数组，并将其初始化为全0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, n));</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><hr>
<h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><h4 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> revx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        revx *= <span class="number">10</span>;</span><br><span class="line">        revx += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> revx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h4><p>含哑结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">reverseHead</span><span class="params">(struct ListNode* dummyhead)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">r</span> = <span class="title">dummyhead</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// 保存头结点以后信息</span></span><br><span class="line">    dummyhead-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头结点独立</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">curr</span> = <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">t</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// 保存当前结点后所有信息</span></span><br><span class="line">        curr-&gt;next = prev; <span class="comment">// curr结点的下一个为prev</span></span><br><span class="line">        prev = curr; <span class="comment">// prev更新为curr（前移一位）</span></span><br><span class="line">        curr = t; <span class="comment">// 当前结点更新为当前结点原来的后面信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head = prev; <span class="comment">// 此时prev为头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不含哑结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">reverseArray</span><span class="params">(<span class="keyword">int</span> *arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (arr.length + <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">// 求中位数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++) &#123;  <span class="comment">// 遍历[0:mid]</span></span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span> - i;  <span class="comment">// 求出下半部分交换数的索引</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><h4 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> &amp;num1, <span class="built_in">string</span> &amp;num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>, j = num2.<span class="built_in">size</span>() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.at(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.at(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">        ans.push_back(result % <span class="number">10</span>); <span class="comment">// 先将其压入整数</span></span><br><span class="line">        add = result / <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c: ans) &#123;</span><br><span class="line">        c += <span class="string">'0'</span>; <span class="comment">// 再转换成对应的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈-链表-相加"><a href="#栈-链表-相加" class="headerlink" title="栈(链表)相加"></a>栈(链表)相加</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addStack</span><span class="params">(<span class="built_in">stack</span> s1, <span class="built_in">stack</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s1.empty() || !s2.empty() || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = s1.empty() ? <span class="number">0</span> : s1.top();</span><br><span class="line">        <span class="keyword">int</span> b = s2.empty() ? <span class="number">0</span> : s2.top();</span><br><span class="line">        <span class="keyword">if</span> (!s1.empty()) s1.pop();</span><br><span class="line">        <span class="keyword">if</span> (!s2.empty()) s2.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = a + b + carry;</span><br><span class="line">        <span class="keyword">auto</span> temp = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        temp-&gt;next = dummyHead-&gt;next;</span><br><span class="line">        dummyHead-&gt;next = temp;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>应试</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目cJson</title>
    <url>/2020/09/07/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEcJson/</url>
    <content><![CDATA[<p>cJson是一个可以自动整理Json格式文件的脚本。</p>
<a id="more"></a>

<h1 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h1><ul>
<li>cJSON.c</li>
<li>cJSON.h</li>
<li>test.c</li>
</ul>
<h2 id="cJSON-h"><a href="#cJSON-h" class="headerlink" title="cJSON.h"></a>cJSON.h</h2><p>定义了9个宏，表示JSON格式中的全部7个数据类型加上两个额外项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_False 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_True 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_NULL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_Number 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_String 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_Array 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_Object 6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_IsReference 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cJSON_StringIsConst 512</span></span><br></pre></td></tr></table></figure>

<p>声明了JSON格式的数据结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*cJSON格式的数据结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> type; <span class="comment">// 对应上面的宏定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *valuestring;</span><br><span class="line">    <span class="keyword">int</span> valueint;</span><br><span class="line">    <span class="keyword">double</span> valuedouble;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">string</span>; <span class="comment">// 对象的名称字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON_Hooks</span> &#123;</span></span><br><span class="line">	<span class="comment">/*malloc_fn是一个函数指针，它所指向的函数有一个size_t类型的参数，返回一个void类型的指针*/</span></span><br><span class="line">    <span class="keyword">void</span> *(*malloc_fn)(<span class="keyword">size_t</span> sz);</span><br><span class="line">    <span class="comment">/*free_fn是一个函数指针，它所指向的函数具有一个void*类型的指针参数，无返回值*/</span></span><br><span class="line">    <span class="keyword">void</span> (*free_fn)(<span class="keyword">void</span> *ptr);</span><br><span class="line">&#125; cJSON_Hooks;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫笔记-3</title>
    <url>/2020/07/05/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<p>主要介绍re库和相关实例。</p>
<a id="more"></a>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="正则表达式的概述"><a href="#正则表达式的概述" class="headerlink" title="正则表达式的概述"></a>正则表达式的概述</h4><p>正则表达式是用来<strong>简洁</strong>表达一组字符串的表达式。</p>
<p>正则表达式的使用：通过编译，将符合正则表达式语法的字符串转换成正则表达式特征。</p>
<h4 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h4><p>语法表</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.</code></td>
<td align="center">表示任何单个字符</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center"><code>[]</code></td>
<td align="center">字符集，对单个字符给出取值范围</td>
<td align="center">[abc]/[a-z]</td>
</tr>
<tr>
<td align="center"><code>[^]</code></td>
<td align="center">非字符集，对单个字符给出排除范围</td>
<td align="center">[^abc]表示非a非b非c的单个字符</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">前一个字符0次或无限次扩展</td>
<td align="center">abc*-&gt;ab、abc、abcc……</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center">前一个字符1次或无限次扩展</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center"><code>?</code></td>
<td align="center">前一个字符0次或1次扩展</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center">`</td>
<td align="center">左右表达式任意一个</td>
</tr>
<tr>
<td align="center"><code>{m}</code></td>
<td align="center">扩展前一个字符m次</td>
<td align="center">ab{2}c-&gt;abbc</td>
</tr>
<tr>
<td align="center"><code>{m,n}</code></td>
<td align="center">扩展前一个字符m至n次(含n)</td>
<td align="center">ab{1,2}c-&gt;abc、abbc</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">匹配字符串开头</td>
<td align="center">^abc表示abc且在一个字符串的开头</td>
</tr>
<tr>
<td align="center"><code>$</code></td>
<td align="center">匹配字符串结尾</td>
<td align="center">abc$表示abc且在一个字符串的结尾</td>
</tr>
<tr>
<td align="center"><code>()</code></td>
<td align="center">分组标记，内部只能用`</td>
<td align="center">`</td>
</tr>
<tr>
<td align="center"><code>\d</code></td>
<td align="center">数字，等价于[0-9]</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center"><code>\w</code></td>
<td align="center">单词字符，等价于[A-Za-z0-9_]</td>
<td align="center">略</td>
</tr>
</tbody></table>
<p>经典正则表达式实例：<br>|表达式|意义|<br>|:–:|:–:|<br>|<code>^[A-Za-z]+$</code>|26个字母组成的字符串|<br>|<code>^-?\d+$</code>|整数形式的字符串|<br>|<code>^[0-9]*[1-9][0-9]*$</code>|正整数形式字符串|<br>|<code>[1-9]\d{5}</code>|中国境内邮政编码，6位|<br>|<code>[\u4e00-\u9fa5]</code>|匹配中文字符|<br>|<code>\d{3}-\d{8}|\d{4}-\d{7}</code>|国内电话号码|<br>|<code>[1-9]?\d</code>|0-99|<br>|<code>1\d{2}</code>|100-199|</p>
<p>表示0-255：<br><code>([1‐9]?\d | 1\d{2} | 2[0‐4]\d | 25[0‐5])</code></p>
<p>表示IP地址：<br><code>(([1‐9]?\d|1\d{2}|2[0‐4]\d|25[0‐5]).){3}([1‐9]?\d|1\d{2}|2[0‐4]\d|25[0‐5])</code></p>
<h3 id="re库"><a href="#re库" class="headerlink" title="re库"></a>re库</h3><p>正则表达式的表示类型：<br><strong>raw string</strong>类型：<code>r&#39;text&#39;</code>–不包含转义符的类型</p>
<h4 id="re库主要功能函数"><a href="#re库主要功能函数" class="headerlink" title="re库主要功能函数"></a>re库主要功能函数</h4><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>re.search()</code></td>
<td align="center">在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象</td>
</tr>
<tr>
<td align="center"><code>re.match()</code></td>
<td align="center">从一个字符串的开始位置起匹配正则表达式，返回match对象</td>
</tr>
<tr>
<td align="center"><code>re.findall()</code></td>
<td align="center">搜索字符串，以列表类型返回全部能匹配的子串</td>
</tr>
<tr>
<td align="center"><code>re.split()</code></td>
<td align="center">将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td>
</tr>
<tr>
<td align="center"><code>re.finditer()</code></td>
<td align="center">搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象</td>
</tr>
<tr>
<td align="center"><code>re.sub()</code></td>
<td align="center">在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">常用标记</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>re.I</code></td>
<td align="center">忽略正则表达式的大小写，<code>[A‐Z]</code>能够匹配小写字符</td>
</tr>
<tr>
<td align="center"><code>re.M</code></td>
<td align="center">正则表达式中的<code>^</code>操作符能够将给定字符串的每行当作匹配开始</td>
</tr>
<tr>
<td align="center"><code>re.S</code></td>
<td align="center">正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符</td>
</tr>
</tbody></table>
<h4 id="re库面向对象用法"><a href="#re库面向对象用法" class="headerlink" title="re库面向对象用法"></a>re库面向对象用法</h4><p>一次编译后，可以多次使用该正则表达式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pat = re.compile(<span class="string">r'[1-9]\d&#123;5&#125;'</span>)</span><br><span class="line">rst = pat.research(<span class="string">'BIT 100081'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="match对象"><a href="#match对象" class="headerlink" title="match对象"></a>match对象</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.string</code></td>
<td align="center">带匹配的文本</td>
</tr>
<tr>
<td align="center"><code>.re</code></td>
<td align="center">匹配时使用的patter对象（正则表达式）</td>
</tr>
<tr>
<td align="center"><code>.pos</code></td>
<td align="center">正则表达式搜索文本的开始位置</td>
</tr>
<tr>
<td align="center"><code>.endpos</code></td>
<td align="center">正则表达式搜索文本的结束位置</td>
</tr>
<tr>
<td align="center"><code>.group(0)</code></td>
<td align="center">获得匹配后的字符串</td>
</tr>
<tr>
<td align="center"><code>.start()</code></td>
<td align="center">匹配字符串在原始字符串的开始位置</td>
</tr>
<tr>
<td align="center"><code>.end()</code></td>
<td align="center">匹配字符串在原始字符串的结束位置</td>
</tr>
<tr>
<td align="center"><code>.span()</code></td>
<td align="center">返回(<code>.start()</code>,<code>.end()</code>)</td>
</tr>
</tbody></table>
<h4 id="贪婪匹配和最小匹配"><a href="#贪婪匹配和最小匹配" class="headerlink" title="贪婪匹配和最小匹配"></a>贪婪匹配和最小匹配</h4><p>Re库默认采用贪婪匹配，即输出匹配最长的子串。<br>最小匹配需要引入最小匹配操作符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>*?</code></td>
<td align="center">最小的..</td>
</tr>
<tr>
<td align="center"><code>+?</code></td>
<td align="center">最小的..</td>
</tr>
<tr>
<td align="center"><code>??</code></td>
<td align="center">最小的..</td>
</tr>
<tr>
<td align="center"><code>{m,n}?</code></td>
<td align="center">最小的..</td>
</tr>
</tbody></table>
<h3 id="实例：淘宝商品比价定向爬取"><a href="#实例：淘宝商品比价定向爬取" class="headerlink" title="实例：淘宝商品比价定向爬取"></a>实例：淘宝商品比价定向爬取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        header = &#123;</span><br><span class="line">            <span class="string">'authority'</span>: <span class="string">'s.taobao.com'</span>,</span><br><span class="line">            <span class="string">'cache-control'</span>: <span class="string">'max-age=0'</span>,</span><br><span class="line">            <span class="string">'upgrade-insecure-requests'</span>: <span class="string">'1'</span>,</span><br><span class="line">            <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-site'</span>: <span class="string">'same-origin'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-mode'</span>: <span class="string">'navigate'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-user'</span>: <span class="string">'?1'</span>,</span><br><span class="line">            <span class="string">'sec-fetch-dest'</span>: <span class="string">'document'</span>,</span><br><span class="line">            <span class="string">'referer'</span>: <span class="string">'https://s.taobao.com/search?q=%E4%B9%A6%E5%8C%85'</span>,</span><br><span class="line">            <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">            <span class="string">'cookie'</span>: <span class="string">'cna=4gSsFiILVA8CAbRPiIEJDXhF; miid=1778120109322818651; t=a3a888add051197e89322f6ac86403c5; sgcookie=EELv%2B4XJBYFwT%2Bhuy%2FTQ%2B; uc3=id2=UNkwd%2Ftz5MUGAw%3D%3D&amp;lg2=VFC%2FuZ9ayeYq2g%3D%3D&amp;nk2=F5REODHw3K6Q%2BD8%3D&amp;vt3=F8dBxGJrlnv3T4HD81o%3D; lgc=tb162242636; uc4=nk4=0%40FY4Pam9Lwk6E41txt%2F1TC19ozrosnQ%3D%3D&amp;id4=0%40Ug46uCfrf6NfVRrSuV4vCECMhqce; tracknick=tb162242636; _cc_=URm48syIZQ%3D%3D; tfstk=c7F5BRa8S3x7eJWeaz_q4yEfcjGFaejjoTi8P--2OluGb34SDsYH_cGl7JxDMA3f.; enc=qCR4%2Bv6cUjkOuvgrakFshhE%2F46cDPAwDb8Gev5FH7UI1LN0ry3vlgtuMnhJU%2BKlc%2FspoGvT9CB7NKS2BEruk%2Fg%3D%3D; mt=ci=22_1; thw=cn; cookie2=7d4e0cb8e8f704666b1c1961f5f55cd9; _tb_token_=3bb5e05733efb; v=0; uc1=cookie14=UoTV6OIrH78%2Bvw%3D%3D; JSESSIONID=CAB751B32AF7D64E317AA254FB07BFB2; l=eBaLBPIVqovCAMUoBOfanurza77tbIRYSuPzaNbMiOCP_bCH59jdWZlodgLMCnGVhs9BR3ow4YKgBeYBqS24n5U62j-laTDmn; isg=BLGxbgYJSkcl6-TbYQmF-OWzwD1LniUQmN7K7JPGuniXutEM2-xT4FtY2E7cd71I'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        r = requests.get(url, headers = header)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"get_false"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(ilt, html)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        plt = re.findall(<span class="string">r'\"view_price\":\"\d+\.\d*\"'</span>, html)</span><br><span class="line">        tlt = re.findall(<span class="string">r'\"raw_title\":\".*?\"'</span>, html)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plt)):</span><br><span class="line">            price = eval(plt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])</span><br><span class="line">            title = eval(tlt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])</span><br><span class="line">            ilt.append([price, title])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"parse_falut"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGoodsList</span><span class="params">(ilt)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"序号"</span>, <span class="string">"价格"</span>, <span class="string">"商品名称"</span>))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> g <span class="keyword">in</span> ilt:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        print(tplt.format(count, g[<span class="number">0</span>], g[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    goods = <span class="string">'书包'</span></span><br><span class="line">    depth = <span class="number">3</span></span><br><span class="line">    start_url = <span class="string">'https://s.taobao.com/search?q='</span> + goods</span><br><span class="line">    infoList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(depth):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            url = start_url + <span class="string">'&amp;s='</span> + str(<span class="number">44</span> * i)</span><br><span class="line">            html = getHTMLText(url)</span><br><span class="line">            parsePage(infoList, html)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            print(<span class="string">"&#123;&#125;层fault"</span>.format(depth))</span><br><span class="line">    printGoodsList(infoList)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>与MOOC上的有些许出入，主要是淘宝最近增加了反爬虫机制（是不是教学视频火了，让学习狗把淘宝爬急了hh），参照这位大神的方法可成<br><a href="https://blog.csdn.net/Guanhai1617/article/details/104120581" target="_blank" rel="noopener">入口</a></p>
<p>实例中的正则表达式：</p>
<table>
<thead>
<tr>
<th align="center">原式</th>
<th align="center">正则语法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“raw_title”=”某某书包”</td>
<td align="center"><code>r&#39;\&quot;view_price\&quot;:\&quot;\d+\.\d*\&quot;&#39;</code></td>
</tr>
<tr>
<td align="center">“view_price”=”125.00”</td>
<td align="center"><code>r&#39;\&quot;raw_title\&quot;:\&quot;.*?\&quot;&#39;</code></td>
</tr>
</tbody></table>
<h3 id="实例：股票信息爬取"><a href="#实例：股票信息爬取" class="headerlink" title="实例：股票信息爬取"></a>实例：股票信息爬取</h3><p>链接已挂，不过源代码值得学习一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStockList</span><span class="params">(lst, stockURL)</span>:</span></span><br><span class="line">    html = getHTMLText(stockURL)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)  <span class="comment"># 针对url1进行解析</span></span><br><span class="line">    a = soup.find_all(<span class="string">'a'</span>)  <span class="comment"># 获取a标签内容，解析其中有用的字段，以应用到后面百度股票的url尾部信息</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            href = i.attrs[<span class="string">'href'</span>]</span><br><span class="line">            lst.append(re.findall(<span class="string">r'[s][hz]\d&#123;6&#125;'</span>, href)[<span class="number">0</span>])  <span class="comment"># sh100000 或 sz0219012</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStockInfo</span><span class="params">(lst, stockURL, fpath)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> stock <span class="keyword">in</span> lst:</span><br><span class="line">        url = stockURL + stock + <span class="string">".html"</span></span><br><span class="line">        html = getHTMLText(url)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> html == <span class="string">""</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            infoDict = &#123;&#125;</span><br><span class="line">            soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)  <span class="comment"># 针对url2进行解析</span></span><br><span class="line">            stockInfo = soup.find(<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'stock-bets'</span>&#125;)</span><br><span class="line"></span><br><span class="line">            name = stockInfo.find_all(attrs=&#123;<span class="string">'class'</span>: <span class="string">'bets-name'</span>&#125;)[<span class="number">0</span>]</span><br><span class="line">            infoDict.update(&#123;<span class="string">'股票名称'</span>: name.text.split()[<span class="number">0</span>]&#125;)</span><br><span class="line"></span><br><span class="line">            keyList = stockInfo.find_all(<span class="string">'dt'</span>)</span><br><span class="line">            valueList = stockInfo.find_all(<span class="string">'dd'</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(keyList)):</span><br><span class="line">                key = keyList[i].text</span><br><span class="line">                val = valueList.text</span><br><span class="line">                infoDict[key] = val</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> open(fpath, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(str(infoDict) + <span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 思路：通过东方财富网获取股票列表，根据股票列表逐个到百度股票获取个股信息</span></span><br><span class="line">    stock_list_url = <span class="string">'https://quote.eastmoney.com/stocklist.html'</span></span><br><span class="line">    stock_info_url = <span class="string">'https://gupiao.baidu.com/stock/'</span></span><br><span class="line">    output_file = <span class="string">'D://University-Learning//computer//Python编程//python爬虫//StockInfo.txt'</span></span><br><span class="line">    slist = []</span><br><span class="line">    getStockList(slist, stock_list_url)</span><br><span class="line">    getStockInfo(slist, stock_info_url, output_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目Simple-Nes</title>
    <url>/2020/09/06/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AESimple-Nes/</url>
    <content><![CDATA[<p><a href="https://github.com/amhndu/SimpleNES" target="_blank" rel="noopener">项目来源</a></p>
<a id="more"></a>

<h1 id="compiling-need"><a href="#compiling-need" class="headerlink" title="compiling need"></a>compiling need</h1><ul>
<li>SFML 2.0+ development headers and library</li>
<li>C++11 compliant compiler</li>
<li>CMake build system</li>
</ul>
<h2 id="SFML"><a href="#SFML" class="headerlink" title="SFML"></a>SFML</h2><p><a href="https://blog.csdn.net/qq_33567644/article/details/91126507" target="_blank" rel="noopener">参考博客</a></p>
<p><strong>SFML</strong> 是<strong>多媒体库</strong>，它为PC的各个组件提供简单的界面，用来<em>简化游戏和多媒体应用程序的开发</em>。 主要由五个模块组成，分别是：<strong>系统，窗口，图形，音频和网络。</strong></p>
<p><strong>SFML</strong> 是跨平台的，通过 <strong>SFML</strong>，你的应用程序可以在最常见的操作系统上进行编译和运行：Windows，Linux，macOS以及Android和iOS。</p>
<p><strong>SFML</strong> 支持多种语言，具体可以在<a href="https://www.sfml-dev.org/download/bindings.php" target="_blank" rel="noopener">官网</a>查看支持的语言。</p>
<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake是一个开源、跨平台的工程构建工具，用于构建、测试和打包软件。CMake是用来控制软件编译过程使用简单的平台和编译器独立的配置文件，并生成本地makefile和工作区，可以在您选择的编译器环境中使用。</p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆栈</title>
    <url>/2020/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>数据结构中的堆栈和队列知识。堆栈和队列其实就是操作受限的线性表。</p>
<a id="more"></a>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    DataType <span class="built_in">stack</span>[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; seqStack;</span><br></pre></td></tr></table></figure>
<h4 id="链表存储结构"><a href="#链表存储结构" class="headerlink" title="链表存储结构"></a>链表存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slNode</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; slNodeType;</span><br></pre></td></tr></table></figure>

<h4 id="经典问题：括号匹配"><a href="#经典问题：括号匹配" class="headerlink" title="经典问题：括号匹配"></a>经典问题：括号匹配</h4><p>思想：</p>
<ol>
<li>循环：自左向右扫描表达式串（基本框架），<ul>
<li>当遇到左括号，左括号入栈</li>
<li>当遇到右括号，比较当前栈顶元素与其是否匹配，<ul>
<li>若配对，则出栈，并继续扫描</li>
<li>若不配对，则返回不匹配</li>
<li>若栈空，则右括号多于左括号</li>
</ul>
</li>
</ul>
</li>
<li>扫描结束后，<ul>
<li>若栈非空，则左括号多于右括号</li>
<li>若栈为空，则左右括号配对<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        dic = &#123;<span class="string">'['</span>:<span class="string">']'</span>,<span class="string">'('</span>:<span class="string">')'</span>,<span class="string">'&#123;'</span>:<span class="string">'&#125;'</span>&#125;</span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span> <span class="keyword">or</span> s[i]==<span class="string">'['</span> <span class="keyword">or</span> s[i]==<span class="string">'&#123;'</span>):</span><br><span class="line">                stack.append(dic[s[i]])</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span> <span class="keyword">or</span> s[i]==<span class="string">']'</span> <span class="keyword">or</span> s[i]==<span class="string">'&#125;'</span>):</span><br><span class="line">                <span class="keyword">if</span>(stack == []):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span>(stack[<span class="number">-1</span>] != s[i]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span>(stack[<span class="number">-1</span>] == s[i]):</span><br><span class="line">                    stack = stack[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span>(stack == []):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="栈的应用：递归栈"><a href="#栈的应用：递归栈" class="headerlink" title="栈的应用：递归栈"></a>栈的应用：递归栈</h3><p>在一个函数的运行期间调用另一个函数时，<strong>在运行该被调用函数之前</strong>，需要先完成三项任务：</p>
<ul>
<li>将所有实在参数、返回地址等信息传递给被调用函数保存。</li>
<li>为被调用函数的局部变量分配存储区。</li>
<li>将控制转移到被调用函数的入口。</li>
</ul>
<p>从被调用函数返回调用函数之前，应该完成下列三项任务：</p>
<ul>
<li>保存被调函数的计算结果</li>
<li>释放被调函数的数据区</li>
<li>依照被调函数保存的返回地址将控制转移到调用函数</li>
</ul>
<p>四个概念：</p>
<ul>
<li>递归工作栈：递归过程执行过程中占用的数据区。</li>
<li>递归工作记录：每一层递归参数合成一个记录。</li>
<li>当前活动记录：栈顶记录指示当前层的执行情况。</li>
<li>当前环境指针：递归工作栈的栈顶指针。</li>
</ul>
<h3 id="栈应用：消去递归"><a href="#栈应用：消去递归" class="headerlink" title="栈应用：消去递归"></a>栈应用：消去递归</h3><p>将调用函数的过程，等效成入栈。将返回值的过程等效为出栈。</p>
<h4 id="实例：斐波那契数列的求解"><a href="#实例：斐波那契数列的求解" class="headerlink" title="实例：斐波那契数列的求解"></a>实例：斐波那契数列的求解</h4><p>解法1：堆栈消去递归（C++）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibnacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node&gt; S;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Node w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123; <span class="comment">// 向左递归，执行进栈操作</span></span><br><span class="line">            w.n = n;</span><br><span class="line">            w.tag = <span class="number">1</span>;</span><br><span class="line">            S.push(w);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum + n; <span class="comment">// 求和，因为到底已经返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!S.empty())&#123;</span><br><span class="line">            w = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="keyword">if</span>(w.tag == <span class="number">1</span>)&#123; <span class="comment">// 若左侧已经被进栈</span></span><br><span class="line">                w.tag = <span class="number">2</span>;</span><br><span class="line">                S.push(w);</span><br><span class="line">                n = w.n - <span class="number">2</span>; <span class="comment">// F(n)的右下侧为F(n-2)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!S.empty());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法2：迭代法<br>一般对于<strong>尾递归或单向递归</strong>的情形，都可以利用迭代的方法，将递归转换为非递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">longFibIter(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    longtwoback=<span class="number">0</span>,oneback=<span class="number">1</span>,Current;</span><br><span class="line">    <span class="keyword">for</span>(inti=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        Current=twoback+oneback;</span><br><span class="line">        twoback=oneback;</span><br><span class="line">        oneback=Current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h3><h4 id="顺序存储结构-1"><a href="#顺序存储结构-1" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    DataType <span class="built_in">queue</span>[MaxQueueSize];</span><br><span class="line">    <span class="keyword">int</span> front; <span class="comment">// 头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear; <span class="comment">// 尾指针</span></span><br><span class="line">&#125;SeqQueue;</span><br></pre></td></tr></table></figure>
<ul>
<li>当出队，<code>front</code>递增</li>
<li>当入队，<code>rear</code>递增</li>
<li>当队空，<code>front=rear</code></li>
</ul>
<h4 id="链表存储结构-1"><a href="#链表存储结构-1" class="headerlink" title="链表存储结构"></a>链表存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LQNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链队列定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LQNode *front;</span><br><span class="line">    LQNode *rear;</span><br><span class="line">&#125;LQueue;</span><br></pre></td></tr></table></figure>

<h3 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h3><p>操作系统的作业调度。</p>
]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/07/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，创立了解决这类过程优化问题的新方法——<strong>动态规划</strong>。</p>
<a id="more"></a>
<p><a href="https://www.bilibili.com/video/BV1xb411e7ww?from=search&seid=6405207412150244964" target="_blank" rel="noopener">动态规划入门链接</a></p>
<h3 id="动态规划题目特点"><a href="#动态规划题目特点" class="headerlink" title="动态规划题目特点"></a>动态规划题目特点</h3><ol>
<li>计数</li>
<li>求最值</li>
<li>求存在性</li>
</ol>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="实例1–求最值"><a href="#实例1–求最值" class="headerlink" title="实例1–求最值"></a>实例1–求最值</h4><p>结账时，需要交价值27元，要求用2元、5元、7元想出一种使得<strong>纸币数最少</strong>的交钱方法。</p>
<h4 id="实例2–计数"><a href="#实例2–计数" class="headerlink" title="实例2–计数"></a>实例2–计数</h4><p>给定m行n列(m=4,n=8)的网络，有一个机器人从左上角(0,0)出发，每一步可以向下或者向右走一步。问有多少种不同的方式走到右下角？</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">起点</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">终点</td>
</tr>
</tbody></table>
<h4 id="实例3–存在性"><a href="#实例3–存在性" class="headerlink" title="实例3–存在性"></a>实例3–存在性</h4><p>有n块石头分别在x轴的0,1,…,n-1位置，一只青蛙在石头0，想跳到石头n-1。如果青蛙在第i块石头上，它最多可以向右跳距离$a_i$，问青蛙能否跳到石头n-1?</p>
<h4 id="实例4–求最值–多状态"><a href="#实例4–求最值–多状态" class="headerlink" title="实例4–求最值–多状态"></a>实例4–求最值–多状态</h4><p>出处：Leetcode309<br>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<h4 id="实例5–交错字符串"><a href="#实例5–交错字符串" class="headerlink" title="实例5–交错字符串"></a>实例5–交错字符串</h4><p>出处：Leetcode97<br>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<h3 id="动态规划四组成"><a href="#动态规划四组成" class="headerlink" title="动态规划四组成"></a>动态规划四组成</h3><h4 id="动态规划组成部分一：确定状态"><a href="#动态规划组成部分一：确定状态" class="headerlink" title="动态规划组成部分一：确定状态"></a>动态规划组成部分一：确定状态</h4><h5 id="两个意识"><a href="#两个意识" class="headerlink" title="两个意识"></a>两个意识</h5><ul>
<li>最后一步</li>
<li>子问题</li>
</ul>
<p>状态由<br>$$ f(x)=最少用多少枚硬币拼出27 $$<br>转换为<br>$$f(x)=最少用多少枚硬币拼出27-a_{k}$$<br>归纳为<br>$$状态f(x)=最少用多少枚硬币拼出x$$</p>
<p>根据最后一步分部考虑： </p>
<p>$$f(27) = min{f(27-2)+1, f(27-5)+1, f(27-7)+1}$$</p>
<p>我们根据这个公式可以写出一种递归算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res=np.inf  <span class="comment"># res初始化为极大值</span></span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">2</span>:</span><br><span class="line">        res=min(f(x<span class="number">-2</span>)+<span class="number">1</span>,res)</span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">5</span>:</span><br><span class="line">        res=min(f(x<span class="number">-5</span>)+<span class="number">1</span>,res)</span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">7</span>:</span><br><span class="line">        res=min(f(x<span class="number">-7</span>)+<span class="number">1</span>,res)</span><br><span class="line">    <span class="keyword">return</span> res  <span class="comment"># 当传入的x为1时，res返回的是inf，也就相当于不成立！！</span></span><br><span class="line">print(f(<span class="number">27</span>))</span><br></pre></td></tr></table></figure>

<h4 id="动态规划组成部分二：转移方程"><a href="#动态规划组成部分二：转移方程" class="headerlink" title="动态规划组成部分二：转移方程"></a>动态规划组成部分二：转移方程</h4><p>$$f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}$$</p>
<h4 id="动态规划组成部分三：初始条件和边界情况"><a href="#动态规划组成部分三：初始条件和边界情况" class="headerlink" title="动态规划组成部分三：初始条件和边界情况"></a>动态规划组成部分三：初始条件和边界情况</h4><p>初始条件：</p>
<p>$$f[0] = 0$$</p>
<p>边界情况：</p>
<p>$$数组不越界$$</p>
<h4 id="动态规划组成部分四：计算顺序"><a href="#动态规划组成部分四：计算顺序" class="headerlink" title="动态规划组成部分四：计算顺序"></a>动态规划组成部分四：计算顺序</h4><ul>
<li>正序</li>
<li>逆序</li>
<li>其他</li>
</ul>
<p>判断标准：当前的数据在已经算出后，前面（后面）的数据是否已经得出了。</p>
<h4 id="实例1解答"><a href="#实例1解答" class="headerlink" title="实例1解答"></a>实例1解答</h4><p>个人解答</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">f = [<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">28</span>)]</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">f[<span class="number">1</span>] = np.inf</span><br><span class="line">n = <span class="number">27</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>): <span class="comment"># 时间复杂度O(n)</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">7</span>):</span><br><span class="line">        f[i] = min(f[i<span class="number">-2</span>]+<span class="number">1</span>,f[i<span class="number">-5</span>]+<span class="number">1</span>,f[i<span class="number">-7</span>]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">7</span>&gt;i&gt;=<span class="number">5</span>):</span><br><span class="line">        f[i] = min(f[i<span class="number">-2</span>]+<span class="number">1</span>, f[i<span class="number">-5</span>]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">5</span>):</span><br><span class="line">        f[i] = f[i<span class="number">-2</span>]+<span class="number">1</span></span><br><span class="line">print(f[<span class="number">27</span>])</span><br></pre></td></tr></table></figure>
<p>完美改进</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *fun;</span><br><span class="line">    fun = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(M+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A)/<span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    fun[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= A[j] &amp;&amp; fun[i-A[j]] != INT_MAX)&#123; </span><br><span class="line">                <span class="comment">// 防止下标溢出；防止无穷大加法溢出！！</span></span><br><span class="line">                fun[i] = <span class="built_in">min</span>(fun[i-A[j]]+<span class="number">1</span>, fun[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fun[M]==INT_MAX)&#123;</span><br><span class="line">        fun[M] = <span class="number">-1</span>; <span class="comment">// 题目要求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态规划组成部分概括"><a href="#动态规划组成部分概括" class="headerlink" title="动态规划组成部分概括"></a>动态规划组成部分概括</h4><ol>
<li>确定状态<ul>
<li>最后一步（最优策略中使用的最后一枚硬币$a_k$）</li>
<li>化成子问题（最少的硬币拼出来更小的面值$27-a_k$）</li>
</ul>
</li>
<li>转移方程<ul>
<li>$f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}$</li>
</ul>
</li>
<li>初始条件和边界情况<ul>
<li>f[0] = 0，如果不能拼出Y，f[Y]=inf</li>
</ul>
</li>
<li>计算顺序<ul>
<li>正序</li>
</ul>
</li>
</ol>
<h3 id="利用动态规划解实例2"><a href="#利用动态规划解实例2" class="headerlink" title="利用动态规划解实例2"></a>利用动态规划解实例2</h3><ol>
<li>确定状态<ul>
<li>最后一步：到达(m-1,n-1)前的方法是以M种方法到(m-2,n-1)加上以N种方法到(m-1,n-2)</li>
<li>化成子问题：有多少种方法到达(m-2,n-1)或(m-1,n-2)</li>
<li>状态：设$f[i][j]$为从左上角有多少种路径走到$(i,j)$</li>
</ul>
</li>
<li>转移方程<ul>
<li>$f[i][j] = f[i-1][j] + f[i][j-1]$</li>
</ul>
</li>
<li>初始条件和边界情况<ul>
<li>初始条件：$f[0][0]=1$</li>
<li>边界情况：$i=j=0$时，$f[i][j]=1$</li>
</ul>
</li>
<li>计算顺序<ul>
<li>由左到右，逐行计算</li>
</ul>
</li>
</ol>
<p>代码解答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePath</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[m][n];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i = <span class="number">0</span> || j = <span class="number">0</span>)&#123;</span><br><span class="line">                f[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j] + f[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用动态规划解实例3"><a href="#利用动态规划解实例3" class="headerlink" title="利用动态规划解实例3"></a>利用动态规划解实例3</h3><ol>
<li>确定状态<ul>
<li>最后一步：到达n-1之前已经到达i</li>
<li>化成子问题：跳到n-1 -&gt; 跳到i</li>
<li>状态：设$f[j]$为青蛙能不能跳到石头j</li>
</ul>
</li>
<li>转移方程<ul>
<li>$f[j]=OR_{0&lt;=i&lt;j}(f[i] AND i +a[i]&gt;=j)$</li>
</ul>
</li>
<li>初始条件和边界情况<ul>
<li>初始条件：$f[0]=true$</li>
</ul>
</li>
<li>计算顺序<ul>
<li>从小到大</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span> *A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="keyword">sizeof</span>(A)/<span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> *f;</span><br><span class="line">    f = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        f[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[j] &amp;&amp; j+A[j] &gt;= i)&#123;</span><br><span class="line">                <span class="comment">// 能到达目标点前的这个点，并且还能跳到目标点，则能到达目标点</span></span><br><span class="line">                f[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^2)$<br>空间复杂度：$O(n)$</p>
<h3 id="利用动态规划解实例4"><a href="#利用动态规划解实例4" class="headerlink" title="利用动态规划解实例4"></a>利用动态规划解实例4</h3><ol>
<li><p>确定状态<br>用$f[i]$表示第i天结束后的累计最大收益，状态分为三种：</p>
<ul>
<li>持股状态：目前持有一种股票，累计最大收益为$f[i][0]$</li>
<li>冷冻期状态：该天结束后处于冷冻期，对应的累计最大收益为$f[i][1]$</li>
<li>双非状态：既不持有股票也不处于冷冻期状态，对应$f[i][2]$</li>
</ul>
</li>
<li><p>转移方程<br> 状态转移：<br>$$f[i][0] = max{f[i-1][0], f[i-1][2]-prices[i]}$$<br>$$f[i][1] = f[i-1][0] + prices[i]$$<br>$$f[i][2] = max{f[i-1][2], f[i-1][1]}$$<br> 结果：<br>$$result = max{f[n-1][1],f[n-1][2]}$$</p>
</li>
<li><p>初始条件和边界情况<br>$$f[0][0] = -prices[0]$$<br>$$f[0][1] = 0$$<br>$$f[0][2] = 0$$</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// f[i][0]代表目前持有一支股票</span></span><br><span class="line">    <span class="comment">// f[i][1]代表第i天结束后，位于冷冻期</span></span><br><span class="line">    <span class="comment">// f[i][2]代表当前不持股，也不位于冷冻期</span></span><br><span class="line">    <span class="keyword">if</span>(pricesSize==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[pricesSize][<span class="number">3</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; pricesSize; i++)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = fmax(f[i<span class="number">-1</span>][<span class="number">0</span>], f[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">        f[i][<span class="number">2</span>] = fmax(f[i<span class="number">-1</span>][<span class="number">2</span>], f[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmax(f[pricesSize<span class="number">-1</span>][<span class="number">1</span>],f[pricesSize<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="利用动态规划解实例5"><a href="#利用动态规划解实例5" class="headerlink" title="利用动态规划解实例5"></a>利用动态规划解实例5</h3><ol>
<li>确定状态：$f[i][j]=s_1的前i个和s_2的前j个能否交错成s3的前i+j个$</li>
<li>转移方程：<br>$$f[i][j] = [f[i-1][j] \ and \ s_1[i-1]=s_3[p]] or [f[i][j-1] \ and \ s_2[j-1]=s_3[p]]$$<br>其中$p=i+j-1$</li>
<li>初始条件和边界情况：<ul>
<li>初始条件：$f[0][0]=true$</li>
<li>边界条件：注意数组下标是否溢出</li>
</ul>
</li>
<li>计算顺序：从小到大</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span> n3 = s3.length();</span><br><span class="line">        <span class="keyword">if</span>(n1 + n2 != n3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dp[n1+<span class="number">1</span>][n2+<span class="number">1</span>];<span class="comment">// 起初开的空间是dp[n1][n2]，后来发现那样是无法考虑到s1前n个s2不考虑这种情况的，所以要开n1+1和n2+1</span></span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 对应s1==s2==s3==" "</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n2; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]) || (dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于边界情况的处理的优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    f[i][j] |= (f[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    f[i][j] |= (f[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外由于<strong>第i行与i-1行直接相关</strong>，所以可以利用滚动数组进行优化：<br>即将数组申请为<code>dp[n2+1]</code>，后面运算不用带上行下标即可。</p>
]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之查找</title>
    <url>/2020/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>查找这部分是跟着郭老师学的，临近期末，又要复习这部分涉及到的内容又多，掌握的几乎为0。</p>
<a id="more"></a>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="找下限"><a href="#找下限" class="headerlink" title="找下限"></a>找下限</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLower</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        mid = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123; <span class="comment">// 这个if条件下，满足的条件一定是该if条件的真子集</span></span><br><span class="line">            <span class="built_in">end</span> = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="找上限"><a href="#找上限" class="headerlink" title="找上限"></a>找上限</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findHigher</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        mid = start + (<span class="built_in">end</span> - start + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="hash表查找"><a href="#hash表查找" class="headerlink" title="hash表查找"></a>hash表查找</h3><h4 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>目标：不需要把待查记录的关键字与查找表的某些记录进行逐个比较。而是<strong>根据待查记录的关键字值，直接找到该记录的存储地址</strong>。<br>思想：建立一个确定的函数关系H(称为散列函数，或哈希函数)：</p>
<ul>
<li>以结点关键字key作为自变量</li>
<li>以函数值H(key)作为结点的存储地址</li>
<li>通常散列表的存储空间是一个一维数组，散列地址是数组的下标。</li>
</ul>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h6 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h6><p>题目：已知一长度为14的线性表关键字集合<code>S = { and,
begin, do, end, for, go, if, repeat, then, until, while,
else, array, when }</code>。设查找表中每个关键字表示为<br><code>key[8]</code>。</p>
<p>设计：</p>
<ul>
<li>散列表表示为<code>char ht[26][8];</code></li>
<li>散列函数H(key)的值取为关键字key中的第一个字母在字母表中的序号</li>
</ul>
<p>总结：显然a、e、w开头的单词均在其地址内有冲突。</p>
<h6 id="例题改进"><a href="#例题改进" class="headerlink" title="例题改进"></a>例题改进</h6><p>在例1的基础上，修改散列函数H(key)：<strong>值为key中首尾字母在字母表中序号的平均值</strong>，此时地址不产生冲突。</p>
<h4 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p><strong>散列函数H</strong>：<br>$$Address=H(key)$$<br><strong>装载因子</strong>：<br>$$a=n/m$$<br>其中，m为散列表的空间大小，n为散列表中的记录数。</p>
<h5 id="hash函数的构造方法"><a href="#hash函数的构造方法" class="headerlink" title="hash函数的构造方法"></a>hash函数的构造方法</h5><h6 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h6><p>$$H(key)=key%p$$<br>其中p一般取&lt;=m的最大素数。</p>
<h6 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h6><ul>
<li>取关键字作为其hash地址</li>
<li>取关键字的某个线性函数：$H(key)=a*key+b$<h6 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h6>根据散列表的大小，选取其中各种符号分布均匀的若干位作为散列地址。<h6 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h6>先通过求关键字的平方值来扩大差别，<br>再取其中的几位或其组合作为散列地址。<br>具体取几位，由hash表的表长决定。<h6 id="分段叠加法"><a href="#分段叠加法" class="headerlink" title="分段叠加法"></a>分段叠加法</h6></li>
<li>将关键字分割成位数相同的几部分（最后一部分位数可不同）</li>
<li>然后取这几部分的叠加和舍去进位作为散列地址。</li>
</ul>
<h4 id="冲突解决方法"><a href="#冲突解决方法" class="headerlink" title="冲突解决方法"></a>冲突解决方法</h4><h5 id="开放地址法–找下一个空位"><a href="#开放地址法–找下一个空位" class="headerlink" title="开放地址法–找下一个空位"></a>开放地址法–找下一个空位</h5><p>当冲突发生时，使用某种方法为R的关键字key生成一个散列地址序列，其中第i次冲突散列地址：<br>$$d_i = (d_{i-1}+D)%m$$</p>
<h6 id="线性探测再散列"><a href="#线性探测再散列" class="headerlink" title="线性探测再散列"></a>线性探测再散列</h6><p>$D=i$，i表示探测次数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="二次探测再散列"><a href="#二次探测再散列" class="headerlink" title="二次探测再散列"></a>二次探测再散列</h6><p>按照$1^2, -1^2, 2^2, -2^2…$的形式构造D</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(i*i/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i+<span class="number">1</span>)*(i+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="伪随机探测再散列"><a href="#伪随机探测再散列" class="headerlink" title="伪随机探测再散列"></a>伪随机探测再散列</h6><p>按照[1:m]的随机数打乱序列开始探测</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Randomize</span><span class="params">()</span> <span class="comment">//设置随机种子</span></span></span><br><span class="line"><span class="function"></span>&#123; srand(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Random</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">// 返回一个0到i之间的随机整数值</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> rand( ) % i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">permute</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123; <span class="comment">//产生1到m的伪随机排列</span></span><br><span class="line">    <span class="keyword">int</span> i,*perm=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)* m);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m ; i++) </span><br><span class="line">        perm[i] = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        swap(perm[i<span class="number">-1</span>], perm[Random(i)]);</span><br><span class="line">    <span class="keyword">return</span> perm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>* perm)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> perm[i - <span class="number">1</span>]；&#125;</span><br></pre></td></tr></table></figure>

<h5 id="链表法–顺应冲突"><a href="#链表法–顺应冲突" class="headerlink" title="链表法–顺应冲突"></a>链表法–顺应冲突</h5><p>为每一个Hash地址建立一个链表，凡散列地址为i的记录都插入到第i个链表中。</p>
<h4 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h4>]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之树图</title>
    <url>/2020/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91%E5%9B%BE/</url>
    <content><![CDATA[<p>有关数据结构的树和图知识，结合新学的C++知识。</p>
<a id="more"></a>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="主要算法"><a href="#主要算法" class="headerlink" title="主要算法"></a>主要算法</h3><h4 id="DFS-深度优先遍历"><a href="#DFS-深度优先遍历" class="headerlink" title="DFS(深度优先遍历)"></a>DFS(深度优先遍历)</h4><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTreeNode *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t-&gt;data;</span><br><span class="line">        PreOrder(t-&gt;left, Visit);</span><br><span class="line">        PreOrder(t-&gt;right, Visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTreeNode *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(t-&gt;left, Visit);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t-&gt;data;</span><br><span class="line">        PreOrder(t-&gt;right, Visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                ans.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><h6 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTreeNode *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(t-&gt;left, Visit);</span><br><span class="line">        PreOrder(t-&gt;right, Visit);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; mids;</span><br><span class="line">        <span class="comment">// mids的过程和先序遍历相反</span></span><br><span class="line">        <span class="comment">// 只是最后输出应该是倒序，所以设计s</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s; <span class="comment">// s自顶向下为后序序列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !mids.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mids.push(root);</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = mids.top();</span><br><span class="line">                mids.pop();</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.push_back(temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="BFS-广度优先遍历"><a href="#BFS-广度优先遍历" class="headerlink" title="BFS(广度优先遍历)"></a>BFS(广度优先遍历)</h4><p>利用队列实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTreeNode* t)</span> </span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    DataType x;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q.push(t);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123; <span class="comment">// 队列不为空时</span></span><br><span class="line">        x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x-&gt;data; <span class="comment">// 每出列一个，就访问一个</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q.push(x-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q.push(x-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SeqList Vertices;</span><br><span class="line">    <span class="keyword">int</span> edge[MaxVertices][MaxVertices]; <span class="comment">// 存放边集合的邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> numOfEdges;  <span class="comment">// 边条数</span></span><br><span class="line">&#125; AdjMGraph;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><h3 id="主要算法-1"><a href="#主要算法-1" class="headerlink" title="主要算法"></a>主要算法</h3><p><a href="https://blog.csdn.net/waectr/article/details/81161431" target="_blank" rel="noopener">遍历</a><br><a href="https://blog.csdn.net/iqRocket/article/details/8240723?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">拓扑</a></p>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>对一个有向无环图(Directed Acyclic Graph, DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若$&lt;u，v&gt; ∈E(G)$，则u在线性序列中出现在v之前。</p>
<ul>
<li>只有有向无环图才存在拓扑序列</li>
</ul>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ol>
<li>任选一个无前驱的顶点输出</li>
<li>删除该顶点，以及以其为起点的所有边</li>
<li>判断所有顶点是否已经输出？<ul>
<li>若是，不存在回路，排序结束</li>
<li>若否，判断是否还有无前驱的结点<ul>
<li>若是，返回第一步循环</li>
<li>若否，存在回路，排序结束</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="邻接表实现"><a href="#邻接表实现" class="headerlink" title="邻接表实现"></a>邻接表实现</h5><p>以Leetcode课程表这题为例，因为给的输入集就是相当于每条边，求解的问题也是是否有环。所以是一个典型的拓扑排序问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置入度表，存储每个课程的入度（先行课数量）</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建图结构，利用二维vector来存储</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(numCourses, v)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构建图(出边表)过程 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            indegree[prerequisites[i][<span class="number">0</span>]]++;  <span class="comment">// 构建入度表</span></span><br><span class="line">            graph[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]); <span class="comment">// 构建出边表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 拓扑排序过程 */</span></span><br><span class="line">        <span class="comment">// 1. 入度为0的顶点入队</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">                q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 删除结点计数器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将出队的元素的边全部删除，并将入度表和队列更新</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[temp].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                indegree[graph[temp][i]]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[graph[temp][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(graph[temp][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>​    并查集是一种维护集合的数据结构。</p>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>建立数组<code>int father[N]</code></p>
<p>其中，<code>father[i] = j</code>表示<strong>i的父亲节点为元素j</strong>。如果<code>father[i] = i</code>则说明元素i是集合的根节点。</p>
<p>对同一集合来说只存在一个根节点，且将其作为所属集合的标识。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>先初始化<code>father</code>，再根据需要进行查找或合并的操作。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>起初每个元素为一个独立的集合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    father[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>由于一个集合只有一个根节点，查找操作即为<strong>对给定的节点寻找其根节点的过程</strong>。</p>
<p>方式1：递推</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// findFather函数返回元素x所在集合的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2：递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == father[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findFather(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><p>将两个集合合并为一个集合。实现步骤：</p>
<ol>
<li>对于给定的元素a,b，利用查找算法查到根节点后比对是否相同，以判断两个待合并元素是否属于同一集合。</li>
<li>利用1中获取的根节点faA和faB，把其中一个父节点指向另一个节点。例如：<code>father[faA] = faB</code>或者反过来。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在合并的过程中，只对不同的集合进行合并。如果两个元素在一个相同的集合中，那么就不会对它们进行操作。这就保证了在同一个集合中一定不会产生环，即并查集产生的每一个集合都是一棵树。</p>
<h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p><strong>优化查找</strong></p>
<ol>
<li>按原先的算法获得x的根节点r。</li>
<li>重新从x开始走一遍，寻找根节点，把路径上经过的所有节点的父亲全部改为根节点r。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x; </span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="例题：好朋友"><a href="#例题：好朋友" class="headerlink" title="例题：好朋友"></a>例题：好朋友</h4><p>如果A和B是好朋友，则B和A是好朋友。</p>
<p>如果A和C是好朋友，B和C是好朋友，则A和B是好朋友。</p>
<p>现给定输入集：第一行正整数n和m，表示人数量和好朋友组数。接下来的m行每行表示一组好朋友。</p>
<p>要求：输出一组数，元素个数代表有几组好朋友，每个元素代表每组的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> father[N];</span><br><span class="line"><span class="keyword">int</span> isRoot[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        isRoot[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        Union(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        isRoot[findFather(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRoot != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; isRoot[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之链表</title>
    <url>/2020/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表的内容非常非常的基础，快速回顾~</p>
<a id="more"></a>
<h2 id="绕不开的malloc和free"><a href="#绕不开的malloc和free" class="headerlink" title="绕不开的malloc和free"></a>绕不开的malloc和free</h2><p>C没有虚浮的<code>new</code>关键字，只能用使用起来不是很直观的<code>malloc</code>关键字进行内存分配。</p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>声明：<code>malloc</code>向系统申请分配指定<code>size</code>个字节的内存空间。返回类型是 <code>void*</code> 类型。<code>void*</code> 表示未确定类型的指针。C,C++规定，<code>void*</code> 类型可以强制转换为<strong>任何其它类型的指针</strong>。</p>
<h4 id="malloc函数标准用法"><a href="#malloc函数标准用法" class="headerlink" title="malloc函数标准用法"></a>malloc函数标准用法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以申请一个链表SLNode数据为例，此处head已经声明过，为SLNode的二级指针</span></span><br><span class="line"><span class="keyword">if</span> ((*head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请一段连续的内存空间</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">100</span> );</span><br></pre></td></tr></table></figure>

<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h4 id="函数声明-1"><a href="#函数声明-1" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *block)</span></span>;</span><br><span class="line"><span class="comment">// 即 void free(指针变量)</span></span><br></pre></td></tr></table></figure>

<h2 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h2><h3 id="链表vs顺序表"><a href="#链表vs顺序表" class="headerlink" title="链表vs顺序表"></a>链表vs顺序表</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">顺序表</th>
<th align="center">链表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">增删改</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center">访问</td>
<td align="center">$O(1)$</td>
<td align="center">$O(n)$</td>
</tr>
</tbody></table>
<h3 id="单链表操作"><a href="#单链表操作" class="headerlink" title="单链表操作"></a>单链表操作</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SLNode **head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    (*head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="统计元素个数-核心思想"><a href="#统计元素个数-核心思想" class="headerlink" title="统计元素个数(核心思想)"></a>统计元素个数(核心思想)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;next!=null)&#123;</span><br><span class="line">    <span class="built_in">size</span>++;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找算法-略"><a href="#查找算法-略" class="headerlink" title="查找算法(略)"></a>查找算法(略)</h4><h4 id="添加算法"><a href="#添加算法" class="headerlink" title="添加算法"></a>添加算法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = q;</span><br></pre></td></tr></table></figure>
<h4 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q)</span><br></pre></td></tr></table></figure>

<h4 id="头插法建表（反向）"><a href="#头插法建表（反向）" class="headerlink" title="头插法建表（反向）"></a>头插法建表（反向）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creatlist1</span><span class="params">(SLNode **head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 从键盘输入n个整数，建立以head为头指针的带头结点的单链表*/</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    SLNode *p;</span><br><span class="line">    <span class="keyword">if</span> ((*head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    (*head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((p=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p-&gt;data);</span><br><span class="line">        p-&gt;next=(*head)-&gt;next;</span><br><span class="line">        (*head)-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="尾插法建表（正向）"><a href="#尾插法建表（正向）" class="headerlink" title="尾插法建表（正向）"></a>尾插法建表（正向）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SLNode * <span class="title">createlist2</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch; </span><br><span class="line">    SLNode * head,*s,*r;</span><br><span class="line">    <span class="keyword">if</span> ((head=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    (head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r=head;</span><br><span class="line">    <span class="keyword">while</span>((ch=getchar( ))!=‘\n’)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((s=(SLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode)))==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        s–&gt;data=ch;</span><br><span class="line">        r–&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">    &#125;</span><br><span class="line">    r–&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表操作"><a href="#双向链表操作" class="headerlink" title="双向链表操作"></a>双向链表操作</h3><p>略</p>
<h3 id="实例：多项式加法-amp-多项式乘法"><a href="#实例：多项式加法-amp-多项式乘法" class="headerlink" title="实例：多项式加法&amp;多项式乘法"></a>实例：多项式加法&amp;多项式乘法</h3><p>具体思想：</p>
<ul>
<li>设<code>p</code>和<code>q</code>分别指示多项式A和B中某一结点，</li>
<li>当<code>p</code>和<code>q</code>均非空时，比较<code>p-&gt;exp</code>与<code>q-&gt;exp</code>：<ul>
<li>若<code>p-&gt;exp</code> &lt; <code>q-&gt;exp</code>，则<code>p</code>所指结点是“和多项式”中的一项，令指针<code>p</code>后移；</li>
<li>若<code>p-&gt;exp</code> &gt; <code>q-&gt;exp</code>，则q所指结点是“和多项式”中的一项，将结点<code>q</code>插入在结点<code>p</code>之前，且令指针<code>q</code>在原来的链表上后移；</li>
<li>若<code>p-&gt;exp</code> == <code>q-&gt;exp</code>，则将两个结点中的系数相加，当和不为零时修改结点<code>p</code>的系数域，释放<code>q</code>结点；若和为零，则和多项式中无此项，从A中删去<code>p</code>结点，同时释放<code>p</code>和<code>q</code>结点。</li>
</ul>
</li>
<li>if (<code>q</code> == null) A即为“和多项式”结果</li>
<li>if (<code>p</code> == null) 将剩余的<code>q</code>表全部链接至原A最后一个结点的后继</li>
</ul>
]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶算法笔记</title>
    <url>/2020/08/05/%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>​    主要包括数据结构和算法课中没有提及到的结构和算法。</p>
<a id="more"></a>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><p>​    <strong>字符串hash是指将一个字符串S映射为一个整数，使得该整数可以尽可能唯一地代表S</strong>。如果转换的整数相同，则代表的S也相同。</p>
<p>​    下面为hash值的递推公式，其中$str[i]$表示字符串的第$i$位，<code>index</code>函数将A-Z分别转换为数值0-25，$H[i]$表示字符串的前$i$个字符串的hash值。</p>
<p>$$H[i] = H[i - 1] * 26 + index(str[i])$$</p>
<p>​    以上公式，虽然字符串与整数是一一对应的，但由于没有适当处理，因此当长度较长，产生的整数过大，没法保存。为了应对，放弃“唯一性”，进行取模运算。</p>
<p>$$H[i] = (H[i - 1] * 26 + index(str[i])) % mod$$</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><a href="https://www.cnblogs.com/miachel-zheng/p/6965172.html" target="_blank" rel="noopener">可参考blog</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/108982607" target="_blank" rel="noopener">可参考解释</a></p>
<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>求主串中与模式串匹配的字符串的首次匹配位置。</p>
<h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute-force"></a>brute-force</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n1 = s.length(), i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> n2 = t.length(), j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i -= (j - <span class="number">1</span>);</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    i - j &gt;  n2 - n1时匹配失败</span></span><br><span class="line"><span class="comment">    i - j &lt;= n2 - n1时匹配成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kmp算法思想"><a href="#kmp算法思想" class="headerlink" title="kmp算法思想"></a>kmp算法思想</h3><p>利用好每次匹配中的信息，使得$i$的后移更加“快速”。减少每次重复冗余的匹配，使得$i$每次能向后移动最大的距离。</p>
<p>设立next数组，next[i]的值表达的意义为<strong>[0,i)位置中的最长相等前后缀长度</strong>。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*求解next数组*/</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buildNext</span><span class="params">(<span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = T.length(), j = <span class="number">0</span>; <span class="comment">// "主"串指针</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">-1</span>; <span class="comment">// 模式串指针</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span> || T[j] == T[t]) &#123;</span><br><span class="line">            <span class="comment">/*如果碰到了哨兵或是正确匹配*/</span></span><br><span class="line">            ++t; ++j;</span><br><span class="line">            next[j] = (T[j] == T[t]) ? next[t] : t; <span class="comment">// 防止以卵击石的"幼稚"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = next[t]; <span class="comment">// 赋值为next(相当于移动模式串)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;   	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*kmp主算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = buildNext(T);</span><br><span class="line">    <span class="keyword">int</span> n1 = S.length(), i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = T.length(), j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span> || S[i] == T[j]) &#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>brute-force —-$O(n1 * n2)$ –&gt;实际情况下$\approx O(n1 + n2)$</p>
<p>kmp —-$O(n1 + n2)$ —-最差$O(2 * n1 + 2 * n2)$</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口的本质是一个双指针，它并不局限于字符串类问题，主要用于解<strong>最优解问题</strong>。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>设置<code>l = 0</code>和<code>r = 0</code>两个指针，<code>[l, r]</code>的区间看作一个窗口。</li>
<li>通过<code>++r</code>逐步将指针右移，查看是否有匹配原题的答案（例如字符串匹配，或者是加和相等），直到有匹配的答案时停止右移。</li>
<li>然后通过<code>++l</code>的方式缩短区间<code>[l, r]</code>，直到该区间内的答案不再匹配。更新当前的<code>ans</code>（可以是窗口大小）</li>
<li>重复2、3步，直到<code>l == n - 1</code>，此时的<code>ans</code>即为结果。</li>
</ol>
<p>本质上来看，第2步在<strong>寻找可行解</strong>，第三步在<strong>优化可行解</strong>。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">长度最小的子数组</a></p>
<hr>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p><a href="https://blog.csdn.net/qq_39553725/article/details/76696168" target="_blank" rel="noopener">树状数组应用汇总</a></p>
<h3 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h3><p><code>lowbit(x)</code>返回<strong>能整除x的最大2的幂次</strong>(转换为二进制后，右侧第一个1和右边所有的0)。</p>
<h3 id="BIT"><a href="#BIT" class="headerlink" title="BIT"></a>BIT</h3><p>定义：树状数组（Binary Indexed Tree）依然是一个数组，并且与sum数组相似，是一个用来记录和的数组，只不过它存放的不是前$i$个整数之和，而是在<strong>$i$号位之前（含$i$）$lowbit(i)$个整数之和</strong>。</p>
<p><img src="https://img2018.cnblogs.com/blog/1727888/201907/1727888-20190715193025175-355675081.png" alt="树状数组图"></p>
<h4 id="设计函数getSum-x"><a href="#设计函数getSum-x" class="headerlink" title="设计函数getSum(x)"></a>设计函数<code>getSum(x)</code></h4><p>功能：返回前x个数之和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C[x] &#x3D; A[x - lowbit(x) + 1] + ...A[x] </span><br><span class="line">SUM(1,x) &#x3D; A[1] + ... A[x]</span><br><span class="line">         &#x3D; A[1] + ... A[x - lowbit(x)] + A[x - lowbit(x) + 1] + ... + A[x]</span><br><span class="line">         &#x3D; SUM(1, x - lowbit(x)) + C[x]</span><br></pre></td></tr></table></figure>

<p>依据上述推导过程写出<code>getSum</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 时间复杂度O(logn)</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样下来，<strong>求解[x,y]区间和的问题转换为求 <code>getSum(y) - getSum(x - 1)</code></strong>。</p>
<h4 id="设计函数update-x-v"><a href="#设计函数update-x-v" class="headerlink" title="设计函数update(x, v)"></a>设计函数<code>update(x, v)</code></h4><p>功能：实现将第x个数加上一个数v的功能，即<code>A[x] += v</code></p>
<p>与getSum函数相对应的，以对A[6]加上v为例，需要寻找树状数组C中覆盖了A[6]的元素，将其加上v。也就是对C[6]、C[8]、C[16]分别加上v。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// 时间复杂度O(logn)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">        c[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>​    给定一个有N个正整数的序列A(N &lt;= 1e5, A[i] &lt;= 1e5)，对序列中每一个数，求出序列中左边比它小的数的个数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i) &amp; (-i))</span></span><br><span class="line"><span class="keyword">int</span> c[maxn]; <span class="comment">// 树状数组，存储每个数的出现次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; maxn; i += lowbit(i)) &#123;</span><br><span class="line">        c[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="comment">// 输入序列元素</span></span><br><span class="line">        update(x, <span class="number">1</span>); <span class="comment">// x的出现次数加1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getSum(x - <span class="number">1</span>)); <span class="comment">// 输出当前小于x的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拓展（离散化）"><a href="#拓展（离散化）" class="headerlink" title="拓展（离散化）"></a>拓展（离散化）</h3><p>假设：A[i] &lt;= N这个条件不成立。那数组不能开的太大了。</p>
<p>应对类似情况需要将<code>[520, 9999999999, 18, 666, 88888]</code>转换成类似于<code>[2,5,1,3,4]</code>这样的等价序列。一般来说，设置一个临时的结构体数组，用以存放输入的序列元素的值以及原始序号，而在输入完毕后将数组按val大小从小到大进行排序，排序后再按照计算排名的方式将排名根据原始序号pos存入一个新的数组。这个过程称为<strong>离散化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i) &amp; (-i))</span></span><br><span class="line"><span class="keyword">int</span> c[maxn]; <span class="comment">// 树状数组，存储每个数的出现次数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Node &#123;</span></span><br><span class="line"><span class="comment">    int val; // 元素值</span></span><br><span class="line"><span class="comment">    int pos; // 原始序号</span></span><br><span class="line"><span class="comment">&#125; temp[maxn];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt; pair&lt;int, int&gt; &gt; temp(maxn); // &#123;元素值，原始序号&#125;</span><br><span class="line"><span class="keyword">int</span> A[maxn]; <span class="comment">// 离散化后的原始数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; maxn; i += lowbit(i)) &#123;</span><br><span class="line">        c[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp[i].first); <span class="comment">// 输入序列元素</span></span><br><span class="line">        temp[i].second = i; <span class="comment">// 原始序号</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 离散化</span></span><br><span class="line">    sort(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 与前一个元素不同，赋值为元素个数</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || temp[i].first != temp[i - <span class="number">1</span>].first) &#123;</span><br><span class="line">            A[temp[i].second] = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，直接继承</span></span><br><span class="line">            A[temp[i].second] = A[temp[i - <span class="number">1</span>].second];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 离散化后，每个位存储的是前方比它大的元素的个数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新求和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        update(A[i], <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getSum(A[i] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>V -&gt; A 的过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V [520, 9999999999, 18, 666, 88888]</span><br><span class="line">temp [&#123;520,0&#125;, &#123;9999999999,1&#125;, &#123;18,2&#125;, &#123;666,3&#125;, &#123;88888,4&#125;] ---排序前</span><br><span class="line">temp [&#123;18,2&#125;, &#123;520,0&#125;, &#123;666,3&#125;, &#123;88888,4&#125;, &#123;9999999999,1&#125;] ---排序后</span><br><span class="line">A [2,5,1,3,4]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(nlogn)$</p>
<p>空间复杂度：$O(n)$</p>
<h4 id="计算右侧小于当前元素个数"><a href="#计算右侧小于当前元素个数" class="headerlink" title="计算右侧小于当前元素个数"></a>计算右侧小于当前元素个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c; <span class="comment">// 树状数组c</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A; <span class="comment">// 离散化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; temp; <span class="comment">// &#123;元素值，原始序号&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//#define lowbit(i) ((i) &amp; (-i))</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i) &amp; (-i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">            c[i] += v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 获取x的前i项和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">            sum += c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        c.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        A.assign(n, <span class="number">0</span>);</span><br><span class="line">        temp.resize(n);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            temp[i].first = nums[i];</span><br><span class="line">            temp[i].second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 离散化</span></span><br><span class="line">        sort(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 与前一个元素不同，赋值为元素个数</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || temp[i].first != temp[i - <span class="number">1</span>].first) &#123;</span><br><span class="line">                A[temp[i].second] = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，直接继承</span></span><br><span class="line">                A[temp[i].second] = A[temp[i - <span class="number">1</span>].second];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            update(A[i], <span class="number">1</span>);</span><br><span class="line">            ans[i] = getSum(A[i] - <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​    又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常<strong>被搜索引擎系统用于文本词频统计</strong>。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<p><img src="https://pic.leetcode-cn.com/e3c98484881bd654daa8419bcb0791a2b6f8288b58ef50df70ddaeefc4084f48-file_1575215107950" alt="来自算法4"></p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="抽象结构"><a href="#抽象结构" class="headerlink" title="抽象结构"></a>抽象结构</h4><p>例如以下的trie树，存储了一组字符串<code>[&quot;cat&quot;, &quot;can&quot;, &quot;cs&quot;, &quot;cstring&quot;]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    r</span><br><span class="line">    |</span><br><span class="line">    c</span><br><span class="line">   &#x2F; \</span><br><span class="line">  a   s*</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">t*  n*  t</span><br><span class="line">         \</span><br><span class="line">          r</span><br><span class="line">           \</span><br><span class="line">            i</span><br><span class="line">             \</span><br><span class="line">              n</span><br><span class="line">               \</span><br><span class="line">                g*</span><br></pre></td></tr></table></figure>

<h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p>法1 ：空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    trieNode** son; <span class="comment">// 二维指针指向一个trieNode指针数组</span></span><br><span class="line">    <span class="keyword">int</span> cnt; <span class="comment">// 标记</span></span><br><span class="line">    trieNode(<span class="keyword">char</span> c) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">        val = c;</span><br><span class="line">        son = <span class="keyword">new</span> trieNode*[<span class="number">26</span>];</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            son[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或参考例题中的写法</span></span><br></pre></td></tr></table></figure>

<p>法2：数组模拟空间</p>
<p>开辟一个二维数组<code>tree[m][26]</code>。</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>root(0,25)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[…’c’:1…]</td>
<td>[‘a’:2…’s’:2…]</td>
<td>[…’n’:3…’t’:3…]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    trieNode* p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;son[c])	p-&gt;son[c] = <span class="keyword">new</span> trieNode(c);</span><br><span class="line">        p = p-&gt;son[c];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    trieNode* p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;son[c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = p-&gt;son[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p>给定一组 <strong>互不相同</strong> 的单词， 找出所有<strong>不同</strong> 的索引对<code>(i, j)</code>，使得列表中的两个单词， <code>words[i] + words[j]</code> ，可拼接成回文串。</p>
<p>实现：数组模拟空间结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ch[<span class="number">26</span>]; <span class="comment">// 节点存储的字母</span></span><br><span class="line">        <span class="keyword">int</span> flag; <span class="comment">// 标记字符串结束节点</span></span><br><span class="line">        node() &#123; <span class="comment">// node的初始化</span></span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; tree; <span class="comment">// 建立字典树</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 遍历字符串</span></span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'a'</span>; <span class="comment">// 获取字母</span></span><br><span class="line">            <span class="keyword">if</span> (!tree[add].ch[x]) &#123; <span class="comment">// 如果树中不存在这样的节点</span></span><br><span class="line">                tree.emplace_back(); <span class="comment">// 给树添加新的节点</span></span><br><span class="line">                tree[add].ch[x] = tree.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 前驱节点指向下一个节点(此处用数组的结构表示)</span></span><br><span class="line">            &#125;</span><br><span class="line">            add = tree[add].ch[x]; <span class="comment">// 指向下一个节点，继续向后添加</span></span><br><span class="line">        &#125;</span><br><span class="line">        tree[add].flag = id; <span class="comment">// 遍历完字符串，将尾字符做标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findWord</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; i--) &#123; <span class="comment">// 倒序遍历指定区间的字符串</span></span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'a'</span>; <span class="comment">// 获取字母</span></span><br><span class="line">            <span class="keyword">if</span> (!tree[add].ch[x]) &#123; <span class="comment">// 如果不存在，返回-1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            add = tree[add].ch[x]; <span class="comment">// 否则继续向下遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree[add].flag; <span class="comment">// 返回是否尾结点有标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; <span class="comment">// 左右指针逼近遍历判断是否是回文串</span></span><br><span class="line">        <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left + i] != s[right - i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">palindromePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造字典树</span></span><br><span class="line">        tree.emplace_back(node());</span><br><span class="line">        <span class="keyword">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            insert(words[i], i); <span class="comment">// 单词在words中的序号即为其id</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断回文对</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 遍历words容器</span></span><br><span class="line">            <span class="keyword">int</span> m = words[i].<span class="built_in">size</span>(); <span class="comment">// 获取当前遍历元素的长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123; <span class="comment">// 遍历该单词</span></span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(words[i], j, m - <span class="number">1</span>)) &#123; <span class="comment">// 如果(j:m-1)的部分是回文串</span></span><br><span class="line">                    <span class="comment">// 先用left_id保存(0:j-1)区间字符串是否在字典树中的返回值</span></span><br><span class="line">                    <span class="keyword">int</span> left_id = findWord(words[i], <span class="number">0</span>, j - <span class="number">1</span>); </span><br><span class="line">                    <span class="keyword">if</span> (left_id != <span class="number">-1</span> &amp;&amp; left_id != i) &#123; <span class="comment">// 如果找得到这样的字符串，且该字符串不是本身</span></span><br><span class="line">                        ret.push_back(&#123;i, left_id&#125;); <span class="comment">// 则证明(i, j)是一个合法的二元组</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &amp;&amp; isPalindrome(words[i], <span class="number">0</span>, j - <span class="number">1</span>)) &#123; <span class="comment">// 由于上界是j-1，应该保持j合法</span></span><br><span class="line">                    <span class="keyword">int</span> right_id = findWord(words[i], j, m - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (right_id != <span class="number">-1</span> &amp;&amp; right_id != i) &#123;</span><br><span class="line">                        ret.push_back(&#123;right_id, i&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p><a href="https://leetcode-cn.com/problems/re-space-lcci/" target="_blank" rel="noopener">恢复空格</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    Trie* son[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span>(son));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">// 倒序插入</span></span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;son[x]) node-&gt;son[x] = <span class="keyword">new</span> Trie();</span><br><span class="line">            node = node-&gt;son[x];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;flag++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dictionary, <span class="built_in">string</span> sentence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = dictionary.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len = sentence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n || !len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Trie* tree = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            tree-&gt;insert(dictionary[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>, INT_MAX)</span></span>; <span class="comment">// dp[i]代表前i个字符中未识别的个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// 出现次数默认为前一个+1</span></span><br><span class="line">            Trie* cur = tree;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; --j) &#123; <span class="comment">// 从第i位开始向前匹配单词</span></span><br><span class="line">                <span class="keyword">int</span> c = sentence[j - <span class="number">1</span>] - <span class="string">'a'</span>; <span class="comment">// 获取字母</span></span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;son[c]) &#123; <span class="comment">// 如果未识别到</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果识别到该单词了，则i位置的dp应取为识别该单词和不识别该单词中的最小值</span></span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;son[c]-&gt;flag) dp[i] = <span class="built_in">min</span>(dp[i], dp[j - <span class="number">1</span>]); </span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;son[c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他应用：寻找某字符串在另一个字符串数组中的前缀出现次数。</p>
<h2 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h2><p>与三种经典DFS的时间相同，却只消耗常数级别的空间。</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ol>
<li>如果当前节点的左孩子为空，则输出当前节点</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="前缀和思想"><a href="#前缀和思想" class="headerlink" title="前缀和思想"></a>前缀和思想</h2><h3 id="两要素"><a href="#两要素" class="headerlink" title="两要素"></a>两要素</h3><ol>
<li>pre或pre[i]存储前缀和</li>
<li>hash表保存 个数/前缀和出现下标 等信息。(hash表的初值很重要)</li>
</ol>
<h3 id="例1-和为K的子数组"><a href="#例1-和为K的子数组" class="headerlink" title="例1 和为K的子数组"></a>例1 和为K的子数组</h3><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>hash表用来存储遍历到当前获取的合法子数组数目。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// pre : cnt</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>; <span class="comment">// 前n项的和</span></span><br><span class="line">        <span class="comment">// (j:i)中pre[j - 1]个数 == pre[i] - target个数</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pre += nums[i]; <span class="comment">// 前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(pre - target) != m.<span class="built_in">end</span>()) <span class="comment">// 如果前侧有</span></span><br><span class="line">                ans += m[pre - target];</span><br><span class="line">            m[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="例2-和为目标值的最大数目不重叠非空子数组数目"><a href="#例2-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="例2 和为目标值的最大数目不重叠非空子数组数目"></a>例2 和为目标值的最大数目不重叠非空子数组数目</h3><p>请你返回 <strong>非空不重叠</strong> 子数组的最大数目，且每个子数组中数字和都为 <code>target</code> 。</p>
<h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><p>hash表用来存储遍历到当前$i$，满足$target$的下标$j$出现的最新位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">-1</span>; <span class="comment">// pre表示前缀和，end表示已经保存的子数组中的最大下标</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pre_idx; <span class="comment">// pre:idx</span></span><br><span class="line">        pre_idx[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 访问到pre刚好为target时，此时的pre_idx == 0为错误值，应为下标-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            pre += nums[i - <span class="number">1</span>]; <span class="comment">// 求得前缀和</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 寻找[j, i]区间内和满足要求的最近的j(pre[i] - pre[j] = target)</span></span><br><span class="line">            <span class="keyword">if</span> (pre_idx.<span class="built_in">find</span>(pre - target) != pre_idx.<span class="built_in">end</span>()) &#123; <span class="comment">/// 如果这样的前缀存在</span></span><br><span class="line">                <span class="keyword">int</span> j = pre_idx[pre - target]; <span class="comment">// 获取区间上界j</span></span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &gt; <span class="built_in">end</span>) &#123; <span class="comment">// 如果j在end之后</span></span><br><span class="line">                    ++ans;</span><br><span class="line">                    <span class="built_in">end</span> = i - <span class="number">1</span>; <span class="comment">// 将当前已纳入结果中的子数组的最大下标更新为end</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre_idx[pre] = i - <span class="number">1</span>; <span class="comment">// 更新前缀和出现的下标 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><a href="https://blog.csdn.net/morewindows/article/details/7354571" target="_blank" rel="noopener">参考原文</a></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>位运算其实就是直接对内存中的二进制数据进行操作</strong>，因此速度非常快。</p>
<h3 id="基础位操作符"><a href="#基础位操作符" class="headerlink" title="基础位操作符"></a>基础位操作符</h3><table>
<thead>
<tr>
<th>符号</th>
<th align="left">描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td align="left">与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr>
<td>`</td>
<td align="left">`</td>
<td>或</td>
</tr>
<tr>
<td><code>^</code></td>
<td align="left">异或</td>
<td>两个位相同为0，相异为1</td>
</tr>
<tr>
<td><code>~</code></td>
<td align="left">取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td align="left">左移</td>
<td>各二进位全部左移若干位，<strong>高位丢弃，低位补0</strong></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td align="left">右移</td>
<td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>只有<code>~</code>是单目运算符</li>
<li>位操作只作用于int</li>
<li>VC6.0和VS2008的编译器会将<code>&gt;&gt;</code>按算术右移处理</li>
<li>位运算符的运算级比较低</li>
<li>除以上还有复合操作符，<code>&amp;=</code>、<code>|=</code>、 <code>^=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>。</li>
</ul>
<h3 id="常用位操作"><a href="#常用位操作" class="headerlink" title="常用位操作"></a>常用位操作</h3><h4 id="简单运算"><a href="#简单运算" class="headerlink" title="简单运算"></a>简单运算</h4><table>
<thead>
<tr>
<th>操作</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>原数除以2</td>
<td><code>i &gt;&gt; 1</code></td>
</tr>
<tr>
<td>取原数符号位</td>
<td><code>i &gt;&gt; 31</code></td>
</tr>
<tr>
<td>获取奇偶性(1奇0偶)</td>
<td><code>i &amp; 1</code></td>
</tr>
<tr>
<td>二进制取反</td>
<td><code>i ^ -1</code></td>
</tr>
<tr>
<td>返回二进制数最低位1的权值(例如从右向左第3位，2 ^ 2 = 4)</td>
<td><code>i &amp; (-i)</code></td>
</tr>
<tr>
<td>判断是否是2的幂</td>
<td><code>i &amp; (i - 1) == 0 &amp;&amp; n &gt; 0</code></td>
</tr>
</tbody></table>
<h4 id="交换两数"><a href="#交换两数" class="headerlink" title="交换两数"></a>交换两数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="逆转符号"><a href="#逆转符号" class="headerlink" title="逆转符号"></a>逆转符号</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">signRev</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据逆转符号的原理设计的绝对值函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = (a &gt;&gt; <span class="number">31</span>); <span class="comment">// 通过移位求得符号位(int为32位)i为0/-1</span></span><br><span class="line">    <span class="keyword">return</span> i == <span class="number">0</span> ? a : (~a + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = (a &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="comment">// 与0异或保持不变，与-1异或相当于取反</span></span><br><span class="line">    <span class="keyword">return</span> ((a ^ i) - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="位操作与空间压缩"><a href="#位操作与空间压缩" class="headerlink" title="位操作与空间压缩"></a>位操作与空间压缩</h3><h4 id="二进制逆序"><a href="#二进制逆序" class="headerlink" title="二进制逆序"></a>二进制逆序</h4>]]></content>
      <categories>
        <category>算法题目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之排序</title>
    <url>/2020/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>主要介绍8种排序算法：直接插入排序，直接选择排序，冒泡排序，希尔排序，堆排序，快速排序，归并排序，基数排序。</p>
<a id="more"></a>

<h1 id="排序方法一览"><a href="#排序方法一览" class="headerlink" title="排序方法一览"></a>排序方法一览</h1><ul>
<li>三种简单排序 —-$O(n^2)$<ul>
<li>直接插入排序</li>
<li>直接选择排序</li>
<li>冒泡排序</li>
</ul>
</li>
<li>希尔排序 —-$O(n^{\frac{3}{2}})$</li>
<li>堆排序 —-$O(nlogn)$</li>
<li>快速排序 —-$O(nlogn)$</li>
<li>归并排序 —-$O(nlogn)$</li>
<li>基数排序 —-$O(nlogn)$</li>
</ul>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><p><strong>一个关键字序列${K_0, K_1, …, K_{n-1}}$</strong>，满足条件：</p>
<ul>
<li>$K_i \le K_{2i+1}，K_i \le K_{2i+2}$（或$\ge$）</li>
</ul>
<p>即每层所有元素大于（小于）下一层，其实质是一个<strong>完全二叉树的层次序列</strong>，可以用数组表示。堆中的序列是部分有序的。</p>
<p><strong>大顶堆</strong></p>
<p><img src="https://pic.leetcode-cn.com/f660d0d7b248ba51e6b39ef1a7bdf18f22a1b56fef07043bde9fd53019c3db26-image.png" alt="image.png"></p>
<p><strong>小顶堆</strong></p>
<p><img src="https://pic.leetcode-cn.com/b303b6b280c2a78d37789a35bf7e74335415298c2b48f0b5aa1d443370995c4a-image.png" alt="image.png"></p>
<h2 id="代码实现（以大顶堆为例）"><a href="#代码实现（以大顶堆为例）" class="headerlink" title="代码实现（以大顶堆为例）"></a>代码实现（以大顶堆为例）</h2><h3 id="向下调整函数"><a href="#向下调整函数" class="headerlink" title="向下调整函数"></a>向下调整函数</h3><p>从<strong>堆顶向堆底</strong>计算，依次计算有后续孩子节点的节点将其与孩子比较，并进行移动，直到整个堆完成排序。</p>
<p>时间复杂度 —-$O(logn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对堆heap进行[low, high]范围内向下调整</span></span><br><span class="line"><span class="comment">// 其中low为调整节点的下标，high为堆的最后一个元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = i * <span class="number">2</span>; <span class="comment">// i为欲调整的节点，j为其左孩子</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123; <span class="comment">// 存在孩子</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果存在右孩子，且右孩子较大</span></span><br><span class="line">            j = j + <span class="number">1</span>; <span class="comment">// j变为右孩子下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap[j] &gt; heap[i]) &#123;</span><br><span class="line">            swap(heap[j], heap[i]);</span><br><span class="line">            <span class="comment">// 更新i和j为调整好后的节点</span></span><br><span class="line">            i = j;</span><br><span class="line">            j = i * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向上调整函数"><a href="#向上调整函数" class="headerlink" title="向上调整函数"></a>向上调整函数</h3><p>时间复杂度 —-$O(logn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = high, j = i / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= low) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[j] &lt; heap[i]) &#123;</span><br><span class="line">            swap(heap[j], heap[i]);</span><br><span class="line">            i = j;</span><br><span class="line">            j = i / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="建堆函数"><a href="#建堆函数" class="headerlink" title="建堆函数"></a>建堆函数</h3><p>假设序列中的元素个数为n，由于完全二叉树的叶子节点数量为$\frac{n}{2}$，因此数组下标在$[1, \frac{n}{2}]$范围内的节点都是非叶子节点。于是从$\frac{n}{2}$号位向上倒着向下进行调整即可。</p>
<p>时间复杂度 —-$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        downAdjust(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h3><p>如果要删除堆中的最大元素（即堆顶元素），<strong>并让其仍然保持堆的结构</strong>，那么只需要最后一个元素覆盖堆顶元素，然后对根节点进行向下调整即可。</p>
<p>时间复杂度 —-$O(logn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">    downAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>如果想要往堆中添加一个元素。</p>
<ul>
<li>将想要添加的元素放在数组末尾</li>
<li>然后进行<strong>向上调整</strong>操作：向上调整就是把欲调整节点与父亲节点比较，如果权值较大就与父节点进行交换</li>
</ul>
<p>时间复杂度 —-$O(logn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++n] = x;</span><br><span class="line">    upAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>思路：</p>
<ol>
<li>取出堆顶元素</li>
<li>将堆的最后一个元素替换到堆顶</li>
<li>进行一次针对堆顶元素的向下调整</li>
<li>重复1-3，直到堆中仅剩一个元素</li>
</ol>
<p>具体实现：</p>
<p>倒序遍历数组</p>
<ol>
<li>假设当前访问到第$i$位，将堆顶元素与$i$号位交换</li>
<li>在$[1, i - 1]$范围内对堆顶元素进行一次向下调整。</li>
</ol>
<p>时间复杂度 —-$O(nlogn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createHeap();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; --i) &#123;</span><br><span class="line">        swap(heap[i], heap[<span class="number">1</span>]);</span><br><span class="line">        downAdjust(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="算法思想-分治"><a href="#算法思想-分治" class="headerlink" title="算法思想(分治)"></a>算法思想(分治)</h2><ol>
<li>选择轴值$pivot$</li>
<li>将待排序列分为两个子序列$L$和$R$，使$L$中所有值都小于或等于$pivot$，$R$中所有值都大于等于$pivot$（这一步需要利用$l$和$r$指针来实现）。</li>
<li>对子序列$L$和$R$进行快速排序。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="轴值选择函数"><a href="#轴值选择函数" class="headerlink" title="轴值选择函数"></a>轴值选择函数</h3><p>选择轴值，<strong>并将轴值与最左元素进行交换。</strong></p>
<p>也可以直接选定最左侧的元素。</p>
<h3 id="分割函数"><a href="#分割函数" class="headerlink" title="分割函数"></a>分割函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high;</span><br><span class="line">    temp = x[i]; <span class="comment">// temp存放pivot</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">/*两侧的数各自寻找两侧的"异类"，并进行互换*/</span></span><br><span class="line">        <span class="keyword">while</span> (x[j] &gt; temp &amp;&amp; (i &lt; j)) &#123;</span><br><span class="line">            <span class="comment">/*右指针寻找一个小于等于pivot的元素*/</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            x[i] = x[j];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x[i] &lt; temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            <span class="comment">/*左指针寻找一个大于等于pivot的元素*/</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            x[j] = x[i];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    x[i] = temp; <span class="comment">// 轴值赋给相遇点，形成闭环</span></span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 返回pivot下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序函数"><a href="#快速排序函数" class="headerlink" title="快速排序函数"></a>快速排序函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(x, low, high);</span><br><span class="line">    qs(x, low, pivot - <span class="number">1</span>);</span><br><span class="line">    qs(x, pivot + <span class="number">1</span>, high);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>快速排序是一种不稳定排序（相同数值的元素的相对位置可能改变）算法。</p>
<p>最差情况：</p>
<ul>
<li><p>时间—-$O(n^2)$</p>
</li>
<li><p>空间—-$O(n)$</p>
</li>
</ul>
<p>最佳情况：</p>
<ul>
<li>时间—-$O(nlogn)$</li>
<li>空间—-$O(logn)$</li>
</ul>
<p>平均情况：</p>
<ul>
<li>时间—-$O(nlogn)$</li>
<li>空间—-$O(logn)$</li>
</ul>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="算法思想-分治-1"><a href="#算法思想-分治-1" class="headerlink" title="算法思想(分治)"></a>算法思想(分治)</h2><ul>
<li>简单的将原始序列二分为两个子序列</li>
<li>继续对两子序列递归划分，将排好序的两个子序列合并为一个新的有序序列并向下归并。</li>
</ul>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="合并函数"><a href="#合并函数" class="headerlink" title="合并函数"></a>合并函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> mid)</span> </span>&#123; <span class="comment">// 存放了(low, mid)和(mid + 1, high)的已排序集合</span></span><br><span class="line">    <span class="comment">// h和j分别为两集合的遍历指针</span></span><br><span class="line">    <span class="keyword">int</span> k = low, i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(high - low + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x[i] &lt;= x[j]) &#123;</span><br><span class="line">            helper[k] = x[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helper[k] = x[j];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*处理残留元素*/</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; mid) &#123; <span class="comment">// 如果后一个集合有剩余</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = j; p &lt;= high; ++p) &#123;</span><br><span class="line">            helper[k] = x[p];</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前一个集合有剩余</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = i; p &lt;= mid; ++p) &#123;</span><br><span class="line">            helper[k] = x[p];</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将辅助数组覆盖原数组*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = low; p &lt;= high; ++p) &#123;</span><br><span class="line">        x[p] = helper[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序函数"><a href="#归并排序函数" class="headerlink" title="归并排序函数"></a>归并排序函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(x, low, mid);</span><br><span class="line">        mergeSort(x, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(x, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><p>归并排序是一种稳定的排序算法。最大、最小、平均时间代价基本相同。</p>
<ul>
<li><p>时间—-$O(nlogn)$</p>
</li>
<li><p>空间—-$O(n+logn) = O(n)$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
</search>
